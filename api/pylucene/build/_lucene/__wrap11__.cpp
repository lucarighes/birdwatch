#include <jni.h>
#include "JCCEnv.h"
#include "java/io/Console.h"
#include "java/io/PrintWriter.h"
#include "java/io/Console.h"
#include "java/lang/Class.h"
#include "java/io/Flushable.h"
#include "java/lang/String.h"
#include "java/io/Reader.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *Console::class$ = NULL;
    jmethodID *Console::mids$ = NULL;
    bool Console::live$ = false;

    jclass Console::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/Console");

        mids$ = new jmethodID[max_mid];
        mids$[mid_flush_f2cc1bce94666404] = env->getMethodID(cls, "flush", "()V");
        mids$[mid_format_128ea441775d7ef6] = env->getMethodID(cls, "format", "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/Console;");
        mids$[mid_printf_128ea441775d7ef6] = env->getMethodID(cls, "printf", "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/Console;");
        mids$[mid_readLine_db9b55ba01e03e4b] = env->getMethodID(cls, "readLine", "()Ljava/lang/String;");
        mids$[mid_readLine_8fd1aa183c04cdf5] = env->getMethodID(cls, "readLine", "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;");
        mids$[mid_readPassword_e11cf13c9a887534] = env->getMethodID(cls, "readPassword", "()[C");
        mids$[mid_readPassword_d2e10c7d7d84d3e1] = env->getMethodID(cls, "readPassword", "(Ljava/lang/String;[Ljava/lang/Object;)[C");
        mids$[mid_reader_cad8e490f39649d8] = env->getMethodID(cls, "reader", "()Ljava/io/Reader;");
        mids$[mid_writer_d01a36a347171c1d] = env->getMethodID(cls, "writer", "()Ljava/io/PrintWriter;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Console::flush() const
    {
      env->callVoidMethod(this$, mids$[mid_flush_f2cc1bce94666404]);
    }

    Console Console::format(const ::java::lang::String & a0, const JArray< ::java::lang::Object > & a1) const
    {
      return Console(env->callObjectMethod(this$, mids$[mid_format_128ea441775d7ef6], a0.this$, a1.this$));
    }

    Console Console::printf(const ::java::lang::String & a0, const JArray< ::java::lang::Object > & a1) const
    {
      return Console(env->callObjectMethod(this$, mids$[mid_printf_128ea441775d7ef6], a0.this$, a1.this$));
    }

    ::java::lang::String Console::readLine() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_readLine_db9b55ba01e03e4b]));
    }

    ::java::lang::String Console::readLine(const ::java::lang::String & a0, const JArray< ::java::lang::Object > & a1) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_readLine_8fd1aa183c04cdf5], a0.this$, a1.this$));
    }

    JArray< jchar > Console::readPassword() const
    {
      return JArray< jchar >(env->callObjectMethod(this$, mids$[mid_readPassword_e11cf13c9a887534]));
    }

    JArray< jchar > Console::readPassword(const ::java::lang::String & a0, const JArray< ::java::lang::Object > & a1) const
    {
      return JArray< jchar >(env->callObjectMethod(this$, mids$[mid_readPassword_d2e10c7d7d84d3e1], a0.this$, a1.this$));
    }

    ::java::io::Reader Console::reader() const
    {
      return ::java::io::Reader(env->callObjectMethod(this$, mids$[mid_reader_cad8e490f39649d8]));
    }

    ::java::io::PrintWriter Console::writer() const
    {
      return ::java::io::PrintWriter(env->callObjectMethod(this$, mids$[mid_writer_d01a36a347171c1d]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_Console_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Console_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Console_flush(t_Console *self);
    static PyObject *t_Console_format(t_Console *self, PyObject *args);
    static PyObject *t_Console_printf(t_Console *self, PyObject *args);
    static PyObject *t_Console_readLine(t_Console *self, PyObject *args);
    static PyObject *t_Console_readPassword(t_Console *self, PyObject *args);
    static PyObject *t_Console_reader(t_Console *self);
    static PyObject *t_Console_writer(t_Console *self);

    static PyMethodDef t_Console__methods_[] = {
      DECLARE_METHOD(t_Console, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Console, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Console, flush, METH_NOARGS),
      DECLARE_METHOD(t_Console, format, METH_VARARGS),
      DECLARE_METHOD(t_Console, printf, METH_VARARGS),
      DECLARE_METHOD(t_Console, readLine, METH_VARARGS),
      DECLARE_METHOD(t_Console, readPassword, METH_VARARGS),
      DECLARE_METHOD(t_Console, reader, METH_NOARGS),
      DECLARE_METHOD(t_Console, writer, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Console)[] = {
      { Py_tp_methods, t_Console__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Console)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Console, t_Console, Console);

    void t_Console::install(PyObject *module)
    {
      installType(&PY_TYPE(Console), &PY_TYPE_DEF(Console), module, "Console", 0);
    }

    void t_Console::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Console), "class_", make_descriptor(Console::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Console), "wrapfn_", make_descriptor(t_Console::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Console), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Console_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Console::initializeClass, 1)))
        return NULL;
      return t_Console::wrap_Object(Console(((t_Console *) arg)->object.this$));
    }
    static PyObject *t_Console_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Console::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Console_flush(t_Console *self)
    {
      OBJ_CALL(self->object.flush());
      Py_RETURN_NONE;
    }

    static PyObject *t_Console_format(t_Console *self, PyObject *args)
    {
      ::java::lang::String a0((jobject) NULL);
      JArray< ::java::lang::Object > a1((jobject) NULL);
      Console result((jobject) NULL);

      if (!parseArgs(args, "s[o", &a0, &a1))
      {
        OBJ_CALL(result = self->object.format(a0, a1));
        return t_Console::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "format", args);
      return NULL;
    }

    static PyObject *t_Console_printf(t_Console *self, PyObject *args)
    {
      ::java::lang::String a0((jobject) NULL);
      JArray< ::java::lang::Object > a1((jobject) NULL);
      Console result((jobject) NULL);

      if (!parseArgs(args, "s[o", &a0, &a1))
      {
        OBJ_CALL(result = self->object.printf(a0, a1));
        return t_Console::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "printf", args);
      return NULL;
    }

    static PyObject *t_Console_readLine(t_Console *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.readLine());
          return j2p(result);
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          JArray< ::java::lang::Object > a1((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "s[o", &a0, &a1))
          {
            OBJ_CALL(result = self->object.readLine(a0, a1));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "readLine", args);
      return NULL;
    }

    static PyObject *t_Console_readPassword(t_Console *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          JArray< jchar > result((jobject) NULL);
          OBJ_CALL(result = self->object.readPassword());
          return result.wrap();
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          JArray< ::java::lang::Object > a1((jobject) NULL);
          JArray< jchar > result((jobject) NULL);

          if (!parseArgs(args, "s[o", &a0, &a1))
          {
            OBJ_CALL(result = self->object.readPassword(a0, a1));
            return result.wrap();
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "readPassword", args);
      return NULL;
    }

    static PyObject *t_Console_reader(t_Console *self)
    {
      ::java::io::Reader result((jobject) NULL);
      OBJ_CALL(result = self->object.reader());
      return ::java::io::t_Reader::wrap_Object(result);
    }

    static PyObject *t_Console_writer(t_Console *self)
    {
      ::java::io::PrintWriter result((jobject) NULL);
      OBJ_CALL(result = self->object.writer());
      return ::java::io::t_PrintWriter::wrap_Object(result);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Collection.h"
#include "java/util/Collection.h"
#include "java/util/function/Predicate.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/Spliterator.h"
#include "java/util/Iterator.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Collection::class$ = NULL;
    jmethodID *Collection::mids$ = NULL;
    bool Collection::live$ = false;

    jclass Collection::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Collection");

        mids$ = new jmethodID[max_mid];
        mids$[mid_add_8b72f2dcdde6fd1d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)Z");
        mids$[mid_addAll_15d9cc2398c22637] = env->getMethodID(cls, "addAll", "(Ljava/util/Collection;)Z");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_contains_8b72f2dcdde6fd1d] = env->getMethodID(cls, "contains", "(Ljava/lang/Object;)Z");
        mids$[mid_containsAll_15d9cc2398c22637] = env->getMethodID(cls, "containsAll", "(Ljava/util/Collection;)Z");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
        mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
        mids$[mid_remove_8b72f2dcdde6fd1d] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Z");
        mids$[mid_removeAll_15d9cc2398c22637] = env->getMethodID(cls, "removeAll", "(Ljava/util/Collection;)Z");
        mids$[mid_removeIf_bb7983a2fafd563c] = env->getMethodID(cls, "removeIf", "(Ljava/util/function/Predicate;)Z");
        mids$[mid_retainAll_15d9cc2398c22637] = env->getMethodID(cls, "retainAll", "(Ljava/util/Collection;)Z");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
        mids$[mid_spliterator_7a761c107a8e14bd] = env->getMethodID(cls, "spliterator", "()Ljava/util/Spliterator;");
        mids$[mid_toArray_6becf78ffd87a9bc] = env->getMethodID(cls, "toArray", "()[Ljava/lang/Object;");
        mids$[mid_toArray_609b05756010dc5d] = env->getMethodID(cls, "toArray", "([Ljava/lang/Object;)[Ljava/lang/Object;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jboolean Collection::add(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_add_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Collection::addAll(const Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_15d9cc2398c22637], a0.this$);
    }

    void Collection::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    jboolean Collection::contains(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_contains_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Collection::containsAll(const Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_containsAll_15d9cc2398c22637], a0.this$);
    }

    jboolean Collection::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    jint Collection::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean Collection::isEmpty() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
    }

    ::java::util::Iterator Collection::iterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
    }

    jboolean Collection::remove(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_remove_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Collection::removeAll(const Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeAll_15d9cc2398c22637], a0.this$);
    }

    jboolean Collection::removeIf(const ::java::util::function::Predicate & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeIf_bb7983a2fafd563c], a0.this$);
    }

    jboolean Collection::retainAll(const Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_retainAll_15d9cc2398c22637], a0.this$);
    }

    jint Collection::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }

    ::java::util::Spliterator Collection::spliterator() const
    {
      return ::java::util::Spliterator(env->callObjectMethod(this$, mids$[mid_spliterator_7a761c107a8e14bd]));
    }

    JArray< ::java::lang::Object > Collection::toArray() const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_6becf78ffd87a9bc]));
    }

    JArray< ::java::lang::Object > Collection::toArray(const JArray< ::java::lang::Object > & a0) const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_609b05756010dc5d], a0.this$));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Collection_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Collection_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Collection_of_(t_Collection *self, PyObject *args);
    static PyObject *t_Collection_add(t_Collection *self, PyObject *arg);
    static PyObject *t_Collection_addAll(t_Collection *self, PyObject *arg);
    static PyObject *t_Collection_clear(t_Collection *self);
    static PyObject *t_Collection_contains(t_Collection *self, PyObject *arg);
    static PyObject *t_Collection_containsAll(t_Collection *self, PyObject *arg);
    static PyObject *t_Collection_equals(t_Collection *self, PyObject *arg);
    static PyObject *t_Collection_hashCode(t_Collection *self);
    static PyObject *t_Collection_isEmpty(t_Collection *self);
    static PyObject *t_Collection_iterator(t_Collection *self, PyObject *args);
    static PyObject *t_Collection_remove(t_Collection *self, PyObject *arg);
    static PyObject *t_Collection_removeAll(t_Collection *self, PyObject *arg);
    static PyObject *t_Collection_removeIf(t_Collection *self, PyObject *arg);
    static PyObject *t_Collection_retainAll(t_Collection *self, PyObject *arg);
    static PyObject *t_Collection_size(t_Collection *self);
    static PyObject *t_Collection_spliterator(t_Collection *self, PyObject *args);
    static PyObject *t_Collection_toArray(t_Collection *self, PyObject *args);
    static PyObject *t_Collection_get__empty(t_Collection *self, void *data);
    static PyObject *t_Collection_get__parameters_(t_Collection *self, void *data);
    static PyGetSetDef t_Collection__fields_[] = {
      DECLARE_GET_FIELD(t_Collection, empty),
      DECLARE_GET_FIELD(t_Collection, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Collection__methods_[] = {
      DECLARE_METHOD(t_Collection, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Collection, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Collection, of_, METH_VARARGS),
      DECLARE_METHOD(t_Collection, add, METH_O),
      DECLARE_METHOD(t_Collection, addAll, METH_O),
      DECLARE_METHOD(t_Collection, clear, METH_NOARGS),
      DECLARE_METHOD(t_Collection, contains, METH_O),
      DECLARE_METHOD(t_Collection, containsAll, METH_O),
      DECLARE_METHOD(t_Collection, equals, METH_O),
      DECLARE_METHOD(t_Collection, hashCode, METH_NOARGS),
      DECLARE_METHOD(t_Collection, isEmpty, METH_NOARGS),
      DECLARE_METHOD(t_Collection, iterator, METH_VARARGS),
      DECLARE_METHOD(t_Collection, remove, METH_O),
      DECLARE_METHOD(t_Collection, removeAll, METH_O),
      DECLARE_METHOD(t_Collection, removeIf, METH_O),
      DECLARE_METHOD(t_Collection, retainAll, METH_O),
      DECLARE_METHOD(t_Collection, size, METH_NOARGS),
      DECLARE_METHOD(t_Collection, spliterator, METH_VARARGS),
      DECLARE_METHOD(t_Collection, toArray, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Collection)[] = {
      { Py_tp_methods, t_Collection__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Collection__fields_ },
      { Py_tp_iter, (void *) ((PyObject *(*)(t_Collection *)) get_generic_iterator< t_Collection >) },
      { Py_tp_iternext, (void *) 0 },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Collection)[] = {
      &PY_TYPE_DEF(::java::lang::Iterable),
      NULL
    };

    DEFINE_TYPE(Collection, t_Collection, Collection);
    PyObject *t_Collection::wrap_Object(const Collection& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Collection::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Collection *self = (t_Collection *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Collection::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Collection::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Collection *self = (t_Collection *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Collection::install(PyObject *module)
    {
      installType(&PY_TYPE(Collection), &PY_TYPE_DEF(Collection), module, "Collection", 0);
    }

    void t_Collection::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Collection), "class_", make_descriptor(Collection::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Collection), "wrapfn_", make_descriptor(t_Collection::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Collection), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Collection_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Collection::initializeClass, 1)))
        return NULL;
      return t_Collection::wrap_Object(Collection(((t_Collection *) arg)->object.this$));
    }
    static PyObject *t_Collection_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Collection::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Collection_of_(t_Collection *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Collection_add(t_Collection *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.add(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "add", arg);
      return NULL;
    }

    static PyObject *t_Collection_addAll(t_Collection *self, PyObject *arg)
    {
      Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArg(arg, "K", Collection::initializeClass, &a0, &p0, t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.addAll(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "addAll", arg);
      return NULL;
    }

    static PyObject *t_Collection_clear(t_Collection *self)
    {
      OBJ_CALL(self->object.clear());
      Py_RETURN_NONE;
    }

    static PyObject *t_Collection_contains(t_Collection *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.contains(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "contains", arg);
      return NULL;
    }

    static PyObject *t_Collection_containsAll(t_Collection *self, PyObject *arg)
    {
      Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArg(arg, "K", Collection::initializeClass, &a0, &p0, t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.containsAll(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "containsAll", arg);
      return NULL;
    }

    static PyObject *t_Collection_equals(t_Collection *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "equals", arg);
      return NULL;
    }

    static PyObject *t_Collection_hashCode(t_Collection *self)
    {
      jint result;
      OBJ_CALL(result = self->object.hashCode());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Collection_isEmpty(t_Collection *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isEmpty());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_Collection_iterator(t_Collection *self, PyObject *args)
    {
      ::java::util::Iterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.iterator());
        return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(Collection), (PyObject *) self, "iterator", args, 2);
    }

    static PyObject *t_Collection_remove(t_Collection *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.remove(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "remove", arg);
      return NULL;
    }

    static PyObject *t_Collection_removeAll(t_Collection *self, PyObject *arg)
    {
      Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArg(arg, "K", Collection::initializeClass, &a0, &p0, t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.removeAll(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "removeAll", arg);
      return NULL;
    }

    static PyObject *t_Collection_removeIf(t_Collection *self, PyObject *arg)
    {
      ::java::util::function::Predicate a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArg(arg, "K", ::java::util::function::Predicate::initializeClass, &a0, &p0, ::java::util::function::t_Predicate::parameters_))
      {
        OBJ_CALL(result = self->object.removeIf(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "removeIf", arg);
      return NULL;
    }

    static PyObject *t_Collection_retainAll(t_Collection *self, PyObject *arg)
    {
      Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArg(arg, "K", Collection::initializeClass, &a0, &p0, t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.retainAll(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "retainAll", arg);
      return NULL;
    }

    static PyObject *t_Collection_size(t_Collection *self)
    {
      jint result;
      OBJ_CALL(result = self->object.size());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Collection_spliterator(t_Collection *self, PyObject *args)
    {
      ::java::util::Spliterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.spliterator());
        return ::java::util::t_Spliterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(Collection), (PyObject *) self, "spliterator", args, 2);
    }

    static PyObject *t_Collection_toArray(t_Collection *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          JArray< ::java::lang::Object > result((jobject) NULL);
          OBJ_CALL(result = self->object.toArray());
          return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
        }
        break;
       case 1:
        {
          JArray< ::java::lang::Object > a0((jobject) NULL);
          JArray< ::java::lang::Object > result((jobject) NULL);

          if (!parseArgs(args, "[o", &a0))
          {
            OBJ_CALL(result = self->object.toArray(a0));
            return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "toArray", args);
      return NULL;
    }
    static PyObject *t_Collection_get__parameters_(t_Collection *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_Collection_get__empty(t_Collection *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isEmpty());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/LinkOption.h"
#include "java/nio/file/LinkOption.h"
#include "java/lang/Class.h"
#include "java/nio/file/OpenOption.h"
#include "java/lang/String.h"
#include "java/nio/file/CopyOption.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *LinkOption::class$ = NULL;
      jmethodID *LinkOption::mids$ = NULL;
      bool LinkOption::live$ = false;
      LinkOption *LinkOption::NOFOLLOW_LINKS = NULL;

      jclass LinkOption::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/LinkOption");

          mids$ = new jmethodID[max_mid];
          mids$[mid_valueOf_2ec90f89a2ce4698] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Ljava/nio/file/LinkOption;");
          mids$[mid_values_4475f60e7e8f6d6f] = env->getStaticMethodID(cls, "values", "()[Ljava/nio/file/LinkOption;");

          class$ = new ::java::lang::Class(cls);
          cls = (jclass) class$->this$;

          NOFOLLOW_LINKS = new LinkOption(env->getStaticObjectField(cls, "NOFOLLOW_LINKS", "Ljava/nio/file/LinkOption;"));
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      LinkOption LinkOption::valueOf(const ::java::lang::String & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return LinkOption(env->callStaticObjectMethod(cls, mids$[mid_valueOf_2ec90f89a2ce4698], a0.this$));
      }

      JArray< LinkOption > LinkOption::values()
      {
        jclass cls = env->getClass(initializeClass);
        return JArray< LinkOption >(env->callStaticObjectMethod(cls, mids$[mid_values_4475f60e7e8f6d6f]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_LinkOption_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_LinkOption_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_LinkOption_of_(t_LinkOption *self, PyObject *args);
      static PyObject *t_LinkOption_valueOf(PyTypeObject *type, PyObject *args);
      static PyObject *t_LinkOption_values(PyTypeObject *type);
      static PyObject *t_LinkOption_get__parameters_(t_LinkOption *self, void *data);
      static PyGetSetDef t_LinkOption__fields_[] = {
        DECLARE_GET_FIELD(t_LinkOption, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_LinkOption__methods_[] = {
        DECLARE_METHOD(t_LinkOption, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_LinkOption, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_LinkOption, of_, METH_VARARGS),
        DECLARE_METHOD(t_LinkOption, valueOf, METH_VARARGS | METH_CLASS),
        DECLARE_METHOD(t_LinkOption, values, METH_NOARGS | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(LinkOption)[] = {
        { Py_tp_methods, t_LinkOption__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_LinkOption__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(LinkOption)[] = {
        &PY_TYPE_DEF(::java::lang::Enum),
        NULL
      };

      DEFINE_TYPE(LinkOption, t_LinkOption, LinkOption);
      PyObject *t_LinkOption::wrap_Object(const LinkOption& object, PyTypeObject *p0)
      {
        PyObject *obj = t_LinkOption::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_LinkOption *self = (t_LinkOption *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_LinkOption::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_LinkOption::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_LinkOption *self = (t_LinkOption *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_LinkOption::install(PyObject *module)
      {
        installType(&PY_TYPE(LinkOption), &PY_TYPE_DEF(LinkOption), module, "LinkOption", 0);
      }

      void t_LinkOption::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(LinkOption), "class_", make_descriptor(LinkOption::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(LinkOption), "wrapfn_", make_descriptor(t_LinkOption::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(LinkOption), "boxfn_", make_descriptor(boxObject));
        env->getClass(LinkOption::initializeClass);
        PyObject_SetAttrString((PyObject *) PY_TYPE(LinkOption), "NOFOLLOW_LINKS", make_descriptor(t_LinkOption::wrap_Object(*LinkOption::NOFOLLOW_LINKS)));
      }

      static PyObject *t_LinkOption_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, LinkOption::initializeClass, 1)))
          return NULL;
        return t_LinkOption::wrap_Object(LinkOption(((t_LinkOption *) arg)->object.this$));
      }
      static PyObject *t_LinkOption_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, LinkOption::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_LinkOption_of_(t_LinkOption *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_LinkOption_valueOf(PyTypeObject *type, PyObject *args)
      {
        ::java::lang::String a0((jobject) NULL);
        LinkOption result((jobject) NULL);

        if (!parseArgs(args, "s", &a0))
        {
          OBJ_CALL(result = ::java::nio::file::LinkOption::valueOf(a0));
          return t_LinkOption::wrap_Object(result);
        }

        return callSuper(type, "valueOf", args, 2);
      }

      static PyObject *t_LinkOption_values(PyTypeObject *type)
      {
        JArray< LinkOption > result((jobject) NULL);
        OBJ_CALL(result = ::java::nio::file::LinkOption::values());
        return JArray<jobject>(result.this$).wrap(t_LinkOption::wrap_jobject);
      }
      static PyObject *t_LinkOption_get__parameters_(t_LinkOption *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/DirectoryStream.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/lang/Iterable.h"
#include "java/util/Iterator.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *DirectoryStream::class$ = NULL;
      jmethodID *DirectoryStream::mids$ = NULL;
      bool DirectoryStream::live$ = false;

      jclass DirectoryStream::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/DirectoryStream");

          mids$ = new jmethodID[max_mid];
          mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::util::Iterator DirectoryStream::iterator() const
      {
        return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"
#include "java/nio/file/DirectoryStream$Filter.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_DirectoryStream_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DirectoryStream_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DirectoryStream_of_(t_DirectoryStream *self, PyObject *args);
      static PyObject *t_DirectoryStream_iterator(t_DirectoryStream *self);
      static PyObject *t_DirectoryStream_get__parameters_(t_DirectoryStream *self, void *data);
      static PyGetSetDef t_DirectoryStream__fields_[] = {
        DECLARE_GET_FIELD(t_DirectoryStream, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_DirectoryStream__methods_[] = {
        DECLARE_METHOD(t_DirectoryStream, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DirectoryStream, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DirectoryStream, of_, METH_VARARGS),
        DECLARE_METHOD(t_DirectoryStream, iterator, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(DirectoryStream)[] = {
        { Py_tp_methods, t_DirectoryStream__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_DirectoryStream__fields_ },
        { Py_tp_iter, (void *) ((PyObject *(*)(t_DirectoryStream *)) get_generic_iterator< t_DirectoryStream >) },
        { Py_tp_iternext, (void *) 0 },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(DirectoryStream)[] = {
        &PY_TYPE_DEF(::java::io::Closeable),
        NULL
      };

      DEFINE_TYPE(DirectoryStream, t_DirectoryStream, DirectoryStream);
      PyObject *t_DirectoryStream::wrap_Object(const DirectoryStream& object, PyTypeObject *p0)
      {
        PyObject *obj = t_DirectoryStream::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_DirectoryStream *self = (t_DirectoryStream *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_DirectoryStream::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_DirectoryStream::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_DirectoryStream *self = (t_DirectoryStream *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_DirectoryStream::install(PyObject *module)
      {
        installType(&PY_TYPE(DirectoryStream), &PY_TYPE_DEF(DirectoryStream), module, "DirectoryStream", 0);
        PyObject_SetAttrString((PyObject *) PY_TYPE(DirectoryStream), "Filter", make_descriptor(&PY_TYPE_DEF(DirectoryStream$Filter)));
      }

      void t_DirectoryStream::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(DirectoryStream), "class_", make_descriptor(DirectoryStream::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DirectoryStream), "wrapfn_", make_descriptor(t_DirectoryStream::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DirectoryStream), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_DirectoryStream_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, DirectoryStream::initializeClass, 1)))
          return NULL;
        return t_DirectoryStream::wrap_Object(DirectoryStream(((t_DirectoryStream *) arg)->object.this$));
      }
      static PyObject *t_DirectoryStream_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, DirectoryStream::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_DirectoryStream_of_(t_DirectoryStream *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_DirectoryStream_iterator(t_DirectoryStream *self)
      {
        ::java::util::Iterator result((jobject) NULL);
        OBJ_CALL(result = self->object.iterator());
        return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
      }
      static PyObject *t_DirectoryStream_get__parameters_(t_DirectoryStream *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/IllegalAccessException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *IllegalAccessException::class$ = NULL;
    jmethodID *IllegalAccessException::mids$ = NULL;
    bool IllegalAccessException::live$ = false;

    jclass IllegalAccessException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/IllegalAccessException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    IllegalAccessException::IllegalAccessException() : ::java::lang::ReflectiveOperationException(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    IllegalAccessException::IllegalAccessException(const ::java::lang::String & a0) : ::java::lang::ReflectiveOperationException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_IllegalAccessException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_IllegalAccessException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_IllegalAccessException_init_(t_IllegalAccessException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_IllegalAccessException__methods_[] = {
      DECLARE_METHOD(t_IllegalAccessException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_IllegalAccessException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(IllegalAccessException)[] = {
      { Py_tp_methods, t_IllegalAccessException__methods_ },
      { Py_tp_init, (void *) t_IllegalAccessException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(IllegalAccessException)[] = {
      &PY_TYPE_DEF(::java::lang::ReflectiveOperationException),
      NULL
    };

    DEFINE_TYPE(IllegalAccessException, t_IllegalAccessException, IllegalAccessException);

    void t_IllegalAccessException::install(PyObject *module)
    {
      installType(&PY_TYPE(IllegalAccessException), &PY_TYPE_DEF(IllegalAccessException), module, "IllegalAccessException", 0);
    }

    void t_IllegalAccessException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(IllegalAccessException), "class_", make_descriptor(IllegalAccessException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(IllegalAccessException), "wrapfn_", make_descriptor(t_IllegalAccessException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(IllegalAccessException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_IllegalAccessException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, IllegalAccessException::initializeClass, 1)))
        return NULL;
      return t_IllegalAccessException::wrap_Object(IllegalAccessException(((t_IllegalAccessException *) arg)->object.this$));
    }
    static PyObject *t_IllegalAccessException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, IllegalAccessException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_IllegalAccessException_init_(t_IllegalAccessException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          IllegalAccessException object((jobject) NULL);

          INT_CALL(object = IllegalAccessException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          IllegalAccessException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = IllegalAccessException(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Spliterator.h"
#include "java/util/Comparator.h"
#include "java/lang/Class.h"
#include "java/util/function/Consumer.h"
#include "java/util/Spliterator.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Spliterator::class$ = NULL;
    jmethodID *Spliterator::mids$ = NULL;
    bool Spliterator::live$ = false;
    jint Spliterator::CONCURRENT = (jint) 0;
    jint Spliterator::DISTINCT = (jint) 0;
    jint Spliterator::IMMUTABLE = (jint) 0;
    jint Spliterator::NONNULL = (jint) 0;
    jint Spliterator::ORDERED = (jint) 0;
    jint Spliterator::SIZED = (jint) 0;
    jint Spliterator::SORTED = (jint) 0;
    jint Spliterator::SUBSIZED = (jint) 0;

    jclass Spliterator::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Spliterator");

        mids$ = new jmethodID[max_mid];
        mids$[mid_characteristics_9972fcc56b44e79d] = env->getMethodID(cls, "characteristics", "()I");
        mids$[mid_estimateSize_2e5ae9edcb9b072f] = env->getMethodID(cls, "estimateSize", "()J");
        mids$[mid_forEachRemaining_39fdd8ee24bf1a00] = env->getMethodID(cls, "forEachRemaining", "(Ljava/util/function/Consumer;)V");
        mids$[mid_getComparator_beb0414e0ec1de00] = env->getMethodID(cls, "getComparator", "()Ljava/util/Comparator;");
        mids$[mid_getExactSizeIfKnown_2e5ae9edcb9b072f] = env->getMethodID(cls, "getExactSizeIfKnown", "()J");
        mids$[mid_hasCharacteristics_a1d30e1ee40c89a2] = env->getMethodID(cls, "hasCharacteristics", "(I)Z");
        mids$[mid_tryAdvance_9aa53ce3333098c2] = env->getMethodID(cls, "tryAdvance", "(Ljava/util/function/Consumer;)Z");
        mids$[mid_trySplit_7a761c107a8e14bd] = env->getMethodID(cls, "trySplit", "()Ljava/util/Spliterator;");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        CONCURRENT = env->getStaticIntField(cls, "CONCURRENT");
        DISTINCT = env->getStaticIntField(cls, "DISTINCT");
        IMMUTABLE = env->getStaticIntField(cls, "IMMUTABLE");
        NONNULL = env->getStaticIntField(cls, "NONNULL");
        ORDERED = env->getStaticIntField(cls, "ORDERED");
        SIZED = env->getStaticIntField(cls, "SIZED");
        SORTED = env->getStaticIntField(cls, "SORTED");
        SUBSIZED = env->getStaticIntField(cls, "SUBSIZED");
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jint Spliterator::characteristics() const
    {
      return env->callIntMethod(this$, mids$[mid_characteristics_9972fcc56b44e79d]);
    }

    jlong Spliterator::estimateSize() const
    {
      return env->callLongMethod(this$, mids$[mid_estimateSize_2e5ae9edcb9b072f]);
    }

    void Spliterator::forEachRemaining(const ::java::util::function::Consumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEachRemaining_39fdd8ee24bf1a00], a0.this$);
    }

    ::java::util::Comparator Spliterator::getComparator() const
    {
      return ::java::util::Comparator(env->callObjectMethod(this$, mids$[mid_getComparator_beb0414e0ec1de00]));
    }

    jlong Spliterator::getExactSizeIfKnown() const
    {
      return env->callLongMethod(this$, mids$[mid_getExactSizeIfKnown_2e5ae9edcb9b072f]);
    }

    jboolean Spliterator::hasCharacteristics(jint a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_hasCharacteristics_a1d30e1ee40c89a2], a0);
    }

    jboolean Spliterator::tryAdvance(const ::java::util::function::Consumer & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_tryAdvance_9aa53ce3333098c2], a0.this$);
    }

    Spliterator Spliterator::trySplit() const
    {
      return Spliterator(env->callObjectMethod(this$, mids$[mid_trySplit_7a761c107a8e14bd]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"
#include "java/util/Spliterator$OfDouble.h"
#include "java/util/Spliterator$OfLong.h"
#include "java/util/Spliterator$OfInt.h"

namespace java {
  namespace util {
    static PyObject *t_Spliterator_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator_of_(t_Spliterator *self, PyObject *args);
    static PyObject *t_Spliterator_characteristics(t_Spliterator *self);
    static PyObject *t_Spliterator_estimateSize(t_Spliterator *self);
    static PyObject *t_Spliterator_forEachRemaining(t_Spliterator *self, PyObject *arg);
    static PyObject *t_Spliterator_getComparator(t_Spliterator *self);
    static PyObject *t_Spliterator_getExactSizeIfKnown(t_Spliterator *self);
    static PyObject *t_Spliterator_hasCharacteristics(t_Spliterator *self, PyObject *arg);
    static PyObject *t_Spliterator_tryAdvance(t_Spliterator *self, PyObject *arg);
    static PyObject *t_Spliterator_trySplit(t_Spliterator *self);
    static PyObject *t_Spliterator_get__comparator(t_Spliterator *self, void *data);
    static PyObject *t_Spliterator_get__exactSizeIfKnown(t_Spliterator *self, void *data);
    static PyObject *t_Spliterator_get__parameters_(t_Spliterator *self, void *data);
    static PyGetSetDef t_Spliterator__fields_[] = {
      DECLARE_GET_FIELD(t_Spliterator, comparator),
      DECLARE_GET_FIELD(t_Spliterator, exactSizeIfKnown),
      DECLARE_GET_FIELD(t_Spliterator, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Spliterator__methods_[] = {
      DECLARE_METHOD(t_Spliterator, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator, of_, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator, characteristics, METH_NOARGS),
      DECLARE_METHOD(t_Spliterator, estimateSize, METH_NOARGS),
      DECLARE_METHOD(t_Spliterator, forEachRemaining, METH_O),
      DECLARE_METHOD(t_Spliterator, getComparator, METH_NOARGS),
      DECLARE_METHOD(t_Spliterator, getExactSizeIfKnown, METH_NOARGS),
      DECLARE_METHOD(t_Spliterator, hasCharacteristics, METH_O),
      DECLARE_METHOD(t_Spliterator, tryAdvance, METH_O),
      DECLARE_METHOD(t_Spliterator, trySplit, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Spliterator)[] = {
      { Py_tp_methods, t_Spliterator__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Spliterator__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Spliterator)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Spliterator, t_Spliterator, Spliterator);
    PyObject *t_Spliterator::wrap_Object(const Spliterator& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Spliterator::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator *self = (t_Spliterator *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Spliterator::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Spliterator::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator *self = (t_Spliterator *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Spliterator::install(PyObject *module)
    {
      installType(&PY_TYPE(Spliterator), &PY_TYPE_DEF(Spliterator), module, "Spliterator", 0);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "OfDouble", make_descriptor(&PY_TYPE_DEF(Spliterator$OfDouble)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "OfLong", make_descriptor(&PY_TYPE_DEF(Spliterator$OfLong)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "OfInt", make_descriptor(&PY_TYPE_DEF(Spliterator$OfInt)));
    }

    void t_Spliterator::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "class_", make_descriptor(Spliterator::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "wrapfn_", make_descriptor(t_Spliterator::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "boxfn_", make_descriptor(boxObject));
      env->getClass(Spliterator::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "CONCURRENT", make_descriptor(Spliterator::CONCURRENT));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "DISTINCT", make_descriptor(Spliterator::DISTINCT));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "IMMUTABLE", make_descriptor(Spliterator::IMMUTABLE));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "NONNULL", make_descriptor(Spliterator::NONNULL));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "ORDERED", make_descriptor(Spliterator::ORDERED));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "SIZED", make_descriptor(Spliterator::SIZED));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "SORTED", make_descriptor(Spliterator::SORTED));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator), "SUBSIZED", make_descriptor(Spliterator::SUBSIZED));
    }

    static PyObject *t_Spliterator_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Spliterator::initializeClass, 1)))
        return NULL;
      return t_Spliterator::wrap_Object(Spliterator(((t_Spliterator *) arg)->object.this$));
    }
    static PyObject *t_Spliterator_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Spliterator::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Spliterator_of_(t_Spliterator *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Spliterator_characteristics(t_Spliterator *self)
    {
      jint result;
      OBJ_CALL(result = self->object.characteristics());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Spliterator_estimateSize(t_Spliterator *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.estimateSize());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_Spliterator_forEachRemaining(t_Spliterator *self, PyObject *arg)
    {
      ::java::util::function::Consumer a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
      {
        OBJ_CALL(self->object.forEachRemaining(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "forEachRemaining", arg);
      return NULL;
    }

    static PyObject *t_Spliterator_getComparator(t_Spliterator *self)
    {
      ::java::util::Comparator result((jobject) NULL);
      OBJ_CALL(result = self->object.getComparator());
      return ::java::util::t_Comparator::wrap_Object(result);
    }

    static PyObject *t_Spliterator_getExactSizeIfKnown(t_Spliterator *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.getExactSizeIfKnown());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_Spliterator_hasCharacteristics(t_Spliterator *self, PyObject *arg)
    {
      jint a0;
      jboolean result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.hasCharacteristics(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "hasCharacteristics", arg);
      return NULL;
    }

    static PyObject *t_Spliterator_tryAdvance(t_Spliterator *self, PyObject *arg)
    {
      ::java::util::function::Consumer a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArg(arg, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
      {
        OBJ_CALL(result = self->object.tryAdvance(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "tryAdvance", arg);
      return NULL;
    }

    static PyObject *t_Spliterator_trySplit(t_Spliterator *self)
    {
      Spliterator result((jobject) NULL);
      OBJ_CALL(result = self->object.trySplit());
      return t_Spliterator::wrap_Object(result, self->parameters[0]);
    }
    static PyObject *t_Spliterator_get__parameters_(t_Spliterator *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_Spliterator_get__comparator(t_Spliterator *self, void *data)
    {
      ::java::util::Comparator value((jobject) NULL);
      OBJ_CALL(value = self->object.getComparator());
      return ::java::util::t_Comparator::wrap_Object(value);
    }

    static PyObject *t_Spliterator_get__exactSizeIfKnown(t_Spliterator *self, void *data)
    {
      jlong value;
      OBJ_CALL(value = self->object.getExactSizeIfKnown());
      return PyLong_FromLongLong((PY_LONG_LONG) value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/UnaryOperator.h"
#include "java/util/function/UnaryOperator.h"
#include "java/lang/Object.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *UnaryOperator::class$ = NULL;
      jmethodID *UnaryOperator::mids$ = NULL;
      bool UnaryOperator::live$ = false;

      jclass UnaryOperator::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/UnaryOperator");

          mids$ = new jmethodID[max_mid];
          mids$[mid_identity_1cfc907d63d0665f] = env->getStaticMethodID(cls, "identity", "()Ljava/util/function/UnaryOperator;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      UnaryOperator UnaryOperator::identity()
      {
        jclass cls = env->getClass(initializeClass);
        return UnaryOperator(env->callStaticObjectMethod(cls, mids$[mid_identity_1cfc907d63d0665f]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_UnaryOperator_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_UnaryOperator_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_UnaryOperator_of_(t_UnaryOperator *self, PyObject *args);
      static PyObject *t_UnaryOperator_identity(PyTypeObject *type, PyObject *args);
      static PyObject *t_UnaryOperator_get__parameters_(t_UnaryOperator *self, void *data);
      static PyGetSetDef t_UnaryOperator__fields_[] = {
        DECLARE_GET_FIELD(t_UnaryOperator, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_UnaryOperator__methods_[] = {
        DECLARE_METHOD(t_UnaryOperator, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_UnaryOperator, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_UnaryOperator, of_, METH_VARARGS),
        DECLARE_METHOD(t_UnaryOperator, identity, METH_VARARGS | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(UnaryOperator)[] = {
        { Py_tp_methods, t_UnaryOperator__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_UnaryOperator__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(UnaryOperator)[] = {
        &PY_TYPE_DEF(::java::util::function::Function),
        NULL
      };

      DEFINE_TYPE(UnaryOperator, t_UnaryOperator, UnaryOperator);
      PyObject *t_UnaryOperator::wrap_Object(const UnaryOperator& object, PyTypeObject *p0)
      {
        PyObject *obj = t_UnaryOperator::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_UnaryOperator *self = (t_UnaryOperator *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_UnaryOperator::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_UnaryOperator::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_UnaryOperator *self = (t_UnaryOperator *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_UnaryOperator::install(PyObject *module)
      {
        installType(&PY_TYPE(UnaryOperator), &PY_TYPE_DEF(UnaryOperator), module, "UnaryOperator", 0);
      }

      void t_UnaryOperator::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(UnaryOperator), "class_", make_descriptor(UnaryOperator::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(UnaryOperator), "wrapfn_", make_descriptor(t_UnaryOperator::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(UnaryOperator), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_UnaryOperator_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, UnaryOperator::initializeClass, 1)))
          return NULL;
        return t_UnaryOperator::wrap_Object(UnaryOperator(((t_UnaryOperator *) arg)->object.this$));
      }
      static PyObject *t_UnaryOperator_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, UnaryOperator::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_UnaryOperator_of_(t_UnaryOperator *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_UnaryOperator_identity(PyTypeObject *type, PyObject *args)
      {
        UnaryOperator result((jobject) NULL);

        if (!parseArgs(args, ""))
        {
          OBJ_CALL(result = ::java::util::function::UnaryOperator::identity());
          return t_UnaryOperator::wrap_Object(result);
        }

        return callSuper(type, "identity", args, 2);
      }
      static PyObject *t_UnaryOperator_get__parameters_(t_UnaryOperator *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/FileStore.h"
#include "java/lang/String.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *FileStore::class$ = NULL;
      jmethodID *FileStore::mids$ = NULL;
      bool FileStore::live$ = false;

      jclass FileStore::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/FileStore");

          mids$ = new jmethodID[max_mid];
          mids$[mid_getAttribute_c0a3c3394484d296] = env->getMethodID(cls, "getAttribute", "(Ljava/lang/String;)Ljava/lang/Object;");
          mids$[mid_getTotalSpace_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTotalSpace", "()J");
          mids$[mid_getUnallocatedSpace_2e5ae9edcb9b072f] = env->getMethodID(cls, "getUnallocatedSpace", "()J");
          mids$[mid_getUsableSpace_2e5ae9edcb9b072f] = env->getMethodID(cls, "getUsableSpace", "()J");
          mids$[mid_isReadOnly_8454bd5aa23fd11e] = env->getMethodID(cls, "isReadOnly", "()Z");
          mids$[mid_name_db9b55ba01e03e4b] = env->getMethodID(cls, "name", "()Ljava/lang/String;");
          mids$[mid_supportsFileAttributeView_145b2d0af0c06b93] = env->getMethodID(cls, "supportsFileAttributeView", "(Ljava/lang/String;)Z");
          mids$[mid_type_db9b55ba01e03e4b] = env->getMethodID(cls, "type", "()Ljava/lang/String;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::lang::Object FileStore::getAttribute(const ::java::lang::String & a0) const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_getAttribute_c0a3c3394484d296], a0.this$));
      }

      jlong FileStore::getTotalSpace() const
      {
        return env->callLongMethod(this$, mids$[mid_getTotalSpace_2e5ae9edcb9b072f]);
      }

      jlong FileStore::getUnallocatedSpace() const
      {
        return env->callLongMethod(this$, mids$[mid_getUnallocatedSpace_2e5ae9edcb9b072f]);
      }

      jlong FileStore::getUsableSpace() const
      {
        return env->callLongMethod(this$, mids$[mid_getUsableSpace_2e5ae9edcb9b072f]);
      }

      jboolean FileStore::isReadOnly() const
      {
        return env->callBooleanMethod(this$, mids$[mid_isReadOnly_8454bd5aa23fd11e]);
      }

      ::java::lang::String FileStore::name() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_name_db9b55ba01e03e4b]));
      }

      jboolean FileStore::supportsFileAttributeView(const ::java::lang::String & a0) const
      {
        return env->callBooleanMethod(this$, mids$[mid_supportsFileAttributeView_145b2d0af0c06b93], a0.this$);
      }

      ::java::lang::String FileStore::type() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_type_db9b55ba01e03e4b]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_FileStore_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileStore_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileStore_getAttribute(t_FileStore *self, PyObject *arg);
      static PyObject *t_FileStore_getTotalSpace(t_FileStore *self);
      static PyObject *t_FileStore_getUnallocatedSpace(t_FileStore *self);
      static PyObject *t_FileStore_getUsableSpace(t_FileStore *self);
      static PyObject *t_FileStore_isReadOnly(t_FileStore *self);
      static PyObject *t_FileStore_name(t_FileStore *self);
      static PyObject *t_FileStore_supportsFileAttributeView(t_FileStore *self, PyObject *arg);
      static PyObject *t_FileStore_type(t_FileStore *self);
      static PyObject *t_FileStore_get__readOnly(t_FileStore *self, void *data);
      static PyObject *t_FileStore_get__totalSpace(t_FileStore *self, void *data);
      static PyObject *t_FileStore_get__unallocatedSpace(t_FileStore *self, void *data);
      static PyObject *t_FileStore_get__usableSpace(t_FileStore *self, void *data);
      static PyGetSetDef t_FileStore__fields_[] = {
        DECLARE_GET_FIELD(t_FileStore, readOnly),
        DECLARE_GET_FIELD(t_FileStore, totalSpace),
        DECLARE_GET_FIELD(t_FileStore, unallocatedSpace),
        DECLARE_GET_FIELD(t_FileStore, usableSpace),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_FileStore__methods_[] = {
        DECLARE_METHOD(t_FileStore, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileStore, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileStore, getAttribute, METH_O),
        DECLARE_METHOD(t_FileStore, getTotalSpace, METH_NOARGS),
        DECLARE_METHOD(t_FileStore, getUnallocatedSpace, METH_NOARGS),
        DECLARE_METHOD(t_FileStore, getUsableSpace, METH_NOARGS),
        DECLARE_METHOD(t_FileStore, isReadOnly, METH_NOARGS),
        DECLARE_METHOD(t_FileStore, name, METH_NOARGS),
        DECLARE_METHOD(t_FileStore, supportsFileAttributeView, METH_O),
        DECLARE_METHOD(t_FileStore, type, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(FileStore)[] = {
        { Py_tp_methods, t_FileStore__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_FileStore__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(FileStore)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(FileStore, t_FileStore, FileStore);

      void t_FileStore::install(PyObject *module)
      {
        installType(&PY_TYPE(FileStore), &PY_TYPE_DEF(FileStore), module, "FileStore", 0);
      }

      void t_FileStore::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileStore), "class_", make_descriptor(FileStore::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileStore), "wrapfn_", make_descriptor(t_FileStore::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileStore), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_FileStore_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, FileStore::initializeClass, 1)))
          return NULL;
        return t_FileStore::wrap_Object(FileStore(((t_FileStore *) arg)->object.this$));
      }
      static PyObject *t_FileStore_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, FileStore::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_FileStore_getAttribute(t_FileStore *self, PyObject *arg)
      {
        ::java::lang::String a0((jobject) NULL);
        ::java::lang::Object result((jobject) NULL);

        if (!parseArg(arg, "s", &a0))
        {
          OBJ_CALL(result = self->object.getAttribute(a0));
          return ::java::lang::t_Object::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "getAttribute", arg);
        return NULL;
      }

      static PyObject *t_FileStore_getTotalSpace(t_FileStore *self)
      {
        jlong result;
        OBJ_CALL(result = self->object.getTotalSpace());
        return PyLong_FromLongLong((PY_LONG_LONG) result);
      }

      static PyObject *t_FileStore_getUnallocatedSpace(t_FileStore *self)
      {
        jlong result;
        OBJ_CALL(result = self->object.getUnallocatedSpace());
        return PyLong_FromLongLong((PY_LONG_LONG) result);
      }

      static PyObject *t_FileStore_getUsableSpace(t_FileStore *self)
      {
        jlong result;
        OBJ_CALL(result = self->object.getUsableSpace());
        return PyLong_FromLongLong((PY_LONG_LONG) result);
      }

      static PyObject *t_FileStore_isReadOnly(t_FileStore *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.isReadOnly());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_FileStore_name(t_FileStore *self)
      {
        ::java::lang::String result((jobject) NULL);
        OBJ_CALL(result = self->object.name());
        return j2p(result);
      }

      static PyObject *t_FileStore_supportsFileAttributeView(t_FileStore *self, PyObject *arg)
      {
        ::java::lang::String a0((jobject) NULL);
        jboolean result;

        if (!parseArg(arg, "s", &a0))
        {
          OBJ_CALL(result = self->object.supportsFileAttributeView(a0));
          Py_RETURN_BOOL(result);
        }

        PyErr_SetArgsError((PyObject *) self, "supportsFileAttributeView", arg);
        return NULL;
      }

      static PyObject *t_FileStore_type(t_FileStore *self)
      {
        ::java::lang::String result((jobject) NULL);
        OBJ_CALL(result = self->object.type());
        return j2p(result);
      }

      static PyObject *t_FileStore_get__readOnly(t_FileStore *self, void *data)
      {
        jboolean value;
        OBJ_CALL(value = self->object.isReadOnly());
        Py_RETURN_BOOL(value);
      }

      static PyObject *t_FileStore_get__totalSpace(t_FileStore *self, void *data)
      {
        jlong value;
        OBJ_CALL(value = self->object.getTotalSpace());
        return PyLong_FromLongLong((PY_LONG_LONG) value);
      }

      static PyObject *t_FileStore_get__unallocatedSpace(t_FileStore *self, void *data)
      {
        jlong value;
        OBJ_CALL(value = self->object.getUnallocatedSpace());
        return PyLong_FromLongLong((PY_LONG_LONG) value);
      }

      static PyObject *t_FileStore_get__usableSpace(t_FileStore *self, void *data)
      {
        jlong value;
        OBJ_CALL(value = self->object.getUsableSpace());
        return PyLong_FromLongLong((PY_LONG_LONG) value);
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/IntToLongFunction.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *IntToLongFunction::class$ = NULL;
      jmethodID *IntToLongFunction::mids$ = NULL;
      bool IntToLongFunction::live$ = false;

      jclass IntToLongFunction::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/IntToLongFunction");

          mids$ = new jmethodID[max_mid];
          mids$[mid_applyAsLong_0f1d64a641e8af53] = env->getMethodID(cls, "applyAsLong", "(I)J");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jlong IntToLongFunction::applyAsLong(jint a0) const
      {
        return env->callLongMethod(this$, mids$[mid_applyAsLong_0f1d64a641e8af53], a0);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_IntToLongFunction_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntToLongFunction_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntToLongFunction_applyAsLong(t_IntToLongFunction *self, PyObject *arg);

      static PyMethodDef t_IntToLongFunction__methods_[] = {
        DECLARE_METHOD(t_IntToLongFunction, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntToLongFunction, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntToLongFunction, applyAsLong, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(IntToLongFunction)[] = {
        { Py_tp_methods, t_IntToLongFunction__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(IntToLongFunction)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(IntToLongFunction, t_IntToLongFunction, IntToLongFunction);

      void t_IntToLongFunction::install(PyObject *module)
      {
        installType(&PY_TYPE(IntToLongFunction), &PY_TYPE_DEF(IntToLongFunction), module, "IntToLongFunction", 0);
      }

      void t_IntToLongFunction::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntToLongFunction), "class_", make_descriptor(IntToLongFunction::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntToLongFunction), "wrapfn_", make_descriptor(t_IntToLongFunction::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntToLongFunction), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_IntToLongFunction_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, IntToLongFunction::initializeClass, 1)))
          return NULL;
        return t_IntToLongFunction::wrap_Object(IntToLongFunction(((t_IntToLongFunction *) arg)->object.this$));
      }
      static PyObject *t_IntToLongFunction_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, IntToLongFunction::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_IntToLongFunction_applyAsLong(t_IntToLongFunction *self, PyObject *arg)
      {
        jint a0;
        jlong result;

        if (!parseArg(arg, "I", &a0))
        {
          OBJ_CALL(result = self->object.applyAsLong(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsLong", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Dictionary.h"
#include "java/util/Enumeration.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Dictionary::class$ = NULL;
    jmethodID *Dictionary::mids$ = NULL;
    bool Dictionary::live$ = false;

    jclass Dictionary::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Dictionary");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_elements_f270cc1d2d4072a8] = env->getMethodID(cls, "elements", "()Ljava/util/Enumeration;");
        mids$[mid_get_e5ae0f8c04795fa9] = env->getMethodID(cls, "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
        mids$[mid_keys_f270cc1d2d4072a8] = env->getMethodID(cls, "keys", "()Ljava/util/Enumeration;");
        mids$[mid_put_128a89bbc17a8b69] = env->getMethodID(cls, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_remove_e5ae0f8c04795fa9] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Dictionary::Dictionary() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    ::java::util::Enumeration Dictionary::elements() const
    {
      return ::java::util::Enumeration(env->callObjectMethod(this$, mids$[mid_elements_f270cc1d2d4072a8]));
    }

    ::java::lang::Object Dictionary::get(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_e5ae0f8c04795fa9], a0.this$));
    }

    jboolean Dictionary::isEmpty() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
    }

    ::java::util::Enumeration Dictionary::keys() const
    {
      return ::java::util::Enumeration(env->callObjectMethod(this$, mids$[mid_keys_f270cc1d2d4072a8]));
    }

    ::java::lang::Object Dictionary::put(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_put_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    ::java::lang::Object Dictionary::remove(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_e5ae0f8c04795fa9], a0.this$));
    }

    jint Dictionary::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Dictionary_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Dictionary_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Dictionary_of_(t_Dictionary *self, PyObject *args);
    static int t_Dictionary_init_(t_Dictionary *self, PyObject *args, PyObject *kwds);
    static PyObject *t_Dictionary_elements(t_Dictionary *self);
    static PyObject *t_Dictionary_get(t_Dictionary *self, PyObject *arg);
    static PyObject *t_Dictionary_isEmpty(t_Dictionary *self);
    static PyObject *t_Dictionary_keys(t_Dictionary *self);
    static PyObject *t_Dictionary_put(t_Dictionary *self, PyObject *args);
    static PyObject *t_Dictionary_remove(t_Dictionary *self, PyObject *arg);
    static PyObject *t_Dictionary_size(t_Dictionary *self);
    static PyObject *t_Dictionary_get__empty(t_Dictionary *self, void *data);
    static PyObject *t_Dictionary_get__parameters_(t_Dictionary *self, void *data);
    static PyGetSetDef t_Dictionary__fields_[] = {
      DECLARE_GET_FIELD(t_Dictionary, empty),
      DECLARE_GET_FIELD(t_Dictionary, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Dictionary__methods_[] = {
      DECLARE_METHOD(t_Dictionary, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Dictionary, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Dictionary, of_, METH_VARARGS),
      DECLARE_METHOD(t_Dictionary, elements, METH_NOARGS),
      DECLARE_METHOD(t_Dictionary, get, METH_O),
      DECLARE_METHOD(t_Dictionary, isEmpty, METH_NOARGS),
      DECLARE_METHOD(t_Dictionary, keys, METH_NOARGS),
      DECLARE_METHOD(t_Dictionary, put, METH_VARARGS),
      DECLARE_METHOD(t_Dictionary, remove, METH_O),
      DECLARE_METHOD(t_Dictionary, size, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Dictionary)[] = {
      { Py_tp_methods, t_Dictionary__methods_ },
      { Py_tp_init, (void *) t_Dictionary_init_ },
      { Py_tp_getset, t_Dictionary__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Dictionary)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Dictionary, t_Dictionary, Dictionary);
    PyObject *t_Dictionary::wrap_Object(const Dictionary& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_Dictionary::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Dictionary *self = (t_Dictionary *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    PyObject *t_Dictionary::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_Dictionary::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Dictionary *self = (t_Dictionary *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    void t_Dictionary::install(PyObject *module)
    {
      installType(&PY_TYPE(Dictionary), &PY_TYPE_DEF(Dictionary), module, "Dictionary", 0);
    }

    void t_Dictionary::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Dictionary), "class_", make_descriptor(Dictionary::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Dictionary), "wrapfn_", make_descriptor(t_Dictionary::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Dictionary), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Dictionary_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Dictionary::initializeClass, 1)))
        return NULL;
      return t_Dictionary::wrap_Object(Dictionary(((t_Dictionary *) arg)->object.this$));
    }
    static PyObject *t_Dictionary_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Dictionary::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Dictionary_of_(t_Dictionary *self, PyObject *args)
    {
      if (!parseArg(args, "T", 2, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static int t_Dictionary_init_(t_Dictionary *self, PyObject *args, PyObject *kwds)
    {
      Dictionary object((jobject) NULL);

      INT_CALL(object = Dictionary());
      self->object = object;

      return 0;
    }

    static PyObject *t_Dictionary_elements(t_Dictionary *self)
    {
      ::java::util::Enumeration result((jobject) NULL);
      OBJ_CALL(result = self->object.elements());
      return ::java::util::t_Enumeration::wrap_Object(result, self->parameters[1]);
    }

    static PyObject *t_Dictionary_get(t_Dictionary *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "get", arg);
      return NULL;
    }

    static PyObject *t_Dictionary_isEmpty(t_Dictionary *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isEmpty());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_Dictionary_keys(t_Dictionary *self)
    {
      ::java::util::Enumeration result((jobject) NULL);
      OBJ_CALL(result = self->object.keys());
      return ::java::util::t_Enumeration::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_Dictionary_put(t_Dictionary *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
      {
        OBJ_CALL(result = self->object.put(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "put", args);
      return NULL;
    }

    static PyObject *t_Dictionary_remove(t_Dictionary *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.remove(a0));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "remove", arg);
      return NULL;
    }

    static PyObject *t_Dictionary_size(t_Dictionary *self)
    {
      jint result;
      OBJ_CALL(result = self->object.size());
      return PyLong_FromLong((long) result);
    }
    static PyObject *t_Dictionary_get__parameters_(t_Dictionary *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_Dictionary_get__empty(t_Dictionary *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isEmpty());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/OpenOption.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *OpenOption::class$ = NULL;
      jmethodID *OpenOption::mids$ = NULL;
      bool OpenOption::live$ = false;

      jclass OpenOption::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/OpenOption");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_OpenOption_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_OpenOption_instance_(PyTypeObject *type, PyObject *arg);

      static PyMethodDef t_OpenOption__methods_[] = {
        DECLARE_METHOD(t_OpenOption, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_OpenOption, instance_, METH_O | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(OpenOption)[] = {
        { Py_tp_methods, t_OpenOption__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(OpenOption)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(OpenOption, t_OpenOption, OpenOption);

      void t_OpenOption::install(PyObject *module)
      {
        installType(&PY_TYPE(OpenOption), &PY_TYPE_DEF(OpenOption), module, "OpenOption", 0);
      }

      void t_OpenOption::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(OpenOption), "class_", make_descriptor(OpenOption::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(OpenOption), "wrapfn_", make_descriptor(t_OpenOption::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(OpenOption), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_OpenOption_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, OpenOption::initializeClass, 1)))
          return NULL;
        return t_OpenOption::wrap_Object(OpenOption(((t_OpenOption *) arg)->object.this$));
      }
      static PyObject *t_OpenOption_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, OpenOption::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/NavigableMap.h"
#include "java/util/Map$Entry.h"
#include "java/util/NavigableMap.h"
#include "java/util/NavigableSet.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *NavigableMap::class$ = NULL;
    jmethodID *NavigableMap::mids$ = NULL;
    bool NavigableMap::live$ = false;

    jclass NavigableMap::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/NavigableMap");

        mids$ = new jmethodID[max_mid];
        mids$[mid_ceilingEntry_fff755411ed1529f] = env->getMethodID(cls, "ceilingEntry", "(Ljava/lang/Object;)Ljava/util/Map$Entry;");
        mids$[mid_ceilingKey_e5ae0f8c04795fa9] = env->getMethodID(cls, "ceilingKey", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_descendingKeySet_69a674c200eed505] = env->getMethodID(cls, "descendingKeySet", "()Ljava/util/NavigableSet;");
        mids$[mid_descendingMap_4e7fc959a77f584b] = env->getMethodID(cls, "descendingMap", "()Ljava/util/NavigableMap;");
        mids$[mid_firstEntry_e3cdd83e5947ee54] = env->getMethodID(cls, "firstEntry", "()Ljava/util/Map$Entry;");
        mids$[mid_floorEntry_fff755411ed1529f] = env->getMethodID(cls, "floorEntry", "(Ljava/lang/Object;)Ljava/util/Map$Entry;");
        mids$[mid_floorKey_e5ae0f8c04795fa9] = env->getMethodID(cls, "floorKey", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_headMap_ebd5eccc289248f0] = env->getMethodID(cls, "headMap", "(Ljava/lang/Object;)Ljava/util/SortedMap;");
        mids$[mid_headMap_923f6d78a49e76e5] = env->getMethodID(cls, "headMap", "(Ljava/lang/Object;Z)Ljava/util/NavigableMap;");
        mids$[mid_higherEntry_fff755411ed1529f] = env->getMethodID(cls, "higherEntry", "(Ljava/lang/Object;)Ljava/util/Map$Entry;");
        mids$[mid_higherKey_e5ae0f8c04795fa9] = env->getMethodID(cls, "higherKey", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_lastEntry_e3cdd83e5947ee54] = env->getMethodID(cls, "lastEntry", "()Ljava/util/Map$Entry;");
        mids$[mid_lowerEntry_fff755411ed1529f] = env->getMethodID(cls, "lowerEntry", "(Ljava/lang/Object;)Ljava/util/Map$Entry;");
        mids$[mid_lowerKey_e5ae0f8c04795fa9] = env->getMethodID(cls, "lowerKey", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_navigableKeySet_69a674c200eed505] = env->getMethodID(cls, "navigableKeySet", "()Ljava/util/NavigableSet;");
        mids$[mid_pollFirstEntry_e3cdd83e5947ee54] = env->getMethodID(cls, "pollFirstEntry", "()Ljava/util/Map$Entry;");
        mids$[mid_pollLastEntry_e3cdd83e5947ee54] = env->getMethodID(cls, "pollLastEntry", "()Ljava/util/Map$Entry;");
        mids$[mid_subMap_5f2ca92e52d24a87] = env->getMethodID(cls, "subMap", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/SortedMap;");
        mids$[mid_subMap_a8f2bed54a4920ca] = env->getMethodID(cls, "subMap", "(Ljava/lang/Object;ZLjava/lang/Object;Z)Ljava/util/NavigableMap;");
        mids$[mid_tailMap_ebd5eccc289248f0] = env->getMethodID(cls, "tailMap", "(Ljava/lang/Object;)Ljava/util/SortedMap;");
        mids$[mid_tailMap_923f6d78a49e76e5] = env->getMethodID(cls, "tailMap", "(Ljava/lang/Object;Z)Ljava/util/NavigableMap;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ::java::util::Map$Entry NavigableMap::ceilingEntry(const ::java::lang::Object & a0) const
    {
      return ::java::util::Map$Entry(env->callObjectMethod(this$, mids$[mid_ceilingEntry_fff755411ed1529f], a0.this$));
    }

    ::java::lang::Object NavigableMap::ceilingKey(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_ceilingKey_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::util::NavigableSet NavigableMap::descendingKeySet() const
    {
      return ::java::util::NavigableSet(env->callObjectMethod(this$, mids$[mid_descendingKeySet_69a674c200eed505]));
    }

    NavigableMap NavigableMap::descendingMap() const
    {
      return NavigableMap(env->callObjectMethod(this$, mids$[mid_descendingMap_4e7fc959a77f584b]));
    }

    ::java::util::Map$Entry NavigableMap::firstEntry() const
    {
      return ::java::util::Map$Entry(env->callObjectMethod(this$, mids$[mid_firstEntry_e3cdd83e5947ee54]));
    }

    ::java::util::Map$Entry NavigableMap::floorEntry(const ::java::lang::Object & a0) const
    {
      return ::java::util::Map$Entry(env->callObjectMethod(this$, mids$[mid_floorEntry_fff755411ed1529f], a0.this$));
    }

    ::java::lang::Object NavigableMap::floorKey(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_floorKey_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::util::SortedMap NavigableMap::headMap(const ::java::lang::Object & a0) const
    {
      return ::java::util::SortedMap(env->callObjectMethod(this$, mids$[mid_headMap_ebd5eccc289248f0], a0.this$));
    }

    NavigableMap NavigableMap::headMap(const ::java::lang::Object & a0, jboolean a1) const
    {
      return NavigableMap(env->callObjectMethod(this$, mids$[mid_headMap_923f6d78a49e76e5], a0.this$, a1));
    }

    ::java::util::Map$Entry NavigableMap::higherEntry(const ::java::lang::Object & a0) const
    {
      return ::java::util::Map$Entry(env->callObjectMethod(this$, mids$[mid_higherEntry_fff755411ed1529f], a0.this$));
    }

    ::java::lang::Object NavigableMap::higherKey(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_higherKey_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::util::Map$Entry NavigableMap::lastEntry() const
    {
      return ::java::util::Map$Entry(env->callObjectMethod(this$, mids$[mid_lastEntry_e3cdd83e5947ee54]));
    }

    ::java::util::Map$Entry NavigableMap::lowerEntry(const ::java::lang::Object & a0) const
    {
      return ::java::util::Map$Entry(env->callObjectMethod(this$, mids$[mid_lowerEntry_fff755411ed1529f], a0.this$));
    }

    ::java::lang::Object NavigableMap::lowerKey(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_lowerKey_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::util::NavigableSet NavigableMap::navigableKeySet() const
    {
      return ::java::util::NavigableSet(env->callObjectMethod(this$, mids$[mid_navigableKeySet_69a674c200eed505]));
    }

    ::java::util::Map$Entry NavigableMap::pollFirstEntry() const
    {
      return ::java::util::Map$Entry(env->callObjectMethod(this$, mids$[mid_pollFirstEntry_e3cdd83e5947ee54]));
    }

    ::java::util::Map$Entry NavigableMap::pollLastEntry() const
    {
      return ::java::util::Map$Entry(env->callObjectMethod(this$, mids$[mid_pollLastEntry_e3cdd83e5947ee54]));
    }

    ::java::util::SortedMap NavigableMap::subMap(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::util::SortedMap(env->callObjectMethod(this$, mids$[mid_subMap_5f2ca92e52d24a87], a0.this$, a1.this$));
    }

    NavigableMap NavigableMap::subMap(const ::java::lang::Object & a0, jboolean a1, const ::java::lang::Object & a2, jboolean a3) const
    {
      return NavigableMap(env->callObjectMethod(this$, mids$[mid_subMap_a8f2bed54a4920ca], a0.this$, a1, a2.this$, a3));
    }

    ::java::util::SortedMap NavigableMap::tailMap(const ::java::lang::Object & a0) const
    {
      return ::java::util::SortedMap(env->callObjectMethod(this$, mids$[mid_tailMap_ebd5eccc289248f0], a0.this$));
    }

    NavigableMap NavigableMap::tailMap(const ::java::lang::Object & a0, jboolean a1) const
    {
      return NavigableMap(env->callObjectMethod(this$, mids$[mid_tailMap_923f6d78a49e76e5], a0.this$, a1));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_NavigableMap_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_NavigableMap_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_NavigableMap_of_(t_NavigableMap *self, PyObject *args);
    static PyObject *t_NavigableMap_ceilingEntry(t_NavigableMap *self, PyObject *arg);
    static PyObject *t_NavigableMap_ceilingKey(t_NavigableMap *self, PyObject *arg);
    static PyObject *t_NavigableMap_descendingKeySet(t_NavigableMap *self);
    static PyObject *t_NavigableMap_descendingMap(t_NavigableMap *self);
    static PyObject *t_NavigableMap_firstEntry(t_NavigableMap *self);
    static PyObject *t_NavigableMap_floorEntry(t_NavigableMap *self, PyObject *arg);
    static PyObject *t_NavigableMap_floorKey(t_NavigableMap *self, PyObject *arg);
    static PyObject *t_NavigableMap_headMap(t_NavigableMap *self, PyObject *args);
    static PyObject *t_NavigableMap_higherEntry(t_NavigableMap *self, PyObject *arg);
    static PyObject *t_NavigableMap_higherKey(t_NavigableMap *self, PyObject *arg);
    static PyObject *t_NavigableMap_lastEntry(t_NavigableMap *self);
    static PyObject *t_NavigableMap_lowerEntry(t_NavigableMap *self, PyObject *arg);
    static PyObject *t_NavigableMap_lowerKey(t_NavigableMap *self, PyObject *arg);
    static PyObject *t_NavigableMap_navigableKeySet(t_NavigableMap *self);
    static PyObject *t_NavigableMap_pollFirstEntry(t_NavigableMap *self);
    static PyObject *t_NavigableMap_pollLastEntry(t_NavigableMap *self);
    static PyObject *t_NavigableMap_subMap(t_NavigableMap *self, PyObject *args);
    static PyObject *t_NavigableMap_tailMap(t_NavigableMap *self, PyObject *args);
    static PyObject *t_NavigableMap_get__parameters_(t_NavigableMap *self, void *data);
    static PyGetSetDef t_NavigableMap__fields_[] = {
      DECLARE_GET_FIELD(t_NavigableMap, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_NavigableMap__methods_[] = {
      DECLARE_METHOD(t_NavigableMap, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_NavigableMap, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_NavigableMap, of_, METH_VARARGS),
      DECLARE_METHOD(t_NavigableMap, ceilingEntry, METH_O),
      DECLARE_METHOD(t_NavigableMap, ceilingKey, METH_O),
      DECLARE_METHOD(t_NavigableMap, descendingKeySet, METH_NOARGS),
      DECLARE_METHOD(t_NavigableMap, descendingMap, METH_NOARGS),
      DECLARE_METHOD(t_NavigableMap, firstEntry, METH_NOARGS),
      DECLARE_METHOD(t_NavigableMap, floorEntry, METH_O),
      DECLARE_METHOD(t_NavigableMap, floorKey, METH_O),
      DECLARE_METHOD(t_NavigableMap, headMap, METH_VARARGS),
      DECLARE_METHOD(t_NavigableMap, higherEntry, METH_O),
      DECLARE_METHOD(t_NavigableMap, higherKey, METH_O),
      DECLARE_METHOD(t_NavigableMap, lastEntry, METH_NOARGS),
      DECLARE_METHOD(t_NavigableMap, lowerEntry, METH_O),
      DECLARE_METHOD(t_NavigableMap, lowerKey, METH_O),
      DECLARE_METHOD(t_NavigableMap, navigableKeySet, METH_NOARGS),
      DECLARE_METHOD(t_NavigableMap, pollFirstEntry, METH_NOARGS),
      DECLARE_METHOD(t_NavigableMap, pollLastEntry, METH_NOARGS),
      DECLARE_METHOD(t_NavigableMap, subMap, METH_VARARGS),
      DECLARE_METHOD(t_NavigableMap, tailMap, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(NavigableMap)[] = {
      { Py_tp_methods, t_NavigableMap__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_NavigableMap__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(NavigableMap)[] = {
      &PY_TYPE_DEF(::java::util::SortedMap),
      NULL
    };

    DEFINE_TYPE(NavigableMap, t_NavigableMap, NavigableMap);
    PyObject *t_NavigableMap::wrap_Object(const NavigableMap& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_NavigableMap::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_NavigableMap *self = (t_NavigableMap *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    PyObject *t_NavigableMap::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_NavigableMap::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_NavigableMap *self = (t_NavigableMap *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    void t_NavigableMap::install(PyObject *module)
    {
      installType(&PY_TYPE(NavigableMap), &PY_TYPE_DEF(NavigableMap), module, "NavigableMap", 0);
    }

    void t_NavigableMap::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(NavigableMap), "class_", make_descriptor(NavigableMap::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(NavigableMap), "wrapfn_", make_descriptor(t_NavigableMap::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(NavigableMap), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_NavigableMap_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, NavigableMap::initializeClass, 1)))
        return NULL;
      return t_NavigableMap::wrap_Object(NavigableMap(((t_NavigableMap *) arg)->object.this$));
    }
    static PyObject *t_NavigableMap_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, NavigableMap::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_NavigableMap_of_(t_NavigableMap *self, PyObject *args)
    {
      if (!parseArg(args, "T", 2, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_NavigableMap_ceilingEntry(t_NavigableMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::Map$Entry result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.ceilingEntry(a0));
        return ::java::util::t_Map$Entry::wrap_Object(result, self->parameters[0], self->parameters[1]);
      }

      PyErr_SetArgsError((PyObject *) self, "ceilingEntry", arg);
      return NULL;
    }

    static PyObject *t_NavigableMap_ceilingKey(t_NavigableMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.ceilingKey(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "ceilingKey", arg);
      return NULL;
    }

    static PyObject *t_NavigableMap_descendingKeySet(t_NavigableMap *self)
    {
      ::java::util::NavigableSet result((jobject) NULL);
      OBJ_CALL(result = self->object.descendingKeySet());
      return ::java::util::t_NavigableSet::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_NavigableMap_descendingMap(t_NavigableMap *self)
    {
      NavigableMap result((jobject) NULL);
      OBJ_CALL(result = self->object.descendingMap());
      return t_NavigableMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
    }

    static PyObject *t_NavigableMap_firstEntry(t_NavigableMap *self)
    {
      ::java::util::Map$Entry result((jobject) NULL);
      OBJ_CALL(result = self->object.firstEntry());
      return ::java::util::t_Map$Entry::wrap_Object(result, self->parameters[0], self->parameters[1]);
    }

    static PyObject *t_NavigableMap_floorEntry(t_NavigableMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::Map$Entry result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.floorEntry(a0));
        return ::java::util::t_Map$Entry::wrap_Object(result, self->parameters[0], self->parameters[1]);
      }

      PyErr_SetArgsError((PyObject *) self, "floorEntry", arg);
      return NULL;
    }

    static PyObject *t_NavigableMap_floorKey(t_NavigableMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.floorKey(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "floorKey", arg);
      return NULL;
    }

    static PyObject *t_NavigableMap_headMap(t_NavigableMap *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::util::SortedMap result((jobject) NULL);

          if (!parseArgs(args, "O", self->parameters[0], &a0))
          {
            OBJ_CALL(result = self->object.headMap(a0));
            return ::java::util::t_SortedMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
          }
        }
        break;
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean a1;
          NavigableMap result((jobject) NULL);

          if (!parseArgs(args, "OZ", self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(result = self->object.headMap(a0, a1));
            return t_NavigableMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
          }
        }
      }

      return callSuper(PY_TYPE(NavigableMap), (PyObject *) self, "headMap", args, 2);
    }

    static PyObject *t_NavigableMap_higherEntry(t_NavigableMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::Map$Entry result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.higherEntry(a0));
        return ::java::util::t_Map$Entry::wrap_Object(result, self->parameters[0], self->parameters[1]);
      }

      PyErr_SetArgsError((PyObject *) self, "higherEntry", arg);
      return NULL;
    }

    static PyObject *t_NavigableMap_higherKey(t_NavigableMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.higherKey(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "higherKey", arg);
      return NULL;
    }

    static PyObject *t_NavigableMap_lastEntry(t_NavigableMap *self)
    {
      ::java::util::Map$Entry result((jobject) NULL);
      OBJ_CALL(result = self->object.lastEntry());
      return ::java::util::t_Map$Entry::wrap_Object(result, self->parameters[0], self->parameters[1]);
    }

    static PyObject *t_NavigableMap_lowerEntry(t_NavigableMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::Map$Entry result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.lowerEntry(a0));
        return ::java::util::t_Map$Entry::wrap_Object(result, self->parameters[0], self->parameters[1]);
      }

      PyErr_SetArgsError((PyObject *) self, "lowerEntry", arg);
      return NULL;
    }

    static PyObject *t_NavigableMap_lowerKey(t_NavigableMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.lowerKey(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "lowerKey", arg);
      return NULL;
    }

    static PyObject *t_NavigableMap_navigableKeySet(t_NavigableMap *self)
    {
      ::java::util::NavigableSet result((jobject) NULL);
      OBJ_CALL(result = self->object.navigableKeySet());
      return ::java::util::t_NavigableSet::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_NavigableMap_pollFirstEntry(t_NavigableMap *self)
    {
      ::java::util::Map$Entry result((jobject) NULL);
      OBJ_CALL(result = self->object.pollFirstEntry());
      return ::java::util::t_Map$Entry::wrap_Object(result, self->parameters[0], self->parameters[1]);
    }

    static PyObject *t_NavigableMap_pollLastEntry(t_NavigableMap *self)
    {
      ::java::util::Map$Entry result((jobject) NULL);
      OBJ_CALL(result = self->object.pollLastEntry());
      return ::java::util::t_Map$Entry::wrap_Object(result, self->parameters[0], self->parameters[1]);
    }

    static PyObject *t_NavigableMap_subMap(t_NavigableMap *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object a1((jobject) NULL);
          ::java::util::SortedMap result((jobject) NULL);

          if (!parseArgs(args, "OO", self->parameters[0], self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(result = self->object.subMap(a0, a1));
            return ::java::util::t_SortedMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
          }
        }
        break;
       case 4:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean a1;
          ::java::lang::Object a2((jobject) NULL);
          jboolean a3;
          NavigableMap result((jobject) NULL);

          if (!parseArgs(args, "OZOZ", self->parameters[0], self->parameters[0], &a0, &a1, &a2, &a3))
          {
            OBJ_CALL(result = self->object.subMap(a0, a1, a2, a3));
            return t_NavigableMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
          }
        }
      }

      return callSuper(PY_TYPE(NavigableMap), (PyObject *) self, "subMap", args, 2);
    }

    static PyObject *t_NavigableMap_tailMap(t_NavigableMap *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::util::SortedMap result((jobject) NULL);

          if (!parseArgs(args, "O", self->parameters[0], &a0))
          {
            OBJ_CALL(result = self->object.tailMap(a0));
            return ::java::util::t_SortedMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
          }
        }
        break;
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean a1;
          NavigableMap result((jobject) NULL);

          if (!parseArgs(args, "OZ", self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(result = self->object.tailMap(a0, a1));
            return t_NavigableMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
          }
        }
      }

      return callSuper(PY_TYPE(NavigableMap), (PyObject *) self, "tailMap", args, 2);
    }
    static PyObject *t_NavigableMap_get__parameters_(t_NavigableMap *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/StringBuffer.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/lang/String.h"
#include "java/lang/CharSequence.h"
#include "java/lang/StringBuffer.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *StringBuffer::class$ = NULL;
    jmethodID *StringBuffer::mids$ = NULL;
    bool StringBuffer::live$ = false;

    jclass StringBuffer::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/StringBuffer");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_040c4cd0390c5aff] = env->getMethodID(cls, "<init>", "(I)V");
        mids$[mid_init$_4b7f5e38f806ae55] = env->getMethodID(cls, "<init>", "(Ljava/lang/CharSequence;)V");
        mids$[mid_append_9e0b91680059c0b9] = env->getMethodID(cls, "append", "(Ljava/lang/StringBuffer;)Ljava/lang/StringBuffer;");
        mids$[mid_append_4c6f9eae8a1f384c] = env->getMethodID(cls, "append", "([C)Ljava/lang/StringBuffer;");
        mids$[mid_append_942dc874baba9ebd] = env->getMethodID(cls, "append", "(Ljava/lang/String;)Ljava/lang/StringBuffer;");
        mids$[mid_append_b657eb3bf0275d66] = env->getMethodID(cls, "append", "(Z)Ljava/lang/StringBuffer;");
        mids$[mid_append_2d66b0da0984256e] = env->getMethodID(cls, "append", "(C)Ljava/lang/StringBuffer;");
        mids$[mid_append_6a80930d7502ebdf] = env->getMethodID(cls, "append", "(D)Ljava/lang/StringBuffer;");
        mids$[mid_append_8398576c041c0b0b] = env->getMethodID(cls, "append", "(F)Ljava/lang/StringBuffer;");
        mids$[mid_append_f0aa20a80b52b0f7] = env->getMethodID(cls, "append", "(I)Ljava/lang/StringBuffer;");
        mids$[mid_append_13ac9758380b2a77] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;)Ljava/lang/StringBuffer;");
        mids$[mid_append_5714890f5187aa6b] = env->getMethodID(cls, "append", "(Ljava/lang/Object;)Ljava/lang/StringBuffer;");
        mids$[mid_append_cd9750143a8b5bf3] = env->getMethodID(cls, "append", "(J)Ljava/lang/StringBuffer;");
        mids$[mid_append_ec0a11e2734b6e2f] = env->getMethodID(cls, "append", "([CII)Ljava/lang/StringBuffer;");
        mids$[mid_append_289a4a8022da39f2] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;II)Ljava/lang/StringBuffer;");
        mids$[mid_appendCodePoint_f0aa20a80b52b0f7] = env->getMethodID(cls, "appendCodePoint", "(I)Ljava/lang/StringBuffer;");
        mids$[mid_capacity_9972fcc56b44e79d] = env->getMethodID(cls, "capacity", "()I");
        mids$[mid_charAt_ebc61ec1e57770d1] = env->getMethodID(cls, "charAt", "(I)C");
        mids$[mid_codePointAt_1e143afe1894d213] = env->getMethodID(cls, "codePointAt", "(I)I");
        mids$[mid_codePointBefore_1e143afe1894d213] = env->getMethodID(cls, "codePointBefore", "(I)I");
        mids$[mid_codePointCount_57a58545eba514db] = env->getMethodID(cls, "codePointCount", "(II)I");
        mids$[mid_delete_3c229bf87e15cfa4] = env->getMethodID(cls, "delete", "(II)Ljava/lang/StringBuffer;");
        mids$[mid_deleteCharAt_f0aa20a80b52b0f7] = env->getMethodID(cls, "deleteCharAt", "(I)Ljava/lang/StringBuffer;");
        mids$[mid_ensureCapacity_040c4cd0390c5aff] = env->getMethodID(cls, "ensureCapacity", "(I)V");
        mids$[mid_getChars_520fb522c03f2e69] = env->getMethodID(cls, "getChars", "(II[CI)V");
        mids$[mid_indexOf_a5a7d1128e9e2bb7] = env->getMethodID(cls, "indexOf", "(Ljava/lang/String;)I");
        mids$[mid_indexOf_30cd5d5b9318bd5d] = env->getMethodID(cls, "indexOf", "(Ljava/lang/String;I)I");
        mids$[mid_insert_5a82a1ef6d57f34e] = env->getMethodID(cls, "insert", "(I[C)Ljava/lang/StringBuffer;");
        mids$[mid_insert_a610ec3896945564] = env->getMethodID(cls, "insert", "(ILjava/lang/String;)Ljava/lang/StringBuffer;");
        mids$[mid_insert_4cef785922b98c34] = env->getMethodID(cls, "insert", "(IZ)Ljava/lang/StringBuffer;");
        mids$[mid_insert_9ff128c3d51c9b39] = env->getMethodID(cls, "insert", "(IC)Ljava/lang/StringBuffer;");
        mids$[mid_insert_3c6fd573987f067e] = env->getMethodID(cls, "insert", "(ID)Ljava/lang/StringBuffer;");
        mids$[mid_insert_5e754580ddd42ee8] = env->getMethodID(cls, "insert", "(IF)Ljava/lang/StringBuffer;");
        mids$[mid_insert_3c229bf87e15cfa4] = env->getMethodID(cls, "insert", "(II)Ljava/lang/StringBuffer;");
        mids$[mid_insert_5f6ff65bc1d8cb86] = env->getMethodID(cls, "insert", "(ILjava/lang/CharSequence;)Ljava/lang/StringBuffer;");
        mids$[mid_insert_aea1c04c57b6cb18] = env->getMethodID(cls, "insert", "(ILjava/lang/Object;)Ljava/lang/StringBuffer;");
        mids$[mid_insert_571ebb07b7d7a83b] = env->getMethodID(cls, "insert", "(IJ)Ljava/lang/StringBuffer;");
        mids$[mid_insert_222564c4fca1841f] = env->getMethodID(cls, "insert", "(I[CII)Ljava/lang/StringBuffer;");
        mids$[mid_insert_7d082429df65d0a6] = env->getMethodID(cls, "insert", "(ILjava/lang/CharSequence;II)Ljava/lang/StringBuffer;");
        mids$[mid_lastIndexOf_a5a7d1128e9e2bb7] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/String;)I");
        mids$[mid_lastIndexOf_30cd5d5b9318bd5d] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/String;I)I");
        mids$[mid_length_9972fcc56b44e79d] = env->getMethodID(cls, "length", "()I");
        mids$[mid_offsetByCodePoints_57a58545eba514db] = env->getMethodID(cls, "offsetByCodePoints", "(II)I");
        mids$[mid_replace_3f75941503d044be] = env->getMethodID(cls, "replace", "(IILjava/lang/String;)Ljava/lang/StringBuffer;");
        mids$[mid_reverse_3e74005fd5116584] = env->getMethodID(cls, "reverse", "()Ljava/lang/StringBuffer;");
        mids$[mid_setCharAt_49eec491b83160ef] = env->getMethodID(cls, "setCharAt", "(IC)V");
        mids$[mid_setLength_040c4cd0390c5aff] = env->getMethodID(cls, "setLength", "(I)V");
        mids$[mid_subSequence_26d6f5be97bcdc38] = env->getMethodID(cls, "subSequence", "(II)Ljava/lang/CharSequence;");
        mids$[mid_substring_d7593acad64ef635] = env->getMethodID(cls, "substring", "(I)Ljava/lang/String;");
        mids$[mid_substring_1f239231430be983] = env->getMethodID(cls, "substring", "(II)Ljava/lang/String;");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
        mids$[mid_trimToSize_f2cc1bce94666404] = env->getMethodID(cls, "trimToSize", "()V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    StringBuffer::StringBuffer() : ::java::lang::AbstractStringBuilder(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    StringBuffer::StringBuffer(const ::java::lang::String & a0) : ::java::lang::AbstractStringBuilder(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    StringBuffer::StringBuffer(jint a0) : ::java::lang::AbstractStringBuilder(env->newObject(initializeClass, &mids$, mid_init$_040c4cd0390c5aff, a0)) {}

    StringBuffer::StringBuffer(const ::java::lang::CharSequence & a0) : ::java::lang::AbstractStringBuilder(env->newObject(initializeClass, &mids$, mid_init$_4b7f5e38f806ae55, a0.this$)) {}

    StringBuffer StringBuffer::append(const StringBuffer & a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_9e0b91680059c0b9], a0.this$));
    }

    StringBuffer StringBuffer::append(const JArray< jchar > & a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_4c6f9eae8a1f384c], a0.this$));
    }

    StringBuffer StringBuffer::append(const ::java::lang::String & a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_942dc874baba9ebd], a0.this$));
    }

    StringBuffer StringBuffer::append(jboolean a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_b657eb3bf0275d66], a0));
    }

    StringBuffer StringBuffer::append(jchar a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_2d66b0da0984256e], a0));
    }

    StringBuffer StringBuffer::append(jdouble a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_6a80930d7502ebdf], a0));
    }

    StringBuffer StringBuffer::append(jfloat a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_8398576c041c0b0b], a0));
    }

    StringBuffer StringBuffer::append(jint a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_f0aa20a80b52b0f7], a0));
    }

    StringBuffer StringBuffer::append(const ::java::lang::CharSequence & a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_13ac9758380b2a77], a0.this$));
    }

    StringBuffer StringBuffer::append(const ::java::lang::Object & a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_5714890f5187aa6b], a0.this$));
    }

    StringBuffer StringBuffer::append(jlong a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_cd9750143a8b5bf3], a0));
    }

    StringBuffer StringBuffer::append(const JArray< jchar > & a0, jint a1, jint a2) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_ec0a11e2734b6e2f], a0.this$, a1, a2));
    }

    StringBuffer StringBuffer::append(const ::java::lang::CharSequence & a0, jint a1, jint a2) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_append_289a4a8022da39f2], a0.this$, a1, a2));
    }

    StringBuffer StringBuffer::appendCodePoint(jint a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_appendCodePoint_f0aa20a80b52b0f7], a0));
    }

    jint StringBuffer::capacity() const
    {
      return env->callIntMethod(this$, mids$[mid_capacity_9972fcc56b44e79d]);
    }

    jchar StringBuffer::charAt(jint a0) const
    {
      return env->callCharMethod(this$, mids$[mid_charAt_ebc61ec1e57770d1], a0);
    }

    jint StringBuffer::codePointAt(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_codePointAt_1e143afe1894d213], a0);
    }

    jint StringBuffer::codePointBefore(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_codePointBefore_1e143afe1894d213], a0);
    }

    jint StringBuffer::codePointCount(jint a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_codePointCount_57a58545eba514db], a0, a1);
    }

    StringBuffer StringBuffer::delete$(jint a0, jint a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_delete_3c229bf87e15cfa4], a0, a1));
    }

    StringBuffer StringBuffer::deleteCharAt(jint a0) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_deleteCharAt_f0aa20a80b52b0f7], a0));
    }

    void StringBuffer::ensureCapacity(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_ensureCapacity_040c4cd0390c5aff], a0);
    }

    void StringBuffer::getChars(jint a0, jint a1, const JArray< jchar > & a2, jint a3) const
    {
      env->callVoidMethod(this$, mids$[mid_getChars_520fb522c03f2e69], a0, a1, a2.this$, a3);
    }

    jint StringBuffer::indexOf(const ::java::lang::String & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_a5a7d1128e9e2bb7], a0.this$);
    }

    jint StringBuffer::indexOf(const ::java::lang::String & a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_30cd5d5b9318bd5d], a0.this$, a1);
    }

    StringBuffer StringBuffer::insert(jint a0, const JArray< jchar > & a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_5a82a1ef6d57f34e], a0, a1.this$));
    }

    StringBuffer StringBuffer::insert(jint a0, const ::java::lang::String & a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_a610ec3896945564], a0, a1.this$));
    }

    StringBuffer StringBuffer::insert(jint a0, jboolean a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_4cef785922b98c34], a0, a1));
    }

    StringBuffer StringBuffer::insert(jint a0, jchar a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_9ff128c3d51c9b39], a0, a1));
    }

    StringBuffer StringBuffer::insert(jint a0, jdouble a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_3c6fd573987f067e], a0, a1));
    }

    StringBuffer StringBuffer::insert(jint a0, jfloat a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_5e754580ddd42ee8], a0, a1));
    }

    StringBuffer StringBuffer::insert(jint a0, jint a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_3c229bf87e15cfa4], a0, a1));
    }

    StringBuffer StringBuffer::insert(jint a0, const ::java::lang::CharSequence & a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_5f6ff65bc1d8cb86], a0, a1.this$));
    }

    StringBuffer StringBuffer::insert(jint a0, const ::java::lang::Object & a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_aea1c04c57b6cb18], a0, a1.this$));
    }

    StringBuffer StringBuffer::insert(jint a0, jlong a1) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_571ebb07b7d7a83b], a0, a1));
    }

    StringBuffer StringBuffer::insert(jint a0, const JArray< jchar > & a1, jint a2, jint a3) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_222564c4fca1841f], a0, a1.this$, a2, a3));
    }

    StringBuffer StringBuffer::insert(jint a0, const ::java::lang::CharSequence & a1, jint a2, jint a3) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_insert_7d082429df65d0a6], a0, a1.this$, a2, a3));
    }

    jint StringBuffer::lastIndexOf(const ::java::lang::String & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_a5a7d1128e9e2bb7], a0.this$);
    }

    jint StringBuffer::lastIndexOf(const ::java::lang::String & a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_30cd5d5b9318bd5d], a0.this$, a1);
    }

    jint StringBuffer::length() const
    {
      return env->callIntMethod(this$, mids$[mid_length_9972fcc56b44e79d]);
    }

    jint StringBuffer::offsetByCodePoints(jint a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_offsetByCodePoints_57a58545eba514db], a0, a1);
    }

    StringBuffer StringBuffer::replace(jint a0, jint a1, const ::java::lang::String & a2) const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_replace_3f75941503d044be], a0, a1, a2.this$));
    }

    StringBuffer StringBuffer::reverse() const
    {
      return StringBuffer(env->callObjectMethod(this$, mids$[mid_reverse_3e74005fd5116584]));
    }

    void StringBuffer::setCharAt(jint a0, jchar a1) const
    {
      env->callVoidMethod(this$, mids$[mid_setCharAt_49eec491b83160ef], a0, a1);
    }

    void StringBuffer::setLength(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setLength_040c4cd0390c5aff], a0);
    }

    ::java::lang::CharSequence StringBuffer::subSequence(jint a0, jint a1) const
    {
      return ::java::lang::CharSequence(env->callObjectMethod(this$, mids$[mid_subSequence_26d6f5be97bcdc38], a0, a1));
    }

    ::java::lang::String StringBuffer::substring(jint a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_substring_d7593acad64ef635], a0));
    }

    ::java::lang::String StringBuffer::substring(jint a0, jint a1) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_substring_1f239231430be983], a0, a1));
    }

    ::java::lang::String StringBuffer::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }

    void StringBuffer::trimToSize() const
    {
      env->callVoidMethod(this$, mids$[mid_trimToSize_f2cc1bce94666404]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_StringBuffer_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_StringBuffer_instance_(PyTypeObject *type, PyObject *arg);
    static int t_StringBuffer_init_(t_StringBuffer *self, PyObject *args, PyObject *kwds);
    static PyObject *t_StringBuffer_append(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_appendCodePoint(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_capacity(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_charAt(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_codePointAt(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_codePointBefore(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_codePointCount(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_delete(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_deleteCharAt(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_ensureCapacity(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_getChars(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_indexOf(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_insert(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_lastIndexOf(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_length(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_offsetByCodePoints(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_replace(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_reverse(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_setCharAt(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_setLength(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_subSequence(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_substring(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_toString(t_StringBuffer *self, PyObject *args);
    static PyObject *t_StringBuffer_trimToSize(t_StringBuffer *self, PyObject *args);

    static PyMethodDef t_StringBuffer__methods_[] = {
      DECLARE_METHOD(t_StringBuffer, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_StringBuffer, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_StringBuffer, append, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, appendCodePoint, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, capacity, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, charAt, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, codePointAt, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, codePointBefore, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, codePointCount, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, delete, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, deleteCharAt, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, ensureCapacity, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, getChars, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, indexOf, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, insert, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, lastIndexOf, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, length, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, offsetByCodePoints, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, replace, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, reverse, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, setCharAt, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, setLength, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, subSequence, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, substring, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, toString, METH_VARARGS),
      DECLARE_METHOD(t_StringBuffer, trimToSize, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(StringBuffer)[] = {
      { Py_tp_methods, t_StringBuffer__methods_ },
      { Py_tp_init, (void *) t_StringBuffer_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(StringBuffer)[] = {
      &PY_TYPE_DEF(::java::lang::AbstractStringBuilder),
      NULL
    };

    DEFINE_TYPE(StringBuffer, t_StringBuffer, StringBuffer);

    void t_StringBuffer::install(PyObject *module)
    {
      installType(&PY_TYPE(StringBuffer), &PY_TYPE_DEF(StringBuffer), module, "StringBuffer", 0);
    }

    void t_StringBuffer::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(StringBuffer), "class_", make_descriptor(StringBuffer::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(StringBuffer), "wrapfn_", make_descriptor(t_StringBuffer::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(StringBuffer), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_StringBuffer_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, StringBuffer::initializeClass, 1)))
        return NULL;
      return t_StringBuffer::wrap_Object(StringBuffer(((t_StringBuffer *) arg)->object.this$));
    }
    static PyObject *t_StringBuffer_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, StringBuffer::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_StringBuffer_init_(t_StringBuffer *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          StringBuffer object((jobject) NULL);

          INT_CALL(object = StringBuffer());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          StringBuffer object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = StringBuffer(a0));
            self->object = object;
            break;
          }
        }
        {
          jint a0;
          StringBuffer object((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            INT_CALL(object = StringBuffer(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          StringBuffer object((jobject) NULL);

          if (!parseArgs(args, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
          {
            INT_CALL(object = StringBuffer(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_StringBuffer_append(t_StringBuffer *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          StringBuffer a0((jobject) NULL);
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "k", StringBuffer::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          JArray< jchar > a0((jobject) NULL);
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "[C", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jboolean a0;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "Z", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jchar a0;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "C", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jdouble a0;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "D", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jfloat a0;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "F", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          ::java::lang::Object a0((jobject) NULL);
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jlong a0;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "J", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          JArray< jchar > a0((jobject) NULL);
          jint a1;
          jint a2;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "[CII", &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.append(a0, a1, a2));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          jint a1;
          jint a2;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "OII", ::java::lang::PY_TYPE(CharSequence), &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.append(a0, a1, a2));
            return t_StringBuffer::wrap_Object(result);
          }
        }
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "append", args, 2);
    }

    static PyObject *t_StringBuffer_appendCodePoint(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      StringBuffer result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.appendCodePoint(a0));
        return t_StringBuffer::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "appendCodePoint", args, 2);
    }

    static PyObject *t_StringBuffer_capacity(t_StringBuffer *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.capacity());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "capacity", args, 2);
    }

    static PyObject *t_StringBuffer_charAt(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jchar result;

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.charAt(a0));
        return c2p(result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "charAt", args, 2);
    }

    static PyObject *t_StringBuffer_codePointAt(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jint result;

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.codePointAt(a0));
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "codePointAt", args, 2);
    }

    static PyObject *t_StringBuffer_codePointBefore(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jint result;

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.codePointBefore(a0));
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "codePointBefore", args, 2);
    }

    static PyObject *t_StringBuffer_codePointCount(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jint a1;
      jint result;

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.codePointCount(a0, a1));
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "codePointCount", args, 2);
    }

    static PyObject *t_StringBuffer_delete(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jint a1;
      StringBuffer result((jobject) NULL);

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.delete$(a0, a1));
        return t_StringBuffer::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "delete", args, 2);
    }

    static PyObject *t_StringBuffer_deleteCharAt(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      StringBuffer result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.deleteCharAt(a0));
        return t_StringBuffer::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "deleteCharAt", args, 2);
    }

    static PyObject *t_StringBuffer_ensureCapacity(t_StringBuffer *self, PyObject *args)
    {
      jint a0;

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(self->object.ensureCapacity(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "ensureCapacity", args, 2);
    }

    static PyObject *t_StringBuffer_getChars(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jint a1;
      JArray< jchar > a2((jobject) NULL);
      jint a3;

      if (!parseArgs(args, "II[CI", &a0, &a1, &a2, &a3))
      {
        OBJ_CALL(self->object.getChars(a0, a1, a2, a3));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "getChars", args, 2);
    }

    static PyObject *t_StringBuffer_indexOf(t_StringBuffer *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          jint result;

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.indexOf(a0));
            return PyLong_FromLong((long) result);
          }
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          jint a1;
          jint result;

          if (!parseArgs(args, "sI", &a0, &a1))
          {
            OBJ_CALL(result = self->object.indexOf(a0, a1));
            return PyLong_FromLong((long) result);
          }
        }
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "indexOf", args, 2);
    }

    static PyObject *t_StringBuffer_insert(t_StringBuffer *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          jint a0;
          JArray< jchar > a1((jobject) NULL);
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "I[C", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::String a1((jobject) NULL);
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "Is", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          jboolean a1;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "IZ", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          jchar a1;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "IC", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          jdouble a1;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "ID", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          jfloat a1;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "IF", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          jint a1;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::CharSequence a1((jobject) NULL);
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "IO", ::java::lang::PY_TYPE(CharSequence), &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::Object a1((jobject) NULL);
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "Io", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          jlong a1;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "IJ", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        break;
       case 4:
        {
          jint a0;
          JArray< jchar > a1((jobject) NULL);
          jint a2;
          jint a3;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "I[CII", &a0, &a1, &a2, &a3))
          {
            OBJ_CALL(result = self->object.insert(a0, a1, a2, a3));
            return t_StringBuffer::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::CharSequence a1((jobject) NULL);
          jint a2;
          jint a3;
          StringBuffer result((jobject) NULL);

          if (!parseArgs(args, "IOII", ::java::lang::PY_TYPE(CharSequence), &a0, &a1, &a2, &a3))
          {
            OBJ_CALL(result = self->object.insert(a0, a1, a2, a3));
            return t_StringBuffer::wrap_Object(result);
          }
        }
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "insert", args, 2);
    }

    static PyObject *t_StringBuffer_lastIndexOf(t_StringBuffer *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          jint result;

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.lastIndexOf(a0));
            return PyLong_FromLong((long) result);
          }
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          jint a1;
          jint result;

          if (!parseArgs(args, "sI", &a0, &a1))
          {
            OBJ_CALL(result = self->object.lastIndexOf(a0, a1));
            return PyLong_FromLong((long) result);
          }
        }
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "lastIndexOf", args, 2);
    }

    static PyObject *t_StringBuffer_length(t_StringBuffer *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.length());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "length", args, 2);
    }

    static PyObject *t_StringBuffer_offsetByCodePoints(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jint a1;
      jint result;

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.offsetByCodePoints(a0, a1));
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "offsetByCodePoints", args, 2);
    }

    static PyObject *t_StringBuffer_replace(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jint a1;
      ::java::lang::String a2((jobject) NULL);
      StringBuffer result((jobject) NULL);

      if (!parseArgs(args, "IIs", &a0, &a1, &a2))
      {
        OBJ_CALL(result = self->object.replace(a0, a1, a2));
        return t_StringBuffer::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "replace", args, 2);
    }

    static PyObject *t_StringBuffer_reverse(t_StringBuffer *self, PyObject *args)
    {
      StringBuffer result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.reverse());
        return t_StringBuffer::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "reverse", args, 2);
    }

    static PyObject *t_StringBuffer_setCharAt(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jchar a1;

      if (!parseArgs(args, "IC", &a0, &a1))
      {
        OBJ_CALL(self->object.setCharAt(a0, a1));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "setCharAt", args, 2);
    }

    static PyObject *t_StringBuffer_setLength(t_StringBuffer *self, PyObject *args)
    {
      jint a0;

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(self->object.setLength(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "setLength", args, 2);
    }

    static PyObject *t_StringBuffer_subSequence(t_StringBuffer *self, PyObject *args)
    {
      jint a0;
      jint a1;
      ::java::lang::CharSequence result((jobject) NULL);

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.subSequence(a0, a1));
        return ::java::lang::t_CharSequence::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "subSequence", args, 2);
    }

    static PyObject *t_StringBuffer_substring(t_StringBuffer *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jint a0;
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.substring(a0));
            return j2p(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          jint a1;
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(result = self->object.substring(a0, a1));
            return j2p(result);
          }
        }
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "substring", args, 2);
    }

    static PyObject *t_StringBuffer_toString(t_StringBuffer *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_StringBuffer_trimToSize(t_StringBuffer *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.trimToSize());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(StringBuffer), (PyObject *) self, "trimToSize", args, 2);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/FileVisitor.h"
#include "java/nio/file/FileVisitResult.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *FileVisitor::class$ = NULL;
      jmethodID *FileVisitor::mids$ = NULL;
      bool FileVisitor::live$ = false;

      jclass FileVisitor::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/FileVisitor");

          mids$ = new jmethodID[max_mid];
          mids$[mid_postVisitDirectory_92412eff65de8915] = env->getMethodID(cls, "postVisitDirectory", "(Ljava/lang/Object;Ljava/io/IOException;)Ljava/nio/file/FileVisitResult;");
          mids$[mid_visitFileFailed_92412eff65de8915] = env->getMethodID(cls, "visitFileFailed", "(Ljava/lang/Object;Ljava/io/IOException;)Ljava/nio/file/FileVisitResult;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::nio::file::FileVisitResult FileVisitor::postVisitDirectory(const ::java::lang::Object & a0, const ::java::io::IOException & a1) const
      {
        return ::java::nio::file::FileVisitResult(env->callObjectMethod(this$, mids$[mid_postVisitDirectory_92412eff65de8915], a0.this$, a1.this$));
      }

      ::java::nio::file::FileVisitResult FileVisitor::visitFileFailed(const ::java::lang::Object & a0, const ::java::io::IOException & a1) const
      {
        return ::java::nio::file::FileVisitResult(env->callObjectMethod(this$, mids$[mid_visitFileFailed_92412eff65de8915], a0.this$, a1.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_FileVisitor_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileVisitor_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileVisitor_of_(t_FileVisitor *self, PyObject *args);
      static PyObject *t_FileVisitor_postVisitDirectory(t_FileVisitor *self, PyObject *args);
      static PyObject *t_FileVisitor_visitFileFailed(t_FileVisitor *self, PyObject *args);
      static PyObject *t_FileVisitor_get__parameters_(t_FileVisitor *self, void *data);
      static PyGetSetDef t_FileVisitor__fields_[] = {
        DECLARE_GET_FIELD(t_FileVisitor, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_FileVisitor__methods_[] = {
        DECLARE_METHOD(t_FileVisitor, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileVisitor, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileVisitor, of_, METH_VARARGS),
        DECLARE_METHOD(t_FileVisitor, postVisitDirectory, METH_VARARGS),
        DECLARE_METHOD(t_FileVisitor, visitFileFailed, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(FileVisitor)[] = {
        { Py_tp_methods, t_FileVisitor__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_FileVisitor__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(FileVisitor)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(FileVisitor, t_FileVisitor, FileVisitor);
      PyObject *t_FileVisitor::wrap_Object(const FileVisitor& object, PyTypeObject *p0)
      {
        PyObject *obj = t_FileVisitor::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_FileVisitor *self = (t_FileVisitor *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_FileVisitor::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_FileVisitor::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_FileVisitor *self = (t_FileVisitor *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_FileVisitor::install(PyObject *module)
      {
        installType(&PY_TYPE(FileVisitor), &PY_TYPE_DEF(FileVisitor), module, "FileVisitor", 0);
      }

      void t_FileVisitor::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitor), "class_", make_descriptor(FileVisitor::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitor), "wrapfn_", make_descriptor(t_FileVisitor::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitor), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_FileVisitor_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, FileVisitor::initializeClass, 1)))
          return NULL;
        return t_FileVisitor::wrap_Object(FileVisitor(((t_FileVisitor *) arg)->object.this$));
      }
      static PyObject *t_FileVisitor_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, FileVisitor::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_FileVisitor_of_(t_FileVisitor *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_FileVisitor_postVisitDirectory(t_FileVisitor *self, PyObject *args)
      {
        ::java::lang::Object a0((jobject) NULL);
        ::java::io::IOException a1((jobject) NULL);
        ::java::nio::file::FileVisitResult result((jobject) NULL);

        if (!parseArgs(args, "Ok", self->parameters[0], ::java::io::IOException::initializeClass, &a0, &a1))
        {
          OBJ_CALL(result = self->object.postVisitDirectory(a0, a1));
          return ::java::nio::file::t_FileVisitResult::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "postVisitDirectory", args);
        return NULL;
      }

      static PyObject *t_FileVisitor_visitFileFailed(t_FileVisitor *self, PyObject *args)
      {
        ::java::lang::Object a0((jobject) NULL);
        ::java::io::IOException a1((jobject) NULL);
        ::java::nio::file::FileVisitResult result((jobject) NULL);

        if (!parseArgs(args, "Ok", self->parameters[0], ::java::io::IOException::initializeClass, &a0, &a1))
        {
          OBJ_CALL(result = self->object.visitFileFailed(a0, a1));
          return ::java::nio::file::t_FileVisitResult::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "visitFileFailed", args);
        return NULL;
      }
      static PyObject *t_FileVisitor_get__parameters_(t_FileVisitor *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/DataInput.h"
#include "java/lang/String.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *DataInput::class$ = NULL;
    jmethodID *DataInput::mids$ = NULL;
    bool DataInput::live$ = false;

    jclass DataInput::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/DataInput");

        mids$ = new jmethodID[max_mid];
        mids$[mid_readBoolean_8454bd5aa23fd11e] = env->getMethodID(cls, "readBoolean", "()Z");
        mids$[mid_readByte_871cd52a74f26213] = env->getMethodID(cls, "readByte", "()B");
        mids$[mid_readChar_8eea1dd85c3239c3] = env->getMethodID(cls, "readChar", "()C");
        mids$[mid_readDouble_8c74b787998ce4bc] = env->getMethodID(cls, "readDouble", "()D");
        mids$[mid_readFloat_58aec2b64dff50c8] = env->getMethodID(cls, "readFloat", "()F");
        mids$[mid_readFully_9ffdf271836656c4] = env->getMethodID(cls, "readFully", "([B)V");
        mids$[mid_readFully_43fdd39c09bb2fad] = env->getMethodID(cls, "readFully", "([BII)V");
        mids$[mid_readInt_9972fcc56b44e79d] = env->getMethodID(cls, "readInt", "()I");
        mids$[mid_readLine_db9b55ba01e03e4b] = env->getMethodID(cls, "readLine", "()Ljava/lang/String;");
        mids$[mid_readLong_2e5ae9edcb9b072f] = env->getMethodID(cls, "readLong", "()J");
        mids$[mid_readShort_ec20af88366b851e] = env->getMethodID(cls, "readShort", "()S");
        mids$[mid_readUTF_db9b55ba01e03e4b] = env->getMethodID(cls, "readUTF", "()Ljava/lang/String;");
        mids$[mid_readUnsignedByte_9972fcc56b44e79d] = env->getMethodID(cls, "readUnsignedByte", "()I");
        mids$[mid_readUnsignedShort_9972fcc56b44e79d] = env->getMethodID(cls, "readUnsignedShort", "()I");
        mids$[mid_skipBytes_1e143afe1894d213] = env->getMethodID(cls, "skipBytes", "(I)I");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jboolean DataInput::readBoolean() const
    {
      return env->callBooleanMethod(this$, mids$[mid_readBoolean_8454bd5aa23fd11e]);
    }

    jbyte DataInput::readByte() const
    {
      return env->callByteMethod(this$, mids$[mid_readByte_871cd52a74f26213]);
    }

    jchar DataInput::readChar() const
    {
      return env->callCharMethod(this$, mids$[mid_readChar_8eea1dd85c3239c3]);
    }

    jdouble DataInput::readDouble() const
    {
      return env->callDoubleMethod(this$, mids$[mid_readDouble_8c74b787998ce4bc]);
    }

    jfloat DataInput::readFloat() const
    {
      return env->callFloatMethod(this$, mids$[mid_readFloat_58aec2b64dff50c8]);
    }

    void DataInput::readFully(const JArray< jbyte > & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_readFully_9ffdf271836656c4], a0.this$);
    }

    void DataInput::readFully(const JArray< jbyte > & a0, jint a1, jint a2) const
    {
      env->callVoidMethod(this$, mids$[mid_readFully_43fdd39c09bb2fad], a0.this$, a1, a2);
    }

    jint DataInput::readInt() const
    {
      return env->callIntMethod(this$, mids$[mid_readInt_9972fcc56b44e79d]);
    }

    ::java::lang::String DataInput::readLine() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_readLine_db9b55ba01e03e4b]));
    }

    jlong DataInput::readLong() const
    {
      return env->callLongMethod(this$, mids$[mid_readLong_2e5ae9edcb9b072f]);
    }

    jshort DataInput::readShort() const
    {
      return env->callShortMethod(this$, mids$[mid_readShort_ec20af88366b851e]);
    }

    ::java::lang::String DataInput::readUTF() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_readUTF_db9b55ba01e03e4b]));
    }

    jint DataInput::readUnsignedByte() const
    {
      return env->callIntMethod(this$, mids$[mid_readUnsignedByte_9972fcc56b44e79d]);
    }

    jint DataInput::readUnsignedShort() const
    {
      return env->callIntMethod(this$, mids$[mid_readUnsignedShort_9972fcc56b44e79d]);
    }

    jint DataInput::skipBytes(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_skipBytes_1e143afe1894d213], a0);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_DataInput_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_DataInput_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_DataInput_readBoolean(t_DataInput *self);
    static PyObject *t_DataInput_readByte(t_DataInput *self);
    static PyObject *t_DataInput_readChar(t_DataInput *self);
    static PyObject *t_DataInput_readDouble(t_DataInput *self);
    static PyObject *t_DataInput_readFloat(t_DataInput *self);
    static PyObject *t_DataInput_readFully(t_DataInput *self, PyObject *args);
    static PyObject *t_DataInput_readInt(t_DataInput *self);
    static PyObject *t_DataInput_readLine(t_DataInput *self);
    static PyObject *t_DataInput_readLong(t_DataInput *self);
    static PyObject *t_DataInput_readShort(t_DataInput *self);
    static PyObject *t_DataInput_readUTF(t_DataInput *self);
    static PyObject *t_DataInput_readUnsignedByte(t_DataInput *self);
    static PyObject *t_DataInput_readUnsignedShort(t_DataInput *self);
    static PyObject *t_DataInput_skipBytes(t_DataInput *self, PyObject *arg);

    static PyMethodDef t_DataInput__methods_[] = {
      DECLARE_METHOD(t_DataInput, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_DataInput, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_DataInput, readBoolean, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readByte, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readChar, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readDouble, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readFloat, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readFully, METH_VARARGS),
      DECLARE_METHOD(t_DataInput, readInt, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readLine, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readLong, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readShort, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readUTF, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readUnsignedByte, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, readUnsignedShort, METH_NOARGS),
      DECLARE_METHOD(t_DataInput, skipBytes, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(DataInput)[] = {
      { Py_tp_methods, t_DataInput__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(DataInput)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(DataInput, t_DataInput, DataInput);

    void t_DataInput::install(PyObject *module)
    {
      installType(&PY_TYPE(DataInput), &PY_TYPE_DEF(DataInput), module, "DataInput", 0);
    }

    void t_DataInput::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(DataInput), "class_", make_descriptor(DataInput::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(DataInput), "wrapfn_", make_descriptor(t_DataInput::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(DataInput), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_DataInput_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, DataInput::initializeClass, 1)))
        return NULL;
      return t_DataInput::wrap_Object(DataInput(((t_DataInput *) arg)->object.this$));
    }
    static PyObject *t_DataInput_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, DataInput::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_DataInput_readBoolean(t_DataInput *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.readBoolean());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_DataInput_readByte(t_DataInput *self)
    {
      jbyte result;
      OBJ_CALL(result = self->object.readByte());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_DataInput_readChar(t_DataInput *self)
    {
      jchar result;
      OBJ_CALL(result = self->object.readChar());
      return c2p(result);
    }

    static PyObject *t_DataInput_readDouble(t_DataInput *self)
    {
      jdouble result;
      OBJ_CALL(result = self->object.readDouble());
      return PyFloat_FromDouble((double) result);
    }

    static PyObject *t_DataInput_readFloat(t_DataInput *self)
    {
      jfloat result;
      OBJ_CALL(result = self->object.readFloat());
      return PyFloat_FromDouble((double) result);
    }

    static PyObject *t_DataInput_readFully(t_DataInput *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          JArray< jbyte > a0((jobject) NULL);

          if (!parseArgs(args, "[B", &a0))
          {
            OBJ_CALL(self->object.readFully(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          JArray< jbyte > a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "[BII", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.readFully(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "readFully", args);
      return NULL;
    }

    static PyObject *t_DataInput_readInt(t_DataInput *self)
    {
      jint result;
      OBJ_CALL(result = self->object.readInt());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_DataInput_readLine(t_DataInput *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.readLine());
      return j2p(result);
    }

    static PyObject *t_DataInput_readLong(t_DataInput *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.readLong());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_DataInput_readShort(t_DataInput *self)
    {
      jshort result;
      OBJ_CALL(result = self->object.readShort());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_DataInput_readUTF(t_DataInput *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.readUTF());
      return j2p(result);
    }

    static PyObject *t_DataInput_readUnsignedByte(t_DataInput *self)
    {
      jint result;
      OBJ_CALL(result = self->object.readUnsignedByte());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_DataInput_readUnsignedShort(t_DataInput *self)
    {
      jint result;
      OBJ_CALL(result = self->object.readUnsignedShort());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_DataInput_skipBytes(t_DataInput *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.skipBytes(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "skipBytes", arg);
      return NULL;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/DoubleBinaryOperator.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *DoubleBinaryOperator::class$ = NULL;
      jmethodID *DoubleBinaryOperator::mids$ = NULL;
      bool DoubleBinaryOperator::live$ = false;

      jclass DoubleBinaryOperator::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/DoubleBinaryOperator");

          mids$ = new jmethodID[max_mid];
          mids$[mid_applyAsDouble_990b512583b70d91] = env->getMethodID(cls, "applyAsDouble", "(DD)D");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jdouble DoubleBinaryOperator::applyAsDouble(jdouble a0, jdouble a1) const
      {
        return env->callDoubleMethod(this$, mids$[mid_applyAsDouble_990b512583b70d91], a0, a1);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_DoubleBinaryOperator_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DoubleBinaryOperator_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DoubleBinaryOperator_applyAsDouble(t_DoubleBinaryOperator *self, PyObject *args);

      static PyMethodDef t_DoubleBinaryOperator__methods_[] = {
        DECLARE_METHOD(t_DoubleBinaryOperator, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DoubleBinaryOperator, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DoubleBinaryOperator, applyAsDouble, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(DoubleBinaryOperator)[] = {
        { Py_tp_methods, t_DoubleBinaryOperator__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(DoubleBinaryOperator)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(DoubleBinaryOperator, t_DoubleBinaryOperator, DoubleBinaryOperator);

      void t_DoubleBinaryOperator::install(PyObject *module)
      {
        installType(&PY_TYPE(DoubleBinaryOperator), &PY_TYPE_DEF(DoubleBinaryOperator), module, "DoubleBinaryOperator", 0);
      }

      void t_DoubleBinaryOperator::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(DoubleBinaryOperator), "class_", make_descriptor(DoubleBinaryOperator::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DoubleBinaryOperator), "wrapfn_", make_descriptor(t_DoubleBinaryOperator::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DoubleBinaryOperator), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_DoubleBinaryOperator_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, DoubleBinaryOperator::initializeClass, 1)))
          return NULL;
        return t_DoubleBinaryOperator::wrap_Object(DoubleBinaryOperator(((t_DoubleBinaryOperator *) arg)->object.this$));
      }
      static PyObject *t_DoubleBinaryOperator_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, DoubleBinaryOperator::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_DoubleBinaryOperator_applyAsDouble(t_DoubleBinaryOperator *self, PyObject *args)
      {
        jdouble a0;
        jdouble a1;
        jdouble result;

        if (!parseArgs(args, "DD", &a0, &a1))
        {
          OBJ_CALL(result = self->object.applyAsDouble(a0, a1));
          return PyFloat_FromDouble((double) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsDouble", args);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Properties.h"
#include "java/io/PrintWriter.h"
#include "java/io/InputStream.h"
#include "java/lang/Class.h"
#include "java/io/PrintStream.h"
#include "java/lang/Object.h"
#include "java/util/InvalidPropertiesFormatException.h"
#include "java/util/Enumeration.h"
#include "java/lang/String.h"
#include "java/io/OutputStream.h"
#include "java/io/Reader.h"
#include "java/util/Set.h"
#include "java/io/Writer.h"
#include "java/io/IOException.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Properties::class$ = NULL;
    jmethodID *Properties::mids$ = NULL;
    bool Properties::live$ = false;

    jclass Properties::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Properties");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_getProperty_9bfa75c9f141b67f] = env->getMethodID(cls, "getProperty", "(Ljava/lang/String;)Ljava/lang/String;");
        mids$[mid_getProperty_04b762e0ad33dcc5] = env->getMethodID(cls, "getProperty", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;");
        mids$[mid_list_51d7bcb97eea24e3] = env->getMethodID(cls, "list", "(Ljava/io/PrintStream;)V");
        mids$[mid_list_3df1c1d548bf22a4] = env->getMethodID(cls, "list", "(Ljava/io/PrintWriter;)V");
        mids$[mid_load_a227449bf251faf1] = env->getMethodID(cls, "load", "(Ljava/io/InputStream;)V");
        mids$[mid_load_b2f3c57f5e6eb3f2] = env->getMethodID(cls, "load", "(Ljava/io/Reader;)V");
        mids$[mid_loadFromXML_a227449bf251faf1] = env->getMethodID(cls, "loadFromXML", "(Ljava/io/InputStream;)V");
        mids$[mid_propertyNames_f270cc1d2d4072a8] = env->getMethodID(cls, "propertyNames", "()Ljava/util/Enumeration;");
        mids$[mid_save_6769bfc075198100] = env->getMethodID(cls, "save", "(Ljava/io/OutputStream;Ljava/lang/String;)V");
        mids$[mid_setProperty_2f6fb31a87be462e] = env->getMethodID(cls, "setProperty", "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;");
        mids$[mid_store_6769bfc075198100] = env->getMethodID(cls, "store", "(Ljava/io/OutputStream;Ljava/lang/String;)V");
        mids$[mid_store_def7691ca7c0ba7d] = env->getMethodID(cls, "store", "(Ljava/io/Writer;Ljava/lang/String;)V");
        mids$[mid_storeToXML_6769bfc075198100] = env->getMethodID(cls, "storeToXML", "(Ljava/io/OutputStream;Ljava/lang/String;)V");
        mids$[mid_storeToXML_8a8d4c88d90882a9] = env->getMethodID(cls, "storeToXML", "(Ljava/io/OutputStream;Ljava/lang/String;Ljava/lang/String;)V");
        mids$[mid_stringPropertyNames_7dcf4034c6d1a92a] = env->getMethodID(cls, "stringPropertyNames", "()Ljava/util/Set;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Properties::Properties() : ::java::util::Hashtable(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    ::java::lang::String Properties::getProperty(const ::java::lang::String & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getProperty_9bfa75c9f141b67f], a0.this$));
    }

    ::java::lang::String Properties::getProperty(const ::java::lang::String & a0, const ::java::lang::String & a1) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getProperty_04b762e0ad33dcc5], a0.this$, a1.this$));
    }

    void Properties::list(const ::java::io::PrintStream & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_list_51d7bcb97eea24e3], a0.this$);
    }

    void Properties::list(const ::java::io::PrintWriter & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_list_3df1c1d548bf22a4], a0.this$);
    }

    void Properties::load(const ::java::io::InputStream & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_load_a227449bf251faf1], a0.this$);
    }

    void Properties::load(const ::java::io::Reader & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_load_b2f3c57f5e6eb3f2], a0.this$);
    }

    void Properties::loadFromXML(const ::java::io::InputStream & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_loadFromXML_a227449bf251faf1], a0.this$);
    }

    ::java::util::Enumeration Properties::propertyNames() const
    {
      return ::java::util::Enumeration(env->callObjectMethod(this$, mids$[mid_propertyNames_f270cc1d2d4072a8]));
    }

    void Properties::save(const ::java::io::OutputStream & a0, const ::java::lang::String & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_save_6769bfc075198100], a0.this$, a1.this$);
    }

    ::java::lang::Object Properties::setProperty(const ::java::lang::String & a0, const ::java::lang::String & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_setProperty_2f6fb31a87be462e], a0.this$, a1.this$));
    }

    void Properties::store(const ::java::io::OutputStream & a0, const ::java::lang::String & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_store_6769bfc075198100], a0.this$, a1.this$);
    }

    void Properties::store(const ::java::io::Writer & a0, const ::java::lang::String & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_store_def7691ca7c0ba7d], a0.this$, a1.this$);
    }

    void Properties::storeToXML(const ::java::io::OutputStream & a0, const ::java::lang::String & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_storeToXML_6769bfc075198100], a0.this$, a1.this$);
    }

    void Properties::storeToXML(const ::java::io::OutputStream & a0, const ::java::lang::String & a1, const ::java::lang::String & a2) const
    {
      env->callVoidMethod(this$, mids$[mid_storeToXML_8a8d4c88d90882a9], a0.this$, a1.this$, a2.this$);
    }

    ::java::util::Set Properties::stringPropertyNames() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_stringPropertyNames_7dcf4034c6d1a92a]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Properties_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Properties_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Properties_of_(t_Properties *self, PyObject *args);
    static int t_Properties_init_(t_Properties *self, PyObject *args, PyObject *kwds);
    static PyObject *t_Properties_getProperty(t_Properties *self, PyObject *args);
    static PyObject *t_Properties_list(t_Properties *self, PyObject *args);
    static PyObject *t_Properties_load(t_Properties *self, PyObject *args);
    static PyObject *t_Properties_loadFromXML(t_Properties *self, PyObject *arg);
    static PyObject *t_Properties_propertyNames(t_Properties *self);
    static PyObject *t_Properties_save(t_Properties *self, PyObject *args);
    static PyObject *t_Properties_setProperty(t_Properties *self, PyObject *args);
    static PyObject *t_Properties_store(t_Properties *self, PyObject *args);
    static PyObject *t_Properties_storeToXML(t_Properties *self, PyObject *args);
    static PyObject *t_Properties_stringPropertyNames(t_Properties *self);
    static PyObject *t_Properties_get__parameters_(t_Properties *self, void *data);
    static PyGetSetDef t_Properties__fields_[] = {
      DECLARE_GET_FIELD(t_Properties, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Properties__methods_[] = {
      DECLARE_METHOD(t_Properties, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Properties, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Properties, of_, METH_VARARGS),
      DECLARE_METHOD(t_Properties, getProperty, METH_VARARGS),
      DECLARE_METHOD(t_Properties, list, METH_VARARGS),
      DECLARE_METHOD(t_Properties, load, METH_VARARGS),
      DECLARE_METHOD(t_Properties, loadFromXML, METH_O),
      DECLARE_METHOD(t_Properties, propertyNames, METH_NOARGS),
      DECLARE_METHOD(t_Properties, save, METH_VARARGS),
      DECLARE_METHOD(t_Properties, setProperty, METH_VARARGS),
      DECLARE_METHOD(t_Properties, store, METH_VARARGS),
      DECLARE_METHOD(t_Properties, storeToXML, METH_VARARGS),
      DECLARE_METHOD(t_Properties, stringPropertyNames, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };
    static PyObject *t_Properties_getProperty_map_(t_Properties *self, PyObject *key);

    static PyType_Slot PY_TYPE_SLOTS(Properties)[] = {
      { Py_tp_methods, t_Properties__methods_ },
      { Py_tp_init, (void *) t_Properties_init_ },
      { Py_tp_getset, t_Properties__fields_ },
      { Py_mp_subscript, (void *) t_Properties_getProperty_map_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Properties)[] = {
      &PY_TYPE_DEF(::java::util::Hashtable),
      NULL
    };

    DEFINE_TYPE(Properties, t_Properties, Properties);
    PyObject *t_Properties::wrap_Object(const Properties& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_Properties::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Properties *self = (t_Properties *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    PyObject *t_Properties::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_Properties::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Properties *self = (t_Properties *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    void t_Properties::install(PyObject *module)
    {
      installType(&PY_TYPE(Properties), &PY_TYPE_DEF(Properties), module, "Properties", 0);
    }

    void t_Properties::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Properties), "class_", make_descriptor(Properties::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Properties), "wrapfn_", make_descriptor(t_Properties::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Properties), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Properties_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Properties::initializeClass, 1)))
        return NULL;
      return t_Properties::wrap_Object(Properties(((t_Properties *) arg)->object.this$));
    }
    static PyObject *t_Properties_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Properties::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Properties_of_(t_Properties *self, PyObject *args)
    {
      if (!parseArg(args, "T", 2, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static int t_Properties_init_(t_Properties *self, PyObject *args, PyObject *kwds)
    {
      Properties object((jobject) NULL);

      INT_CALL(object = Properties());
      self->object = object;
      self->parameters[0] = ::java::lang::PY_TYPE(Object);
      self->parameters[1] = ::java::lang::PY_TYPE(Object);

      return 0;
    }

    static PyObject *t_Properties_getProperty(t_Properties *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.getProperty(a0));
            return j2p(result);
          }
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "ss", &a0, &a1))
          {
            OBJ_CALL(result = self->object.getProperty(a0, a1));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getProperty", args);
      return NULL;
    }

    static PyObject *t_Properties_list(t_Properties *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::io::PrintStream a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::PrintStream::initializeClass, &a0))
          {
            OBJ_CALL(self->object.list(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::io::PrintWriter a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::PrintWriter::initializeClass, &a0))
          {
            OBJ_CALL(self->object.list(a0));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "list", args);
      return NULL;
    }

    static PyObject *t_Properties_load(t_Properties *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::io::InputStream a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::InputStream::initializeClass, &a0))
          {
            OBJ_CALL(self->object.load(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::io::Reader a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::Reader::initializeClass, &a0))
          {
            OBJ_CALL(self->object.load(a0));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "load", args);
      return NULL;
    }

    static PyObject *t_Properties_loadFromXML(t_Properties *self, PyObject *arg)
    {
      ::java::io::InputStream a0((jobject) NULL);

      if (!parseArg(arg, "k", ::java::io::InputStream::initializeClass, &a0))
      {
        OBJ_CALL(self->object.loadFromXML(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "loadFromXML", arg);
      return NULL;
    }

    static PyObject *t_Properties_propertyNames(t_Properties *self)
    {
      ::java::util::Enumeration result((jobject) NULL);
      OBJ_CALL(result = self->object.propertyNames());
      return ::java::util::t_Enumeration::wrap_Object(result);
    }

    static PyObject *t_Properties_save(t_Properties *self, PyObject *args)
    {
      ::java::io::OutputStream a0((jobject) NULL);
      ::java::lang::String a1((jobject) NULL);

      if (!parseArgs(args, "ks", ::java::io::OutputStream::initializeClass, &a0, &a1))
      {
        OBJ_CALL(self->object.save(a0, a1));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "save", args);
      return NULL;
    }

    static PyObject *t_Properties_setProperty(t_Properties *self, PyObject *args)
    {
      ::java::lang::String a0((jobject) NULL);
      ::java::lang::String a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "ss", &a0, &a1))
      {
        OBJ_CALL(result = self->object.setProperty(a0, a1));
        return ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "setProperty", args);
      return NULL;
    }

    static PyObject *t_Properties_store(t_Properties *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::io::OutputStream a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);

          if (!parseArgs(args, "ks", ::java::io::OutputStream::initializeClass, &a0, &a1))
          {
            OBJ_CALL(self->object.store(a0, a1));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::io::Writer a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);

          if (!parseArgs(args, "ks", ::java::io::Writer::initializeClass, &a0, &a1))
          {
            OBJ_CALL(self->object.store(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "store", args);
      return NULL;
    }

    static PyObject *t_Properties_storeToXML(t_Properties *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::io::OutputStream a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);

          if (!parseArgs(args, "ks", ::java::io::OutputStream::initializeClass, &a0, &a1))
          {
            OBJ_CALL(self->object.storeToXML(a0, a1));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          ::java::io::OutputStream a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          ::java::lang::String a2((jobject) NULL);

          if (!parseArgs(args, "kss", ::java::io::OutputStream::initializeClass, &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.storeToXML(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "storeToXML", args);
      return NULL;
    }

    static PyObject *t_Properties_stringPropertyNames(t_Properties *self)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = self->object.stringPropertyNames());
      return ::java::util::t_Set::wrap_Object(result, ::java::lang::PY_TYPE(String));
    }
    static PyObject *t_Properties_get__parameters_(t_Properties *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_Properties_getProperty_map_(t_Properties *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      ::java::lang::String result((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = self->object.getProperty(a0));
        return j2p(result);
      }

      PyErr_SetArgsError((PyObject *) self, "getProperty", arg);
      return NULL;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/BiFunction.h"
#include "java/util/function/BiFunction.h"
#include "java/util/function/Function.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *BiFunction::class$ = NULL;
      jmethodID *BiFunction::mids$ = NULL;
      bool BiFunction::live$ = false;

      jclass BiFunction::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/BiFunction");

          mids$ = new jmethodID[max_mid];
          mids$[mid_andThen_ee01a618a5d20944] = env->getMethodID(cls, "andThen", "(Ljava/util/function/Function;)Ljava/util/function/BiFunction;");
          mids$[mid_apply_128a89bbc17a8b69] = env->getMethodID(cls, "apply", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      BiFunction BiFunction::andThen(const ::java::util::function::Function & a0) const
      {
        return BiFunction(env->callObjectMethod(this$, mids$[mid_andThen_ee01a618a5d20944], a0.this$));
      }

      ::java::lang::Object BiFunction::apply(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_apply_128a89bbc17a8b69], a0.this$, a1.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_BiFunction_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BiFunction_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BiFunction_of_(t_BiFunction *self, PyObject *args);
      static PyObject *t_BiFunction_andThen(t_BiFunction *self, PyObject *arg);
      static PyObject *t_BiFunction_apply(t_BiFunction *self, PyObject *args);
      static PyObject *t_BiFunction_get__parameters_(t_BiFunction *self, void *data);
      static PyGetSetDef t_BiFunction__fields_[] = {
        DECLARE_GET_FIELD(t_BiFunction, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_BiFunction__methods_[] = {
        DECLARE_METHOD(t_BiFunction, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_BiFunction, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_BiFunction, of_, METH_VARARGS),
        DECLARE_METHOD(t_BiFunction, andThen, METH_O),
        DECLARE_METHOD(t_BiFunction, apply, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(BiFunction)[] = {
        { Py_tp_methods, t_BiFunction__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_BiFunction__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(BiFunction)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(BiFunction, t_BiFunction, BiFunction);
      PyObject *t_BiFunction::wrap_Object(const BiFunction& object, PyTypeObject *p0, PyTypeObject *p1, PyTypeObject *p2)
      {
        PyObject *obj = t_BiFunction::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_BiFunction *self = (t_BiFunction *) obj;
          self->parameters[0] = p0;
          self->parameters[1] = p1;
          self->parameters[2] = p2;
        }
        return obj;
      }

      PyObject *t_BiFunction::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1, PyTypeObject *p2)
      {
        PyObject *obj = t_BiFunction::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_BiFunction *self = (t_BiFunction *) obj;
          self->parameters[0] = p0;
          self->parameters[1] = p1;
          self->parameters[2] = p2;
        }
        return obj;
      }

      void t_BiFunction::install(PyObject *module)
      {
        installType(&PY_TYPE(BiFunction), &PY_TYPE_DEF(BiFunction), module, "BiFunction", 0);
      }

      void t_BiFunction::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(BiFunction), "class_", make_descriptor(BiFunction::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(BiFunction), "wrapfn_", make_descriptor(t_BiFunction::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(BiFunction), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_BiFunction_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, BiFunction::initializeClass, 1)))
          return NULL;
        return t_BiFunction::wrap_Object(BiFunction(((t_BiFunction *) arg)->object.this$));
      }
      static PyObject *t_BiFunction_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, BiFunction::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_BiFunction_of_(t_BiFunction *self, PyObject *args)
      {
        if (!parseArg(args, "T", 3, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_BiFunction_andThen(t_BiFunction *self, PyObject *arg)
      {
        ::java::util::function::Function a0((jobject) NULL);
        PyTypeObject **p0;
        BiFunction result((jobject) NULL);

        if (!parseArg(arg, "K", ::java::util::function::Function::initializeClass, &a0, &p0, ::java::util::function::t_Function::parameters_))
        {
          OBJ_CALL(result = self->object.andThen(a0));
          return t_BiFunction::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "andThen", arg);
        return NULL;
      }

      static PyObject *t_BiFunction_apply(t_BiFunction *self, PyObject *args)
      {
        ::java::lang::Object a0((jobject) NULL);
        ::java::lang::Object a1((jobject) NULL);
        ::java::lang::Object result((jobject) NULL);

        if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
        {
          OBJ_CALL(result = self->object.apply(a0, a1));
          return self->parameters[2] != NULL ? wrapType(self->parameters[2], result.this$) : ::java::lang::t_Object::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "apply", args);
        return NULL;
      }
      static PyObject *t_BiFunction_get__parameters_(t_BiFunction *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/Watchable.h"
#include "java/lang/Class.h"
#include "java/nio/file/WatchKey.h"
#include "java/io/IOException.h"
#include "java/nio/file/WatchEvent$Kind.h"
#include "java/nio/file/WatchService.h"
#include "java/nio/file/WatchEvent$Modifier.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *Watchable::class$ = NULL;
      jmethodID *Watchable::mids$ = NULL;
      bool Watchable::live$ = false;

      jclass Watchable::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/Watchable");

          mids$ = new jmethodID[max_mid];
          mids$[mid_register_6cfc9d5463561f8d] = env->getMethodID(cls, "register", "(Ljava/nio/file/WatchService;[Ljava/nio/file/WatchEvent$Kind;)Ljava/nio/file/WatchKey;");
          mids$[mid_register_b4bf47bf477ac77c] = env->getMethodID(cls, "register", "(Ljava/nio/file/WatchService;[Ljava/nio/file/WatchEvent$Kind;[Ljava/nio/file/WatchEvent$Modifier;)Ljava/nio/file/WatchKey;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::nio::file::WatchKey Watchable::register$(const ::java::nio::file::WatchService & a0, const JArray< ::java::nio::file::WatchEvent$Kind > & a1) const
      {
        return ::java::nio::file::WatchKey(env->callObjectMethod(this$, mids$[mid_register_6cfc9d5463561f8d], a0.this$, a1.this$));
      }

      ::java::nio::file::WatchKey Watchable::register$(const ::java::nio::file::WatchService & a0, const JArray< ::java::nio::file::WatchEvent$Kind > & a1, const JArray< ::java::nio::file::WatchEvent$Modifier > & a2) const
      {
        return ::java::nio::file::WatchKey(env->callObjectMethod(this$, mids$[mid_register_b4bf47bf477ac77c], a0.this$, a1.this$, a2.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_Watchable_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Watchable_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Watchable_register(t_Watchable *self, PyObject *args);

      static PyMethodDef t_Watchable__methods_[] = {
        DECLARE_METHOD(t_Watchable, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Watchable, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Watchable, register, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Watchable)[] = {
        { Py_tp_methods, t_Watchable__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Watchable)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Watchable, t_Watchable, Watchable);

      void t_Watchable::install(PyObject *module)
      {
        installType(&PY_TYPE(Watchable), &PY_TYPE_DEF(Watchable), module, "Watchable", 0);
      }

      void t_Watchable::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Watchable), "class_", make_descriptor(Watchable::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Watchable), "wrapfn_", make_descriptor(t_Watchable::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Watchable), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Watchable_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Watchable::initializeClass, 1)))
          return NULL;
        return t_Watchable::wrap_Object(Watchable(((t_Watchable *) arg)->object.this$));
      }
      static PyObject *t_Watchable_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Watchable::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Watchable_register(t_Watchable *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 2:
          {
            ::java::nio::file::WatchService a0((jobject) NULL);
            JArray< ::java::nio::file::WatchEvent$Kind > a1((jobject) NULL);
            PyTypeObject **p1;
            ::java::nio::file::WatchKey result((jobject) NULL);

            if (!parseArgs(args, "k[K", ::java::nio::file::WatchService::initializeClass, ::java::nio::file::WatchEvent$Kind::initializeClass, &a0, &a1, &p1, ::java::nio::file::t_WatchEvent$Kind::parameters_))
            {
              OBJ_CALL(result = self->object.register$(a0, a1));
              return ::java::nio::file::t_WatchKey::wrap_Object(result);
            }
          }
          break;
         case 3:
          {
            ::java::nio::file::WatchService a0((jobject) NULL);
            JArray< ::java::nio::file::WatchEvent$Kind > a1((jobject) NULL);
            PyTypeObject **p1;
            JArray< ::java::nio::file::WatchEvent$Modifier > a2((jobject) NULL);
            PyTypeObject **p2;
            ::java::nio::file::WatchKey result((jobject) NULL);

            if (!parseArgs(args, "k[K[K", ::java::nio::file::WatchService::initializeClass, ::java::nio::file::WatchEvent$Kind::initializeClass, ::java::nio::file::WatchEvent$Modifier::initializeClass, &a0, &a1, &p1, ::java::nio::file::t_WatchEvent$Kind::parameters_, &a2, &p2, ::java::nio::file::t_WatchEvent$Modifier::parameters_))
            {
              OBJ_CALL(result = self->object.register$(a0, a1, a2));
              return ::java::nio::file::t_WatchKey::wrap_Object(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "register", args);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/Serializable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *Serializable::class$ = NULL;
    jmethodID *Serializable::mids$ = NULL;
    bool Serializable::live$ = false;

    jclass Serializable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/Serializable");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_Serializable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Serializable_instance_(PyTypeObject *type, PyObject *arg);

    static PyMethodDef t_Serializable__methods_[] = {
      DECLARE_METHOD(t_Serializable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Serializable, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Serializable)[] = {
      { Py_tp_methods, t_Serializable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Serializable)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Serializable, t_Serializable, Serializable);

    void t_Serializable::install(PyObject *module)
    {
      installType(&PY_TYPE(Serializable), &PY_TYPE_DEF(Serializable), module, "Serializable", 0);
    }

    void t_Serializable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Serializable), "class_", make_descriptor(Serializable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Serializable), "wrapfn_", make_descriptor(t_Serializable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Serializable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Serializable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Serializable::initializeClass, 1)))
        return NULL;
      return t_Serializable::wrap_Object(Serializable(((t_Serializable *) arg)->object.this$));
    }
    static PyObject *t_Serializable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Serializable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/ThreadFactory.h"
#include "java/lang/Runnable.h"
#include "java/lang/Thread.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *ThreadFactory::class$ = NULL;
      jmethodID *ThreadFactory::mids$ = NULL;
      bool ThreadFactory::live$ = false;

      jclass ThreadFactory::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/ThreadFactory");

          mids$ = new jmethodID[max_mid];
          mids$[mid_newThread_2808e07b368f4be8] = env->getMethodID(cls, "newThread", "(Ljava/lang/Runnable;)Ljava/lang/Thread;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::lang::Thread ThreadFactory::newThread(const ::java::lang::Runnable & a0) const
      {
        return ::java::lang::Thread(env->callObjectMethod(this$, mids$[mid_newThread_2808e07b368f4be8], a0.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_ThreadFactory_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ThreadFactory_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ThreadFactory_newThread(t_ThreadFactory *self, PyObject *arg);

      static PyMethodDef t_ThreadFactory__methods_[] = {
        DECLARE_METHOD(t_ThreadFactory, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ThreadFactory, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ThreadFactory, newThread, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(ThreadFactory)[] = {
        { Py_tp_methods, t_ThreadFactory__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(ThreadFactory)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(ThreadFactory, t_ThreadFactory, ThreadFactory);

      void t_ThreadFactory::install(PyObject *module)
      {
        installType(&PY_TYPE(ThreadFactory), &PY_TYPE_DEF(ThreadFactory), module, "ThreadFactory", 0);
      }

      void t_ThreadFactory::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(ThreadFactory), "class_", make_descriptor(ThreadFactory::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ThreadFactory), "wrapfn_", make_descriptor(t_ThreadFactory::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ThreadFactory), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_ThreadFactory_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, ThreadFactory::initializeClass, 1)))
          return NULL;
        return t_ThreadFactory::wrap_Object(ThreadFactory(((t_ThreadFactory *) arg)->object.this$));
      }
      static PyObject *t_ThreadFactory_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, ThreadFactory::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_ThreadFactory_newThread(t_ThreadFactory *self, PyObject *arg)
      {
        ::java::lang::Runnable a0((jobject) NULL);
        ::java::lang::Thread result((jobject) NULL);

        if (!parseArg(arg, "k", ::java::lang::Runnable::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.newThread(a0));
          return ::java::lang::t_Thread::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "newThread", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/DoublePredicate.h"
#include "java/util/function/DoublePredicate.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *DoublePredicate::class$ = NULL;
      jmethodID *DoublePredicate::mids$ = NULL;
      bool DoublePredicate::live$ = false;

      jclass DoublePredicate::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/DoublePredicate");

          mids$ = new jmethodID[max_mid];
          mids$[mid_and_4a1e2d99b420dbe4] = env->getMethodID(cls, "and", "(Ljava/util/function/DoublePredicate;)Ljava/util/function/DoublePredicate;");
          mids$[mid_negate_1eedf99122b4aa4e] = env->getMethodID(cls, "negate", "()Ljava/util/function/DoublePredicate;");
          mids$[mid_or_4a1e2d99b420dbe4] = env->getMethodID(cls, "or", "(Ljava/util/function/DoublePredicate;)Ljava/util/function/DoublePredicate;");
          mids$[mid_test_17ce67a573fe19e0] = env->getMethodID(cls, "test", "(D)Z");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      DoublePredicate DoublePredicate::and$(const DoublePredicate & a0) const
      {
        return DoublePredicate(env->callObjectMethod(this$, mids$[mid_and_4a1e2d99b420dbe4], a0.this$));
      }

      DoublePredicate DoublePredicate::negate() const
      {
        return DoublePredicate(env->callObjectMethod(this$, mids$[mid_negate_1eedf99122b4aa4e]));
      }

      DoublePredicate DoublePredicate::or$(const DoublePredicate & a0) const
      {
        return DoublePredicate(env->callObjectMethod(this$, mids$[mid_or_4a1e2d99b420dbe4], a0.this$));
      }

      jboolean DoublePredicate::test(jdouble a0) const
      {
        return env->callBooleanMethod(this$, mids$[mid_test_17ce67a573fe19e0], a0);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_DoublePredicate_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DoublePredicate_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DoublePredicate_and(t_DoublePredicate *self, PyObject *arg);
      static PyObject *t_DoublePredicate_negate(t_DoublePredicate *self);
      static PyObject *t_DoublePredicate_or(t_DoublePredicate *self, PyObject *arg);
      static PyObject *t_DoublePredicate_test(t_DoublePredicate *self, PyObject *arg);

      static PyMethodDef t_DoublePredicate__methods_[] = {
        DECLARE_METHOD(t_DoublePredicate, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DoublePredicate, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DoublePredicate, and, METH_O),
        DECLARE_METHOD(t_DoublePredicate, negate, METH_NOARGS),
        DECLARE_METHOD(t_DoublePredicate, or, METH_O),
        DECLARE_METHOD(t_DoublePredicate, test, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(DoublePredicate)[] = {
        { Py_tp_methods, t_DoublePredicate__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(DoublePredicate)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(DoublePredicate, t_DoublePredicate, DoublePredicate);

      void t_DoublePredicate::install(PyObject *module)
      {
        installType(&PY_TYPE(DoublePredicate), &PY_TYPE_DEF(DoublePredicate), module, "DoublePredicate", 0);
      }

      void t_DoublePredicate::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(DoublePredicate), "class_", make_descriptor(DoublePredicate::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DoublePredicate), "wrapfn_", make_descriptor(t_DoublePredicate::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DoublePredicate), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_DoublePredicate_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, DoublePredicate::initializeClass, 1)))
          return NULL;
        return t_DoublePredicate::wrap_Object(DoublePredicate(((t_DoublePredicate *) arg)->object.this$));
      }
      static PyObject *t_DoublePredicate_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, DoublePredicate::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_DoublePredicate_and(t_DoublePredicate *self, PyObject *arg)
      {
        DoublePredicate a0((jobject) NULL);
        DoublePredicate result((jobject) NULL);

        if (!parseArg(arg, "k", DoublePredicate::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.and$(a0));
          return t_DoublePredicate::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "and", arg);
        return NULL;
      }

      static PyObject *t_DoublePredicate_negate(t_DoublePredicate *self)
      {
        DoublePredicate result((jobject) NULL);
        OBJ_CALL(result = self->object.negate());
        return t_DoublePredicate::wrap_Object(result);
      }

      static PyObject *t_DoublePredicate_or(t_DoublePredicate *self, PyObject *arg)
      {
        DoublePredicate a0((jobject) NULL);
        DoublePredicate result((jobject) NULL);

        if (!parseArg(arg, "k", DoublePredicate::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.or$(a0));
          return t_DoublePredicate::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "or", arg);
        return NULL;
      }

      static PyObject *t_DoublePredicate_test(t_DoublePredicate *self, PyObject *arg)
      {
        jdouble a0;
        jboolean result;

        if (!parseArg(arg, "D", &a0))
        {
          OBJ_CALL(result = self->object.test(a0));
          Py_RETURN_BOOL(result);
        }

        PyErr_SetArgsError((PyObject *) self, "test", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Comparator.h"
#include "java/util/Comparator.h"
#include "java/util/function/ToIntFunction.h"
#include "java/lang/Comparable.h"
#include "java/util/function/ToLongFunction.h"
#include "java/lang/Class.h"
#include "java/util/function/Function.h"
#include "java/util/function/ToDoubleFunction.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Comparator::class$ = NULL;
    jmethodID *Comparator::mids$ = NULL;
    bool Comparator::live$ = false;

    jclass Comparator::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Comparator");

        mids$ = new jmethodID[max_mid];
        mids$[mid_compare_9dae63203ae747af] = env->getMethodID(cls, "compare", "(Ljava/lang/Object;Ljava/lang/Object;)I");
        mids$[mid_comparing_dc201a331bfef5c1] = env->getStaticMethodID(cls, "comparing", "(Ljava/util/function/Function;)Ljava/util/Comparator;");
        mids$[mid_comparing_eb8ae37fcd6bd979] = env->getStaticMethodID(cls, "comparing", "(Ljava/util/function/Function;Ljava/util/Comparator;)Ljava/util/Comparator;");
        mids$[mid_comparingDouble_25ba8710a789ab77] = env->getStaticMethodID(cls, "comparingDouble", "(Ljava/util/function/ToDoubleFunction;)Ljava/util/Comparator;");
        mids$[mid_comparingInt_db59d1eb87800dd4] = env->getStaticMethodID(cls, "comparingInt", "(Ljava/util/function/ToIntFunction;)Ljava/util/Comparator;");
        mids$[mid_comparingLong_b76ef25e61ac1a12] = env->getStaticMethodID(cls, "comparingLong", "(Ljava/util/function/ToLongFunction;)Ljava/util/Comparator;");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_naturalOrder_beb0414e0ec1de00] = env->getStaticMethodID(cls, "naturalOrder", "()Ljava/util/Comparator;");
        mids$[mid_nullsFirst_5cea92c6ee384471] = env->getStaticMethodID(cls, "nullsFirst", "(Ljava/util/Comparator;)Ljava/util/Comparator;");
        mids$[mid_nullsLast_5cea92c6ee384471] = env->getStaticMethodID(cls, "nullsLast", "(Ljava/util/Comparator;)Ljava/util/Comparator;");
        mids$[mid_reverseOrder_beb0414e0ec1de00] = env->getStaticMethodID(cls, "reverseOrder", "()Ljava/util/Comparator;");
        mids$[mid_reversed_beb0414e0ec1de00] = env->getMethodID(cls, "reversed", "()Ljava/util/Comparator;");
        mids$[mid_thenComparing_5cea92c6ee384471] = env->getMethodID(cls, "thenComparing", "(Ljava/util/Comparator;)Ljava/util/Comparator;");
        mids$[mid_thenComparing_dc201a331bfef5c1] = env->getMethodID(cls, "thenComparing", "(Ljava/util/function/Function;)Ljava/util/Comparator;");
        mids$[mid_thenComparing_eb8ae37fcd6bd979] = env->getMethodID(cls, "thenComparing", "(Ljava/util/function/Function;Ljava/util/Comparator;)Ljava/util/Comparator;");
        mids$[mid_thenComparingDouble_25ba8710a789ab77] = env->getMethodID(cls, "thenComparingDouble", "(Ljava/util/function/ToDoubleFunction;)Ljava/util/Comparator;");
        mids$[mid_thenComparingInt_db59d1eb87800dd4] = env->getMethodID(cls, "thenComparingInt", "(Ljava/util/function/ToIntFunction;)Ljava/util/Comparator;");
        mids$[mid_thenComparingLong_b76ef25e61ac1a12] = env->getMethodID(cls, "thenComparingLong", "(Ljava/util/function/ToLongFunction;)Ljava/util/Comparator;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jint Comparator::compare(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return env->callIntMethod(this$, mids$[mid_compare_9dae63203ae747af], a0.this$, a1.this$);
    }

    Comparator Comparator::comparing(const ::java::util::function::Function & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Comparator(env->callStaticObjectMethod(cls, mids$[mid_comparing_dc201a331bfef5c1], a0.this$));
    }

    Comparator Comparator::comparing(const ::java::util::function::Function & a0, const Comparator & a1)
    {
      jclass cls = env->getClass(initializeClass);
      return Comparator(env->callStaticObjectMethod(cls, mids$[mid_comparing_eb8ae37fcd6bd979], a0.this$, a1.this$));
    }

    Comparator Comparator::comparingDouble(const ::java::util::function::ToDoubleFunction & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Comparator(env->callStaticObjectMethod(cls, mids$[mid_comparingDouble_25ba8710a789ab77], a0.this$));
    }

    Comparator Comparator::comparingInt(const ::java::util::function::ToIntFunction & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Comparator(env->callStaticObjectMethod(cls, mids$[mid_comparingInt_db59d1eb87800dd4], a0.this$));
    }

    Comparator Comparator::comparingLong(const ::java::util::function::ToLongFunction & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Comparator(env->callStaticObjectMethod(cls, mids$[mid_comparingLong_b76ef25e61ac1a12], a0.this$));
    }

    jboolean Comparator::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    Comparator Comparator::naturalOrder()
    {
      jclass cls = env->getClass(initializeClass);
      return Comparator(env->callStaticObjectMethod(cls, mids$[mid_naturalOrder_beb0414e0ec1de00]));
    }

    Comparator Comparator::nullsFirst(const Comparator & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Comparator(env->callStaticObjectMethod(cls, mids$[mid_nullsFirst_5cea92c6ee384471], a0.this$));
    }

    Comparator Comparator::nullsLast(const Comparator & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Comparator(env->callStaticObjectMethod(cls, mids$[mid_nullsLast_5cea92c6ee384471], a0.this$));
    }

    Comparator Comparator::reverseOrder()
    {
      jclass cls = env->getClass(initializeClass);
      return Comparator(env->callStaticObjectMethod(cls, mids$[mid_reverseOrder_beb0414e0ec1de00]));
    }

    Comparator Comparator::reversed() const
    {
      return Comparator(env->callObjectMethod(this$, mids$[mid_reversed_beb0414e0ec1de00]));
    }

    Comparator Comparator::thenComparing(const Comparator & a0) const
    {
      return Comparator(env->callObjectMethod(this$, mids$[mid_thenComparing_5cea92c6ee384471], a0.this$));
    }

    Comparator Comparator::thenComparing(const ::java::util::function::Function & a0) const
    {
      return Comparator(env->callObjectMethod(this$, mids$[mid_thenComparing_dc201a331bfef5c1], a0.this$));
    }

    Comparator Comparator::thenComparing(const ::java::util::function::Function & a0, const Comparator & a1) const
    {
      return Comparator(env->callObjectMethod(this$, mids$[mid_thenComparing_eb8ae37fcd6bd979], a0.this$, a1.this$));
    }

    Comparator Comparator::thenComparingDouble(const ::java::util::function::ToDoubleFunction & a0) const
    {
      return Comparator(env->callObjectMethod(this$, mids$[mid_thenComparingDouble_25ba8710a789ab77], a0.this$));
    }

    Comparator Comparator::thenComparingInt(const ::java::util::function::ToIntFunction & a0) const
    {
      return Comparator(env->callObjectMethod(this$, mids$[mid_thenComparingInt_db59d1eb87800dd4], a0.this$));
    }

    Comparator Comparator::thenComparingLong(const ::java::util::function::ToLongFunction & a0) const
    {
      return Comparator(env->callObjectMethod(this$, mids$[mid_thenComparingLong_b76ef25e61ac1a12], a0.this$));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Comparator_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Comparator_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Comparator_of_(t_Comparator *self, PyObject *args);
    static PyObject *t_Comparator_compare(t_Comparator *self, PyObject *args);
    static PyObject *t_Comparator_comparing(PyTypeObject *type, PyObject *args);
    static PyObject *t_Comparator_comparingDouble(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Comparator_comparingInt(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Comparator_comparingLong(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Comparator_equals(t_Comparator *self, PyObject *args);
    static PyObject *t_Comparator_naturalOrder(PyTypeObject *type);
    static PyObject *t_Comparator_nullsFirst(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Comparator_nullsLast(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Comparator_reverseOrder(PyTypeObject *type);
    static PyObject *t_Comparator_reversed(t_Comparator *self);
    static PyObject *t_Comparator_thenComparing(t_Comparator *self, PyObject *args);
    static PyObject *t_Comparator_thenComparingDouble(t_Comparator *self, PyObject *arg);
    static PyObject *t_Comparator_thenComparingInt(t_Comparator *self, PyObject *arg);
    static PyObject *t_Comparator_thenComparingLong(t_Comparator *self, PyObject *arg);
    static PyObject *t_Comparator_get__parameters_(t_Comparator *self, void *data);
    static PyGetSetDef t_Comparator__fields_[] = {
      DECLARE_GET_FIELD(t_Comparator, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Comparator__methods_[] = {
      DECLARE_METHOD(t_Comparator, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Comparator, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Comparator, of_, METH_VARARGS),
      DECLARE_METHOD(t_Comparator, compare, METH_VARARGS),
      DECLARE_METHOD(t_Comparator, comparing, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Comparator, comparingDouble, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Comparator, comparingInt, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Comparator, comparingLong, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Comparator, equals, METH_VARARGS),
      DECLARE_METHOD(t_Comparator, naturalOrder, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_Comparator, nullsFirst, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Comparator, nullsLast, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Comparator, reverseOrder, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_Comparator, reversed, METH_NOARGS),
      DECLARE_METHOD(t_Comparator, thenComparing, METH_VARARGS),
      DECLARE_METHOD(t_Comparator, thenComparingDouble, METH_O),
      DECLARE_METHOD(t_Comparator, thenComparingInt, METH_O),
      DECLARE_METHOD(t_Comparator, thenComparingLong, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Comparator)[] = {
      { Py_tp_methods, t_Comparator__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Comparator__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Comparator)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Comparator, t_Comparator, Comparator);
    PyObject *t_Comparator::wrap_Object(const Comparator& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Comparator::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Comparator *self = (t_Comparator *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Comparator::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Comparator::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Comparator *self = (t_Comparator *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Comparator::install(PyObject *module)
    {
      installType(&PY_TYPE(Comparator), &PY_TYPE_DEF(Comparator), module, "Comparator", 0);
    }

    void t_Comparator::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Comparator), "class_", make_descriptor(Comparator::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Comparator), "wrapfn_", make_descriptor(t_Comparator::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Comparator), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Comparator_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Comparator::initializeClass, 1)))
        return NULL;
      return t_Comparator::wrap_Object(Comparator(((t_Comparator *) arg)->object.this$));
    }
    static PyObject *t_Comparator_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Comparator::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Comparator_of_(t_Comparator *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Comparator_compare(t_Comparator *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      jint result;

      if (!parseArgs(args, "OO", self->parameters[0], self->parameters[0], &a0, &a1))
      {
        OBJ_CALL(result = self->object.compare(a0, a1));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "compare", args);
      return NULL;
    }

    static PyObject *t_Comparator_comparing(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::function::Function a0((jobject) NULL);
          PyTypeObject **p0;
          Comparator result((jobject) NULL);

          if (!parseArgs(args, "K", ::java::util::function::Function::initializeClass, &a0, &p0, ::java::util::function::t_Function::parameters_))
          {
            OBJ_CALL(result = ::java::util::Comparator::comparing(a0));
            return t_Comparator::wrap_Object(result);
          }
        }
        break;
       case 2:
        {
          ::java::util::function::Function a0((jobject) NULL);
          PyTypeObject **p0;
          Comparator a1((jobject) NULL);
          PyTypeObject **p1;
          Comparator result((jobject) NULL);

          if (!parseArgs(args, "KK", ::java::util::function::Function::initializeClass, Comparator::initializeClass, &a0, &p0, ::java::util::function::t_Function::parameters_, &a1, &p1, t_Comparator::parameters_))
          {
            OBJ_CALL(result = ::java::util::Comparator::comparing(a0, a1));
            return t_Comparator::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError(type, "comparing", args);
      return NULL;
    }

    static PyObject *t_Comparator_comparingDouble(PyTypeObject *type, PyObject *arg)
    {
      ::java::util::function::ToDoubleFunction a0((jobject) NULL);
      PyTypeObject **p0;
      Comparator result((jobject) NULL);

      if (!parseArg(arg, "K", ::java::util::function::ToDoubleFunction::initializeClass, &a0, &p0, ::java::util::function::t_ToDoubleFunction::parameters_))
      {
        OBJ_CALL(result = ::java::util::Comparator::comparingDouble(a0));
        return t_Comparator::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "comparingDouble", arg);
      return NULL;
    }

    static PyObject *t_Comparator_comparingInt(PyTypeObject *type, PyObject *arg)
    {
      ::java::util::function::ToIntFunction a0((jobject) NULL);
      PyTypeObject **p0;
      Comparator result((jobject) NULL);

      if (!parseArg(arg, "K", ::java::util::function::ToIntFunction::initializeClass, &a0, &p0, ::java::util::function::t_ToIntFunction::parameters_))
      {
        OBJ_CALL(result = ::java::util::Comparator::comparingInt(a0));
        return t_Comparator::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "comparingInt", arg);
      return NULL;
    }

    static PyObject *t_Comparator_comparingLong(PyTypeObject *type, PyObject *arg)
    {
      ::java::util::function::ToLongFunction a0((jobject) NULL);
      PyTypeObject **p0;
      Comparator result((jobject) NULL);

      if (!parseArg(arg, "K", ::java::util::function::ToLongFunction::initializeClass, &a0, &p0, ::java::util::function::t_ToLongFunction::parameters_))
      {
        OBJ_CALL(result = ::java::util::Comparator::comparingLong(a0));
        return t_Comparator::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "comparingLong", arg);
      return NULL;
    }

    static PyObject *t_Comparator_equals(t_Comparator *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Comparator), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_Comparator_naturalOrder(PyTypeObject *type)
    {
      Comparator result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Comparator::naturalOrder());
      return t_Comparator::wrap_Object(result);
    }

    static PyObject *t_Comparator_nullsFirst(PyTypeObject *type, PyObject *arg)
    {
      Comparator a0((jobject) NULL);
      PyTypeObject **p0;
      Comparator result((jobject) NULL);

      if (!parseArg(arg, "K", Comparator::initializeClass, &a0, &p0, t_Comparator::parameters_))
      {
        OBJ_CALL(result = ::java::util::Comparator::nullsFirst(a0));
        return t_Comparator::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "nullsFirst", arg);
      return NULL;
    }

    static PyObject *t_Comparator_nullsLast(PyTypeObject *type, PyObject *arg)
    {
      Comparator a0((jobject) NULL);
      PyTypeObject **p0;
      Comparator result((jobject) NULL);

      if (!parseArg(arg, "K", Comparator::initializeClass, &a0, &p0, t_Comparator::parameters_))
      {
        OBJ_CALL(result = ::java::util::Comparator::nullsLast(a0));
        return t_Comparator::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "nullsLast", arg);
      return NULL;
    }

    static PyObject *t_Comparator_reverseOrder(PyTypeObject *type)
    {
      Comparator result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Comparator::reverseOrder());
      return t_Comparator::wrap_Object(result);
    }

    static PyObject *t_Comparator_reversed(t_Comparator *self)
    {
      Comparator result((jobject) NULL);
      OBJ_CALL(result = self->object.reversed());
      return t_Comparator::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_Comparator_thenComparing(t_Comparator *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          Comparator a0((jobject) NULL);
          PyTypeObject **p0;
          Comparator result((jobject) NULL);

          if (!parseArgs(args, "K", Comparator::initializeClass, &a0, &p0, t_Comparator::parameters_))
          {
            OBJ_CALL(result = self->object.thenComparing(a0));
            return t_Comparator::wrap_Object(result, self->parameters[0]);
          }
        }
        {
          ::java::util::function::Function a0((jobject) NULL);
          PyTypeObject **p0;
          Comparator result((jobject) NULL);

          if (!parseArgs(args, "K", ::java::util::function::Function::initializeClass, &a0, &p0, ::java::util::function::t_Function::parameters_))
          {
            OBJ_CALL(result = self->object.thenComparing(a0));
            return t_Comparator::wrap_Object(result, self->parameters[0]);
          }
        }
        break;
       case 2:
        {
          ::java::util::function::Function a0((jobject) NULL);
          PyTypeObject **p0;
          Comparator a1((jobject) NULL);
          PyTypeObject **p1;
          Comparator result((jobject) NULL);

          if (!parseArgs(args, "KK", ::java::util::function::Function::initializeClass, Comparator::initializeClass, &a0, &p0, ::java::util::function::t_Function::parameters_, &a1, &p1, t_Comparator::parameters_))
          {
            OBJ_CALL(result = self->object.thenComparing(a0, a1));
            return t_Comparator::wrap_Object(result, self->parameters[0]);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "thenComparing", args);
      return NULL;
    }

    static PyObject *t_Comparator_thenComparingDouble(t_Comparator *self, PyObject *arg)
    {
      ::java::util::function::ToDoubleFunction a0((jobject) NULL);
      PyTypeObject **p0;
      Comparator result((jobject) NULL);

      if (!parseArg(arg, "K", ::java::util::function::ToDoubleFunction::initializeClass, &a0, &p0, ::java::util::function::t_ToDoubleFunction::parameters_))
      {
        OBJ_CALL(result = self->object.thenComparingDouble(a0));
        return t_Comparator::wrap_Object(result, self->parameters[0]);
      }

      PyErr_SetArgsError((PyObject *) self, "thenComparingDouble", arg);
      return NULL;
    }

    static PyObject *t_Comparator_thenComparingInt(t_Comparator *self, PyObject *arg)
    {
      ::java::util::function::ToIntFunction a0((jobject) NULL);
      PyTypeObject **p0;
      Comparator result((jobject) NULL);

      if (!parseArg(arg, "K", ::java::util::function::ToIntFunction::initializeClass, &a0, &p0, ::java::util::function::t_ToIntFunction::parameters_))
      {
        OBJ_CALL(result = self->object.thenComparingInt(a0));
        return t_Comparator::wrap_Object(result, self->parameters[0]);
      }

      PyErr_SetArgsError((PyObject *) self, "thenComparingInt", arg);
      return NULL;
    }

    static PyObject *t_Comparator_thenComparingLong(t_Comparator *self, PyObject *arg)
    {
      ::java::util::function::ToLongFunction a0((jobject) NULL);
      PyTypeObject **p0;
      Comparator result((jobject) NULL);

      if (!parseArg(arg, "K", ::java::util::function::ToLongFunction::initializeClass, &a0, &p0, ::java::util::function::t_ToLongFunction::parameters_))
      {
        OBJ_CALL(result = self->object.thenComparingLong(a0));
        return t_Comparator::wrap_Object(result, self->parameters[0]);
      }

      PyErr_SetArgsError((PyObject *) self, "thenComparingLong", arg);
      return NULL;
    }
    static PyObject *t_Comparator_get__parameters_(t_Comparator *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Thread$UncaughtExceptionHandler.h"
#include "java/lang/Throwable.h"
#include "java/lang/Thread.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Thread$UncaughtExceptionHandler::class$ = NULL;
    jmethodID *Thread$UncaughtExceptionHandler::mids$ = NULL;
    bool Thread$UncaughtExceptionHandler::live$ = false;

    jclass Thread$UncaughtExceptionHandler::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Thread$UncaughtExceptionHandler");

        mids$ = new jmethodID[max_mid];
        mids$[mid_uncaughtException_8a0c1817de3dc30e] = env->getMethodID(cls, "uncaughtException", "(Ljava/lang/Thread;Ljava/lang/Throwable;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Thread$UncaughtExceptionHandler::uncaughtException(const ::java::lang::Thread & a0, const ::java::lang::Throwable & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_uncaughtException_8a0c1817de3dc30e], a0.this$, a1.this$);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Thread$UncaughtExceptionHandler_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Thread$UncaughtExceptionHandler_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Thread$UncaughtExceptionHandler_uncaughtException(t_Thread$UncaughtExceptionHandler *self, PyObject *args);

    static PyMethodDef t_Thread$UncaughtExceptionHandler__methods_[] = {
      DECLARE_METHOD(t_Thread$UncaughtExceptionHandler, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Thread$UncaughtExceptionHandler, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Thread$UncaughtExceptionHandler, uncaughtException, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Thread$UncaughtExceptionHandler)[] = {
      { Py_tp_methods, t_Thread$UncaughtExceptionHandler__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Thread$UncaughtExceptionHandler)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Thread$UncaughtExceptionHandler, t_Thread$UncaughtExceptionHandler, Thread$UncaughtExceptionHandler);

    void t_Thread$UncaughtExceptionHandler::install(PyObject *module)
    {
      installType(&PY_TYPE(Thread$UncaughtExceptionHandler), &PY_TYPE_DEF(Thread$UncaughtExceptionHandler), module, "Thread$UncaughtExceptionHandler", 0);
    }

    void t_Thread$UncaughtExceptionHandler::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$UncaughtExceptionHandler), "class_", make_descriptor(Thread$UncaughtExceptionHandler::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$UncaughtExceptionHandler), "wrapfn_", make_descriptor(t_Thread$UncaughtExceptionHandler::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$UncaughtExceptionHandler), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Thread$UncaughtExceptionHandler_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Thread$UncaughtExceptionHandler::initializeClass, 1)))
        return NULL;
      return t_Thread$UncaughtExceptionHandler::wrap_Object(Thread$UncaughtExceptionHandler(((t_Thread$UncaughtExceptionHandler *) arg)->object.this$));
    }
    static PyObject *t_Thread$UncaughtExceptionHandler_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Thread$UncaughtExceptionHandler::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Thread$UncaughtExceptionHandler_uncaughtException(t_Thread$UncaughtExceptionHandler *self, PyObject *args)
    {
      ::java::lang::Thread a0((jobject) NULL);
      ::java::lang::Throwable a1((jobject) NULL);

      if (!parseArgs(args, "kk", ::java::lang::Thread::initializeClass, ::java::lang::Throwable::initializeClass, &a0, &a1))
      {
        OBJ_CALL(self->object.uncaughtException(a0, a1));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "uncaughtException", args);
      return NULL;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/Function.h"
#include "java/util/function/Function.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *Function::class$ = NULL;
      jmethodID *Function::mids$ = NULL;
      bool Function::live$ = false;

      jclass Function::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/Function");

          mids$ = new jmethodID[max_mid];
          mids$[mid_andThen_ec9ce4130914478a] = env->getMethodID(cls, "andThen", "(Ljava/util/function/Function;)Ljava/util/function/Function;");
          mids$[mid_apply_e5ae0f8c04795fa9] = env->getMethodID(cls, "apply", "(Ljava/lang/Object;)Ljava/lang/Object;");
          mids$[mid_compose_ec9ce4130914478a] = env->getMethodID(cls, "compose", "(Ljava/util/function/Function;)Ljava/util/function/Function;");
          mids$[mid_identity_15fca6bcaa13077e] = env->getStaticMethodID(cls, "identity", "()Ljava/util/function/Function;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      Function Function::andThen(const Function & a0) const
      {
        return Function(env->callObjectMethod(this$, mids$[mid_andThen_ec9ce4130914478a], a0.this$));
      }

      ::java::lang::Object Function::apply(const ::java::lang::Object & a0) const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_apply_e5ae0f8c04795fa9], a0.this$));
      }

      Function Function::compose(const Function & a0) const
      {
        return Function(env->callObjectMethod(this$, mids$[mid_compose_ec9ce4130914478a], a0.this$));
      }

      Function Function::identity()
      {
        jclass cls = env->getClass(initializeClass);
        return Function(env->callStaticObjectMethod(cls, mids$[mid_identity_15fca6bcaa13077e]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_Function_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Function_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Function_of_(t_Function *self, PyObject *args);
      static PyObject *t_Function_andThen(t_Function *self, PyObject *arg);
      static PyObject *t_Function_apply(t_Function *self, PyObject *arg);
      static PyObject *t_Function_compose(t_Function *self, PyObject *arg);
      static PyObject *t_Function_identity(PyTypeObject *type);
      static PyObject *t_Function_get__parameters_(t_Function *self, void *data);
      static PyGetSetDef t_Function__fields_[] = {
        DECLARE_GET_FIELD(t_Function, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_Function__methods_[] = {
        DECLARE_METHOD(t_Function, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Function, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Function, of_, METH_VARARGS),
        DECLARE_METHOD(t_Function, andThen, METH_O),
        DECLARE_METHOD(t_Function, apply, METH_O),
        DECLARE_METHOD(t_Function, compose, METH_O),
        DECLARE_METHOD(t_Function, identity, METH_NOARGS | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Function)[] = {
        { Py_tp_methods, t_Function__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_Function__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Function)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Function, t_Function, Function);
      PyObject *t_Function::wrap_Object(const Function& object, PyTypeObject *p0, PyTypeObject *p1)
      {
        PyObject *obj = t_Function::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Function *self = (t_Function *) obj;
          self->parameters[0] = p0;
          self->parameters[1] = p1;
        }
        return obj;
      }

      PyObject *t_Function::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
      {
        PyObject *obj = t_Function::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Function *self = (t_Function *) obj;
          self->parameters[0] = p0;
          self->parameters[1] = p1;
        }
        return obj;
      }

      void t_Function::install(PyObject *module)
      {
        installType(&PY_TYPE(Function), &PY_TYPE_DEF(Function), module, "Function", 0);
      }

      void t_Function::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Function), "class_", make_descriptor(Function::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Function), "wrapfn_", make_descriptor(t_Function::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Function), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Function_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Function::initializeClass, 1)))
          return NULL;
        return t_Function::wrap_Object(Function(((t_Function *) arg)->object.this$));
      }
      static PyObject *t_Function_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Function::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Function_of_(t_Function *self, PyObject *args)
      {
        if (!parseArg(args, "T", 2, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_Function_andThen(t_Function *self, PyObject *arg)
      {
        Function a0((jobject) NULL);
        PyTypeObject **p0;
        Function result((jobject) NULL);

        if (!parseArg(arg, "K", Function::initializeClass, &a0, &p0, t_Function::parameters_))
        {
          OBJ_CALL(result = self->object.andThen(a0));
          return t_Function::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "andThen", arg);
        return NULL;
      }

      static PyObject *t_Function_apply(t_Function *self, PyObject *arg)
      {
        ::java::lang::Object a0((jobject) NULL);
        ::java::lang::Object result((jobject) NULL);

        if (!parseArg(arg, "O", self->parameters[0], &a0))
        {
          OBJ_CALL(result = self->object.apply(a0));
          return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "apply", arg);
        return NULL;
      }

      static PyObject *t_Function_compose(t_Function *self, PyObject *arg)
      {
        Function a0((jobject) NULL);
        PyTypeObject **p0;
        Function result((jobject) NULL);

        if (!parseArg(arg, "K", Function::initializeClass, &a0, &p0, t_Function::parameters_))
        {
          OBJ_CALL(result = self->object.compose(a0));
          return t_Function::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "compose", arg);
        return NULL;
      }

      static PyObject *t_Function_identity(PyTypeObject *type)
      {
        Function result((jobject) NULL);
        OBJ_CALL(result = ::java::util::function::Function::identity());
        return t_Function::wrap_Object(result);
      }
      static PyObject *t_Function_get__parameters_(t_Function *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/Executor.h"
#include "java/lang/Runnable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *Executor::class$ = NULL;
      jmethodID *Executor::mids$ = NULL;
      bool Executor::live$ = false;

      jclass Executor::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/Executor");

          mids$ = new jmethodID[max_mid];
          mids$[mid_execute_81586dca3e83f35f] = env->getMethodID(cls, "execute", "(Ljava/lang/Runnable;)V");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      void Executor::execute(const ::java::lang::Runnable & a0) const
      {
        env->callVoidMethod(this$, mids$[mid_execute_81586dca3e83f35f], a0.this$);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_Executor_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Executor_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Executor_execute(t_Executor *self, PyObject *arg);

      static PyMethodDef t_Executor__methods_[] = {
        DECLARE_METHOD(t_Executor, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Executor, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Executor, execute, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Executor)[] = {
        { Py_tp_methods, t_Executor__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Executor)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Executor, t_Executor, Executor);

      void t_Executor::install(PyObject *module)
      {
        installType(&PY_TYPE(Executor), &PY_TYPE_DEF(Executor), module, "Executor", 0);
      }

      void t_Executor::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Executor), "class_", make_descriptor(Executor::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Executor), "wrapfn_", make_descriptor(t_Executor::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Executor), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Executor_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Executor::initializeClass, 1)))
          return NULL;
        return t_Executor::wrap_Object(Executor(((t_Executor *) arg)->object.this$));
      }
      static PyObject *t_Executor_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Executor::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Executor_execute(t_Executor *self, PyObject *arg)
      {
        ::java::lang::Runnable a0((jobject) NULL);

        if (!parseArg(arg, "k", ::java::lang::Runnable::initializeClass, &a0))
        {
          OBJ_CALL(self->object.execute(a0));
          Py_RETURN_NONE;
        }

        PyErr_SetArgsError((PyObject *) self, "execute", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Thread$State.h"
#include "java/lang/String.h"
#include "java/lang/Thread$State.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Thread$State::class$ = NULL;
    jmethodID *Thread$State::mids$ = NULL;
    bool Thread$State::live$ = false;
    Thread$State *Thread$State::BLOCKED = NULL;
    Thread$State *Thread$State::NEW = NULL;
    Thread$State *Thread$State::RUNNABLE = NULL;
    Thread$State *Thread$State::TERMINATED = NULL;
    Thread$State *Thread$State::TIMED_WAITING = NULL;
    Thread$State *Thread$State::WAITING = NULL;

    jclass Thread$State::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Thread$State");

        mids$ = new jmethodID[max_mid];
        mids$[mid_valueOf_9d3488ff8e8590cf] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Ljava/lang/Thread$State;");
        mids$[mid_values_c9e2efef2bfe4609] = env->getStaticMethodID(cls, "values", "()[Ljava/lang/Thread$State;");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        BLOCKED = new Thread$State(env->getStaticObjectField(cls, "BLOCKED", "Ljava/lang/Thread$State;"));
        NEW = new Thread$State(env->getStaticObjectField(cls, "NEW", "Ljava/lang/Thread$State;"));
        RUNNABLE = new Thread$State(env->getStaticObjectField(cls, "RUNNABLE", "Ljava/lang/Thread$State;"));
        TERMINATED = new Thread$State(env->getStaticObjectField(cls, "TERMINATED", "Ljava/lang/Thread$State;"));
        TIMED_WAITING = new Thread$State(env->getStaticObjectField(cls, "TIMED_WAITING", "Ljava/lang/Thread$State;"));
        WAITING = new Thread$State(env->getStaticObjectField(cls, "WAITING", "Ljava/lang/Thread$State;"));
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Thread$State Thread$State::valueOf(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Thread$State(env->callStaticObjectMethod(cls, mids$[mid_valueOf_9d3488ff8e8590cf], a0.this$));
    }

    JArray< Thread$State > Thread$State::values()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< Thread$State >(env->callStaticObjectMethod(cls, mids$[mid_values_c9e2efef2bfe4609]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Thread$State_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Thread$State_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Thread$State_of_(t_Thread$State *self, PyObject *args);
    static PyObject *t_Thread$State_valueOf(PyTypeObject *type, PyObject *args);
    static PyObject *t_Thread$State_values(PyTypeObject *type);
    static PyObject *t_Thread$State_get__parameters_(t_Thread$State *self, void *data);
    static PyGetSetDef t_Thread$State__fields_[] = {
      DECLARE_GET_FIELD(t_Thread$State, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Thread$State__methods_[] = {
      DECLARE_METHOD(t_Thread$State, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Thread$State, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Thread$State, of_, METH_VARARGS),
      DECLARE_METHOD(t_Thread$State, valueOf, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Thread$State, values, METH_NOARGS | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Thread$State)[] = {
      { Py_tp_methods, t_Thread$State__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Thread$State__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Thread$State)[] = {
      &PY_TYPE_DEF(::java::lang::Enum),
      NULL
    };

    DEFINE_TYPE(Thread$State, t_Thread$State, Thread$State);
    PyObject *t_Thread$State::wrap_Object(const Thread$State& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Thread$State::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Thread$State *self = (t_Thread$State *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Thread$State::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Thread$State::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Thread$State *self = (t_Thread$State *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Thread$State::install(PyObject *module)
    {
      installType(&PY_TYPE(Thread$State), &PY_TYPE_DEF(Thread$State), module, "Thread$State", 0);
    }

    void t_Thread$State::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$State), "class_", make_descriptor(Thread$State::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$State), "wrapfn_", make_descriptor(t_Thread$State::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$State), "boxfn_", make_descriptor(boxObject));
      env->getClass(Thread$State::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$State), "BLOCKED", make_descriptor(t_Thread$State::wrap_Object(*Thread$State::BLOCKED)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$State), "NEW", make_descriptor(t_Thread$State::wrap_Object(*Thread$State::NEW)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$State), "RUNNABLE", make_descriptor(t_Thread$State::wrap_Object(*Thread$State::RUNNABLE)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$State), "TERMINATED", make_descriptor(t_Thread$State::wrap_Object(*Thread$State::TERMINATED)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$State), "TIMED_WAITING", make_descriptor(t_Thread$State::wrap_Object(*Thread$State::TIMED_WAITING)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Thread$State), "WAITING", make_descriptor(t_Thread$State::wrap_Object(*Thread$State::WAITING)));
    }

    static PyObject *t_Thread$State_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Thread$State::initializeClass, 1)))
        return NULL;
      return t_Thread$State::wrap_Object(Thread$State(((t_Thread$State *) arg)->object.this$));
    }
    static PyObject *t_Thread$State_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Thread$State::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Thread$State_of_(t_Thread$State *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Thread$State_valueOf(PyTypeObject *type, PyObject *args)
    {
      ::java::lang::String a0((jobject) NULL);
      Thread$State result((jobject) NULL);

      if (!parseArgs(args, "s", &a0))
      {
        OBJ_CALL(result = ::java::lang::Thread$State::valueOf(a0));
        return t_Thread$State::wrap_Object(result);
      }

      return callSuper(type, "valueOf", args, 2);
    }

    static PyObject *t_Thread$State_values(PyTypeObject *type)
    {
      JArray< Thread$State > result((jobject) NULL);
      OBJ_CALL(result = ::java::lang::Thread$State::values());
      return JArray<jobject>(result.this$).wrap(t_Thread$State::wrap_jobject);
    }
    static PyObject *t_Thread$State_get__parameters_(t_Thread$State *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/WatchKey.h"
#include "java/lang/Class.h"
#include "java/nio/file/Watchable.h"
#include "java/util/List.h"
#include "java/nio/file/WatchEvent.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *WatchKey::class$ = NULL;
      jmethodID *WatchKey::mids$ = NULL;
      bool WatchKey::live$ = false;

      jclass WatchKey::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/WatchKey");

          mids$ = new jmethodID[max_mid];
          mids$[mid_cancel_f2cc1bce94666404] = env->getMethodID(cls, "cancel", "()V");
          mids$[mid_isValid_8454bd5aa23fd11e] = env->getMethodID(cls, "isValid", "()Z");
          mids$[mid_pollEvents_49ec78390f08338a] = env->getMethodID(cls, "pollEvents", "()Ljava/util/List;");
          mids$[mid_reset_8454bd5aa23fd11e] = env->getMethodID(cls, "reset", "()Z");
          mids$[mid_watchable_a533b577be01364b] = env->getMethodID(cls, "watchable", "()Ljava/nio/file/Watchable;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      void WatchKey::cancel() const
      {
        env->callVoidMethod(this$, mids$[mid_cancel_f2cc1bce94666404]);
      }

      jboolean WatchKey::isValid() const
      {
        return env->callBooleanMethod(this$, mids$[mid_isValid_8454bd5aa23fd11e]);
      }

      ::java::util::List WatchKey::pollEvents() const
      {
        return ::java::util::List(env->callObjectMethod(this$, mids$[mid_pollEvents_49ec78390f08338a]));
      }

      jboolean WatchKey::reset() const
      {
        return env->callBooleanMethod(this$, mids$[mid_reset_8454bd5aa23fd11e]);
      }

      ::java::nio::file::Watchable WatchKey::watchable() const
      {
        return ::java::nio::file::Watchable(env->callObjectMethod(this$, mids$[mid_watchable_a533b577be01364b]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_WatchKey_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchKey_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchKey_cancel(t_WatchKey *self);
      static PyObject *t_WatchKey_isValid(t_WatchKey *self);
      static PyObject *t_WatchKey_pollEvents(t_WatchKey *self);
      static PyObject *t_WatchKey_reset(t_WatchKey *self);
      static PyObject *t_WatchKey_watchable(t_WatchKey *self);
      static PyObject *t_WatchKey_get__valid(t_WatchKey *self, void *data);
      static PyGetSetDef t_WatchKey__fields_[] = {
        DECLARE_GET_FIELD(t_WatchKey, valid),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_WatchKey__methods_[] = {
        DECLARE_METHOD(t_WatchKey, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchKey, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchKey, cancel, METH_NOARGS),
        DECLARE_METHOD(t_WatchKey, isValid, METH_NOARGS),
        DECLARE_METHOD(t_WatchKey, pollEvents, METH_NOARGS),
        DECLARE_METHOD(t_WatchKey, reset, METH_NOARGS),
        DECLARE_METHOD(t_WatchKey, watchable, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(WatchKey)[] = {
        { Py_tp_methods, t_WatchKey__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_WatchKey__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(WatchKey)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(WatchKey, t_WatchKey, WatchKey);

      void t_WatchKey::install(PyObject *module)
      {
        installType(&PY_TYPE(WatchKey), &PY_TYPE_DEF(WatchKey), module, "WatchKey", 0);
      }

      void t_WatchKey::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchKey), "class_", make_descriptor(WatchKey::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchKey), "wrapfn_", make_descriptor(t_WatchKey::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchKey), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_WatchKey_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, WatchKey::initializeClass, 1)))
          return NULL;
        return t_WatchKey::wrap_Object(WatchKey(((t_WatchKey *) arg)->object.this$));
      }
      static PyObject *t_WatchKey_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, WatchKey::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_WatchKey_cancel(t_WatchKey *self)
      {
        OBJ_CALL(self->object.cancel());
        Py_RETURN_NONE;
      }

      static PyObject *t_WatchKey_isValid(t_WatchKey *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.isValid());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_WatchKey_pollEvents(t_WatchKey *self)
      {
        ::java::util::List result((jobject) NULL);
        OBJ_CALL(result = self->object.pollEvents());
        return ::java::util::t_List::wrap_Object(result);
      }

      static PyObject *t_WatchKey_reset(t_WatchKey *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.reset());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_WatchKey_watchable(t_WatchKey *self)
      {
        ::java::nio::file::Watchable result((jobject) NULL);
        OBJ_CALL(result = self->object.watchable());
        return ::java::nio::file::t_Watchable::wrap_Object(result);
      }

      static PyObject *t_WatchKey_get__valid(t_WatchKey *self, void *data)
      {
        jboolean value;
        OBJ_CALL(value = self->object.isValid());
        Py_RETURN_BOOL(value);
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/lang/String.h"
#include "java/lang/InterruptedException.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/lang/Thread.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *TimeUnit::class$ = NULL;
      jmethodID *TimeUnit::mids$ = NULL;
      bool TimeUnit::live$ = false;
      TimeUnit *TimeUnit::DAYS = NULL;
      TimeUnit *TimeUnit::HOURS = NULL;
      TimeUnit *TimeUnit::MICROSECONDS = NULL;
      TimeUnit *TimeUnit::MILLISECONDS = NULL;
      TimeUnit *TimeUnit::MINUTES = NULL;
      TimeUnit *TimeUnit::NANOSECONDS = NULL;
      TimeUnit *TimeUnit::SECONDS = NULL;

      jclass TimeUnit::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/TimeUnit");

          mids$ = new jmethodID[max_mid];
          mids$[mid_convert_ccb7513c89073172] = env->getMethodID(cls, "convert", "(JLjava/util/concurrent/TimeUnit;)J");
          mids$[mid_sleep_9c778c9bce6694df] = env->getMethodID(cls, "sleep", "(J)V");
          mids$[mid_timedJoin_72ed2aade046f3ba] = env->getMethodID(cls, "timedJoin", "(Ljava/lang/Thread;J)V");
          mids$[mid_timedWait_f63797c6ac19e2f5] = env->getMethodID(cls, "timedWait", "(Ljava/lang/Object;J)V");
          mids$[mid_toDays_d711eecdc469624a] = env->getMethodID(cls, "toDays", "(J)J");
          mids$[mid_toHours_d711eecdc469624a] = env->getMethodID(cls, "toHours", "(J)J");
          mids$[mid_toMicros_d711eecdc469624a] = env->getMethodID(cls, "toMicros", "(J)J");
          mids$[mid_toMillis_d711eecdc469624a] = env->getMethodID(cls, "toMillis", "(J)J");
          mids$[mid_toMinutes_d711eecdc469624a] = env->getMethodID(cls, "toMinutes", "(J)J");
          mids$[mid_toNanos_d711eecdc469624a] = env->getMethodID(cls, "toNanos", "(J)J");
          mids$[mid_toSeconds_d711eecdc469624a] = env->getMethodID(cls, "toSeconds", "(J)J");
          mids$[mid_valueOf_d74b47f51ef4a712] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Ljava/util/concurrent/TimeUnit;");
          mids$[mid_values_7ff1d7c143beb75e] = env->getStaticMethodID(cls, "values", "()[Ljava/util/concurrent/TimeUnit;");

          class$ = new ::java::lang::Class(cls);
          cls = (jclass) class$->this$;

          DAYS = new TimeUnit(env->getStaticObjectField(cls, "DAYS", "Ljava/util/concurrent/TimeUnit;"));
          HOURS = new TimeUnit(env->getStaticObjectField(cls, "HOURS", "Ljava/util/concurrent/TimeUnit;"));
          MICROSECONDS = new TimeUnit(env->getStaticObjectField(cls, "MICROSECONDS", "Ljava/util/concurrent/TimeUnit;"));
          MILLISECONDS = new TimeUnit(env->getStaticObjectField(cls, "MILLISECONDS", "Ljava/util/concurrent/TimeUnit;"));
          MINUTES = new TimeUnit(env->getStaticObjectField(cls, "MINUTES", "Ljava/util/concurrent/TimeUnit;"));
          NANOSECONDS = new TimeUnit(env->getStaticObjectField(cls, "NANOSECONDS", "Ljava/util/concurrent/TimeUnit;"));
          SECONDS = new TimeUnit(env->getStaticObjectField(cls, "SECONDS", "Ljava/util/concurrent/TimeUnit;"));
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jlong TimeUnit::convert(jlong a0, const TimeUnit & a1) const
      {
        return env->callLongMethod(this$, mids$[mid_convert_ccb7513c89073172], a0, a1.this$);
      }

      void TimeUnit::sleep(jlong a0) const
      {
        env->callVoidMethod(this$, mids$[mid_sleep_9c778c9bce6694df], a0);
      }

      void TimeUnit::timedJoin(const ::java::lang::Thread & a0, jlong a1) const
      {
        env->callVoidMethod(this$, mids$[mid_timedJoin_72ed2aade046f3ba], a0.this$, a1);
      }

      void TimeUnit::timedWait(const ::java::lang::Object & a0, jlong a1) const
      {
        env->callVoidMethod(this$, mids$[mid_timedWait_f63797c6ac19e2f5], a0.this$, a1);
      }

      jlong TimeUnit::toDays(jlong a0) const
      {
        return env->callLongMethod(this$, mids$[mid_toDays_d711eecdc469624a], a0);
      }

      jlong TimeUnit::toHours(jlong a0) const
      {
        return env->callLongMethod(this$, mids$[mid_toHours_d711eecdc469624a], a0);
      }

      jlong TimeUnit::toMicros(jlong a0) const
      {
        return env->callLongMethod(this$, mids$[mid_toMicros_d711eecdc469624a], a0);
      }

      jlong TimeUnit::toMillis(jlong a0) const
      {
        return env->callLongMethod(this$, mids$[mid_toMillis_d711eecdc469624a], a0);
      }

      jlong TimeUnit::toMinutes(jlong a0) const
      {
        return env->callLongMethod(this$, mids$[mid_toMinutes_d711eecdc469624a], a0);
      }

      jlong TimeUnit::toNanos(jlong a0) const
      {
        return env->callLongMethod(this$, mids$[mid_toNanos_d711eecdc469624a], a0);
      }

      jlong TimeUnit::toSeconds(jlong a0) const
      {
        return env->callLongMethod(this$, mids$[mid_toSeconds_d711eecdc469624a], a0);
      }

      TimeUnit TimeUnit::valueOf(const ::java::lang::String & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return TimeUnit(env->callStaticObjectMethod(cls, mids$[mid_valueOf_d74b47f51ef4a712], a0.this$));
      }

      JArray< TimeUnit > TimeUnit::values()
      {
        jclass cls = env->getClass(initializeClass);
        return JArray< TimeUnit >(env->callStaticObjectMethod(cls, mids$[mid_values_7ff1d7c143beb75e]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_TimeUnit_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_TimeUnit_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_TimeUnit_of_(t_TimeUnit *self, PyObject *args);
      static PyObject *t_TimeUnit_convert(t_TimeUnit *self, PyObject *args);
      static PyObject *t_TimeUnit_sleep(t_TimeUnit *self, PyObject *arg);
      static PyObject *t_TimeUnit_timedJoin(t_TimeUnit *self, PyObject *args);
      static PyObject *t_TimeUnit_timedWait(t_TimeUnit *self, PyObject *args);
      static PyObject *t_TimeUnit_toDays(t_TimeUnit *self, PyObject *arg);
      static PyObject *t_TimeUnit_toHours(t_TimeUnit *self, PyObject *arg);
      static PyObject *t_TimeUnit_toMicros(t_TimeUnit *self, PyObject *arg);
      static PyObject *t_TimeUnit_toMillis(t_TimeUnit *self, PyObject *arg);
      static PyObject *t_TimeUnit_toMinutes(t_TimeUnit *self, PyObject *arg);
      static PyObject *t_TimeUnit_toNanos(t_TimeUnit *self, PyObject *arg);
      static PyObject *t_TimeUnit_toSeconds(t_TimeUnit *self, PyObject *arg);
      static PyObject *t_TimeUnit_valueOf(PyTypeObject *type, PyObject *args);
      static PyObject *t_TimeUnit_values(PyTypeObject *type);
      static PyObject *t_TimeUnit_get__parameters_(t_TimeUnit *self, void *data);
      static PyGetSetDef t_TimeUnit__fields_[] = {
        DECLARE_GET_FIELD(t_TimeUnit, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_TimeUnit__methods_[] = {
        DECLARE_METHOD(t_TimeUnit, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_TimeUnit, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_TimeUnit, of_, METH_VARARGS),
        DECLARE_METHOD(t_TimeUnit, convert, METH_VARARGS),
        DECLARE_METHOD(t_TimeUnit, sleep, METH_O),
        DECLARE_METHOD(t_TimeUnit, timedJoin, METH_VARARGS),
        DECLARE_METHOD(t_TimeUnit, timedWait, METH_VARARGS),
        DECLARE_METHOD(t_TimeUnit, toDays, METH_O),
        DECLARE_METHOD(t_TimeUnit, toHours, METH_O),
        DECLARE_METHOD(t_TimeUnit, toMicros, METH_O),
        DECLARE_METHOD(t_TimeUnit, toMillis, METH_O),
        DECLARE_METHOD(t_TimeUnit, toMinutes, METH_O),
        DECLARE_METHOD(t_TimeUnit, toNanos, METH_O),
        DECLARE_METHOD(t_TimeUnit, toSeconds, METH_O),
        DECLARE_METHOD(t_TimeUnit, valueOf, METH_VARARGS | METH_CLASS),
        DECLARE_METHOD(t_TimeUnit, values, METH_NOARGS | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(TimeUnit)[] = {
        { Py_tp_methods, t_TimeUnit__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_TimeUnit__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(TimeUnit)[] = {
        &PY_TYPE_DEF(::java::lang::Enum),
        NULL
      };

      DEFINE_TYPE(TimeUnit, t_TimeUnit, TimeUnit);
      PyObject *t_TimeUnit::wrap_Object(const TimeUnit& object, PyTypeObject *p0)
      {
        PyObject *obj = t_TimeUnit::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_TimeUnit *self = (t_TimeUnit *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_TimeUnit::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_TimeUnit::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_TimeUnit *self = (t_TimeUnit *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_TimeUnit::install(PyObject *module)
      {
        installType(&PY_TYPE(TimeUnit), &PY_TYPE_DEF(TimeUnit), module, "TimeUnit", 0);
      }

      void t_TimeUnit::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "class_", make_descriptor(TimeUnit::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "wrapfn_", make_descriptor(t_TimeUnit::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "boxfn_", make_descriptor(boxObject));
        env->getClass(TimeUnit::initializeClass);
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "DAYS", make_descriptor(t_TimeUnit::wrap_Object(*TimeUnit::DAYS)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "HOURS", make_descriptor(t_TimeUnit::wrap_Object(*TimeUnit::HOURS)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "MICROSECONDS", make_descriptor(t_TimeUnit::wrap_Object(*TimeUnit::MICROSECONDS)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "MILLISECONDS", make_descriptor(t_TimeUnit::wrap_Object(*TimeUnit::MILLISECONDS)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "MINUTES", make_descriptor(t_TimeUnit::wrap_Object(*TimeUnit::MINUTES)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "NANOSECONDS", make_descriptor(t_TimeUnit::wrap_Object(*TimeUnit::NANOSECONDS)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeUnit), "SECONDS", make_descriptor(t_TimeUnit::wrap_Object(*TimeUnit::SECONDS)));
      }

      static PyObject *t_TimeUnit_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, TimeUnit::initializeClass, 1)))
          return NULL;
        return t_TimeUnit::wrap_Object(TimeUnit(((t_TimeUnit *) arg)->object.this$));
      }
      static PyObject *t_TimeUnit_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, TimeUnit::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_TimeUnit_of_(t_TimeUnit *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_TimeUnit_convert(t_TimeUnit *self, PyObject *args)
      {
        jlong a0;
        TimeUnit a1((jobject) NULL);
        PyTypeObject **p1;
        jlong result;

        if (!parseArgs(args, "JK", TimeUnit::initializeClass, &a0, &a1, &p1, t_TimeUnit::parameters_))
        {
          OBJ_CALL(result = self->object.convert(a0, a1));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "convert", args);
        return NULL;
      }

      static PyObject *t_TimeUnit_sleep(t_TimeUnit *self, PyObject *arg)
      {
        jlong a0;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(self->object.sleep(a0));
          Py_RETURN_NONE;
        }

        PyErr_SetArgsError((PyObject *) self, "sleep", arg);
        return NULL;
      }

      static PyObject *t_TimeUnit_timedJoin(t_TimeUnit *self, PyObject *args)
      {
        ::java::lang::Thread a0((jobject) NULL);
        jlong a1;

        if (!parseArgs(args, "kJ", ::java::lang::Thread::initializeClass, &a0, &a1))
        {
          OBJ_CALL(self->object.timedJoin(a0, a1));
          Py_RETURN_NONE;
        }

        PyErr_SetArgsError((PyObject *) self, "timedJoin", args);
        return NULL;
      }

      static PyObject *t_TimeUnit_timedWait(t_TimeUnit *self, PyObject *args)
      {
        ::java::lang::Object a0((jobject) NULL);
        jlong a1;

        if (!parseArgs(args, "oJ", &a0, &a1))
        {
          OBJ_CALL(self->object.timedWait(a0, a1));
          Py_RETURN_NONE;
        }

        PyErr_SetArgsError((PyObject *) self, "timedWait", args);
        return NULL;
      }

      static PyObject *t_TimeUnit_toDays(t_TimeUnit *self, PyObject *arg)
      {
        jlong a0;
        jlong result;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(result = self->object.toDays(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "toDays", arg);
        return NULL;
      }

      static PyObject *t_TimeUnit_toHours(t_TimeUnit *self, PyObject *arg)
      {
        jlong a0;
        jlong result;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(result = self->object.toHours(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "toHours", arg);
        return NULL;
      }

      static PyObject *t_TimeUnit_toMicros(t_TimeUnit *self, PyObject *arg)
      {
        jlong a0;
        jlong result;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(result = self->object.toMicros(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "toMicros", arg);
        return NULL;
      }

      static PyObject *t_TimeUnit_toMillis(t_TimeUnit *self, PyObject *arg)
      {
        jlong a0;
        jlong result;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(result = self->object.toMillis(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "toMillis", arg);
        return NULL;
      }

      static PyObject *t_TimeUnit_toMinutes(t_TimeUnit *self, PyObject *arg)
      {
        jlong a0;
        jlong result;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(result = self->object.toMinutes(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "toMinutes", arg);
        return NULL;
      }

      static PyObject *t_TimeUnit_toNanos(t_TimeUnit *self, PyObject *arg)
      {
        jlong a0;
        jlong result;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(result = self->object.toNanos(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "toNanos", arg);
        return NULL;
      }

      static PyObject *t_TimeUnit_toSeconds(t_TimeUnit *self, PyObject *arg)
      {
        jlong a0;
        jlong result;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(result = self->object.toSeconds(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "toSeconds", arg);
        return NULL;
      }

      static PyObject *t_TimeUnit_valueOf(PyTypeObject *type, PyObject *args)
      {
        ::java::lang::String a0((jobject) NULL);
        TimeUnit result((jobject) NULL);

        if (!parseArgs(args, "s", &a0))
        {
          OBJ_CALL(result = ::java::util::concurrent::TimeUnit::valueOf(a0));
          return t_TimeUnit::wrap_Object(result);
        }

        return callSuper(type, "valueOf", args, 2);
      }

      static PyObject *t_TimeUnit_values(PyTypeObject *type)
      {
        JArray< TimeUnit > result((jobject) NULL);
        OBJ_CALL(result = ::java::util::concurrent::TimeUnit::values());
        return JArray<jobject>(result.this$).wrap(t_TimeUnit::wrap_jobject);
      }
      static PyObject *t_TimeUnit_get__parameters_(t_TimeUnit *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Date.h"
#include "java/lang/Cloneable.h"
#include "java/lang/Comparable.h"
#include "java/util/Date.h"
#include "java/lang/Class.h"
#include "java/lang/String.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Date::class$ = NULL;
    jmethodID *Date::mids$ = NULL;
    bool Date::live$ = false;

    jclass Date::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Date");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_9c778c9bce6694df] = env->getMethodID(cls, "<init>", "(J)V");
        mids$[mid_init$_db3e97653d3683f3] = env->getMethodID(cls, "<init>", "(III)V");
        mids$[mid_init$_bfcfa7ea38630f19] = env->getMethodID(cls, "<init>", "(IIIII)V");
        mids$[mid_init$_8a81c36f6bc75ed5] = env->getMethodID(cls, "<init>", "(IIIIII)V");
        mids$[mid_UTC_28ce26c9a9740bcf] = env->getStaticMethodID(cls, "UTC", "(IIIIII)J");
        mids$[mid_after_82a07bf228f15954] = env->getMethodID(cls, "after", "(Ljava/util/Date;)Z");
        mids$[mid_before_82a07bf228f15954] = env->getMethodID(cls, "before", "(Ljava/util/Date;)Z");
        mids$[mid_clone_d6bcd06f3102c4d9] = env->getMethodID(cls, "clone", "()Ljava/lang/Object;");
        mids$[mid_compareTo_938b7ab781c20f5d] = env->getMethodID(cls, "compareTo", "(Ljava/util/Date;)I");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_getDate_9972fcc56b44e79d] = env->getMethodID(cls, "getDate", "()I");
        mids$[mid_getDay_9972fcc56b44e79d] = env->getMethodID(cls, "getDay", "()I");
        mids$[mid_getHours_9972fcc56b44e79d] = env->getMethodID(cls, "getHours", "()I");
        mids$[mid_getMinutes_9972fcc56b44e79d] = env->getMethodID(cls, "getMinutes", "()I");
        mids$[mid_getMonth_9972fcc56b44e79d] = env->getMethodID(cls, "getMonth", "()I");
        mids$[mid_getSeconds_9972fcc56b44e79d] = env->getMethodID(cls, "getSeconds", "()I");
        mids$[mid_getTime_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTime", "()J");
        mids$[mid_getTimezoneOffset_9972fcc56b44e79d] = env->getMethodID(cls, "getTimezoneOffset", "()I");
        mids$[mid_getYear_9972fcc56b44e79d] = env->getMethodID(cls, "getYear", "()I");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_parse_b1e05207ec98e246] = env->getStaticMethodID(cls, "parse", "(Ljava/lang/String;)J");
        mids$[mid_setDate_040c4cd0390c5aff] = env->getMethodID(cls, "setDate", "(I)V");
        mids$[mid_setHours_040c4cd0390c5aff] = env->getMethodID(cls, "setHours", "(I)V");
        mids$[mid_setMinutes_040c4cd0390c5aff] = env->getMethodID(cls, "setMinutes", "(I)V");
        mids$[mid_setMonth_040c4cd0390c5aff] = env->getMethodID(cls, "setMonth", "(I)V");
        mids$[mid_setSeconds_040c4cd0390c5aff] = env->getMethodID(cls, "setSeconds", "(I)V");
        mids$[mid_setTime_9c778c9bce6694df] = env->getMethodID(cls, "setTime", "(J)V");
        mids$[mid_setYear_040c4cd0390c5aff] = env->getMethodID(cls, "setYear", "(I)V");
        mids$[mid_toGMTString_db9b55ba01e03e4b] = env->getMethodID(cls, "toGMTString", "()Ljava/lang/String;");
        mids$[mid_toLocaleString_db9b55ba01e03e4b] = env->getMethodID(cls, "toLocaleString", "()Ljava/lang/String;");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Date::Date() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    Date::Date(const ::java::lang::String & a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    Date::Date(jlong a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_9c778c9bce6694df, a0)) {}

    Date::Date(jint a0, jint a1, jint a2) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_db3e97653d3683f3, a0, a1, a2)) {}

    Date::Date(jint a0, jint a1, jint a2, jint a3, jint a4) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_bfcfa7ea38630f19, a0, a1, a2, a3, a4)) {}

    Date::Date(jint a0, jint a1, jint a2, jint a3, jint a4, jint a5) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_8a81c36f6bc75ed5, a0, a1, a2, a3, a4, a5)) {}

    jlong Date::UTC(jint a0, jint a1, jint a2, jint a3, jint a4, jint a5)
    {
      jclass cls = env->getClass(initializeClass);
      return env->callStaticLongMethod(cls, mids$[mid_UTC_28ce26c9a9740bcf], a0, a1, a2, a3, a4, a5);
    }

    jboolean Date::after(const Date & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_after_82a07bf228f15954], a0.this$);
    }

    jboolean Date::before(const Date & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_before_82a07bf228f15954], a0.this$);
    }

    ::java::lang::Object Date::clone() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_clone_d6bcd06f3102c4d9]));
    }

    jint Date::compareTo(const Date & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_compareTo_938b7ab781c20f5d], a0.this$);
    }

    jboolean Date::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    jint Date::getDate() const
    {
      return env->callIntMethod(this$, mids$[mid_getDate_9972fcc56b44e79d]);
    }

    jint Date::getDay() const
    {
      return env->callIntMethod(this$, mids$[mid_getDay_9972fcc56b44e79d]);
    }

    jint Date::getHours() const
    {
      return env->callIntMethod(this$, mids$[mid_getHours_9972fcc56b44e79d]);
    }

    jint Date::getMinutes() const
    {
      return env->callIntMethod(this$, mids$[mid_getMinutes_9972fcc56b44e79d]);
    }

    jint Date::getMonth() const
    {
      return env->callIntMethod(this$, mids$[mid_getMonth_9972fcc56b44e79d]);
    }

    jint Date::getSeconds() const
    {
      return env->callIntMethod(this$, mids$[mid_getSeconds_9972fcc56b44e79d]);
    }

    jlong Date::getTime() const
    {
      return env->callLongMethod(this$, mids$[mid_getTime_2e5ae9edcb9b072f]);
    }

    jint Date::getTimezoneOffset() const
    {
      return env->callIntMethod(this$, mids$[mid_getTimezoneOffset_9972fcc56b44e79d]);
    }

    jint Date::getYear() const
    {
      return env->callIntMethod(this$, mids$[mid_getYear_9972fcc56b44e79d]);
    }

    jint Date::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jlong Date::parse(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return env->callStaticLongMethod(cls, mids$[mid_parse_b1e05207ec98e246], a0.this$);
    }

    void Date::setDate(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setDate_040c4cd0390c5aff], a0);
    }

    void Date::setHours(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setHours_040c4cd0390c5aff], a0);
    }

    void Date::setMinutes(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setMinutes_040c4cd0390c5aff], a0);
    }

    void Date::setMonth(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setMonth_040c4cd0390c5aff], a0);
    }

    void Date::setSeconds(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setSeconds_040c4cd0390c5aff], a0);
    }

    void Date::setTime(jlong a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setTime_9c778c9bce6694df], a0);
    }

    void Date::setYear(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setYear_040c4cd0390c5aff], a0);
    }

    ::java::lang::String Date::toGMTString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toGMTString_db9b55ba01e03e4b]));
    }

    ::java::lang::String Date::toLocaleString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toLocaleString_db9b55ba01e03e4b]));
    }

    ::java::lang::String Date::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Date_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Date_instance_(PyTypeObject *type, PyObject *arg);
    static int t_Date_init_(t_Date *self, PyObject *args, PyObject *kwds);
    static PyObject *t_Date_UTC(PyTypeObject *type, PyObject *args);
    static PyObject *t_Date_after(t_Date *self, PyObject *arg);
    static PyObject *t_Date_before(t_Date *self, PyObject *arg);
    static PyObject *t_Date_clone(t_Date *self);
    static PyObject *t_Date_compareTo(t_Date *self, PyObject *arg);
    static PyObject *t_Date_equals(t_Date *self, PyObject *args);
    static PyObject *t_Date_getDate(t_Date *self);
    static PyObject *t_Date_getDay(t_Date *self);
    static PyObject *t_Date_getHours(t_Date *self);
    static PyObject *t_Date_getMinutes(t_Date *self);
    static PyObject *t_Date_getMonth(t_Date *self);
    static PyObject *t_Date_getSeconds(t_Date *self);
    static PyObject *t_Date_getTime(t_Date *self);
    static PyObject *t_Date_getTimezoneOffset(t_Date *self);
    static PyObject *t_Date_getYear(t_Date *self);
    static PyObject *t_Date_hashCode(t_Date *self, PyObject *args);
    static PyObject *t_Date_parse(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Date_setDate(t_Date *self, PyObject *arg);
    static PyObject *t_Date_setHours(t_Date *self, PyObject *arg);
    static PyObject *t_Date_setMinutes(t_Date *self, PyObject *arg);
    static PyObject *t_Date_setMonth(t_Date *self, PyObject *arg);
    static PyObject *t_Date_setSeconds(t_Date *self, PyObject *arg);
    static PyObject *t_Date_setTime(t_Date *self, PyObject *arg);
    static PyObject *t_Date_setYear(t_Date *self, PyObject *arg);
    static PyObject *t_Date_toGMTString(t_Date *self);
    static PyObject *t_Date_toLocaleString(t_Date *self);
    static PyObject *t_Date_toString(t_Date *self, PyObject *args);
    static PyObject *t_Date_get__date(t_Date *self, void *data);
    static int t_Date_set__date(t_Date *self, PyObject *arg, void *data);
    static PyObject *t_Date_get__day(t_Date *self, void *data);
    static PyObject *t_Date_get__hours(t_Date *self, void *data);
    static int t_Date_set__hours(t_Date *self, PyObject *arg, void *data);
    static PyObject *t_Date_get__minutes(t_Date *self, void *data);
    static int t_Date_set__minutes(t_Date *self, PyObject *arg, void *data);
    static PyObject *t_Date_get__month(t_Date *self, void *data);
    static int t_Date_set__month(t_Date *self, PyObject *arg, void *data);
    static PyObject *t_Date_get__seconds(t_Date *self, void *data);
    static int t_Date_set__seconds(t_Date *self, PyObject *arg, void *data);
    static PyObject *t_Date_get__time(t_Date *self, void *data);
    static int t_Date_set__time(t_Date *self, PyObject *arg, void *data);
    static PyObject *t_Date_get__timezoneOffset(t_Date *self, void *data);
    static PyObject *t_Date_get__year(t_Date *self, void *data);
    static int t_Date_set__year(t_Date *self, PyObject *arg, void *data);
    static PyGetSetDef t_Date__fields_[] = {
      DECLARE_GETSET_FIELD(t_Date, date),
      DECLARE_GET_FIELD(t_Date, day),
      DECLARE_GETSET_FIELD(t_Date, hours),
      DECLARE_GETSET_FIELD(t_Date, minutes),
      DECLARE_GETSET_FIELD(t_Date, month),
      DECLARE_GETSET_FIELD(t_Date, seconds),
      DECLARE_GETSET_FIELD(t_Date, time),
      DECLARE_GET_FIELD(t_Date, timezoneOffset),
      DECLARE_GETSET_FIELD(t_Date, year),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Date__methods_[] = {
      DECLARE_METHOD(t_Date, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Date, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Date, UTC, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Date, after, METH_O),
      DECLARE_METHOD(t_Date, before, METH_O),
      DECLARE_METHOD(t_Date, clone, METH_NOARGS),
      DECLARE_METHOD(t_Date, compareTo, METH_O),
      DECLARE_METHOD(t_Date, equals, METH_VARARGS),
      DECLARE_METHOD(t_Date, getDate, METH_NOARGS),
      DECLARE_METHOD(t_Date, getDay, METH_NOARGS),
      DECLARE_METHOD(t_Date, getHours, METH_NOARGS),
      DECLARE_METHOD(t_Date, getMinutes, METH_NOARGS),
      DECLARE_METHOD(t_Date, getMonth, METH_NOARGS),
      DECLARE_METHOD(t_Date, getSeconds, METH_NOARGS),
      DECLARE_METHOD(t_Date, getTime, METH_NOARGS),
      DECLARE_METHOD(t_Date, getTimezoneOffset, METH_NOARGS),
      DECLARE_METHOD(t_Date, getYear, METH_NOARGS),
      DECLARE_METHOD(t_Date, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_Date, parse, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Date, setDate, METH_O),
      DECLARE_METHOD(t_Date, setHours, METH_O),
      DECLARE_METHOD(t_Date, setMinutes, METH_O),
      DECLARE_METHOD(t_Date, setMonth, METH_O),
      DECLARE_METHOD(t_Date, setSeconds, METH_O),
      DECLARE_METHOD(t_Date, setTime, METH_O),
      DECLARE_METHOD(t_Date, setYear, METH_O),
      DECLARE_METHOD(t_Date, toGMTString, METH_NOARGS),
      DECLARE_METHOD(t_Date, toLocaleString, METH_NOARGS),
      DECLARE_METHOD(t_Date, toString, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Date)[] = {
      { Py_tp_methods, t_Date__methods_ },
      { Py_tp_init, (void *) t_Date_init_ },
      { Py_tp_getset, t_Date__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Date)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Date, t_Date, Date);

    void t_Date::install(PyObject *module)
    {
      installType(&PY_TYPE(Date), &PY_TYPE_DEF(Date), module, "Date", 0);
    }

    void t_Date::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Date), "class_", make_descriptor(Date::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Date), "wrapfn_", make_descriptor(t_Date::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Date), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Date_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Date::initializeClass, 1)))
        return NULL;
      return t_Date::wrap_Object(Date(((t_Date *) arg)->object.this$));
    }
    static PyObject *t_Date_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Date::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_Date_init_(t_Date *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          Date object((jobject) NULL);

          INT_CALL(object = Date());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          Date object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = Date(a0));
            self->object = object;
            break;
          }
        }
        {
          jlong a0;
          Date object((jobject) NULL);

          if (!parseArgs(args, "J", &a0))
          {
            INT_CALL(object = Date(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 3:
        {
          jint a0;
          jint a1;
          jint a2;
          Date object((jobject) NULL);

          if (!parseArgs(args, "III", &a0, &a1, &a2))
          {
            INT_CALL(object = Date(a0, a1, a2));
            self->object = object;
            break;
          }
        }
        goto err;
       case 5:
        {
          jint a0;
          jint a1;
          jint a2;
          jint a3;
          jint a4;
          Date object((jobject) NULL);

          if (!parseArgs(args, "IIIII", &a0, &a1, &a2, &a3, &a4))
          {
            INT_CALL(object = Date(a0, a1, a2, a3, a4));
            self->object = object;
            break;
          }
        }
        goto err;
       case 6:
        {
          jint a0;
          jint a1;
          jint a2;
          jint a3;
          jint a4;
          jint a5;
          Date object((jobject) NULL);

          if (!parseArgs(args, "IIIIII", &a0, &a1, &a2, &a3, &a4, &a5))
          {
            INT_CALL(object = Date(a0, a1, a2, a3, a4, a5));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_Date_UTC(PyTypeObject *type, PyObject *args)
    {
      jint a0;
      jint a1;
      jint a2;
      jint a3;
      jint a4;
      jint a5;
      jlong result;

      if (!parseArgs(args, "IIIIII", &a0, &a1, &a2, &a3, &a4, &a5))
      {
        OBJ_CALL(result = ::java::util::Date::UTC(a0, a1, a2, a3, a4, a5));
        return PyLong_FromLongLong((PY_LONG_LONG) result);
      }

      PyErr_SetArgsError(type, "UTC", args);
      return NULL;
    }

    static PyObject *t_Date_after(t_Date *self, PyObject *arg)
    {
      Date a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "k", Date::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.after(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "after", arg);
      return NULL;
    }

    static PyObject *t_Date_before(t_Date *self, PyObject *arg)
    {
      Date a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "k", Date::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.before(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "before", arg);
      return NULL;
    }

    static PyObject *t_Date_clone(t_Date *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.clone());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Date_compareTo(t_Date *self, PyObject *arg)
    {
      Date a0((jobject) NULL);
      jint result;

      if (!parseArg(arg, "k", Date::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.compareTo(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "compareTo", arg);
      return NULL;
    }

    static PyObject *t_Date_equals(t_Date *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Date), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_Date_getDate(t_Date *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getDate());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Date_getDay(t_Date *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getDay());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Date_getHours(t_Date *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getHours());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Date_getMinutes(t_Date *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getMinutes());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Date_getMonth(t_Date *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getMonth());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Date_getSeconds(t_Date *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getSeconds());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Date_getTime(t_Date *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.getTime());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_Date_getTimezoneOffset(t_Date *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getTimezoneOffset());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Date_getYear(t_Date *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getYear());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Date_hashCode(t_Date *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Date), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_Date_parse(PyTypeObject *type, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      jlong result;

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = ::java::util::Date::parse(a0));
        return PyLong_FromLongLong((PY_LONG_LONG) result);
      }

      PyErr_SetArgsError(type, "parse", arg);
      return NULL;
    }

    static PyObject *t_Date_setDate(t_Date *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setDate(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setDate", arg);
      return NULL;
    }

    static PyObject *t_Date_setHours(t_Date *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setHours(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setHours", arg);
      return NULL;
    }

    static PyObject *t_Date_setMinutes(t_Date *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setMinutes(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setMinutes", arg);
      return NULL;
    }

    static PyObject *t_Date_setMonth(t_Date *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setMonth(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setMonth", arg);
      return NULL;
    }

    static PyObject *t_Date_setSeconds(t_Date *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setSeconds(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setSeconds", arg);
      return NULL;
    }

    static PyObject *t_Date_setTime(t_Date *self, PyObject *arg)
    {
      jlong a0;

      if (!parseArg(arg, "J", &a0))
      {
        OBJ_CALL(self->object.setTime(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setTime", arg);
      return NULL;
    }

    static PyObject *t_Date_setYear(t_Date *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setYear(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setYear", arg);
      return NULL;
    }

    static PyObject *t_Date_toGMTString(t_Date *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.toGMTString());
      return j2p(result);
    }

    static PyObject *t_Date_toLocaleString(t_Date *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.toLocaleString());
      return j2p(result);
    }

    static PyObject *t_Date_toString(t_Date *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(Date), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_Date_get__date(t_Date *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getDate());
      return PyLong_FromLong((long) value);
    }
    static int t_Date_set__date(t_Date *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setDate(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "date", arg);
      return -1;
    }

    static PyObject *t_Date_get__day(t_Date *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getDay());
      return PyLong_FromLong((long) value);
    }

    static PyObject *t_Date_get__hours(t_Date *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getHours());
      return PyLong_FromLong((long) value);
    }
    static int t_Date_set__hours(t_Date *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setHours(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "hours", arg);
      return -1;
    }

    static PyObject *t_Date_get__minutes(t_Date *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getMinutes());
      return PyLong_FromLong((long) value);
    }
    static int t_Date_set__minutes(t_Date *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setMinutes(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "minutes", arg);
      return -1;
    }

    static PyObject *t_Date_get__month(t_Date *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getMonth());
      return PyLong_FromLong((long) value);
    }
    static int t_Date_set__month(t_Date *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setMonth(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "month", arg);
      return -1;
    }

    static PyObject *t_Date_get__seconds(t_Date *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getSeconds());
      return PyLong_FromLong((long) value);
    }
    static int t_Date_set__seconds(t_Date *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setSeconds(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "seconds", arg);
      return -1;
    }

    static PyObject *t_Date_get__time(t_Date *self, void *data)
    {
      jlong value;
      OBJ_CALL(value = self->object.getTime());
      return PyLong_FromLongLong((PY_LONG_LONG) value);
    }
    static int t_Date_set__time(t_Date *self, PyObject *arg, void *data)
    {
      {
        jlong value;
        if (!parseArg(arg, "J", &value))
        {
          INT_CALL(self->object.setTime(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "time", arg);
      return -1;
    }

    static PyObject *t_Date_get__timezoneOffset(t_Date *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getTimezoneOffset());
      return PyLong_FromLong((long) value);
    }

    static PyObject *t_Date_get__year(t_Date *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getYear());
      return PyLong_FromLong((long) value);
    }
    static int t_Date_set__year(t_Date *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setYear(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "year", arg);
      return -1;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/ExecutionException.h"
#include "java/lang/String.h"
#include "java/lang/Throwable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *ExecutionException::class$ = NULL;
      jmethodID *ExecutionException::mids$ = NULL;
      bool ExecutionException::live$ = false;

      jclass ExecutionException::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/ExecutionException");

          mids$ = new jmethodID[max_mid];
          mids$[mid_init$_471cfbdb800444a7] = env->getMethodID(cls, "<init>", "(Ljava/lang/Throwable;)V");
          mids$[mid_init$_2e9d196dc293ffe6] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/Throwable;)V");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ExecutionException::ExecutionException(const ::java::lang::Throwable & a0) : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_471cfbdb800444a7, a0.this$)) {}

      ExecutionException::ExecutionException(const ::java::lang::String & a0, const ::java::lang::Throwable & a1) : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_2e9d196dc293ffe6, a0.this$, a1.this$)) {}
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_ExecutionException_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ExecutionException_instance_(PyTypeObject *type, PyObject *arg);
      static int t_ExecutionException_init_(t_ExecutionException *self, PyObject *args, PyObject *kwds);

      static PyMethodDef t_ExecutionException__methods_[] = {
        DECLARE_METHOD(t_ExecutionException, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ExecutionException, instance_, METH_O | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(ExecutionException)[] = {
        { Py_tp_methods, t_ExecutionException__methods_ },
        { Py_tp_init, (void *) t_ExecutionException_init_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(ExecutionException)[] = {
        &PY_TYPE_DEF(::java::lang::Exception),
        NULL
      };

      DEFINE_TYPE(ExecutionException, t_ExecutionException, ExecutionException);

      void t_ExecutionException::install(PyObject *module)
      {
        installType(&PY_TYPE(ExecutionException), &PY_TYPE_DEF(ExecutionException), module, "ExecutionException", 0);
      }

      void t_ExecutionException::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(ExecutionException), "class_", make_descriptor(ExecutionException::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ExecutionException), "wrapfn_", make_descriptor(t_ExecutionException::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ExecutionException), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_ExecutionException_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, ExecutionException::initializeClass, 1)))
          return NULL;
        return t_ExecutionException::wrap_Object(ExecutionException(((t_ExecutionException *) arg)->object.this$));
      }
      static PyObject *t_ExecutionException_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, ExecutionException::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static int t_ExecutionException_init_(t_ExecutionException *self, PyObject *args, PyObject *kwds)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 1:
          {
            ::java::lang::Throwable a0((jobject) NULL);
            ExecutionException object((jobject) NULL);

            if (!parseArgs(args, "k", ::java::lang::Throwable::initializeClass, &a0))
            {
              INT_CALL(object = ExecutionException(a0));
              self->object = object;
              break;
            }
          }
          goto err;
         case 2:
          {
            ::java::lang::String a0((jobject) NULL);
            ::java::lang::Throwable a1((jobject) NULL);
            ExecutionException object((jobject) NULL);

            if (!parseArgs(args, "sk", ::java::lang::Throwable::initializeClass, &a0, &a1))
            {
              INT_CALL(object = ExecutionException(a0, a1));
              self->object = object;
              break;
            }
          }
         default:
         err:
          PyErr_SetArgsError((PyObject *) self, "__init__", args);
          return -1;
        }

        return 0;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/LongBinaryOperator.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *LongBinaryOperator::class$ = NULL;
      jmethodID *LongBinaryOperator::mids$ = NULL;
      bool LongBinaryOperator::live$ = false;

      jclass LongBinaryOperator::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/LongBinaryOperator");

          mids$ = new jmethodID[max_mid];
          mids$[mid_applyAsLong_3f3333a84e3e6855] = env->getMethodID(cls, "applyAsLong", "(JJ)J");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jlong LongBinaryOperator::applyAsLong(jlong a0, jlong a1) const
      {
        return env->callLongMethod(this$, mids$[mid_applyAsLong_3f3333a84e3e6855], a0, a1);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_LongBinaryOperator_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_LongBinaryOperator_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_LongBinaryOperator_applyAsLong(t_LongBinaryOperator *self, PyObject *args);

      static PyMethodDef t_LongBinaryOperator__methods_[] = {
        DECLARE_METHOD(t_LongBinaryOperator, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_LongBinaryOperator, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_LongBinaryOperator, applyAsLong, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(LongBinaryOperator)[] = {
        { Py_tp_methods, t_LongBinaryOperator__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(LongBinaryOperator)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(LongBinaryOperator, t_LongBinaryOperator, LongBinaryOperator);

      void t_LongBinaryOperator::install(PyObject *module)
      {
        installType(&PY_TYPE(LongBinaryOperator), &PY_TYPE_DEF(LongBinaryOperator), module, "LongBinaryOperator", 0);
      }

      void t_LongBinaryOperator::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(LongBinaryOperator), "class_", make_descriptor(LongBinaryOperator::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(LongBinaryOperator), "wrapfn_", make_descriptor(t_LongBinaryOperator::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(LongBinaryOperator), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_LongBinaryOperator_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, LongBinaryOperator::initializeClass, 1)))
          return NULL;
        return t_LongBinaryOperator::wrap_Object(LongBinaryOperator(((t_LongBinaryOperator *) arg)->object.this$));
      }
      static PyObject *t_LongBinaryOperator_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, LongBinaryOperator::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_LongBinaryOperator_applyAsLong(t_LongBinaryOperator *self, PyObject *args)
      {
        jlong a0;
        jlong a1;
        jlong result;

        if (!parseArgs(args, "JJ", &a0, &a1))
        {
          OBJ_CALL(result = self->object.applyAsLong(a0, a1));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsLong", args);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/AbstractList.h"
#include "java/util/Collection.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/ListIterator.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *AbstractList::class$ = NULL;
    jmethodID *AbstractList::mids$ = NULL;
    bool AbstractList::live$ = false;

    jclass AbstractList::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/AbstractList");

        mids$ = new jmethodID[max_mid];
        mids$[mid_add_8b72f2dcdde6fd1d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)Z");
        mids$[mid_add_cf6732d7dfcfc293] = env->getMethodID(cls, "add", "(ILjava/lang/Object;)V");
        mids$[mid_addAll_8980636bfaaa897b] = env->getMethodID(cls, "addAll", "(ILjava/util/Collection;)Z");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_get_b15c79acb15c2870] = env->getMethodID(cls, "get", "(I)Ljava/lang/Object;");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_indexOf_5a4805a36cf611e7] = env->getMethodID(cls, "indexOf", "(Ljava/lang/Object;)I");
        mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
        mids$[mid_lastIndexOf_5a4805a36cf611e7] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/Object;)I");
        mids$[mid_listIterator_78bda7a3d01214c3] = env->getMethodID(cls, "listIterator", "()Ljava/util/ListIterator;");
        mids$[mid_listIterator_8204cc66da390272] = env->getMethodID(cls, "listIterator", "(I)Ljava/util/ListIterator;");
        mids$[mid_remove_b15c79acb15c2870] = env->getMethodID(cls, "remove", "(I)Ljava/lang/Object;");
        mids$[mid_set_55e2638f354bbf61] = env->getMethodID(cls, "set", "(ILjava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_subList_e1795bf76fe1346f] = env->getMethodID(cls, "subList", "(II)Ljava/util/List;");
        mids$[mid_removeRange_438c62480c481c65] = env->getMethodID(cls, "removeRange", "(II)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jboolean AbstractList::add(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_add_8b72f2dcdde6fd1d], a0.this$);
    }

    void AbstractList::add(jint a0, const ::java::lang::Object & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_add_cf6732d7dfcfc293], a0, a1.this$);
    }

    jboolean AbstractList::addAll(jint a0, const ::java::util::Collection & a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_8980636bfaaa897b], a0, a1.this$);
    }

    void AbstractList::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    jboolean AbstractList::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object AbstractList::get(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_b15c79acb15c2870], a0));
    }

    jint AbstractList::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jint AbstractList::indexOf(const ::java::lang::Object & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_5a4805a36cf611e7], a0.this$);
    }

    ::java::util::Iterator AbstractList::iterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
    }

    jint AbstractList::lastIndexOf(const ::java::lang::Object & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_5a4805a36cf611e7], a0.this$);
    }

    ::java::util::ListIterator AbstractList::listIterator() const
    {
      return ::java::util::ListIterator(env->callObjectMethod(this$, mids$[mid_listIterator_78bda7a3d01214c3]));
    }

    ::java::util::ListIterator AbstractList::listIterator(jint a0) const
    {
      return ::java::util::ListIterator(env->callObjectMethod(this$, mids$[mid_listIterator_8204cc66da390272], a0));
    }

    ::java::lang::Object AbstractList::remove(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_b15c79acb15c2870], a0));
    }

    ::java::lang::Object AbstractList::set(jint a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_set_55e2638f354bbf61], a0, a1.this$));
    }

    ::java::util::List AbstractList::subList(jint a0, jint a1) const
    {
      return ::java::util::List(env->callObjectMethod(this$, mids$[mid_subList_e1795bf76fe1346f], a0, a1));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_AbstractList_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_AbstractList_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_AbstractList_of_(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_add(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_addAll(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_clear(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_equals(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_get(t_AbstractList *self, PyObject *arg);
    static PyObject *t_AbstractList_hashCode(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_indexOf(t_AbstractList *self, PyObject *arg);
    static PyObject *t_AbstractList_iterator(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_lastIndexOf(t_AbstractList *self, PyObject *arg);
    static PyObject *t_AbstractList_listIterator(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_remove(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_set(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_subList(t_AbstractList *self, PyObject *args);
    static PyObject *t_AbstractList_get__parameters_(t_AbstractList *self, void *data);
    static PyGetSetDef t_AbstractList__fields_[] = {
      DECLARE_GET_FIELD(t_AbstractList, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_AbstractList__methods_[] = {
      DECLARE_METHOD(t_AbstractList, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_AbstractList, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_AbstractList, of_, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, add, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, addAll, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, clear, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, equals, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, get, METH_O),
      DECLARE_METHOD(t_AbstractList, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, indexOf, METH_O),
      DECLARE_METHOD(t_AbstractList, iterator, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, lastIndexOf, METH_O),
      DECLARE_METHOD(t_AbstractList, listIterator, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, remove, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, set, METH_VARARGS),
      DECLARE_METHOD(t_AbstractList, subList, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };
    static PyObject *t_AbstractList_get_seq_(t_AbstractList *self, int n);

    static PyType_Slot PY_TYPE_SLOTS(AbstractList)[] = {
      { Py_tp_methods, t_AbstractList__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_AbstractList__fields_ },
      { Py_tp_iter, (void *) ((PyObject *(*)(t_AbstractList *)) get_generic_iterator< t_AbstractList >) },
      { Py_tp_iternext, (void *) 0 },
      { Py_sq_item, (void *) t_AbstractList_get_seq_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(AbstractList)[] = {
      &PY_TYPE_DEF(::java::util::AbstractCollection),
      NULL
    };

    DEFINE_TYPE(AbstractList, t_AbstractList, AbstractList);
    PyObject *t_AbstractList::wrap_Object(const AbstractList& object, PyTypeObject *p0)
    {
      PyObject *obj = t_AbstractList::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_AbstractList *self = (t_AbstractList *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_AbstractList::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_AbstractList::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_AbstractList *self = (t_AbstractList *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_AbstractList::install(PyObject *module)
    {
      installType(&PY_TYPE(AbstractList), &PY_TYPE_DEF(AbstractList), module, "AbstractList", 0);
    }

    void t_AbstractList::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractList), "class_", make_descriptor(AbstractList::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractList), "wrapfn_", make_descriptor(t_AbstractList::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractList), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_AbstractList_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, AbstractList::initializeClass, 1)))
        return NULL;
      return t_AbstractList::wrap_Object(AbstractList(((t_AbstractList *) arg)->object.this$));
    }
    static PyObject *t_AbstractList_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, AbstractList::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_AbstractList_of_(t_AbstractList *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_AbstractList_add(t_AbstractList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "O", self->parameters[0], &a0))
          {
            OBJ_CALL(result = self->object.add(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          ::java::lang::Object a1((jobject) NULL);

          if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(self->object.add(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(AbstractList), (PyObject *) self, "add", args, 2);
    }

    static PyObject *t_AbstractList_addAll(t_AbstractList *self, PyObject *args)
    {
      jint a0;
      ::java::util::Collection a1((jobject) NULL);
      PyTypeObject **p1;
      jboolean result;

      if (!parseArgs(args, "IK", ::java::util::Collection::initializeClass, &a0, &a1, &p1, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.addAll(a0, a1));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(AbstractList), (PyObject *) self, "addAll", args, 2);
    }

    static PyObject *t_AbstractList_clear(t_AbstractList *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.clear());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(AbstractList), (PyObject *) self, "clear", args, 2);
    }

    static PyObject *t_AbstractList_equals(t_AbstractList *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(AbstractList), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_AbstractList_get(t_AbstractList *self, PyObject *arg)
    {
      jint a0;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "get", arg);
      return NULL;
    }

    static PyObject *t_AbstractList_hashCode(t_AbstractList *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(AbstractList), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_AbstractList_indexOf(t_AbstractList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jint result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.indexOf(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "indexOf", arg);
      return NULL;
    }

    static PyObject *t_AbstractList_iterator(t_AbstractList *self, PyObject *args)
    {
      ::java::util::Iterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.iterator());
        return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(AbstractList), (PyObject *) self, "iterator", args, 2);
    }

    static PyObject *t_AbstractList_lastIndexOf(t_AbstractList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jint result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.lastIndexOf(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "lastIndexOf", arg);
      return NULL;
    }

    static PyObject *t_AbstractList_listIterator(t_AbstractList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::util::ListIterator result((jobject) NULL);
          OBJ_CALL(result = self->object.listIterator());
          return ::java::util::t_ListIterator::wrap_Object(result, self->parameters[0]);
        }
        break;
       case 1:
        {
          jint a0;
          ::java::util::ListIterator result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.listIterator(a0));
            return ::java::util::t_ListIterator::wrap_Object(result, self->parameters[0]);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "listIterator", args);
      return NULL;
    }

    static PyObject *t_AbstractList_remove(t_AbstractList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.remove(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(AbstractList), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_AbstractList_set(t_AbstractList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
      {
        OBJ_CALL(result = self->object.set(a0, a1));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "set", args);
      return NULL;
    }

    static PyObject *t_AbstractList_subList(t_AbstractList *self, PyObject *args)
    {
      jint a0;
      jint a1;
      ::java::util::List result((jobject) NULL);

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.subList(a0, a1));
        return ::java::util::t_List::wrap_Object(result, self->parameters[0]);
      }

      PyErr_SetArgsError((PyObject *) self, "subList", args);
      return NULL;
    }
    static PyObject *t_AbstractList_get__parameters_(t_AbstractList *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_AbstractList_get_seq_(t_AbstractList *self, int n)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.get((jint) n));
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/TimeoutException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *TimeoutException::class$ = NULL;
      jmethodID *TimeoutException::mids$ = NULL;
      bool TimeoutException::live$ = false;

      jclass TimeoutException::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/TimeoutException");

          mids$ = new jmethodID[max_mid];
          mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
          mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      TimeoutException::TimeoutException() : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

      TimeoutException::TimeoutException(const ::java::lang::String & a0) : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_TimeoutException_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_TimeoutException_instance_(PyTypeObject *type, PyObject *arg);
      static int t_TimeoutException_init_(t_TimeoutException *self, PyObject *args, PyObject *kwds);

      static PyMethodDef t_TimeoutException__methods_[] = {
        DECLARE_METHOD(t_TimeoutException, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_TimeoutException, instance_, METH_O | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(TimeoutException)[] = {
        { Py_tp_methods, t_TimeoutException__methods_ },
        { Py_tp_init, (void *) t_TimeoutException_init_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(TimeoutException)[] = {
        &PY_TYPE_DEF(::java::lang::Exception),
        NULL
      };

      DEFINE_TYPE(TimeoutException, t_TimeoutException, TimeoutException);

      void t_TimeoutException::install(PyObject *module)
      {
        installType(&PY_TYPE(TimeoutException), &PY_TYPE_DEF(TimeoutException), module, "TimeoutException", 0);
      }

      void t_TimeoutException::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeoutException), "class_", make_descriptor(TimeoutException::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeoutException), "wrapfn_", make_descriptor(t_TimeoutException::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(TimeoutException), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_TimeoutException_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, TimeoutException::initializeClass, 1)))
          return NULL;
        return t_TimeoutException::wrap_Object(TimeoutException(((t_TimeoutException *) arg)->object.this$));
      }
      static PyObject *t_TimeoutException_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, TimeoutException::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static int t_TimeoutException_init_(t_TimeoutException *self, PyObject *args, PyObject *kwds)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            TimeoutException object((jobject) NULL);

            INT_CALL(object = TimeoutException());
            self->object = object;
            break;
          }
         case 1:
          {
            ::java::lang::String a0((jobject) NULL);
            TimeoutException object((jobject) NULL);

            if (!parseArgs(args, "s", &a0))
            {
              INT_CALL(object = TimeoutException(a0));
              self->object = object;
              break;
            }
          }
         default:
          PyErr_SetArgsError((PyObject *) self, "__init__", args);
          return -1;
        }

        return 0;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/ScheduledExecutorService.h"
#include "java/lang/Class.h"
#include "java/util/concurrent/ScheduledFuture.h"
#include "java/lang/Object.h"
#include "java/lang/Runnable.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/Callable.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *ScheduledExecutorService::class$ = NULL;
      jmethodID *ScheduledExecutorService::mids$ = NULL;
      bool ScheduledExecutorService::live$ = false;

      jclass ScheduledExecutorService::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/ScheduledExecutorService");

          mids$ = new jmethodID[max_mid];
          mids$[mid_schedule_b3900e3b48317db9] = env->getMethodID(cls, "schedule", "(Ljava/lang/Runnable;JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture;");
          mids$[mid_schedule_f09a9c1b6ac59872] = env->getMethodID(cls, "schedule", "(Ljava/util/concurrent/Callable;JLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture;");
          mids$[mid_scheduleAtFixedRate_b50689f7b84ca135] = env->getMethodID(cls, "scheduleAtFixedRate", "(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture;");
          mids$[mid_scheduleWithFixedDelay_b50689f7b84ca135] = env->getMethodID(cls, "scheduleWithFixedDelay", "(Ljava/lang/Runnable;JJLjava/util/concurrent/TimeUnit;)Ljava/util/concurrent/ScheduledFuture;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::util::concurrent::ScheduledFuture ScheduledExecutorService::schedule(const ::java::lang::Runnable & a0, jlong a1, const ::java::util::concurrent::TimeUnit & a2) const
      {
        return ::java::util::concurrent::ScheduledFuture(env->callObjectMethod(this$, mids$[mid_schedule_b3900e3b48317db9], a0.this$, a1, a2.this$));
      }

      ::java::util::concurrent::ScheduledFuture ScheduledExecutorService::schedule(const ::java::util::concurrent::Callable & a0, jlong a1, const ::java::util::concurrent::TimeUnit & a2) const
      {
        return ::java::util::concurrent::ScheduledFuture(env->callObjectMethod(this$, mids$[mid_schedule_f09a9c1b6ac59872], a0.this$, a1, a2.this$));
      }

      ::java::util::concurrent::ScheduledFuture ScheduledExecutorService::scheduleAtFixedRate(const ::java::lang::Runnable & a0, jlong a1, jlong a2, const ::java::util::concurrent::TimeUnit & a3) const
      {
        return ::java::util::concurrent::ScheduledFuture(env->callObjectMethod(this$, mids$[mid_scheduleAtFixedRate_b50689f7b84ca135], a0.this$, a1, a2, a3.this$));
      }

      ::java::util::concurrent::ScheduledFuture ScheduledExecutorService::scheduleWithFixedDelay(const ::java::lang::Runnable & a0, jlong a1, jlong a2, const ::java::util::concurrent::TimeUnit & a3) const
      {
        return ::java::util::concurrent::ScheduledFuture(env->callObjectMethod(this$, mids$[mid_scheduleWithFixedDelay_b50689f7b84ca135], a0.this$, a1, a2, a3.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_ScheduledExecutorService_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ScheduledExecutorService_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ScheduledExecutorService_schedule(t_ScheduledExecutorService *self, PyObject *args);
      static PyObject *t_ScheduledExecutorService_scheduleAtFixedRate(t_ScheduledExecutorService *self, PyObject *args);
      static PyObject *t_ScheduledExecutorService_scheduleWithFixedDelay(t_ScheduledExecutorService *self, PyObject *args);

      static PyMethodDef t_ScheduledExecutorService__methods_[] = {
        DECLARE_METHOD(t_ScheduledExecutorService, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ScheduledExecutorService, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ScheduledExecutorService, schedule, METH_VARARGS),
        DECLARE_METHOD(t_ScheduledExecutorService, scheduleAtFixedRate, METH_VARARGS),
        DECLARE_METHOD(t_ScheduledExecutorService, scheduleWithFixedDelay, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(ScheduledExecutorService)[] = {
        { Py_tp_methods, t_ScheduledExecutorService__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(ScheduledExecutorService)[] = {
        &PY_TYPE_DEF(::java::util::concurrent::ExecutorService),
        NULL
      };

      DEFINE_TYPE(ScheduledExecutorService, t_ScheduledExecutorService, ScheduledExecutorService);

      void t_ScheduledExecutorService::install(PyObject *module)
      {
        installType(&PY_TYPE(ScheduledExecutorService), &PY_TYPE_DEF(ScheduledExecutorService), module, "ScheduledExecutorService", 0);
      }

      void t_ScheduledExecutorService::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(ScheduledExecutorService), "class_", make_descriptor(ScheduledExecutorService::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ScheduledExecutorService), "wrapfn_", make_descriptor(t_ScheduledExecutorService::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ScheduledExecutorService), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_ScheduledExecutorService_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, ScheduledExecutorService::initializeClass, 1)))
          return NULL;
        return t_ScheduledExecutorService::wrap_Object(ScheduledExecutorService(((t_ScheduledExecutorService *) arg)->object.this$));
      }
      static PyObject *t_ScheduledExecutorService_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, ScheduledExecutorService::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_ScheduledExecutorService_schedule(t_ScheduledExecutorService *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 3:
          {
            ::java::lang::Runnable a0((jobject) NULL);
            jlong a1;
            ::java::util::concurrent::TimeUnit a2((jobject) NULL);
            PyTypeObject **p2;
            ::java::util::concurrent::ScheduledFuture result((jobject) NULL);

            if (!parseArgs(args, "kJK", ::java::lang::Runnable::initializeClass, ::java::util::concurrent::TimeUnit::initializeClass, &a0, &a1, &a2, &p2, ::java::util::concurrent::t_TimeUnit::parameters_))
            {
              OBJ_CALL(result = self->object.schedule(a0, a1, a2));
              return ::java::util::concurrent::t_ScheduledFuture::wrap_Object(result);
            }
          }
          {
            ::java::util::concurrent::Callable a0((jobject) NULL);
            PyTypeObject **p0;
            jlong a1;
            ::java::util::concurrent::TimeUnit a2((jobject) NULL);
            PyTypeObject **p2;
            ::java::util::concurrent::ScheduledFuture result((jobject) NULL);

            if (!parseArgs(args, "KJK", ::java::util::concurrent::Callable::initializeClass, ::java::util::concurrent::TimeUnit::initializeClass, &a0, &p0, ::java::util::concurrent::t_Callable::parameters_, &a1, &a2, &p2, ::java::util::concurrent::t_TimeUnit::parameters_))
            {
              OBJ_CALL(result = self->object.schedule(a0, a1, a2));
              return ::java::util::concurrent::t_ScheduledFuture::wrap_Object(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "schedule", args);
        return NULL;
      }

      static PyObject *t_ScheduledExecutorService_scheduleAtFixedRate(t_ScheduledExecutorService *self, PyObject *args)
      {
        ::java::lang::Runnable a0((jobject) NULL);
        jlong a1;
        jlong a2;
        ::java::util::concurrent::TimeUnit a3((jobject) NULL);
        PyTypeObject **p3;
        ::java::util::concurrent::ScheduledFuture result((jobject) NULL);

        if (!parseArgs(args, "kJJK", ::java::lang::Runnable::initializeClass, ::java::util::concurrent::TimeUnit::initializeClass, &a0, &a1, &a2, &a3, &p3, ::java::util::concurrent::t_TimeUnit::parameters_))
        {
          OBJ_CALL(result = self->object.scheduleAtFixedRate(a0, a1, a2, a3));
          return ::java::util::concurrent::t_ScheduledFuture::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "scheduleAtFixedRate", args);
        return NULL;
      }

      static PyObject *t_ScheduledExecutorService_scheduleWithFixedDelay(t_ScheduledExecutorService *self, PyObject *args)
      {
        ::java::lang::Runnable a0((jobject) NULL);
        jlong a1;
        jlong a2;
        ::java::util::concurrent::TimeUnit a3((jobject) NULL);
        PyTypeObject **p3;
        ::java::util::concurrent::ScheduledFuture result((jobject) NULL);

        if (!parseArgs(args, "kJJK", ::java::lang::Runnable::initializeClass, ::java::util::concurrent::TimeUnit::initializeClass, &a0, &a1, &a2, &a3, &p3, ::java::util::concurrent::t_TimeUnit::parameters_))
        {
          OBJ_CALL(result = self->object.scheduleWithFixedDelay(a0, a1, a2, a3));
          return ::java::util::concurrent::t_ScheduledFuture::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "scheduleWithFixedDelay", args);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/PrintStream.h"
#include "java/lang/Class.h"
#include "java/io/PrintStream.h"
#include "java/io/FileNotFoundException.h"
#include "java/lang/Object.h"
#include "java/util/Locale.h"
#include "java/lang/CharSequence.h"
#include "java/io/OutputStream.h"
#include "java/lang/String.h"
#include "java/io/File.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/Appendable.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *PrintStream::class$ = NULL;
    jmethodID *PrintStream::mids$ = NULL;
    bool PrintStream::live$ = false;

    jclass PrintStream::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/PrintStream");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_7bd45e585db89e9f] = env->getMethodID(cls, "<init>", "(Ljava/io/File;)V");
        mids$[mid_init$_02fcdace254a9894] = env->getMethodID(cls, "<init>", "(Ljava/io/OutputStream;)V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_c80751a79d34c011] = env->getMethodID(cls, "<init>", "(Ljava/io/File;Ljava/lang/String;)V");
        mids$[mid_init$_15b72f6a44ff93f2] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");
        mids$[mid_init$_539208f3c661c2fc] = env->getMethodID(cls, "<init>", "(Ljava/io/OutputStream;Z)V");
        mids$[mid_init$_ce122617279d7d15] = env->getMethodID(cls, "<init>", "(Ljava/io/OutputStream;ZLjava/lang/String;)V");
        mids$[mid_append_41561e74a5a0a7eb] = env->getMethodID(cls, "append", "(C)Ljava/io/PrintStream;");
        mids$[mid_append_a9bfc1169d417a98] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;)Ljava/io/PrintStream;");
        mids$[mid_append_9c51c53e73f95295] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;II)Ljava/io/PrintStream;");
        mids$[mid_checkError_8454bd5aa23fd11e] = env->getMethodID(cls, "checkError", "()Z");
        mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");
        mids$[mid_flush_f2cc1bce94666404] = env->getMethodID(cls, "flush", "()V");
        mids$[mid_format_7a23191334eb30e9] = env->getMethodID(cls, "format", "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;");
        mids$[mid_format_87af196ad495a463] = env->getMethodID(cls, "format", "(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;");
        mids$[mid_print_82dffe1ba55ed767] = env->getMethodID(cls, "print", "([C)V");
        mids$[mid_print_9fd2eb66a64e6f0f] = env->getMethodID(cls, "print", "(Ljava/lang/String;)V");
        mids$[mid_print_9d72768e8fdce2b7] = env->getMethodID(cls, "print", "(Z)V");
        mids$[mid_print_b227b2c08d18d29e] = env->getMethodID(cls, "print", "(C)V");
        mids$[mid_print_3c435f10a3b1e038] = env->getMethodID(cls, "print", "(D)V");
        mids$[mid_print_8e1d952dd65cdc3a] = env->getMethodID(cls, "print", "(F)V");
        mids$[mid_print_040c4cd0390c5aff] = env->getMethodID(cls, "print", "(I)V");
        mids$[mid_print_d20f626183f72f7d] = env->getMethodID(cls, "print", "(Ljava/lang/Object;)V");
        mids$[mid_print_9c778c9bce6694df] = env->getMethodID(cls, "print", "(J)V");
        mids$[mid_printf_7a23191334eb30e9] = env->getMethodID(cls, "printf", "(Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;");
        mids$[mid_printf_87af196ad495a463] = env->getMethodID(cls, "printf", "(Ljava/util/Locale;Ljava/lang/String;[Ljava/lang/Object;)Ljava/io/PrintStream;");
        mids$[mid_println_f2cc1bce94666404] = env->getMethodID(cls, "println", "()V");
        mids$[mid_println_82dffe1ba55ed767] = env->getMethodID(cls, "println", "([C)V");
        mids$[mid_println_9fd2eb66a64e6f0f] = env->getMethodID(cls, "println", "(Ljava/lang/String;)V");
        mids$[mid_println_9d72768e8fdce2b7] = env->getMethodID(cls, "println", "(Z)V");
        mids$[mid_println_b227b2c08d18d29e] = env->getMethodID(cls, "println", "(C)V");
        mids$[mid_println_3c435f10a3b1e038] = env->getMethodID(cls, "println", "(D)V");
        mids$[mid_println_8e1d952dd65cdc3a] = env->getMethodID(cls, "println", "(F)V");
        mids$[mid_println_040c4cd0390c5aff] = env->getMethodID(cls, "println", "(I)V");
        mids$[mid_println_d20f626183f72f7d] = env->getMethodID(cls, "println", "(Ljava/lang/Object;)V");
        mids$[mid_println_9c778c9bce6694df] = env->getMethodID(cls, "println", "(J)V");
        mids$[mid_write_040c4cd0390c5aff] = env->getMethodID(cls, "write", "(I)V");
        mids$[mid_write_43fdd39c09bb2fad] = env->getMethodID(cls, "write", "([BII)V");
        mids$[mid_setError_f2cc1bce94666404] = env->getMethodID(cls, "setError", "()V");
        mids$[mid_clearError_f2cc1bce94666404] = env->getMethodID(cls, "clearError", "()V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    PrintStream::PrintStream(const ::java::io::File & a0) : ::java::io::FilterOutputStream(env->newObject(initializeClass, &mids$, mid_init$_7bd45e585db89e9f, a0.this$)) {}

    PrintStream::PrintStream(const ::java::io::OutputStream & a0) : ::java::io::FilterOutputStream(env->newObject(initializeClass, &mids$, mid_init$_02fcdace254a9894, a0.this$)) {}

    PrintStream::PrintStream(const ::java::lang::String & a0) : ::java::io::FilterOutputStream(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    PrintStream::PrintStream(const ::java::io::File & a0, const ::java::lang::String & a1) : ::java::io::FilterOutputStream(env->newObject(initializeClass, &mids$, mid_init$_c80751a79d34c011, a0.this$, a1.this$)) {}

    PrintStream::PrintStream(const ::java::lang::String & a0, const ::java::lang::String & a1) : ::java::io::FilterOutputStream(env->newObject(initializeClass, &mids$, mid_init$_15b72f6a44ff93f2, a0.this$, a1.this$)) {}

    PrintStream::PrintStream(const ::java::io::OutputStream & a0, jboolean a1) : ::java::io::FilterOutputStream(env->newObject(initializeClass, &mids$, mid_init$_539208f3c661c2fc, a0.this$, a1)) {}

    PrintStream::PrintStream(const ::java::io::OutputStream & a0, jboolean a1, const ::java::lang::String & a2) : ::java::io::FilterOutputStream(env->newObject(initializeClass, &mids$, mid_init$_ce122617279d7d15, a0.this$, a1, a2.this$)) {}

    PrintStream PrintStream::append(jchar a0) const
    {
      return PrintStream(env->callObjectMethod(this$, mids$[mid_append_41561e74a5a0a7eb], a0));
    }

    PrintStream PrintStream::append(const ::java::lang::CharSequence & a0) const
    {
      return PrintStream(env->callObjectMethod(this$, mids$[mid_append_a9bfc1169d417a98], a0.this$));
    }

    PrintStream PrintStream::append(const ::java::lang::CharSequence & a0, jint a1, jint a2) const
    {
      return PrintStream(env->callObjectMethod(this$, mids$[mid_append_9c51c53e73f95295], a0.this$, a1, a2));
    }

    jboolean PrintStream::checkError() const
    {
      return env->callBooleanMethod(this$, mids$[mid_checkError_8454bd5aa23fd11e]);
    }

    void PrintStream::close() const
    {
      env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
    }

    void PrintStream::flush() const
    {
      env->callVoidMethod(this$, mids$[mid_flush_f2cc1bce94666404]);
    }

    PrintStream PrintStream::format(const ::java::lang::String & a0, const JArray< ::java::lang::Object > & a1) const
    {
      return PrintStream(env->callObjectMethod(this$, mids$[mid_format_7a23191334eb30e9], a0.this$, a1.this$));
    }

    PrintStream PrintStream::format(const ::java::util::Locale & a0, const ::java::lang::String & a1, const JArray< ::java::lang::Object > & a2) const
    {
      return PrintStream(env->callObjectMethod(this$, mids$[mid_format_87af196ad495a463], a0.this$, a1.this$, a2.this$));
    }

    void PrintStream::print(const JArray< jchar > & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_print_82dffe1ba55ed767], a0.this$);
    }

    void PrintStream::print(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_print_9fd2eb66a64e6f0f], a0.this$);
    }

    void PrintStream::print(jboolean a0) const
    {
      env->callVoidMethod(this$, mids$[mid_print_9d72768e8fdce2b7], a0);
    }

    void PrintStream::print(jchar a0) const
    {
      env->callVoidMethod(this$, mids$[mid_print_b227b2c08d18d29e], a0);
    }

    void PrintStream::print(jdouble a0) const
    {
      env->callVoidMethod(this$, mids$[mid_print_3c435f10a3b1e038], a0);
    }

    void PrintStream::print(jfloat a0) const
    {
      env->callVoidMethod(this$, mids$[mid_print_8e1d952dd65cdc3a], a0);
    }

    void PrintStream::print(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_print_040c4cd0390c5aff], a0);
    }

    void PrintStream::print(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_print_d20f626183f72f7d], a0.this$);
    }

    void PrintStream::print(jlong a0) const
    {
      env->callVoidMethod(this$, mids$[mid_print_9c778c9bce6694df], a0);
    }

    PrintStream PrintStream::printf(const ::java::lang::String & a0, const JArray< ::java::lang::Object > & a1) const
    {
      return PrintStream(env->callObjectMethod(this$, mids$[mid_printf_7a23191334eb30e9], a0.this$, a1.this$));
    }

    PrintStream PrintStream::printf(const ::java::util::Locale & a0, const ::java::lang::String & a1, const JArray< ::java::lang::Object > & a2) const
    {
      return PrintStream(env->callObjectMethod(this$, mids$[mid_printf_87af196ad495a463], a0.this$, a1.this$, a2.this$));
    }

    void PrintStream::println() const
    {
      env->callVoidMethod(this$, mids$[mid_println_f2cc1bce94666404]);
    }

    void PrintStream::println(const JArray< jchar > & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_println_82dffe1ba55ed767], a0.this$);
    }

    void PrintStream::println(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_println_9fd2eb66a64e6f0f], a0.this$);
    }

    void PrintStream::println(jboolean a0) const
    {
      env->callVoidMethod(this$, mids$[mid_println_9d72768e8fdce2b7], a0);
    }

    void PrintStream::println(jchar a0) const
    {
      env->callVoidMethod(this$, mids$[mid_println_b227b2c08d18d29e], a0);
    }

    void PrintStream::println(jdouble a0) const
    {
      env->callVoidMethod(this$, mids$[mid_println_3c435f10a3b1e038], a0);
    }

    void PrintStream::println(jfloat a0) const
    {
      env->callVoidMethod(this$, mids$[mid_println_8e1d952dd65cdc3a], a0);
    }

    void PrintStream::println(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_println_040c4cd0390c5aff], a0);
    }

    void PrintStream::println(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_println_d20f626183f72f7d], a0.this$);
    }

    void PrintStream::println(jlong a0) const
    {
      env->callVoidMethod(this$, mids$[mid_println_9c778c9bce6694df], a0);
    }

    void PrintStream::write(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_write_040c4cd0390c5aff], a0);
    }

    void PrintStream::write(const JArray< jbyte > & a0, jint a1, jint a2) const
    {
      env->callVoidMethod(this$, mids$[mid_write_43fdd39c09bb2fad], a0.this$, a1, a2);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_PrintStream_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_PrintStream_instance_(PyTypeObject *type, PyObject *arg);
    static int t_PrintStream_init_(t_PrintStream *self, PyObject *args, PyObject *kwds);
    static PyObject *t_PrintStream_append(t_PrintStream *self, PyObject *args);
    static PyObject *t_PrintStream_checkError(t_PrintStream *self);
    static PyObject *t_PrintStream_close(t_PrintStream *self, PyObject *args);
    static PyObject *t_PrintStream_flush(t_PrintStream *self, PyObject *args);
    static PyObject *t_PrintStream_format(t_PrintStream *self, PyObject *args);
    static PyObject *t_PrintStream_print(t_PrintStream *self, PyObject *args);
    static PyObject *t_PrintStream_printf(t_PrintStream *self, PyObject *args);
    static PyObject *t_PrintStream_println(t_PrintStream *self, PyObject *args);
    static PyObject *t_PrintStream_write(t_PrintStream *self, PyObject *args);

    static PyMethodDef t_PrintStream__methods_[] = {
      DECLARE_METHOD(t_PrintStream, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_PrintStream, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_PrintStream, append, METH_VARARGS),
      DECLARE_METHOD(t_PrintStream, checkError, METH_NOARGS),
      DECLARE_METHOD(t_PrintStream, close, METH_VARARGS),
      DECLARE_METHOD(t_PrintStream, flush, METH_VARARGS),
      DECLARE_METHOD(t_PrintStream, format, METH_VARARGS),
      DECLARE_METHOD(t_PrintStream, print, METH_VARARGS),
      DECLARE_METHOD(t_PrintStream, printf, METH_VARARGS),
      DECLARE_METHOD(t_PrintStream, println, METH_VARARGS),
      DECLARE_METHOD(t_PrintStream, write, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(PrintStream)[] = {
      { Py_tp_methods, t_PrintStream__methods_ },
      { Py_tp_init, (void *) t_PrintStream_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(PrintStream)[] = {
      &PY_TYPE_DEF(::java::io::FilterOutputStream),
      NULL
    };

    DEFINE_TYPE(PrintStream, t_PrintStream, PrintStream);

    void t_PrintStream::install(PyObject *module)
    {
      installType(&PY_TYPE(PrintStream), &PY_TYPE_DEF(PrintStream), module, "PrintStream", 0);
    }

    void t_PrintStream::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(PrintStream), "class_", make_descriptor(PrintStream::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(PrintStream), "wrapfn_", make_descriptor(t_PrintStream::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(PrintStream), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_PrintStream_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, PrintStream::initializeClass, 1)))
        return NULL;
      return t_PrintStream::wrap_Object(PrintStream(((t_PrintStream *) arg)->object.this$));
    }
    static PyObject *t_PrintStream_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, PrintStream::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_PrintStream_init_(t_PrintStream *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::io::File a0((jobject) NULL);
          PrintStream object((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::File::initializeClass, &a0))
          {
            INT_CALL(object = PrintStream(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::io::OutputStream a0((jobject) NULL);
          PrintStream object((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::OutputStream::initializeClass, &a0))
          {
            INT_CALL(object = PrintStream(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);
          PrintStream object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = PrintStream(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::io::File a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          PrintStream object((jobject) NULL);

          if (!parseArgs(args, "ks", ::java::io::File::initializeClass, &a0, &a1))
          {
            INT_CALL(object = PrintStream(a0, a1));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          PrintStream object((jobject) NULL);

          if (!parseArgs(args, "ss", &a0, &a1))
          {
            INT_CALL(object = PrintStream(a0, a1));
            self->object = object;
            break;
          }
        }
        {
          ::java::io::OutputStream a0((jobject) NULL);
          jboolean a1;
          PrintStream object((jobject) NULL);

          if (!parseArgs(args, "kZ", ::java::io::OutputStream::initializeClass, &a0, &a1))
          {
            INT_CALL(object = PrintStream(a0, a1));
            self->object = object;
            break;
          }
        }
        goto err;
       case 3:
        {
          ::java::io::OutputStream a0((jobject) NULL);
          jboolean a1;
          ::java::lang::String a2((jobject) NULL);
          PrintStream object((jobject) NULL);

          if (!parseArgs(args, "kZs", ::java::io::OutputStream::initializeClass, &a0, &a1, &a2))
          {
            INT_CALL(object = PrintStream(a0, a1, a2));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_PrintStream_append(t_PrintStream *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jchar a0;
          PrintStream result((jobject) NULL);

          if (!parseArgs(args, "C", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_PrintStream::wrap_Object(result);
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          PrintStream result((jobject) NULL);

          if (!parseArgs(args, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_PrintStream::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          jint a1;
          jint a2;
          PrintStream result((jobject) NULL);

          if (!parseArgs(args, "OII", ::java::lang::PY_TYPE(CharSequence), &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.append(a0, a1, a2));
            return t_PrintStream::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "append", args);
      return NULL;
    }

    static PyObject *t_PrintStream_checkError(t_PrintStream *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.checkError());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_PrintStream_close(t_PrintStream *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.close());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(PrintStream), (PyObject *) self, "close", args, 2);
    }

    static PyObject *t_PrintStream_flush(t_PrintStream *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.flush());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(PrintStream), (PyObject *) self, "flush", args, 2);
    }

    static PyObject *t_PrintStream_format(t_PrintStream *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          JArray< ::java::lang::Object > a1((jobject) NULL);
          PrintStream result((jobject) NULL);

          if (!parseArgs(args, "s[o", &a0, &a1))
          {
            OBJ_CALL(result = self->object.format(a0, a1));
            return t_PrintStream::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          ::java::util::Locale a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          JArray< ::java::lang::Object > a2((jobject) NULL);
          PrintStream result((jobject) NULL);

          if (!parseArgs(args, "ks[o", ::java::util::Locale::initializeClass, &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.format(a0, a1, a2));
            return t_PrintStream::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "format", args);
      return NULL;
    }

    static PyObject *t_PrintStream_print(t_PrintStream *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          JArray< jchar > a0((jobject) NULL);

          if (!parseArgs(args, "[C", &a0))
          {
            OBJ_CALL(self->object.print(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(self->object.print(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jboolean a0;

          if (!parseArgs(args, "Z", &a0))
          {
            OBJ_CALL(self->object.print(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jchar a0;

          if (!parseArgs(args, "C", &a0))
          {
            OBJ_CALL(self->object.print(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jdouble a0;

          if (!parseArgs(args, "D", &a0))
          {
            OBJ_CALL(self->object.print(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jfloat a0;

          if (!parseArgs(args, "F", &a0))
          {
            OBJ_CALL(self->object.print(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.print(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::lang::Object a0((jobject) NULL);

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(self->object.print(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jlong a0;

          if (!parseArgs(args, "J", &a0))
          {
            OBJ_CALL(self->object.print(a0));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "print", args);
      return NULL;
    }

    static PyObject *t_PrintStream_printf(t_PrintStream *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          JArray< ::java::lang::Object > a1((jobject) NULL);
          PrintStream result((jobject) NULL);

          if (!parseArgs(args, "s[o", &a0, &a1))
          {
            OBJ_CALL(result = self->object.printf(a0, a1));
            return t_PrintStream::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          ::java::util::Locale a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          JArray< ::java::lang::Object > a2((jobject) NULL);
          PrintStream result((jobject) NULL);

          if (!parseArgs(args, "ks[o", ::java::util::Locale::initializeClass, &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.printf(a0, a1, a2));
            return t_PrintStream::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "printf", args);
      return NULL;
    }

    static PyObject *t_PrintStream_println(t_PrintStream *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          OBJ_CALL(self->object.println());
          Py_RETURN_NONE;
        }
        break;
       case 1:
        {
          JArray< jchar > a0((jobject) NULL);

          if (!parseArgs(args, "[C", &a0))
          {
            OBJ_CALL(self->object.println(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(self->object.println(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jboolean a0;

          if (!parseArgs(args, "Z", &a0))
          {
            OBJ_CALL(self->object.println(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jchar a0;

          if (!parseArgs(args, "C", &a0))
          {
            OBJ_CALL(self->object.println(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jdouble a0;

          if (!parseArgs(args, "D", &a0))
          {
            OBJ_CALL(self->object.println(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jfloat a0;

          if (!parseArgs(args, "F", &a0))
          {
            OBJ_CALL(self->object.println(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.println(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::lang::Object a0((jobject) NULL);

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(self->object.println(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jlong a0;

          if (!parseArgs(args, "J", &a0))
          {
            OBJ_CALL(self->object.println(a0));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "println", args);
      return NULL;
    }

    static PyObject *t_PrintStream_write(t_PrintStream *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.write(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          JArray< jbyte > a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "[BII", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.write(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(PrintStream), (PyObject *) self, "write", args, 2);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/Future.h"
#include "java/lang/Class.h"
#include "java/util/concurrent/ExecutionException.h"
#include "java/util/concurrent/TimeoutException.h"
#include "java/lang/InterruptedException.h"
#include "java/util/concurrent/TimeUnit.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *Future::class$ = NULL;
      jmethodID *Future::mids$ = NULL;
      bool Future::live$ = false;

      jclass Future::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/Future");

          mids$ = new jmethodID[max_mid];
          mids$[mid_cancel_e84cf59305ee1535] = env->getMethodID(cls, "cancel", "(Z)Z");
          mids$[mid_get_d6bcd06f3102c4d9] = env->getMethodID(cls, "get", "()Ljava/lang/Object;");
          mids$[mid_get_273bb3c7d4b13a73] = env->getMethodID(cls, "get", "(JLjava/util/concurrent/TimeUnit;)Ljava/lang/Object;");
          mids$[mid_isCancelled_8454bd5aa23fd11e] = env->getMethodID(cls, "isCancelled", "()Z");
          mids$[mid_isDone_8454bd5aa23fd11e] = env->getMethodID(cls, "isDone", "()Z");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jboolean Future::cancel(jboolean a0) const
      {
        return env->callBooleanMethod(this$, mids$[mid_cancel_e84cf59305ee1535], a0);
      }

      ::java::lang::Object Future::get() const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_d6bcd06f3102c4d9]));
      }

      ::java::lang::Object Future::get(jlong a0, const ::java::util::concurrent::TimeUnit & a1) const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_273bb3c7d4b13a73], a0, a1.this$));
      }

      jboolean Future::isCancelled() const
      {
        return env->callBooleanMethod(this$, mids$[mid_isCancelled_8454bd5aa23fd11e]);
      }

      jboolean Future::isDone() const
      {
        return env->callBooleanMethod(this$, mids$[mid_isDone_8454bd5aa23fd11e]);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_Future_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Future_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Future_of_(t_Future *self, PyObject *args);
      static PyObject *t_Future_cancel(t_Future *self, PyObject *arg);
      static PyObject *t_Future_get(t_Future *self, PyObject *args);
      static PyObject *t_Future_isCancelled(t_Future *self);
      static PyObject *t_Future_isDone(t_Future *self);
      static PyObject *t_Future_get__cancelled(t_Future *self, void *data);
      static PyObject *t_Future_get__done(t_Future *self, void *data);
      static PyObject *t_Future_get__parameters_(t_Future *self, void *data);
      static PyGetSetDef t_Future__fields_[] = {
        DECLARE_GET_FIELD(t_Future, cancelled),
        DECLARE_GET_FIELD(t_Future, done),
        DECLARE_GET_FIELD(t_Future, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_Future__methods_[] = {
        DECLARE_METHOD(t_Future, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Future, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Future, of_, METH_VARARGS),
        DECLARE_METHOD(t_Future, cancel, METH_O),
        DECLARE_METHOD(t_Future, get, METH_VARARGS),
        DECLARE_METHOD(t_Future, isCancelled, METH_NOARGS),
        DECLARE_METHOD(t_Future, isDone, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Future)[] = {
        { Py_tp_methods, t_Future__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_Future__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Future)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Future, t_Future, Future);
      PyObject *t_Future::wrap_Object(const Future& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Future::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Future *self = (t_Future *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_Future::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Future::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Future *self = (t_Future *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_Future::install(PyObject *module)
      {
        installType(&PY_TYPE(Future), &PY_TYPE_DEF(Future), module, "Future", 0);
      }

      void t_Future::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Future), "class_", make_descriptor(Future::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Future), "wrapfn_", make_descriptor(t_Future::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Future), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Future_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Future::initializeClass, 1)))
          return NULL;
        return t_Future::wrap_Object(Future(((t_Future *) arg)->object.this$));
      }
      static PyObject *t_Future_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Future::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Future_of_(t_Future *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_Future_cancel(t_Future *self, PyObject *arg)
      {
        jboolean a0;
        jboolean result;

        if (!parseArg(arg, "Z", &a0))
        {
          OBJ_CALL(result = self->object.cancel(a0));
          Py_RETURN_BOOL(result);
        }

        PyErr_SetArgsError((PyObject *) self, "cancel", arg);
        return NULL;
      }

      static PyObject *t_Future_get(t_Future *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            ::java::lang::Object result((jobject) NULL);
            OBJ_CALL(result = self->object.get());
            return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
          }
          break;
         case 2:
          {
            jlong a0;
            ::java::util::concurrent::TimeUnit a1((jobject) NULL);
            PyTypeObject **p1;
            ::java::lang::Object result((jobject) NULL);

            if (!parseArgs(args, "JK", ::java::util::concurrent::TimeUnit::initializeClass, &a0, &a1, &p1, ::java::util::concurrent::t_TimeUnit::parameters_))
            {
              OBJ_CALL(result = self->object.get(a0, a1));
              return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "get", args);
        return NULL;
      }

      static PyObject *t_Future_isCancelled(t_Future *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.isCancelled());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_Future_isDone(t_Future *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.isDone());
        Py_RETURN_BOOL(result);
      }
      static PyObject *t_Future_get__parameters_(t_Future *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }

      static PyObject *t_Future_get__cancelled(t_Future *self, void *data)
      {
        jboolean value;
        OBJ_CALL(value = self->object.isCancelled());
        Py_RETURN_BOOL(value);
      }

      static PyObject *t_Future_get__done(t_Future *self, void *data)
      {
        jboolean value;
        OBJ_CALL(value = self->object.isDone());
        Py_RETURN_BOOL(value);
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/ReflectiveOperationException.h"
#include "java/lang/String.h"
#include "java/lang/Throwable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *ReflectiveOperationException::class$ = NULL;
    jmethodID *ReflectiveOperationException::mids$ = NULL;
    bool ReflectiveOperationException::live$ = false;

    jclass ReflectiveOperationException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/ReflectiveOperationException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_471cfbdb800444a7] = env->getMethodID(cls, "<init>", "(Ljava/lang/Throwable;)V");
        mids$[mid_init$_2e9d196dc293ffe6] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/Throwable;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ReflectiveOperationException::ReflectiveOperationException() : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    ReflectiveOperationException::ReflectiveOperationException(const ::java::lang::String & a0) : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    ReflectiveOperationException::ReflectiveOperationException(const ::java::lang::Throwable & a0) : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_471cfbdb800444a7, a0.this$)) {}

    ReflectiveOperationException::ReflectiveOperationException(const ::java::lang::String & a0, const ::java::lang::Throwable & a1) : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_2e9d196dc293ffe6, a0.this$, a1.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_ReflectiveOperationException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ReflectiveOperationException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_ReflectiveOperationException_init_(t_ReflectiveOperationException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_ReflectiveOperationException__methods_[] = {
      DECLARE_METHOD(t_ReflectiveOperationException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ReflectiveOperationException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(ReflectiveOperationException)[] = {
      { Py_tp_methods, t_ReflectiveOperationException__methods_ },
      { Py_tp_init, (void *) t_ReflectiveOperationException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(ReflectiveOperationException)[] = {
      &PY_TYPE_DEF(::java::lang::Exception),
      NULL
    };

    DEFINE_TYPE(ReflectiveOperationException, t_ReflectiveOperationException, ReflectiveOperationException);

    void t_ReflectiveOperationException::install(PyObject *module)
    {
      installType(&PY_TYPE(ReflectiveOperationException), &PY_TYPE_DEF(ReflectiveOperationException), module, "ReflectiveOperationException", 0);
    }

    void t_ReflectiveOperationException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(ReflectiveOperationException), "class_", make_descriptor(ReflectiveOperationException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ReflectiveOperationException), "wrapfn_", make_descriptor(t_ReflectiveOperationException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ReflectiveOperationException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_ReflectiveOperationException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, ReflectiveOperationException::initializeClass, 1)))
        return NULL;
      return t_ReflectiveOperationException::wrap_Object(ReflectiveOperationException(((t_ReflectiveOperationException *) arg)->object.this$));
    }
    static PyObject *t_ReflectiveOperationException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, ReflectiveOperationException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_ReflectiveOperationException_init_(t_ReflectiveOperationException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ReflectiveOperationException object((jobject) NULL);

          INT_CALL(object = ReflectiveOperationException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          ReflectiveOperationException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = ReflectiveOperationException(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::Throwable a0((jobject) NULL);
          ReflectiveOperationException object((jobject) NULL);

          if (!parseArgs(args, "k", ::java::lang::Throwable::initializeClass, &a0))
          {
            INT_CALL(object = ReflectiveOperationException(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::Throwable a1((jobject) NULL);
          ReflectiveOperationException object((jobject) NULL);

          if (!parseArgs(args, "sk", ::java::lang::Throwable::initializeClass, &a0, &a1))
          {
            INT_CALL(object = ReflectiveOperationException(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Queue.h"
#include "java/lang/Object.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Queue::class$ = NULL;
    jmethodID *Queue::mids$ = NULL;
    bool Queue::live$ = false;

    jclass Queue::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Queue");

        mids$ = new jmethodID[max_mid];
        mids$[mid_add_8b72f2dcdde6fd1d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)Z");
        mids$[mid_element_d6bcd06f3102c4d9] = env->getMethodID(cls, "element", "()Ljava/lang/Object;");
        mids$[mid_offer_8b72f2dcdde6fd1d] = env->getMethodID(cls, "offer", "(Ljava/lang/Object;)Z");
        mids$[mid_peek_d6bcd06f3102c4d9] = env->getMethodID(cls, "peek", "()Ljava/lang/Object;");
        mids$[mid_poll_d6bcd06f3102c4d9] = env->getMethodID(cls, "poll", "()Ljava/lang/Object;");
        mids$[mid_remove_d6bcd06f3102c4d9] = env->getMethodID(cls, "remove", "()Ljava/lang/Object;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jboolean Queue::add(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_add_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object Queue::element() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_element_d6bcd06f3102c4d9]));
    }

    jboolean Queue::offer(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_offer_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object Queue::peek() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_peek_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Queue::poll() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_poll_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Queue::remove() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_d6bcd06f3102c4d9]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Queue_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Queue_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Queue_of_(t_Queue *self, PyObject *args);
    static PyObject *t_Queue_add(t_Queue *self, PyObject *args);
    static PyObject *t_Queue_element(t_Queue *self);
    static PyObject *t_Queue_offer(t_Queue *self, PyObject *arg);
    static PyObject *t_Queue_peek(t_Queue *self);
    static PyObject *t_Queue_poll(t_Queue *self);
    static PyObject *t_Queue_remove(t_Queue *self, PyObject *args);
    static PyObject *t_Queue_get__parameters_(t_Queue *self, void *data);
    static PyGetSetDef t_Queue__fields_[] = {
      DECLARE_GET_FIELD(t_Queue, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Queue__methods_[] = {
      DECLARE_METHOD(t_Queue, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Queue, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Queue, of_, METH_VARARGS),
      DECLARE_METHOD(t_Queue, add, METH_VARARGS),
      DECLARE_METHOD(t_Queue, element, METH_NOARGS),
      DECLARE_METHOD(t_Queue, offer, METH_O),
      DECLARE_METHOD(t_Queue, peek, METH_NOARGS),
      DECLARE_METHOD(t_Queue, poll, METH_NOARGS),
      DECLARE_METHOD(t_Queue, remove, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Queue)[] = {
      { Py_tp_methods, t_Queue__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Queue__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Queue)[] = {
      &PY_TYPE_DEF(::java::util::Collection),
      NULL
    };

    DEFINE_TYPE(Queue, t_Queue, Queue);
    PyObject *t_Queue::wrap_Object(const Queue& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Queue::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Queue *self = (t_Queue *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Queue::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Queue::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Queue *self = (t_Queue *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Queue::install(PyObject *module)
    {
      installType(&PY_TYPE(Queue), &PY_TYPE_DEF(Queue), module, "Queue", 0);
    }

    void t_Queue::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Queue), "class_", make_descriptor(Queue::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Queue), "wrapfn_", make_descriptor(t_Queue::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Queue), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Queue_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Queue::initializeClass, 1)))
        return NULL;
      return t_Queue::wrap_Object(Queue(((t_Queue *) arg)->object.this$));
    }
    static PyObject *t_Queue_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Queue::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Queue_of_(t_Queue *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Queue_add(t_Queue *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.add(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Queue), (PyObject *) self, "add", args, 2);
    }

    static PyObject *t_Queue_element(t_Queue *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.element());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Queue_offer(t_Queue *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.offer(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "offer", arg);
      return NULL;
    }

    static PyObject *t_Queue_peek(t_Queue *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.peek());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Queue_poll(t_Queue *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.poll());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Queue_remove(t_Queue *self, PyObject *args)
    {
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.remove());
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Queue), (PyObject *) self, "remove", args, 2);
    }
    static PyObject *t_Queue_get__parameters_(t_Queue *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Spliterator$OfDouble.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/function/Consumer.h"
#include "java/lang/Double.h"
#include "java/util/function/DoubleConsumer.h"
#include "java/util/Spliterator$OfDouble.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Spliterator$OfDouble::class$ = NULL;
    jmethodID *Spliterator$OfDouble::mids$ = NULL;
    bool Spliterator$OfDouble::live$ = false;

    jclass Spliterator$OfDouble::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Spliterator$OfDouble");

        mids$ = new jmethodID[max_mid];
        mids$[mid_forEachRemaining_39fdd8ee24bf1a00] = env->getMethodID(cls, "forEachRemaining", "(Ljava/util/function/Consumer;)V");
        mids$[mid_forEachRemaining_ac837d9d17552aee] = env->getMethodID(cls, "forEachRemaining", "(Ljava/util/function/DoubleConsumer;)V");
        mids$[mid_tryAdvance_9aa53ce3333098c2] = env->getMethodID(cls, "tryAdvance", "(Ljava/util/function/Consumer;)Z");
        mids$[mid_tryAdvance_1973883101b2be8b] = env->getMethodID(cls, "tryAdvance", "(Ljava/util/function/DoubleConsumer;)Z");
        mids$[mid_trySplit_bb883c9d45f6c860] = env->getMethodID(cls, "trySplit", "()Ljava/util/Spliterator$OfDouble;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Spliterator$OfDouble::forEachRemaining(const ::java::util::function::Consumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEachRemaining_39fdd8ee24bf1a00], a0.this$);
    }

    void Spliterator$OfDouble::forEachRemaining(const ::java::util::function::DoubleConsumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEachRemaining_ac837d9d17552aee], a0.this$);
    }

    jboolean Spliterator$OfDouble::tryAdvance(const ::java::util::function::Consumer & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_tryAdvance_9aa53ce3333098c2], a0.this$);
    }

    jboolean Spliterator$OfDouble::tryAdvance(const ::java::util::function::DoubleConsumer & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_tryAdvance_1973883101b2be8b], a0.this$);
    }

    Spliterator$OfDouble Spliterator$OfDouble::trySplit() const
    {
      return Spliterator$OfDouble(env->callObjectMethod(this$, mids$[mid_trySplit_bb883c9d45f6c860]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Spliterator$OfDouble_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator$OfDouble_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator$OfDouble_of_(t_Spliterator$OfDouble *self, PyObject *args);
    static PyObject *t_Spliterator$OfDouble_forEachRemaining(t_Spliterator$OfDouble *self, PyObject *args);
    static PyObject *t_Spliterator$OfDouble_tryAdvance(t_Spliterator$OfDouble *self, PyObject *args);
    static PyObject *t_Spliterator$OfDouble_trySplit(t_Spliterator$OfDouble *self, PyObject *args);
    static PyObject *t_Spliterator$OfDouble_get__parameters_(t_Spliterator$OfDouble *self, void *data);
    static PyGetSetDef t_Spliterator$OfDouble__fields_[] = {
      DECLARE_GET_FIELD(t_Spliterator$OfDouble, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Spliterator$OfDouble__methods_[] = {
      DECLARE_METHOD(t_Spliterator$OfDouble, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator$OfDouble, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator$OfDouble, of_, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfDouble, forEachRemaining, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfDouble, tryAdvance, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfDouble, trySplit, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Spliterator$OfDouble)[] = {
      { Py_tp_methods, t_Spliterator$OfDouble__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Spliterator$OfDouble__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Spliterator$OfDouble)[] = {
      &PY_TYPE_DEF(::java::util::Spliterator$OfPrimitive),
      NULL
    };

    DEFINE_TYPE(Spliterator$OfDouble, t_Spliterator$OfDouble, Spliterator$OfDouble);
    PyObject *t_Spliterator$OfDouble::wrap_Object(const Spliterator$OfDouble& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Spliterator$OfDouble::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator$OfDouble *self = (t_Spliterator$OfDouble *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Spliterator$OfDouble::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Spliterator$OfDouble::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator$OfDouble *self = (t_Spliterator$OfDouble *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Spliterator$OfDouble::install(PyObject *module)
    {
      installType(&PY_TYPE(Spliterator$OfDouble), &PY_TYPE_DEF(Spliterator$OfDouble), module, "Spliterator$OfDouble", 0);
    }

    void t_Spliterator$OfDouble::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfDouble), "class_", make_descriptor(Spliterator$OfDouble::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfDouble), "wrapfn_", make_descriptor(t_Spliterator$OfDouble::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfDouble), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Spliterator$OfDouble_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Spliterator$OfDouble::initializeClass, 1)))
        return NULL;
      return t_Spliterator$OfDouble::wrap_Object(Spliterator$OfDouble(((t_Spliterator$OfDouble *) arg)->object.this$));
    }
    static PyObject *t_Spliterator$OfDouble_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Spliterator$OfDouble::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Spliterator$OfDouble_of_(t_Spliterator$OfDouble *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Spliterator$OfDouble_forEachRemaining(t_Spliterator$OfDouble *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::function::Consumer a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArgs(args, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
          {
            OBJ_CALL(self->object.forEachRemaining(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::util::function::DoubleConsumer a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::util::function::DoubleConsumer::initializeClass, &a0))
          {
            OBJ_CALL(self->object.forEachRemaining(a0));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(Spliterator$OfDouble), (PyObject *) self, "forEachRemaining", args, 2);
    }

    static PyObject *t_Spliterator$OfDouble_tryAdvance(t_Spliterator$OfDouble *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::function::Consumer a0((jobject) NULL);
          PyTypeObject **p0;
          jboolean result;

          if (!parseArgs(args, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
          {
            OBJ_CALL(result = self->object.tryAdvance(a0));
            Py_RETURN_BOOL(result);
          }
        }
        {
          ::java::util::function::DoubleConsumer a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "k", ::java::util::function::DoubleConsumer::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.tryAdvance(a0));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(Spliterator$OfDouble), (PyObject *) self, "tryAdvance", args, 2);
    }

    static PyObject *t_Spliterator$OfDouble_trySplit(t_Spliterator$OfDouble *self, PyObject *args)
    {
      Spliterator$OfDouble result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.trySplit());
        return t_Spliterator$OfDouble::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Spliterator$OfDouble), (PyObject *) self, "trySplit", args, 2);
    }
    static PyObject *t_Spliterator$OfDouble_get__parameters_(t_Spliterator$OfDouble *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/FileVisitOption.h"
#include "java/lang/String.h"
#include "java/nio/file/FileVisitOption.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *FileVisitOption::class$ = NULL;
      jmethodID *FileVisitOption::mids$ = NULL;
      bool FileVisitOption::live$ = false;
      FileVisitOption *FileVisitOption::FOLLOW_LINKS = NULL;

      jclass FileVisitOption::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/FileVisitOption");

          mids$ = new jmethodID[max_mid];
          mids$[mid_valueOf_578a31b379eaab48] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Ljava/nio/file/FileVisitOption;");
          mids$[mid_values_2e55ea828d9ee8ed] = env->getStaticMethodID(cls, "values", "()[Ljava/nio/file/FileVisitOption;");

          class$ = new ::java::lang::Class(cls);
          cls = (jclass) class$->this$;

          FOLLOW_LINKS = new FileVisitOption(env->getStaticObjectField(cls, "FOLLOW_LINKS", "Ljava/nio/file/FileVisitOption;"));
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      FileVisitOption FileVisitOption::valueOf(const ::java::lang::String & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return FileVisitOption(env->callStaticObjectMethod(cls, mids$[mid_valueOf_578a31b379eaab48], a0.this$));
      }

      JArray< FileVisitOption > FileVisitOption::values()
      {
        jclass cls = env->getClass(initializeClass);
        return JArray< FileVisitOption >(env->callStaticObjectMethod(cls, mids$[mid_values_2e55ea828d9ee8ed]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_FileVisitOption_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileVisitOption_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileVisitOption_of_(t_FileVisitOption *self, PyObject *args);
      static PyObject *t_FileVisitOption_valueOf(PyTypeObject *type, PyObject *args);
      static PyObject *t_FileVisitOption_values(PyTypeObject *type);
      static PyObject *t_FileVisitOption_get__parameters_(t_FileVisitOption *self, void *data);
      static PyGetSetDef t_FileVisitOption__fields_[] = {
        DECLARE_GET_FIELD(t_FileVisitOption, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_FileVisitOption__methods_[] = {
        DECLARE_METHOD(t_FileVisitOption, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileVisitOption, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileVisitOption, of_, METH_VARARGS),
        DECLARE_METHOD(t_FileVisitOption, valueOf, METH_VARARGS | METH_CLASS),
        DECLARE_METHOD(t_FileVisitOption, values, METH_NOARGS | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(FileVisitOption)[] = {
        { Py_tp_methods, t_FileVisitOption__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_FileVisitOption__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(FileVisitOption)[] = {
        &PY_TYPE_DEF(::java::lang::Enum),
        NULL
      };

      DEFINE_TYPE(FileVisitOption, t_FileVisitOption, FileVisitOption);
      PyObject *t_FileVisitOption::wrap_Object(const FileVisitOption& object, PyTypeObject *p0)
      {
        PyObject *obj = t_FileVisitOption::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_FileVisitOption *self = (t_FileVisitOption *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_FileVisitOption::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_FileVisitOption::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_FileVisitOption *self = (t_FileVisitOption *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_FileVisitOption::install(PyObject *module)
      {
        installType(&PY_TYPE(FileVisitOption), &PY_TYPE_DEF(FileVisitOption), module, "FileVisitOption", 0);
      }

      void t_FileVisitOption::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitOption), "class_", make_descriptor(FileVisitOption::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitOption), "wrapfn_", make_descriptor(t_FileVisitOption::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitOption), "boxfn_", make_descriptor(boxObject));
        env->getClass(FileVisitOption::initializeClass);
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitOption), "FOLLOW_LINKS", make_descriptor(t_FileVisitOption::wrap_Object(*FileVisitOption::FOLLOW_LINKS)));
      }

      static PyObject *t_FileVisitOption_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, FileVisitOption::initializeClass, 1)))
          return NULL;
        return t_FileVisitOption::wrap_Object(FileVisitOption(((t_FileVisitOption *) arg)->object.this$));
      }
      static PyObject *t_FileVisitOption_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, FileVisitOption::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_FileVisitOption_of_(t_FileVisitOption *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_FileVisitOption_valueOf(PyTypeObject *type, PyObject *args)
      {
        ::java::lang::String a0((jobject) NULL);
        FileVisitOption result((jobject) NULL);

        if (!parseArgs(args, "s", &a0))
        {
          OBJ_CALL(result = ::java::nio::file::FileVisitOption::valueOf(a0));
          return t_FileVisitOption::wrap_Object(result);
        }

        return callSuper(type, "valueOf", args, 2);
      }

      static PyObject *t_FileVisitOption_values(PyTypeObject *type)
      {
        JArray< FileVisitOption > result((jobject) NULL);
        OBJ_CALL(result = ::java::nio::file::FileVisitOption::values());
        return JArray<jobject>(result.this$).wrap(t_FileVisitOption::wrap_jobject);
      }
      static PyObject *t_FileVisitOption_get__parameters_(t_FileVisitOption *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/WatchEvent$Modifier.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *WatchEvent$Modifier::class$ = NULL;
      jmethodID *WatchEvent$Modifier::mids$ = NULL;
      bool WatchEvent$Modifier::live$ = false;

      jclass WatchEvent$Modifier::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/WatchEvent$Modifier");

          mids$ = new jmethodID[max_mid];
          mids$[mid_name_db9b55ba01e03e4b] = env->getMethodID(cls, "name", "()Ljava/lang/String;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::lang::String WatchEvent$Modifier::name() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_name_db9b55ba01e03e4b]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_WatchEvent$Modifier_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchEvent$Modifier_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchEvent$Modifier_of_(t_WatchEvent$Modifier *self, PyObject *args);
      static PyObject *t_WatchEvent$Modifier_name(t_WatchEvent$Modifier *self);
      static PyObject *t_WatchEvent$Modifier_get__parameters_(t_WatchEvent$Modifier *self, void *data);
      static PyGetSetDef t_WatchEvent$Modifier__fields_[] = {
        DECLARE_GET_FIELD(t_WatchEvent$Modifier, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_WatchEvent$Modifier__methods_[] = {
        DECLARE_METHOD(t_WatchEvent$Modifier, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchEvent$Modifier, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchEvent$Modifier, of_, METH_VARARGS),
        DECLARE_METHOD(t_WatchEvent$Modifier, name, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(WatchEvent$Modifier)[] = {
        { Py_tp_methods, t_WatchEvent$Modifier__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_WatchEvent$Modifier__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(WatchEvent$Modifier)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(WatchEvent$Modifier, t_WatchEvent$Modifier, WatchEvent$Modifier);
      PyObject *t_WatchEvent$Modifier::wrap_Object(const WatchEvent$Modifier& object, PyTypeObject *p0)
      {
        PyObject *obj = t_WatchEvent$Modifier::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_WatchEvent$Modifier *self = (t_WatchEvent$Modifier *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_WatchEvent$Modifier::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_WatchEvent$Modifier::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_WatchEvent$Modifier *self = (t_WatchEvent$Modifier *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_WatchEvent$Modifier::install(PyObject *module)
      {
        installType(&PY_TYPE(WatchEvent$Modifier), &PY_TYPE_DEF(WatchEvent$Modifier), module, "WatchEvent$Modifier", 0);
      }

      void t_WatchEvent$Modifier::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent$Modifier), "class_", make_descriptor(WatchEvent$Modifier::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent$Modifier), "wrapfn_", make_descriptor(t_WatchEvent$Modifier::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent$Modifier), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_WatchEvent$Modifier_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, WatchEvent$Modifier::initializeClass, 1)))
          return NULL;
        return t_WatchEvent$Modifier::wrap_Object(WatchEvent$Modifier(((t_WatchEvent$Modifier *) arg)->object.this$));
      }
      static PyObject *t_WatchEvent$Modifier_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, WatchEvent$Modifier::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_WatchEvent$Modifier_of_(t_WatchEvent$Modifier *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_WatchEvent$Modifier_name(t_WatchEvent$Modifier *self)
      {
        ::java::lang::String result((jobject) NULL);
        OBJ_CALL(result = self->object.name());
        return j2p(result);
      }
      static PyObject *t_WatchEvent$Modifier_get__parameters_(t_WatchEvent$Modifier *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Process.h"
#include "java/lang/Process.h"
#include "java/io/InputStream.h"
#include "java/lang/Class.h"
#include "java/io/OutputStream.h"
#include "java/lang/InterruptedException.h"
#include "java/util/concurrent/TimeUnit.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Process::class$ = NULL;
    jmethodID *Process::mids$ = NULL;
    bool Process::live$ = false;

    jclass Process::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Process");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_destroy_f2cc1bce94666404] = env->getMethodID(cls, "destroy", "()V");
        mids$[mid_destroyForcibly_6d7d150c8055e2eb] = env->getMethodID(cls, "destroyForcibly", "()Ljava/lang/Process;");
        mids$[mid_exitValue_9972fcc56b44e79d] = env->getMethodID(cls, "exitValue", "()I");
        mids$[mid_getErrorStream_df4bed2fb5ba3ccf] = env->getMethodID(cls, "getErrorStream", "()Ljava/io/InputStream;");
        mids$[mid_getInputStream_df4bed2fb5ba3ccf] = env->getMethodID(cls, "getInputStream", "()Ljava/io/InputStream;");
        mids$[mid_getOutputStream_c558fff49cac4c0c] = env->getMethodID(cls, "getOutputStream", "()Ljava/io/OutputStream;");
        mids$[mid_isAlive_8454bd5aa23fd11e] = env->getMethodID(cls, "isAlive", "()Z");
        mids$[mid_waitFor_9972fcc56b44e79d] = env->getMethodID(cls, "waitFor", "()I");
        mids$[mid_waitFor_30164a42685760d2] = env->getMethodID(cls, "waitFor", "(JLjava/util/concurrent/TimeUnit;)Z");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Process::Process() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    void Process::destroy() const
    {
      env->callVoidMethod(this$, mids$[mid_destroy_f2cc1bce94666404]);
    }

    Process Process::destroyForcibly() const
    {
      return Process(env->callObjectMethod(this$, mids$[mid_destroyForcibly_6d7d150c8055e2eb]));
    }

    jint Process::exitValue() const
    {
      return env->callIntMethod(this$, mids$[mid_exitValue_9972fcc56b44e79d]);
    }

    ::java::io::InputStream Process::getErrorStream() const
    {
      return ::java::io::InputStream(env->callObjectMethod(this$, mids$[mid_getErrorStream_df4bed2fb5ba3ccf]));
    }

    ::java::io::InputStream Process::getInputStream() const
    {
      return ::java::io::InputStream(env->callObjectMethod(this$, mids$[mid_getInputStream_df4bed2fb5ba3ccf]));
    }

    ::java::io::OutputStream Process::getOutputStream() const
    {
      return ::java::io::OutputStream(env->callObjectMethod(this$, mids$[mid_getOutputStream_c558fff49cac4c0c]));
    }

    jboolean Process::isAlive() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isAlive_8454bd5aa23fd11e]);
    }

    jint Process::waitFor() const
    {
      return env->callIntMethod(this$, mids$[mid_waitFor_9972fcc56b44e79d]);
    }

    jboolean Process::waitFor(jlong a0, const ::java::util::concurrent::TimeUnit & a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_waitFor_30164a42685760d2], a0, a1.this$);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Process_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Process_instance_(PyTypeObject *type, PyObject *arg);
    static int t_Process_init_(t_Process *self, PyObject *args, PyObject *kwds);
    static PyObject *t_Process_destroy(t_Process *self);
    static PyObject *t_Process_destroyForcibly(t_Process *self);
    static PyObject *t_Process_exitValue(t_Process *self);
    static PyObject *t_Process_getErrorStream(t_Process *self);
    static PyObject *t_Process_getInputStream(t_Process *self);
    static PyObject *t_Process_getOutputStream(t_Process *self);
    static PyObject *t_Process_isAlive(t_Process *self);
    static PyObject *t_Process_waitFor(t_Process *self, PyObject *args);
    static PyObject *t_Process_get__alive(t_Process *self, void *data);
    static PyObject *t_Process_get__errorStream(t_Process *self, void *data);
    static PyObject *t_Process_get__inputStream(t_Process *self, void *data);
    static PyObject *t_Process_get__outputStream(t_Process *self, void *data);
    static PyGetSetDef t_Process__fields_[] = {
      DECLARE_GET_FIELD(t_Process, alive),
      DECLARE_GET_FIELD(t_Process, errorStream),
      DECLARE_GET_FIELD(t_Process, inputStream),
      DECLARE_GET_FIELD(t_Process, outputStream),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Process__methods_[] = {
      DECLARE_METHOD(t_Process, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Process, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Process, destroy, METH_NOARGS),
      DECLARE_METHOD(t_Process, destroyForcibly, METH_NOARGS),
      DECLARE_METHOD(t_Process, exitValue, METH_NOARGS),
      DECLARE_METHOD(t_Process, getErrorStream, METH_NOARGS),
      DECLARE_METHOD(t_Process, getInputStream, METH_NOARGS),
      DECLARE_METHOD(t_Process, getOutputStream, METH_NOARGS),
      DECLARE_METHOD(t_Process, isAlive, METH_NOARGS),
      DECLARE_METHOD(t_Process, waitFor, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Process)[] = {
      { Py_tp_methods, t_Process__methods_ },
      { Py_tp_init, (void *) t_Process_init_ },
      { Py_tp_getset, t_Process__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Process)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Process, t_Process, Process);

    void t_Process::install(PyObject *module)
    {
      installType(&PY_TYPE(Process), &PY_TYPE_DEF(Process), module, "Process", 0);
    }

    void t_Process::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Process), "class_", make_descriptor(Process::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Process), "wrapfn_", make_descriptor(t_Process::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Process), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Process_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Process::initializeClass, 1)))
        return NULL;
      return t_Process::wrap_Object(Process(((t_Process *) arg)->object.this$));
    }
    static PyObject *t_Process_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Process::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_Process_init_(t_Process *self, PyObject *args, PyObject *kwds)
    {
      Process object((jobject) NULL);

      INT_CALL(object = Process());
      self->object = object;

      return 0;
    }

    static PyObject *t_Process_destroy(t_Process *self)
    {
      OBJ_CALL(self->object.destroy());
      Py_RETURN_NONE;
    }

    static PyObject *t_Process_destroyForcibly(t_Process *self)
    {
      Process result((jobject) NULL);
      OBJ_CALL(result = self->object.destroyForcibly());
      return t_Process::wrap_Object(result);
    }

    static PyObject *t_Process_exitValue(t_Process *self)
    {
      jint result;
      OBJ_CALL(result = self->object.exitValue());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Process_getErrorStream(t_Process *self)
    {
      ::java::io::InputStream result((jobject) NULL);
      OBJ_CALL(result = self->object.getErrorStream());
      return ::java::io::t_InputStream::wrap_Object(result);
    }

    static PyObject *t_Process_getInputStream(t_Process *self)
    {
      ::java::io::InputStream result((jobject) NULL);
      OBJ_CALL(result = self->object.getInputStream());
      return ::java::io::t_InputStream::wrap_Object(result);
    }

    static PyObject *t_Process_getOutputStream(t_Process *self)
    {
      ::java::io::OutputStream result((jobject) NULL);
      OBJ_CALL(result = self->object.getOutputStream());
      return ::java::io::t_OutputStream::wrap_Object(result);
    }

    static PyObject *t_Process_isAlive(t_Process *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isAlive());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_Process_waitFor(t_Process *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          jint result;
          OBJ_CALL(result = self->object.waitFor());
          return PyLong_FromLong((long) result);
        }
        break;
       case 2:
        {
          jlong a0;
          ::java::util::concurrent::TimeUnit a1((jobject) NULL);
          PyTypeObject **p1;
          jboolean result;

          if (!parseArgs(args, "JK", ::java::util::concurrent::TimeUnit::initializeClass, &a0, &a1, &p1, ::java::util::concurrent::t_TimeUnit::parameters_))
          {
            OBJ_CALL(result = self->object.waitFor(a0, a1));
            Py_RETURN_BOOL(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "waitFor", args);
      return NULL;
    }

    static PyObject *t_Process_get__alive(t_Process *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isAlive());
      Py_RETURN_BOOL(value);
    }

    static PyObject *t_Process_get__errorStream(t_Process *self, void *data)
    {
      ::java::io::InputStream value((jobject) NULL);
      OBJ_CALL(value = self->object.getErrorStream());
      return ::java::io::t_InputStream::wrap_Object(value);
    }

    static PyObject *t_Process_get__inputStream(t_Process *self, void *data)
    {
      ::java::io::InputStream value((jobject) NULL);
      OBJ_CALL(value = self->object.getInputStream());
      return ::java::io::t_InputStream::wrap_Object(value);
    }

    static PyObject *t_Process_get__outputStream(t_Process *self, void *data)
    {
      ::java::io::OutputStream value((jobject) NULL);
      OBJ_CALL(value = self->object.getOutputStream());
      return ::java::io::t_OutputStream::wrap_Object(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Set.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/Spliterator.h"
#include "java/util/Iterator.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Set::class$ = NULL;
    jmethodID *Set::mids$ = NULL;
    bool Set::live$ = false;

    jclass Set::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Set");

        mids$ = new jmethodID[max_mid];
        mids$[mid_add_8b72f2dcdde6fd1d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)Z");
        mids$[mid_addAll_15d9cc2398c22637] = env->getMethodID(cls, "addAll", "(Ljava/util/Collection;)Z");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_contains_8b72f2dcdde6fd1d] = env->getMethodID(cls, "contains", "(Ljava/lang/Object;)Z");
        mids$[mid_containsAll_15d9cc2398c22637] = env->getMethodID(cls, "containsAll", "(Ljava/util/Collection;)Z");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
        mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
        mids$[mid_remove_8b72f2dcdde6fd1d] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Z");
        mids$[mid_removeAll_15d9cc2398c22637] = env->getMethodID(cls, "removeAll", "(Ljava/util/Collection;)Z");
        mids$[mid_retainAll_15d9cc2398c22637] = env->getMethodID(cls, "retainAll", "(Ljava/util/Collection;)Z");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
        mids$[mid_spliterator_7a761c107a8e14bd] = env->getMethodID(cls, "spliterator", "()Ljava/util/Spliterator;");
        mids$[mid_toArray_6becf78ffd87a9bc] = env->getMethodID(cls, "toArray", "()[Ljava/lang/Object;");
        mids$[mid_toArray_609b05756010dc5d] = env->getMethodID(cls, "toArray", "([Ljava/lang/Object;)[Ljava/lang/Object;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jboolean Set::add(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_add_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Set::addAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_15d9cc2398c22637], a0.this$);
    }

    void Set::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    jboolean Set::contains(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_contains_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Set::containsAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_containsAll_15d9cc2398c22637], a0.this$);
    }

    jboolean Set::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    jint Set::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean Set::isEmpty() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
    }

    ::java::util::Iterator Set::iterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
    }

    jboolean Set::remove(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_remove_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Set::removeAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeAll_15d9cc2398c22637], a0.this$);
    }

    jboolean Set::retainAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_retainAll_15d9cc2398c22637], a0.this$);
    }

    jint Set::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }

    ::java::util::Spliterator Set::spliterator() const
    {
      return ::java::util::Spliterator(env->callObjectMethod(this$, mids$[mid_spliterator_7a761c107a8e14bd]));
    }

    JArray< ::java::lang::Object > Set::toArray() const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_6becf78ffd87a9bc]));
    }

    JArray< ::java::lang::Object > Set::toArray(const JArray< ::java::lang::Object > & a0) const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_609b05756010dc5d], a0.this$));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Set_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Set_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Set_of_(t_Set *self, PyObject *args);
    static PyObject *t_Set_add(t_Set *self, PyObject *args);
    static PyObject *t_Set_addAll(t_Set *self, PyObject *args);
    static PyObject *t_Set_clear(t_Set *self, PyObject *args);
    static PyObject *t_Set_contains(t_Set *self, PyObject *args);
    static PyObject *t_Set_containsAll(t_Set *self, PyObject *args);
    static PyObject *t_Set_equals(t_Set *self, PyObject *args);
    static PyObject *t_Set_hashCode(t_Set *self, PyObject *args);
    static PyObject *t_Set_isEmpty(t_Set *self, PyObject *args);
    static PyObject *t_Set_iterator(t_Set *self, PyObject *args);
    static PyObject *t_Set_remove(t_Set *self, PyObject *args);
    static PyObject *t_Set_removeAll(t_Set *self, PyObject *args);
    static PyObject *t_Set_retainAll(t_Set *self, PyObject *args);
    static PyObject *t_Set_size(t_Set *self, PyObject *args);
    static PyObject *t_Set_spliterator(t_Set *self, PyObject *args);
    static PyObject *t_Set_toArray(t_Set *self, PyObject *args);
    static PyObject *t_Set_get__empty(t_Set *self, void *data);
    static PyObject *t_Set_get__parameters_(t_Set *self, void *data);
    static PyGetSetDef t_Set__fields_[] = {
      DECLARE_GET_FIELD(t_Set, empty),
      DECLARE_GET_FIELD(t_Set, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Set__methods_[] = {
      DECLARE_METHOD(t_Set, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Set, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Set, of_, METH_VARARGS),
      DECLARE_METHOD(t_Set, add, METH_VARARGS),
      DECLARE_METHOD(t_Set, addAll, METH_VARARGS),
      DECLARE_METHOD(t_Set, clear, METH_VARARGS),
      DECLARE_METHOD(t_Set, contains, METH_VARARGS),
      DECLARE_METHOD(t_Set, containsAll, METH_VARARGS),
      DECLARE_METHOD(t_Set, equals, METH_VARARGS),
      DECLARE_METHOD(t_Set, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_Set, isEmpty, METH_VARARGS),
      DECLARE_METHOD(t_Set, iterator, METH_VARARGS),
      DECLARE_METHOD(t_Set, remove, METH_VARARGS),
      DECLARE_METHOD(t_Set, removeAll, METH_VARARGS),
      DECLARE_METHOD(t_Set, retainAll, METH_VARARGS),
      DECLARE_METHOD(t_Set, size, METH_VARARGS),
      DECLARE_METHOD(t_Set, spliterator, METH_VARARGS),
      DECLARE_METHOD(t_Set, toArray, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Set)[] = {
      { Py_tp_methods, t_Set__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Set__fields_ },
      { Py_tp_iter, (void *) ((PyObject *(*)(t_Set *)) get_generic_iterator< t_Set >) },
      { Py_tp_iternext, (void *) 0 },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Set)[] = {
      &PY_TYPE_DEF(::java::util::Collection),
      NULL
    };

    DEFINE_TYPE(Set, t_Set, Set);
    PyObject *t_Set::wrap_Object(const Set& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Set::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Set *self = (t_Set *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Set::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Set::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Set *self = (t_Set *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Set::install(PyObject *module)
    {
      installType(&PY_TYPE(Set), &PY_TYPE_DEF(Set), module, "Set", 0);
    }

    void t_Set::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Set), "class_", make_descriptor(Set::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Set), "wrapfn_", make_descriptor(t_Set::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Set), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Set_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Set::initializeClass, 1)))
        return NULL;
      return t_Set::wrap_Object(Set(((t_Set *) arg)->object.this$));
    }
    static PyObject *t_Set_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Set::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Set_of_(t_Set *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Set_add(t_Set *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.add(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "add", args, 2);
    }

    static PyObject *t_Set_addAll(t_Set *self, PyObject *args)
    {
      ::java::util::Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.addAll(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "addAll", args, 2);
    }

    static PyObject *t_Set_clear(t_Set *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.clear());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "clear", args, 2);
    }

    static PyObject *t_Set_contains(t_Set *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.contains(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "contains", args, 2);
    }

    static PyObject *t_Set_containsAll(t_Set *self, PyObject *args)
    {
      ::java::util::Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.containsAll(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "containsAll", args, 2);
    }

    static PyObject *t_Set_equals(t_Set *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_Set_hashCode(t_Set *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_Set_isEmpty(t_Set *self, PyObject *args)
    {
      jboolean result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.isEmpty());
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "isEmpty", args, 2);
    }

    static PyObject *t_Set_iterator(t_Set *self, PyObject *args)
    {
      ::java::util::Iterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.iterator());
        return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "iterator", args, 2);
    }

    static PyObject *t_Set_remove(t_Set *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.remove(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_Set_removeAll(t_Set *self, PyObject *args)
    {
      ::java::util::Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.removeAll(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "removeAll", args, 2);
    }

    static PyObject *t_Set_retainAll(t_Set *self, PyObject *args)
    {
      ::java::util::Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.retainAll(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "retainAll", args, 2);
    }

    static PyObject *t_Set_size(t_Set *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.size());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "size", args, 2);
    }

    static PyObject *t_Set_spliterator(t_Set *self, PyObject *args)
    {
      ::java::util::Spliterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.spliterator());
        return ::java::util::t_Spliterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "spliterator", args, 2);
    }

    static PyObject *t_Set_toArray(t_Set *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          JArray< ::java::lang::Object > result((jobject) NULL);
          OBJ_CALL(result = self->object.toArray());
          return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
        }
        break;
       case 1:
        {
          JArray< ::java::lang::Object > a0((jobject) NULL);
          JArray< ::java::lang::Object > result((jobject) NULL);

          if (!parseArgs(args, "[o", &a0))
          {
            OBJ_CALL(result = self->object.toArray(a0));
            return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
          }
        }
      }

      return callSuper(PY_TYPE(Set), (PyObject *) self, "toArray", args, 2);
    }
    static PyObject *t_Set_get__parameters_(t_Set *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_Set_get__empty(t_Set *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isEmpty());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/Token.h"
#include "org/antlr/v4/runtime/TokenSource.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/CharStream.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *Token::class$ = NULL;
        jmethodID *Token::mids$ = NULL;
        bool Token::live$ = false;
        jint Token::DEFAULT_CHANNEL = (jint) 0;
        jint Token::EOF = (jint) 0;
        jint Token::EPSILON = (jint) 0;
        jint Token::HIDDEN_CHANNEL = (jint) 0;
        jint Token::INVALID_TYPE = (jint) 0;
        jint Token::MIN_USER_CHANNEL_VALUE = (jint) 0;
        jint Token::MIN_USER_TOKEN_TYPE = (jint) 0;

        jclass Token::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/Token");

            mids$ = new jmethodID[max_mid];
            mids$[mid_getChannel_9972fcc56b44e79d] = env->getMethodID(cls, "getChannel", "()I");
            mids$[mid_getCharPositionInLine_9972fcc56b44e79d] = env->getMethodID(cls, "getCharPositionInLine", "()I");
            mids$[mid_getInputStream_f3effd93aa48b2fd] = env->getMethodID(cls, "getInputStream", "()Lorg/antlr/v4/runtime/CharStream;");
            mids$[mid_getLine_9972fcc56b44e79d] = env->getMethodID(cls, "getLine", "()I");
            mids$[mid_getStartIndex_9972fcc56b44e79d] = env->getMethodID(cls, "getStartIndex", "()I");
            mids$[mid_getStopIndex_9972fcc56b44e79d] = env->getMethodID(cls, "getStopIndex", "()I");
            mids$[mid_getText_db9b55ba01e03e4b] = env->getMethodID(cls, "getText", "()Ljava/lang/String;");
            mids$[mid_getTokenIndex_9972fcc56b44e79d] = env->getMethodID(cls, "getTokenIndex", "()I");
            mids$[mid_getTokenSource_d01019507f363a98] = env->getMethodID(cls, "getTokenSource", "()Lorg/antlr/v4/runtime/TokenSource;");
            mids$[mid_getType_9972fcc56b44e79d] = env->getMethodID(cls, "getType", "()I");

            class$ = new ::java::lang::Class(cls);
            cls = (jclass) class$->this$;

            DEFAULT_CHANNEL = env->getStaticIntField(cls, "DEFAULT_CHANNEL");
            EOF = env->getStaticIntField(cls, "EOF");
            EPSILON = env->getStaticIntField(cls, "EPSILON");
            HIDDEN_CHANNEL = env->getStaticIntField(cls, "HIDDEN_CHANNEL");
            INVALID_TYPE = env->getStaticIntField(cls, "INVALID_TYPE");
            MIN_USER_CHANNEL_VALUE = env->getStaticIntField(cls, "MIN_USER_CHANNEL_VALUE");
            MIN_USER_TOKEN_TYPE = env->getStaticIntField(cls, "MIN_USER_TOKEN_TYPE");
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        jint Token::getChannel() const
        {
          return env->callIntMethod(this$, mids$[mid_getChannel_9972fcc56b44e79d]);
        }

        jint Token::getCharPositionInLine() const
        {
          return env->callIntMethod(this$, mids$[mid_getCharPositionInLine_9972fcc56b44e79d]);
        }

        ::org::antlr::v4::runtime::CharStream Token::getInputStream() const
        {
          return ::org::antlr::v4::runtime::CharStream(env->callObjectMethod(this$, mids$[mid_getInputStream_f3effd93aa48b2fd]));
        }

        jint Token::getLine() const
        {
          return env->callIntMethod(this$, mids$[mid_getLine_9972fcc56b44e79d]);
        }

        jint Token::getStartIndex() const
        {
          return env->callIntMethod(this$, mids$[mid_getStartIndex_9972fcc56b44e79d]);
        }

        jint Token::getStopIndex() const
        {
          return env->callIntMethod(this$, mids$[mid_getStopIndex_9972fcc56b44e79d]);
        }

        ::java::lang::String Token::getText() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getText_db9b55ba01e03e4b]));
        }

        jint Token::getTokenIndex() const
        {
          return env->callIntMethod(this$, mids$[mid_getTokenIndex_9972fcc56b44e79d]);
        }

        ::org::antlr::v4::runtime::TokenSource Token::getTokenSource() const
        {
          return ::org::antlr::v4::runtime::TokenSource(env->callObjectMethod(this$, mids$[mid_getTokenSource_d01019507f363a98]));
        }

        jint Token::getType() const
        {
          return env->callIntMethod(this$, mids$[mid_getType_9972fcc56b44e79d]);
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_Token_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Token_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Token_getChannel(t_Token *self);
        static PyObject *t_Token_getCharPositionInLine(t_Token *self);
        static PyObject *t_Token_getInputStream(t_Token *self);
        static PyObject *t_Token_getLine(t_Token *self);
        static PyObject *t_Token_getStartIndex(t_Token *self);
        static PyObject *t_Token_getStopIndex(t_Token *self);
        static PyObject *t_Token_getText(t_Token *self);
        static PyObject *t_Token_getTokenIndex(t_Token *self);
        static PyObject *t_Token_getTokenSource(t_Token *self);
        static PyObject *t_Token_getType(t_Token *self);
        static PyObject *t_Token_get__channel(t_Token *self, void *data);
        static PyObject *t_Token_get__charPositionInLine(t_Token *self, void *data);
        static PyObject *t_Token_get__inputStream(t_Token *self, void *data);
        static PyObject *t_Token_get__line(t_Token *self, void *data);
        static PyObject *t_Token_get__startIndex(t_Token *self, void *data);
        static PyObject *t_Token_get__stopIndex(t_Token *self, void *data);
        static PyObject *t_Token_get__text(t_Token *self, void *data);
        static PyObject *t_Token_get__tokenIndex(t_Token *self, void *data);
        static PyObject *t_Token_get__tokenSource(t_Token *self, void *data);
        static PyObject *t_Token_get__type(t_Token *self, void *data);
        static PyGetSetDef t_Token__fields_[] = {
          DECLARE_GET_FIELD(t_Token, channel),
          DECLARE_GET_FIELD(t_Token, charPositionInLine),
          DECLARE_GET_FIELD(t_Token, inputStream),
          DECLARE_GET_FIELD(t_Token, line),
          DECLARE_GET_FIELD(t_Token, startIndex),
          DECLARE_GET_FIELD(t_Token, stopIndex),
          DECLARE_GET_FIELD(t_Token, text),
          DECLARE_GET_FIELD(t_Token, tokenIndex),
          DECLARE_GET_FIELD(t_Token, tokenSource),
          DECLARE_GET_FIELD(t_Token, type),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_Token__methods_[] = {
          DECLARE_METHOD(t_Token, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Token, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Token, getChannel, METH_NOARGS),
          DECLARE_METHOD(t_Token, getCharPositionInLine, METH_NOARGS),
          DECLARE_METHOD(t_Token, getInputStream, METH_NOARGS),
          DECLARE_METHOD(t_Token, getLine, METH_NOARGS),
          DECLARE_METHOD(t_Token, getStartIndex, METH_NOARGS),
          DECLARE_METHOD(t_Token, getStopIndex, METH_NOARGS),
          DECLARE_METHOD(t_Token, getText, METH_NOARGS),
          DECLARE_METHOD(t_Token, getTokenIndex, METH_NOARGS),
          DECLARE_METHOD(t_Token, getTokenSource, METH_NOARGS),
          DECLARE_METHOD(t_Token, getType, METH_NOARGS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(Token)[] = {
          { Py_tp_methods, t_Token__methods_ },
          { Py_tp_init, (void *) abstract_init },
          { Py_tp_getset, t_Token__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(Token)[] = {
          &PY_TYPE_DEF(::java::lang::Object),
          NULL
        };

        DEFINE_TYPE(Token, t_Token, Token);

        void t_Token::install(PyObject *module)
        {
          installType(&PY_TYPE(Token), &PY_TYPE_DEF(Token), module, "Token", 0);
        }

        void t_Token::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "class_", make_descriptor(Token::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "wrapfn_", make_descriptor(t_Token::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "boxfn_", make_descriptor(boxObject));
          env->getClass(Token::initializeClass);
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "DEFAULT_CHANNEL", make_descriptor(Token::DEFAULT_CHANNEL));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "EOF", make_descriptor(Token::EOF));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "EPSILON", make_descriptor(Token::EPSILON));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "HIDDEN_CHANNEL", make_descriptor(Token::HIDDEN_CHANNEL));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "INVALID_TYPE", make_descriptor(Token::INVALID_TYPE));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "MIN_USER_CHANNEL_VALUE", make_descriptor(Token::MIN_USER_CHANNEL_VALUE));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Token), "MIN_USER_TOKEN_TYPE", make_descriptor(Token::MIN_USER_TOKEN_TYPE));
        }

        static PyObject *t_Token_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, Token::initializeClass, 1)))
            return NULL;
          return t_Token::wrap_Object(Token(((t_Token *) arg)->object.this$));
        }
        static PyObject *t_Token_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, Token::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_Token_getChannel(t_Token *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getChannel());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Token_getCharPositionInLine(t_Token *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getCharPositionInLine());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Token_getInputStream(t_Token *self)
        {
          ::org::antlr::v4::runtime::CharStream result((jobject) NULL);
          OBJ_CALL(result = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_CharStream::wrap_Object(result);
        }

        static PyObject *t_Token_getLine(t_Token *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getLine());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Token_getStartIndex(t_Token *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getStartIndex());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Token_getStopIndex(t_Token *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getStopIndex());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Token_getText(t_Token *self)
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getText());
          return j2p(result);
        }

        static PyObject *t_Token_getTokenIndex(t_Token *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getTokenIndex());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Token_getTokenSource(t_Token *self)
        {
          ::org::antlr::v4::runtime::TokenSource result((jobject) NULL);
          OBJ_CALL(result = self->object.getTokenSource());
          return ::org::antlr::v4::runtime::t_TokenSource::wrap_Object(result);
        }

        static PyObject *t_Token_getType(t_Token *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getType());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Token_get__channel(t_Token *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getChannel());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_Token_get__charPositionInLine(t_Token *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getCharPositionInLine());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_Token_get__inputStream(t_Token *self, void *data)
        {
          ::org::antlr::v4::runtime::CharStream value((jobject) NULL);
          OBJ_CALL(value = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_CharStream::wrap_Object(value);
        }

        static PyObject *t_Token_get__line(t_Token *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getLine());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_Token_get__startIndex(t_Token *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getStartIndex());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_Token_get__stopIndex(t_Token *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getStopIndex());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_Token_get__text(t_Token *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object.getText());
          return j2p(value);
        }

        static PyObject *t_Token_get__tokenIndex(t_Token *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getTokenIndex());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_Token_get__tokenSource(t_Token *self, void *data)
        {
          ::org::antlr::v4::runtime::TokenSource value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenSource());
          return ::org::antlr::v4::runtime::t_TokenSource::wrap_Object(value);
        }

        static PyObject *t_Token_get__type(t_Token *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getType());
          return PyLong_FromLong((long) value);
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/IntBinaryOperator.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *IntBinaryOperator::class$ = NULL;
      jmethodID *IntBinaryOperator::mids$ = NULL;
      bool IntBinaryOperator::live$ = false;

      jclass IntBinaryOperator::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/IntBinaryOperator");

          mids$ = new jmethodID[max_mid];
          mids$[mid_applyAsInt_57a58545eba514db] = env->getMethodID(cls, "applyAsInt", "(II)I");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jint IntBinaryOperator::applyAsInt(jint a0, jint a1) const
      {
        return env->callIntMethod(this$, mids$[mid_applyAsInt_57a58545eba514db], a0, a1);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_IntBinaryOperator_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntBinaryOperator_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntBinaryOperator_applyAsInt(t_IntBinaryOperator *self, PyObject *args);

      static PyMethodDef t_IntBinaryOperator__methods_[] = {
        DECLARE_METHOD(t_IntBinaryOperator, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntBinaryOperator, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntBinaryOperator, applyAsInt, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(IntBinaryOperator)[] = {
        { Py_tp_methods, t_IntBinaryOperator__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(IntBinaryOperator)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(IntBinaryOperator, t_IntBinaryOperator, IntBinaryOperator);

      void t_IntBinaryOperator::install(PyObject *module)
      {
        installType(&PY_TYPE(IntBinaryOperator), &PY_TYPE_DEF(IntBinaryOperator), module, "IntBinaryOperator", 0);
      }

      void t_IntBinaryOperator::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntBinaryOperator), "class_", make_descriptor(IntBinaryOperator::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntBinaryOperator), "wrapfn_", make_descriptor(t_IntBinaryOperator::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntBinaryOperator), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_IntBinaryOperator_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, IntBinaryOperator::initializeClass, 1)))
          return NULL;
        return t_IntBinaryOperator::wrap_Object(IntBinaryOperator(((t_IntBinaryOperator *) arg)->object.this$));
      }
      static PyObject *t_IntBinaryOperator_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, IntBinaryOperator::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_IntBinaryOperator_applyAsInt(t_IntBinaryOperator *self, PyObject *args)
      {
        jint a0;
        jint a1;
        jint result;

        if (!parseArgs(args, "II", &a0, &a1))
        {
          OBJ_CALL(result = self->object.applyAsInt(a0, a1));
          return PyLong_FromLong((long) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsInt", args);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/InputStream.h"
#include "java/io/IOException.h"
#include "java/io/Closeable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *InputStream::class$ = NULL;
    jmethodID *InputStream::mids$ = NULL;
    bool InputStream::live$ = false;

    jclass InputStream::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/InputStream");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_available_9972fcc56b44e79d] = env->getMethodID(cls, "available", "()I");
        mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");
        mids$[mid_mark_040c4cd0390c5aff] = env->getMethodID(cls, "mark", "(I)V");
        mids$[mid_markSupported_8454bd5aa23fd11e] = env->getMethodID(cls, "markSupported", "()Z");
        mids$[mid_read_9972fcc56b44e79d] = env->getMethodID(cls, "read", "()I");
        mids$[mid_read_bc39a112ba52f98e] = env->getMethodID(cls, "read", "([B)I");
        mids$[mid_read_a974b127529aaf33] = env->getMethodID(cls, "read", "([BII)I");
        mids$[mid_reset_f2cc1bce94666404] = env->getMethodID(cls, "reset", "()V");
        mids$[mid_skip_d711eecdc469624a] = env->getMethodID(cls, "skip", "(J)J");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    InputStream::InputStream() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    jint InputStream::available() const
    {
      return env->callIntMethod(this$, mids$[mid_available_9972fcc56b44e79d]);
    }

    void InputStream::close() const
    {
      env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
    }

    void InputStream::mark(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_mark_040c4cd0390c5aff], a0);
    }

    jboolean InputStream::markSupported() const
    {
      return env->callBooleanMethod(this$, mids$[mid_markSupported_8454bd5aa23fd11e]);
    }

    jint InputStream::read() const
    {
      return env->callIntMethod(this$, mids$[mid_read_9972fcc56b44e79d]);
    }

    jint InputStream::read(const JArray< jbyte > & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_read_bc39a112ba52f98e], a0.this$);
    }

    jint InputStream::read(const JArray< jbyte > & a0, jint a1, jint a2) const
    {
      return env->callIntMethod(this$, mids$[mid_read_a974b127529aaf33], a0.this$, a1, a2);
    }

    void InputStream::reset() const
    {
      env->callVoidMethod(this$, mids$[mid_reset_f2cc1bce94666404]);
    }

    jlong InputStream::skip(jlong a0) const
    {
      return env->callLongMethod(this$, mids$[mid_skip_d711eecdc469624a], a0);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_InputStream_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_InputStream_instance_(PyTypeObject *type, PyObject *arg);
    static int t_InputStream_init_(t_InputStream *self, PyObject *args, PyObject *kwds);
    static PyObject *t_InputStream_available(t_InputStream *self);
    static PyObject *t_InputStream_close(t_InputStream *self);
    static PyObject *t_InputStream_mark(t_InputStream *self, PyObject *arg);
    static PyObject *t_InputStream_markSupported(t_InputStream *self);
    static PyObject *t_InputStream_read(t_InputStream *self, PyObject *args);
    static PyObject *t_InputStream_reset(t_InputStream *self);
    static PyObject *t_InputStream_skip(t_InputStream *self, PyObject *arg);

    static PyMethodDef t_InputStream__methods_[] = {
      DECLARE_METHOD(t_InputStream, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_InputStream, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_InputStream, available, METH_NOARGS),
      DECLARE_METHOD(t_InputStream, close, METH_NOARGS),
      DECLARE_METHOD(t_InputStream, mark, METH_O),
      DECLARE_METHOD(t_InputStream, markSupported, METH_NOARGS),
      DECLARE_METHOD(t_InputStream, read, METH_VARARGS),
      DECLARE_METHOD(t_InputStream, reset, METH_NOARGS),
      DECLARE_METHOD(t_InputStream, skip, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(InputStream)[] = {
      { Py_tp_methods, t_InputStream__methods_ },
      { Py_tp_init, (void *) t_InputStream_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(InputStream)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(InputStream, t_InputStream, InputStream);

    void t_InputStream::install(PyObject *module)
    {
      installType(&PY_TYPE(InputStream), &PY_TYPE_DEF(InputStream), module, "InputStream", 0);
    }

    void t_InputStream::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(InputStream), "class_", make_descriptor(InputStream::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(InputStream), "wrapfn_", make_descriptor(t_InputStream::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(InputStream), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_InputStream_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, InputStream::initializeClass, 1)))
        return NULL;
      return t_InputStream::wrap_Object(InputStream(((t_InputStream *) arg)->object.this$));
    }
    static PyObject *t_InputStream_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, InputStream::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_InputStream_init_(t_InputStream *self, PyObject *args, PyObject *kwds)
    {
      InputStream object((jobject) NULL);

      INT_CALL(object = InputStream());
      self->object = object;

      return 0;
    }

    static PyObject *t_InputStream_available(t_InputStream *self)
    {
      jint result;
      OBJ_CALL(result = self->object.available());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_InputStream_close(t_InputStream *self)
    {
      OBJ_CALL(self->object.close());
      Py_RETURN_NONE;
    }

    static PyObject *t_InputStream_mark(t_InputStream *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.mark(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "mark", arg);
      return NULL;
    }

    static PyObject *t_InputStream_markSupported(t_InputStream *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.markSupported());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_InputStream_read(t_InputStream *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          jint result;
          OBJ_CALL(result = self->object.read());
          return PyLong_FromLong((long) result);
        }
        break;
       case 1:
        {
          JArray< jbyte > a0((jobject) NULL);
          jint result;

          if (!parseArgs(args, "[B", &a0))
          {
            OBJ_CALL(result = self->object.read(a0));
            return PyLong_FromLong((long) result);
          }
        }
        break;
       case 3:
        {
          JArray< jbyte > a0((jobject) NULL);
          jint a1;
          jint a2;
          jint result;

          if (!parseArgs(args, "[BII", &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.read(a0, a1, a2));
            return PyLong_FromLong((long) result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "read", args);
      return NULL;
    }

    static PyObject *t_InputStream_reset(t_InputStream *self)
    {
      OBJ_CALL(self->object.reset());
      Py_RETURN_NONE;
    }

    static PyObject *t_InputStream_skip(t_InputStream *self, PyObject *arg)
    {
      jlong a0;
      jlong result;

      if (!parseArg(arg, "J", &a0))
      {
        OBJ_CALL(result = self->object.skip(a0));
        return PyLong_FromLongLong((PY_LONG_LONG) result);
      }

      PyErr_SetArgsError((PyObject *) self, "skip", arg);
      return NULL;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/LongToDoubleFunction.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *LongToDoubleFunction::class$ = NULL;
      jmethodID *LongToDoubleFunction::mids$ = NULL;
      bool LongToDoubleFunction::live$ = false;

      jclass LongToDoubleFunction::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/LongToDoubleFunction");

          mids$ = new jmethodID[max_mid];
          mids$[mid_applyAsDouble_d0db46799f607804] = env->getMethodID(cls, "applyAsDouble", "(J)D");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jdouble LongToDoubleFunction::applyAsDouble(jlong a0) const
      {
        return env->callDoubleMethod(this$, mids$[mid_applyAsDouble_d0db46799f607804], a0);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_LongToDoubleFunction_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_LongToDoubleFunction_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_LongToDoubleFunction_applyAsDouble(t_LongToDoubleFunction *self, PyObject *arg);

      static PyMethodDef t_LongToDoubleFunction__methods_[] = {
        DECLARE_METHOD(t_LongToDoubleFunction, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_LongToDoubleFunction, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_LongToDoubleFunction, applyAsDouble, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(LongToDoubleFunction)[] = {
        { Py_tp_methods, t_LongToDoubleFunction__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(LongToDoubleFunction)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(LongToDoubleFunction, t_LongToDoubleFunction, LongToDoubleFunction);

      void t_LongToDoubleFunction::install(PyObject *module)
      {
        installType(&PY_TYPE(LongToDoubleFunction), &PY_TYPE_DEF(LongToDoubleFunction), module, "LongToDoubleFunction", 0);
      }

      void t_LongToDoubleFunction::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(LongToDoubleFunction), "class_", make_descriptor(LongToDoubleFunction::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(LongToDoubleFunction), "wrapfn_", make_descriptor(t_LongToDoubleFunction::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(LongToDoubleFunction), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_LongToDoubleFunction_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, LongToDoubleFunction::initializeClass, 1)))
          return NULL;
        return t_LongToDoubleFunction::wrap_Object(LongToDoubleFunction(((t_LongToDoubleFunction *) arg)->object.this$));
      }
      static PyObject *t_LongToDoubleFunction_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, LongToDoubleFunction::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_LongToDoubleFunction_applyAsDouble(t_LongToDoubleFunction *self, PyObject *arg)
      {
        jlong a0;
        jdouble result;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(result = self->object.applyAsDouble(a0));
          return PyFloat_FromDouble((double) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsDouble", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Locale.h"
#include "java/util/Collection.h"
#include "java/util/Locale$LanguageRange.h"
#include "java/lang/Cloneable.h"
#include "java/util/MissingResourceException.h"
#include "java/lang/Class.h"
#include "java/util/Locale$Category.h"
#include "java/util/Locale$FilteringMode.h"
#include "java/util/Locale.h"
#include "java/lang/Character.h"
#include "java/lang/String.h"
#include "java/util/Set.h"
#include "java/util/List.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Locale::class$ = NULL;
    jmethodID *Locale::mids$ = NULL;
    bool Locale::live$ = false;
    Locale *Locale::CANADA = NULL;
    Locale *Locale::CANADA_FRENCH = NULL;
    Locale *Locale::CHINA = NULL;
    Locale *Locale::CHINESE = NULL;
    Locale *Locale::ENGLISH = NULL;
    Locale *Locale::FRANCE = NULL;
    Locale *Locale::FRENCH = NULL;
    Locale *Locale::GERMAN = NULL;
    Locale *Locale::GERMANY = NULL;
    Locale *Locale::ITALIAN = NULL;
    Locale *Locale::ITALY = NULL;
    Locale *Locale::JAPAN = NULL;
    Locale *Locale::JAPANESE = NULL;
    Locale *Locale::KOREA = NULL;
    Locale *Locale::KOREAN = NULL;
    Locale *Locale::PRC = NULL;
    jchar Locale::PRIVATE_USE_EXTENSION = (jchar) 0;
    Locale *Locale::ROOT = NULL;
    Locale *Locale::SIMPLIFIED_CHINESE = NULL;
    Locale *Locale::TAIWAN = NULL;
    Locale *Locale::TRADITIONAL_CHINESE = NULL;
    Locale *Locale::UK = NULL;
    jchar Locale::UNICODE_LOCALE_EXTENSION = (jchar) 0;
    Locale *Locale::US = NULL;

    jclass Locale::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Locale");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_15b72f6a44ff93f2] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");
        mids$[mid_init$_f05031826564616f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");
        mids$[mid_clone_d6bcd06f3102c4d9] = env->getMethodID(cls, "clone", "()Ljava/lang/Object;");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_filter_329fdf8ab4752674] = env->getStaticMethodID(cls, "filter", "(Ljava/util/List;Ljava/util/Collection;)Ljava/util/List;");
        mids$[mid_filter_076912a206f80f12] = env->getStaticMethodID(cls, "filter", "(Ljava/util/List;Ljava/util/Collection;Ljava/util/Locale$FilteringMode;)Ljava/util/List;");
        mids$[mid_filterTags_329fdf8ab4752674] = env->getStaticMethodID(cls, "filterTags", "(Ljava/util/List;Ljava/util/Collection;)Ljava/util/List;");
        mids$[mid_filterTags_076912a206f80f12] = env->getStaticMethodID(cls, "filterTags", "(Ljava/util/List;Ljava/util/Collection;Ljava/util/Locale$FilteringMode;)Ljava/util/List;");
        mids$[mid_forLanguageTag_08922c4718a69f3b] = env->getStaticMethodID(cls, "forLanguageTag", "(Ljava/lang/String;)Ljava/util/Locale;");
        mids$[mid_getAvailableLocales_9de0c9f607235a40] = env->getStaticMethodID(cls, "getAvailableLocales", "()[Ljava/util/Locale;");
        mids$[mid_getCountry_db9b55ba01e03e4b] = env->getMethodID(cls, "getCountry", "()Ljava/lang/String;");
        mids$[mid_getDefault_bd9770023d5e622d] = env->getStaticMethodID(cls, "getDefault", "()Ljava/util/Locale;");
        mids$[mid_getDefault_bedcaca914099631] = env->getStaticMethodID(cls, "getDefault", "(Ljava/util/Locale$Category;)Ljava/util/Locale;");
        mids$[mid_getDisplayCountry_db9b55ba01e03e4b] = env->getMethodID(cls, "getDisplayCountry", "()Ljava/lang/String;");
        mids$[mid_getDisplayCountry_8cbdae2bb55ad99c] = env->getMethodID(cls, "getDisplayCountry", "(Ljava/util/Locale;)Ljava/lang/String;");
        mids$[mid_getDisplayLanguage_db9b55ba01e03e4b] = env->getMethodID(cls, "getDisplayLanguage", "()Ljava/lang/String;");
        mids$[mid_getDisplayLanguage_8cbdae2bb55ad99c] = env->getMethodID(cls, "getDisplayLanguage", "(Ljava/util/Locale;)Ljava/lang/String;");
        mids$[mid_getDisplayName_db9b55ba01e03e4b] = env->getMethodID(cls, "getDisplayName", "()Ljava/lang/String;");
        mids$[mid_getDisplayName_8cbdae2bb55ad99c] = env->getMethodID(cls, "getDisplayName", "(Ljava/util/Locale;)Ljava/lang/String;");
        mids$[mid_getDisplayScript_db9b55ba01e03e4b] = env->getMethodID(cls, "getDisplayScript", "()Ljava/lang/String;");
        mids$[mid_getDisplayScript_8cbdae2bb55ad99c] = env->getMethodID(cls, "getDisplayScript", "(Ljava/util/Locale;)Ljava/lang/String;");
        mids$[mid_getDisplayVariant_db9b55ba01e03e4b] = env->getMethodID(cls, "getDisplayVariant", "()Ljava/lang/String;");
        mids$[mid_getDisplayVariant_8cbdae2bb55ad99c] = env->getMethodID(cls, "getDisplayVariant", "(Ljava/util/Locale;)Ljava/lang/String;");
        mids$[mid_getExtension_4bb5e6191c541c0d] = env->getMethodID(cls, "getExtension", "(C)Ljava/lang/String;");
        mids$[mid_getExtensionKeys_7dcf4034c6d1a92a] = env->getMethodID(cls, "getExtensionKeys", "()Ljava/util/Set;");
        mids$[mid_getISO3Country_db9b55ba01e03e4b] = env->getMethodID(cls, "getISO3Country", "()Ljava/lang/String;");
        mids$[mid_getISO3Language_db9b55ba01e03e4b] = env->getMethodID(cls, "getISO3Language", "()Ljava/lang/String;");
        mids$[mid_getISOCountries_9865da0b5ee490bc] = env->getStaticMethodID(cls, "getISOCountries", "()[Ljava/lang/String;");
        mids$[mid_getISOLanguages_9865da0b5ee490bc] = env->getStaticMethodID(cls, "getISOLanguages", "()[Ljava/lang/String;");
        mids$[mid_getLanguage_db9b55ba01e03e4b] = env->getMethodID(cls, "getLanguage", "()Ljava/lang/String;");
        mids$[mid_getScript_db9b55ba01e03e4b] = env->getMethodID(cls, "getScript", "()Ljava/lang/String;");
        mids$[mid_getUnicodeLocaleAttributes_7dcf4034c6d1a92a] = env->getMethodID(cls, "getUnicodeLocaleAttributes", "()Ljava/util/Set;");
        mids$[mid_getUnicodeLocaleKeys_7dcf4034c6d1a92a] = env->getMethodID(cls, "getUnicodeLocaleKeys", "()Ljava/util/Set;");
        mids$[mid_getUnicodeLocaleType_9bfa75c9f141b67f] = env->getMethodID(cls, "getUnicodeLocaleType", "(Ljava/lang/String;)Ljava/lang/String;");
        mids$[mid_getVariant_db9b55ba01e03e4b] = env->getMethodID(cls, "getVariant", "()Ljava/lang/String;");
        mids$[mid_hasExtensions_8454bd5aa23fd11e] = env->getMethodID(cls, "hasExtensions", "()Z");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_lookup_bf3cd24731d50409] = env->getStaticMethodID(cls, "lookup", "(Ljava/util/List;Ljava/util/Collection;)Ljava/util/Locale;");
        mids$[mid_lookupTag_8bb89dcc440c4b6b] = env->getStaticMethodID(cls, "lookupTag", "(Ljava/util/List;Ljava/util/Collection;)Ljava/lang/String;");
        mids$[mid_setDefault_8b005052a37adc8a] = env->getStaticMethodID(cls, "setDefault", "(Ljava/util/Locale;)V");
        mids$[mid_setDefault_52bb86de8933b4e4] = env->getStaticMethodID(cls, "setDefault", "(Ljava/util/Locale$Category;Ljava/util/Locale;)V");
        mids$[mid_stripExtensions_bd9770023d5e622d] = env->getMethodID(cls, "stripExtensions", "()Ljava/util/Locale;");
        mids$[mid_toLanguageTag_db9b55ba01e03e4b] = env->getMethodID(cls, "toLanguageTag", "()Ljava/lang/String;");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        CANADA = new Locale(env->getStaticObjectField(cls, "CANADA", "Ljava/util/Locale;"));
        CANADA_FRENCH = new Locale(env->getStaticObjectField(cls, "CANADA_FRENCH", "Ljava/util/Locale;"));
        CHINA = new Locale(env->getStaticObjectField(cls, "CHINA", "Ljava/util/Locale;"));
        CHINESE = new Locale(env->getStaticObjectField(cls, "CHINESE", "Ljava/util/Locale;"));
        ENGLISH = new Locale(env->getStaticObjectField(cls, "ENGLISH", "Ljava/util/Locale;"));
        FRANCE = new Locale(env->getStaticObjectField(cls, "FRANCE", "Ljava/util/Locale;"));
        FRENCH = new Locale(env->getStaticObjectField(cls, "FRENCH", "Ljava/util/Locale;"));
        GERMAN = new Locale(env->getStaticObjectField(cls, "GERMAN", "Ljava/util/Locale;"));
        GERMANY = new Locale(env->getStaticObjectField(cls, "GERMANY", "Ljava/util/Locale;"));
        ITALIAN = new Locale(env->getStaticObjectField(cls, "ITALIAN", "Ljava/util/Locale;"));
        ITALY = new Locale(env->getStaticObjectField(cls, "ITALY", "Ljava/util/Locale;"));
        JAPAN = new Locale(env->getStaticObjectField(cls, "JAPAN", "Ljava/util/Locale;"));
        JAPANESE = new Locale(env->getStaticObjectField(cls, "JAPANESE", "Ljava/util/Locale;"));
        KOREA = new Locale(env->getStaticObjectField(cls, "KOREA", "Ljava/util/Locale;"));
        KOREAN = new Locale(env->getStaticObjectField(cls, "KOREAN", "Ljava/util/Locale;"));
        PRC = new Locale(env->getStaticObjectField(cls, "PRC", "Ljava/util/Locale;"));
        PRIVATE_USE_EXTENSION = env->getStaticCharField(cls, "PRIVATE_USE_EXTENSION");
        ROOT = new Locale(env->getStaticObjectField(cls, "ROOT", "Ljava/util/Locale;"));
        SIMPLIFIED_CHINESE = new Locale(env->getStaticObjectField(cls, "SIMPLIFIED_CHINESE", "Ljava/util/Locale;"));
        TAIWAN = new Locale(env->getStaticObjectField(cls, "TAIWAN", "Ljava/util/Locale;"));
        TRADITIONAL_CHINESE = new Locale(env->getStaticObjectField(cls, "TRADITIONAL_CHINESE", "Ljava/util/Locale;"));
        UK = new Locale(env->getStaticObjectField(cls, "UK", "Ljava/util/Locale;"));
        UNICODE_LOCALE_EXTENSION = env->getStaticCharField(cls, "UNICODE_LOCALE_EXTENSION");
        US = new Locale(env->getStaticObjectField(cls, "US", "Ljava/util/Locale;"));
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Locale::Locale(const ::java::lang::String & a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    Locale::Locale(const ::java::lang::String & a0, const ::java::lang::String & a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_15b72f6a44ff93f2, a0.this$, a1.this$)) {}

    Locale::Locale(const ::java::lang::String & a0, const ::java::lang::String & a1, const ::java::lang::String & a2) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f05031826564616f, a0.this$, a1.this$, a2.this$)) {}

    ::java::lang::Object Locale::clone() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_clone_d6bcd06f3102c4d9]));
    }

    jboolean Locale::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::util::List Locale::filter(const ::java::util::List & a0, const ::java::util::Collection & a1)
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::util::List(env->callStaticObjectMethod(cls, mids$[mid_filter_329fdf8ab4752674], a0.this$, a1.this$));
    }

    ::java::util::List Locale::filter(const ::java::util::List & a0, const ::java::util::Collection & a1, const ::java::util::Locale$FilteringMode & a2)
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::util::List(env->callStaticObjectMethod(cls, mids$[mid_filter_076912a206f80f12], a0.this$, a1.this$, a2.this$));
    }

    ::java::util::List Locale::filterTags(const ::java::util::List & a0, const ::java::util::Collection & a1)
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::util::List(env->callStaticObjectMethod(cls, mids$[mid_filterTags_329fdf8ab4752674], a0.this$, a1.this$));
    }

    ::java::util::List Locale::filterTags(const ::java::util::List & a0, const ::java::util::Collection & a1, const ::java::util::Locale$FilteringMode & a2)
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::util::List(env->callStaticObjectMethod(cls, mids$[mid_filterTags_076912a206f80f12], a0.this$, a1.this$, a2.this$));
    }

    Locale Locale::forLanguageTag(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Locale(env->callStaticObjectMethod(cls, mids$[mid_forLanguageTag_08922c4718a69f3b], a0.this$));
    }

    JArray< Locale > Locale::getAvailableLocales()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< Locale >(env->callStaticObjectMethod(cls, mids$[mid_getAvailableLocales_9de0c9f607235a40]));
    }

    ::java::lang::String Locale::getCountry() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getCountry_db9b55ba01e03e4b]));
    }

    Locale Locale::getDefault()
    {
      jclass cls = env->getClass(initializeClass);
      return Locale(env->callStaticObjectMethod(cls, mids$[mid_getDefault_bd9770023d5e622d]));
    }

    Locale Locale::getDefault(const ::java::util::Locale$Category & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Locale(env->callStaticObjectMethod(cls, mids$[mid_getDefault_bedcaca914099631], a0.this$));
    }

    ::java::lang::String Locale::getDisplayCountry() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayCountry_db9b55ba01e03e4b]));
    }

    ::java::lang::String Locale::getDisplayCountry(const Locale & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayCountry_8cbdae2bb55ad99c], a0.this$));
    }

    ::java::lang::String Locale::getDisplayLanguage() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayLanguage_db9b55ba01e03e4b]));
    }

    ::java::lang::String Locale::getDisplayLanguage(const Locale & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayLanguage_8cbdae2bb55ad99c], a0.this$));
    }

    ::java::lang::String Locale::getDisplayName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_db9b55ba01e03e4b]));
    }

    ::java::lang::String Locale::getDisplayName(const Locale & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_8cbdae2bb55ad99c], a0.this$));
    }

    ::java::lang::String Locale::getDisplayScript() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayScript_db9b55ba01e03e4b]));
    }

    ::java::lang::String Locale::getDisplayScript(const Locale & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayScript_8cbdae2bb55ad99c], a0.this$));
    }

    ::java::lang::String Locale::getDisplayVariant() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayVariant_db9b55ba01e03e4b]));
    }

    ::java::lang::String Locale::getDisplayVariant(const Locale & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayVariant_8cbdae2bb55ad99c], a0.this$));
    }

    ::java::lang::String Locale::getExtension(jchar a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getExtension_4bb5e6191c541c0d], a0));
    }

    ::java::util::Set Locale::getExtensionKeys() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_getExtensionKeys_7dcf4034c6d1a92a]));
    }

    ::java::lang::String Locale::getISO3Country() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getISO3Country_db9b55ba01e03e4b]));
    }

    ::java::lang::String Locale::getISO3Language() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getISO3Language_db9b55ba01e03e4b]));
    }

    JArray< ::java::lang::String > Locale::getISOCountries()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< ::java::lang::String >(env->callStaticObjectMethod(cls, mids$[mid_getISOCountries_9865da0b5ee490bc]));
    }

    JArray< ::java::lang::String > Locale::getISOLanguages()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< ::java::lang::String >(env->callStaticObjectMethod(cls, mids$[mid_getISOLanguages_9865da0b5ee490bc]));
    }

    ::java::lang::String Locale::getLanguage() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getLanguage_db9b55ba01e03e4b]));
    }

    ::java::lang::String Locale::getScript() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getScript_db9b55ba01e03e4b]));
    }

    ::java::util::Set Locale::getUnicodeLocaleAttributes() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_getUnicodeLocaleAttributes_7dcf4034c6d1a92a]));
    }

    ::java::util::Set Locale::getUnicodeLocaleKeys() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_getUnicodeLocaleKeys_7dcf4034c6d1a92a]));
    }

    ::java::lang::String Locale::getUnicodeLocaleType(const ::java::lang::String & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getUnicodeLocaleType_9bfa75c9f141b67f], a0.this$));
    }

    ::java::lang::String Locale::getVariant() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getVariant_db9b55ba01e03e4b]));
    }

    jboolean Locale::hasExtensions() const
    {
      return env->callBooleanMethod(this$, mids$[mid_hasExtensions_8454bd5aa23fd11e]);
    }

    jint Locale::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    Locale Locale::lookup(const ::java::util::List & a0, const ::java::util::Collection & a1)
    {
      jclass cls = env->getClass(initializeClass);
      return Locale(env->callStaticObjectMethod(cls, mids$[mid_lookup_bf3cd24731d50409], a0.this$, a1.this$));
    }

    ::java::lang::String Locale::lookupTag(const ::java::util::List & a0, const ::java::util::Collection & a1)
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::lang::String(env->callStaticObjectMethod(cls, mids$[mid_lookupTag_8bb89dcc440c4b6b], a0.this$, a1.this$));
    }

    void Locale::setDefault(const Locale & a0)
    {
      jclass cls = env->getClass(initializeClass);
      env->callStaticVoidMethod(cls, mids$[mid_setDefault_8b005052a37adc8a], a0.this$);
    }

    void Locale::setDefault(const ::java::util::Locale$Category & a0, const Locale & a1)
    {
      jclass cls = env->getClass(initializeClass);
      env->callStaticVoidMethod(cls, mids$[mid_setDefault_52bb86de8933b4e4], a0.this$, a1.this$);
    }

    Locale Locale::stripExtensions() const
    {
      return Locale(env->callObjectMethod(this$, mids$[mid_stripExtensions_bd9770023d5e622d]));
    }

    ::java::lang::String Locale::toLanguageTag() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toLanguageTag_db9b55ba01e03e4b]));
    }

    ::java::lang::String Locale::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Locale_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Locale_instance_(PyTypeObject *type, PyObject *arg);
    static int t_Locale_init_(t_Locale *self, PyObject *args, PyObject *kwds);
    static PyObject *t_Locale_clone(t_Locale *self);
    static PyObject *t_Locale_equals(t_Locale *self, PyObject *args);
    static PyObject *t_Locale_filter(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale_filterTags(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale_forLanguageTag(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Locale_getAvailableLocales(PyTypeObject *type);
    static PyObject *t_Locale_getCountry(t_Locale *self);
    static PyObject *t_Locale_getDefault(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale_getDisplayCountry(t_Locale *self, PyObject *args);
    static PyObject *t_Locale_getDisplayLanguage(t_Locale *self, PyObject *args);
    static PyObject *t_Locale_getDisplayName(t_Locale *self, PyObject *args);
    static PyObject *t_Locale_getDisplayScript(t_Locale *self, PyObject *args);
    static PyObject *t_Locale_getDisplayVariant(t_Locale *self, PyObject *args);
    static PyObject *t_Locale_getExtension(t_Locale *self, PyObject *arg);
    static PyObject *t_Locale_getExtensionKeys(t_Locale *self);
    static PyObject *t_Locale_getISO3Country(t_Locale *self);
    static PyObject *t_Locale_getISO3Language(t_Locale *self);
    static PyObject *t_Locale_getISOCountries(PyTypeObject *type);
    static PyObject *t_Locale_getISOLanguages(PyTypeObject *type);
    static PyObject *t_Locale_getLanguage(t_Locale *self);
    static PyObject *t_Locale_getScript(t_Locale *self);
    static PyObject *t_Locale_getUnicodeLocaleAttributes(t_Locale *self);
    static PyObject *t_Locale_getUnicodeLocaleKeys(t_Locale *self);
    static PyObject *t_Locale_getUnicodeLocaleType(t_Locale *self, PyObject *arg);
    static PyObject *t_Locale_getVariant(t_Locale *self);
    static PyObject *t_Locale_hasExtensions(t_Locale *self);
    static PyObject *t_Locale_hashCode(t_Locale *self, PyObject *args);
    static PyObject *t_Locale_lookup(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale_lookupTag(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale_setDefault(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale_stripExtensions(t_Locale *self);
    static PyObject *t_Locale_toLanguageTag(t_Locale *self);
    static PyObject *t_Locale_toString(t_Locale *self, PyObject *args);
    static PyObject *t_Locale_get__availableLocales(t_Locale *self, void *data);
    static PyObject *t_Locale_get__country(t_Locale *self, void *data);
    static PyObject *t_Locale_get__default(t_Locale *self, void *data);
    static int t_Locale_set__default(t_Locale *self, PyObject *arg, void *data);
    static PyObject *t_Locale_get__displayCountry(t_Locale *self, void *data);
    static PyObject *t_Locale_get__displayLanguage(t_Locale *self, void *data);
    static PyObject *t_Locale_get__displayName(t_Locale *self, void *data);
    static PyObject *t_Locale_get__displayScript(t_Locale *self, void *data);
    static PyObject *t_Locale_get__displayVariant(t_Locale *self, void *data);
    static PyObject *t_Locale_get__extensionKeys(t_Locale *self, void *data);
    static PyObject *t_Locale_get__iSO3Country(t_Locale *self, void *data);
    static PyObject *t_Locale_get__iSO3Language(t_Locale *self, void *data);
    static PyObject *t_Locale_get__iSOCountries(t_Locale *self, void *data);
    static PyObject *t_Locale_get__iSOLanguages(t_Locale *self, void *data);
    static PyObject *t_Locale_get__language(t_Locale *self, void *data);
    static PyObject *t_Locale_get__script(t_Locale *self, void *data);
    static PyObject *t_Locale_get__unicodeLocaleAttributes(t_Locale *self, void *data);
    static PyObject *t_Locale_get__unicodeLocaleKeys(t_Locale *self, void *data);
    static PyObject *t_Locale_get__variant(t_Locale *self, void *data);
    static PyGetSetDef t_Locale__fields_[] = {
      DECLARE_GET_FIELD(t_Locale, availableLocales),
      DECLARE_GET_FIELD(t_Locale, country),
      DECLARE_GETSET_FIELD(t_Locale, default),
      DECLARE_GET_FIELD(t_Locale, displayCountry),
      DECLARE_GET_FIELD(t_Locale, displayLanguage),
      DECLARE_GET_FIELD(t_Locale, displayName),
      DECLARE_GET_FIELD(t_Locale, displayScript),
      DECLARE_GET_FIELD(t_Locale, displayVariant),
      DECLARE_GET_FIELD(t_Locale, extensionKeys),
      DECLARE_GET_FIELD(t_Locale, iSO3Country),
      DECLARE_GET_FIELD(t_Locale, iSO3Language),
      DECLARE_GET_FIELD(t_Locale, iSOCountries),
      DECLARE_GET_FIELD(t_Locale, iSOLanguages),
      DECLARE_GET_FIELD(t_Locale, language),
      DECLARE_GET_FIELD(t_Locale, script),
      DECLARE_GET_FIELD(t_Locale, unicodeLocaleAttributes),
      DECLARE_GET_FIELD(t_Locale, unicodeLocaleKeys),
      DECLARE_GET_FIELD(t_Locale, variant),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Locale__methods_[] = {
      DECLARE_METHOD(t_Locale, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Locale, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Locale, clone, METH_NOARGS),
      DECLARE_METHOD(t_Locale, equals, METH_VARARGS),
      DECLARE_METHOD(t_Locale, filter, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale, filterTags, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale, forLanguageTag, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Locale, getAvailableLocales, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale, getCountry, METH_NOARGS),
      DECLARE_METHOD(t_Locale, getDefault, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale, getDisplayCountry, METH_VARARGS),
      DECLARE_METHOD(t_Locale, getDisplayLanguage, METH_VARARGS),
      DECLARE_METHOD(t_Locale, getDisplayName, METH_VARARGS),
      DECLARE_METHOD(t_Locale, getDisplayScript, METH_VARARGS),
      DECLARE_METHOD(t_Locale, getDisplayVariant, METH_VARARGS),
      DECLARE_METHOD(t_Locale, getExtension, METH_O),
      DECLARE_METHOD(t_Locale, getExtensionKeys, METH_NOARGS),
      DECLARE_METHOD(t_Locale, getISO3Country, METH_NOARGS),
      DECLARE_METHOD(t_Locale, getISO3Language, METH_NOARGS),
      DECLARE_METHOD(t_Locale, getISOCountries, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale, getISOLanguages, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale, getLanguage, METH_NOARGS),
      DECLARE_METHOD(t_Locale, getScript, METH_NOARGS),
      DECLARE_METHOD(t_Locale, getUnicodeLocaleAttributes, METH_NOARGS),
      DECLARE_METHOD(t_Locale, getUnicodeLocaleKeys, METH_NOARGS),
      DECLARE_METHOD(t_Locale, getUnicodeLocaleType, METH_O),
      DECLARE_METHOD(t_Locale, getVariant, METH_NOARGS),
      DECLARE_METHOD(t_Locale, hasExtensions, METH_NOARGS),
      DECLARE_METHOD(t_Locale, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_Locale, lookup, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale, lookupTag, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale, setDefault, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale, stripExtensions, METH_NOARGS),
      DECLARE_METHOD(t_Locale, toLanguageTag, METH_NOARGS),
      DECLARE_METHOD(t_Locale, toString, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Locale)[] = {
      { Py_tp_methods, t_Locale__methods_ },
      { Py_tp_init, (void *) t_Locale_init_ },
      { Py_tp_getset, t_Locale__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Locale)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Locale, t_Locale, Locale);

    void t_Locale::install(PyObject *module)
    {
      installType(&PY_TYPE(Locale), &PY_TYPE_DEF(Locale), module, "Locale", 0);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "LanguageRange", make_descriptor(&PY_TYPE_DEF(Locale$LanguageRange)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "FilteringMode", make_descriptor(&PY_TYPE_DEF(Locale$FilteringMode)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "Category", make_descriptor(&PY_TYPE_DEF(Locale$Category)));
    }

    void t_Locale::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "class_", make_descriptor(Locale::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "wrapfn_", make_descriptor(t_Locale::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "boxfn_", make_descriptor(boxObject));
      env->getClass(Locale::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "CANADA", make_descriptor(t_Locale::wrap_Object(*Locale::CANADA)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "CANADA_FRENCH", make_descriptor(t_Locale::wrap_Object(*Locale::CANADA_FRENCH)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "CHINA", make_descriptor(t_Locale::wrap_Object(*Locale::CHINA)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "CHINESE", make_descriptor(t_Locale::wrap_Object(*Locale::CHINESE)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "ENGLISH", make_descriptor(t_Locale::wrap_Object(*Locale::ENGLISH)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "FRANCE", make_descriptor(t_Locale::wrap_Object(*Locale::FRANCE)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "FRENCH", make_descriptor(t_Locale::wrap_Object(*Locale::FRENCH)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "GERMAN", make_descriptor(t_Locale::wrap_Object(*Locale::GERMAN)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "GERMANY", make_descriptor(t_Locale::wrap_Object(*Locale::GERMANY)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "ITALIAN", make_descriptor(t_Locale::wrap_Object(*Locale::ITALIAN)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "ITALY", make_descriptor(t_Locale::wrap_Object(*Locale::ITALY)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "JAPAN", make_descriptor(t_Locale::wrap_Object(*Locale::JAPAN)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "JAPANESE", make_descriptor(t_Locale::wrap_Object(*Locale::JAPANESE)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "KOREA", make_descriptor(t_Locale::wrap_Object(*Locale::KOREA)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "KOREAN", make_descriptor(t_Locale::wrap_Object(*Locale::KOREAN)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "PRC", make_descriptor(t_Locale::wrap_Object(*Locale::PRC)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "PRIVATE_USE_EXTENSION", make_descriptor(Locale::PRIVATE_USE_EXTENSION));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "ROOT", make_descriptor(t_Locale::wrap_Object(*Locale::ROOT)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "SIMPLIFIED_CHINESE", make_descriptor(t_Locale::wrap_Object(*Locale::SIMPLIFIED_CHINESE)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "TAIWAN", make_descriptor(t_Locale::wrap_Object(*Locale::TAIWAN)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "TRADITIONAL_CHINESE", make_descriptor(t_Locale::wrap_Object(*Locale::TRADITIONAL_CHINESE)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "UK", make_descriptor(t_Locale::wrap_Object(*Locale::UK)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "UNICODE_LOCALE_EXTENSION", make_descriptor(Locale::UNICODE_LOCALE_EXTENSION));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale), "US", make_descriptor(t_Locale::wrap_Object(*Locale::US)));
    }

    static PyObject *t_Locale_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Locale::initializeClass, 1)))
        return NULL;
      return t_Locale::wrap_Object(Locale(((t_Locale *) arg)->object.this$));
    }
    static PyObject *t_Locale_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Locale::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_Locale_init_(t_Locale *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          Locale object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = Locale(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          Locale object((jobject) NULL);

          if (!parseArgs(args, "ss", &a0, &a1))
          {
            INT_CALL(object = Locale(a0, a1));
            self->object = object;
            break;
          }
        }
        goto err;
       case 3:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          ::java::lang::String a2((jobject) NULL);
          Locale object((jobject) NULL);

          if (!parseArgs(args, "sss", &a0, &a1, &a2))
          {
            INT_CALL(object = Locale(a0, a1, a2));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_Locale_clone(t_Locale *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.clone());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Locale_equals(t_Locale *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Locale), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_Locale_filter(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::util::List a0((jobject) NULL);
          PyTypeObject **p0;
          ::java::util::Collection a1((jobject) NULL);
          PyTypeObject **p1;
          ::java::util::List result((jobject) NULL);

          if (!parseArgs(args, "KK", ::java::util::List::initializeClass, ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_List::parameters_, &a1, &p1, ::java::util::t_Collection::parameters_))
          {
            OBJ_CALL(result = ::java::util::Locale::filter(a0, a1));
            return ::java::util::t_List::wrap_Object(result, ::java::util::PY_TYPE(Locale));
          }
        }
        break;
       case 3:
        {
          ::java::util::List a0((jobject) NULL);
          PyTypeObject **p0;
          ::java::util::Collection a1((jobject) NULL);
          PyTypeObject **p1;
          ::java::util::Locale$FilteringMode a2((jobject) NULL);
          PyTypeObject **p2;
          ::java::util::List result((jobject) NULL);

          if (!parseArgs(args, "KKK", ::java::util::List::initializeClass, ::java::util::Collection::initializeClass, ::java::util::Locale$FilteringMode::initializeClass, &a0, &p0, ::java::util::t_List::parameters_, &a1, &p1, ::java::util::t_Collection::parameters_, &a2, &p2, ::java::util::t_Locale$FilteringMode::parameters_))
          {
            OBJ_CALL(result = ::java::util::Locale::filter(a0, a1, a2));
            return ::java::util::t_List::wrap_Object(result, ::java::util::PY_TYPE(Locale));
          }
        }
      }

      PyErr_SetArgsError(type, "filter", args);
      return NULL;
    }

    static PyObject *t_Locale_filterTags(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::util::List a0((jobject) NULL);
          PyTypeObject **p0;
          ::java::util::Collection a1((jobject) NULL);
          PyTypeObject **p1;
          ::java::util::List result((jobject) NULL);

          if (!parseArgs(args, "KK", ::java::util::List::initializeClass, ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_List::parameters_, &a1, &p1, ::java::util::t_Collection::parameters_))
          {
            OBJ_CALL(result = ::java::util::Locale::filterTags(a0, a1));
            return ::java::util::t_List::wrap_Object(result, ::java::lang::PY_TYPE(String));
          }
        }
        break;
       case 3:
        {
          ::java::util::List a0((jobject) NULL);
          PyTypeObject **p0;
          ::java::util::Collection a1((jobject) NULL);
          PyTypeObject **p1;
          ::java::util::Locale$FilteringMode a2((jobject) NULL);
          PyTypeObject **p2;
          ::java::util::List result((jobject) NULL);

          if (!parseArgs(args, "KKK", ::java::util::List::initializeClass, ::java::util::Collection::initializeClass, ::java::util::Locale$FilteringMode::initializeClass, &a0, &p0, ::java::util::t_List::parameters_, &a1, &p1, ::java::util::t_Collection::parameters_, &a2, &p2, ::java::util::t_Locale$FilteringMode::parameters_))
          {
            OBJ_CALL(result = ::java::util::Locale::filterTags(a0, a1, a2));
            return ::java::util::t_List::wrap_Object(result, ::java::lang::PY_TYPE(String));
          }
        }
      }

      PyErr_SetArgsError(type, "filterTags", args);
      return NULL;
    }

    static PyObject *t_Locale_forLanguageTag(PyTypeObject *type, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      Locale result((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = ::java::util::Locale::forLanguageTag(a0));
        return t_Locale::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "forLanguageTag", arg);
      return NULL;
    }

    static PyObject *t_Locale_getAvailableLocales(PyTypeObject *type)
    {
      JArray< Locale > result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Locale::getAvailableLocales());
      return JArray<jobject>(result.this$).wrap(t_Locale::wrap_jobject);
    }

    static PyObject *t_Locale_getCountry(t_Locale *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getCountry());
      return j2p(result);
    }

    static PyObject *t_Locale_getDefault(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          Locale result((jobject) NULL);
          OBJ_CALL(result = ::java::util::Locale::getDefault());
          return t_Locale::wrap_Object(result);
        }
        break;
       case 1:
        {
          ::java::util::Locale$Category a0((jobject) NULL);
          PyTypeObject **p0;
          Locale result((jobject) NULL);

          if (!parseArgs(args, "K", ::java::util::Locale$Category::initializeClass, &a0, &p0, ::java::util::t_Locale$Category::parameters_))
          {
            OBJ_CALL(result = ::java::util::Locale::getDefault(a0));
            return t_Locale::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError(type, "getDefault", args);
      return NULL;
    }

    static PyObject *t_Locale_getDisplayCountry(t_Locale *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getDisplayCountry());
          return j2p(result);
        }
        break;
       case 1:
        {
          Locale a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "k", Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getDisplayCountry(a0));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getDisplayCountry", args);
      return NULL;
    }

    static PyObject *t_Locale_getDisplayLanguage(t_Locale *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getDisplayLanguage());
          return j2p(result);
        }
        break;
       case 1:
        {
          Locale a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "k", Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getDisplayLanguage(a0));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getDisplayLanguage", args);
      return NULL;
    }

    static PyObject *t_Locale_getDisplayName(t_Locale *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getDisplayName());
          return j2p(result);
        }
        break;
       case 1:
        {
          Locale a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "k", Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getDisplayName(a0));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getDisplayName", args);
      return NULL;
    }

    static PyObject *t_Locale_getDisplayScript(t_Locale *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getDisplayScript());
          return j2p(result);
        }
        break;
       case 1:
        {
          Locale a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "k", Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getDisplayScript(a0));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getDisplayScript", args);
      return NULL;
    }

    static PyObject *t_Locale_getDisplayVariant(t_Locale *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getDisplayVariant());
          return j2p(result);
        }
        break;
       case 1:
        {
          Locale a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "k", Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getDisplayVariant(a0));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getDisplayVariant", args);
      return NULL;
    }

    static PyObject *t_Locale_getExtension(t_Locale *self, PyObject *arg)
    {
      jchar a0;
      ::java::lang::String result((jobject) NULL);

      if (!parseArg(arg, "C", &a0))
      {
        OBJ_CALL(result = self->object.getExtension(a0));
        return j2p(result);
      }

      PyErr_SetArgsError((PyObject *) self, "getExtension", arg);
      return NULL;
    }

    static PyObject *t_Locale_getExtensionKeys(t_Locale *self)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = self->object.getExtensionKeys());
      return ::java::util::t_Set::wrap_Object(result, ::java::lang::PY_TYPE(Character));
    }

    static PyObject *t_Locale_getISO3Country(t_Locale *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getISO3Country());
      return j2p(result);
    }

    static PyObject *t_Locale_getISO3Language(t_Locale *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getISO3Language());
      return j2p(result);
    }

    static PyObject *t_Locale_getISOCountries(PyTypeObject *type)
    {
      JArray< ::java::lang::String > result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Locale::getISOCountries());
      return JArray<jstring>(result.this$).wrap();
    }

    static PyObject *t_Locale_getISOLanguages(PyTypeObject *type)
    {
      JArray< ::java::lang::String > result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Locale::getISOLanguages());
      return JArray<jstring>(result.this$).wrap();
    }

    static PyObject *t_Locale_getLanguage(t_Locale *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getLanguage());
      return j2p(result);
    }

    static PyObject *t_Locale_getScript(t_Locale *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getScript());
      return j2p(result);
    }

    static PyObject *t_Locale_getUnicodeLocaleAttributes(t_Locale *self)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = self->object.getUnicodeLocaleAttributes());
      return ::java::util::t_Set::wrap_Object(result, ::java::lang::PY_TYPE(String));
    }

    static PyObject *t_Locale_getUnicodeLocaleKeys(t_Locale *self)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = self->object.getUnicodeLocaleKeys());
      return ::java::util::t_Set::wrap_Object(result, ::java::lang::PY_TYPE(String));
    }

    static PyObject *t_Locale_getUnicodeLocaleType(t_Locale *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      ::java::lang::String result((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = self->object.getUnicodeLocaleType(a0));
        return j2p(result);
      }

      PyErr_SetArgsError((PyObject *) self, "getUnicodeLocaleType", arg);
      return NULL;
    }

    static PyObject *t_Locale_getVariant(t_Locale *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getVariant());
      return j2p(result);
    }

    static PyObject *t_Locale_hasExtensions(t_Locale *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.hasExtensions());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_Locale_hashCode(t_Locale *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Locale), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_Locale_lookup(PyTypeObject *type, PyObject *args)
    {
      ::java::util::List a0((jobject) NULL);
      PyTypeObject **p0;
      ::java::util::Collection a1((jobject) NULL);
      PyTypeObject **p1;
      Locale result((jobject) NULL);

      if (!parseArgs(args, "KK", ::java::util::List::initializeClass, ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_List::parameters_, &a1, &p1, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = ::java::util::Locale::lookup(a0, a1));
        return t_Locale::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "lookup", args);
      return NULL;
    }

    static PyObject *t_Locale_lookupTag(PyTypeObject *type, PyObject *args)
    {
      ::java::util::List a0((jobject) NULL);
      PyTypeObject **p0;
      ::java::util::Collection a1((jobject) NULL);
      PyTypeObject **p1;
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, "KK", ::java::util::List::initializeClass, ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_List::parameters_, &a1, &p1, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = ::java::util::Locale::lookupTag(a0, a1));
        return j2p(result);
      }

      PyErr_SetArgsError(type, "lookupTag", args);
      return NULL;
    }

    static PyObject *t_Locale_setDefault(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          Locale a0((jobject) NULL);

          if (!parseArgs(args, "k", Locale::initializeClass, &a0))
          {
            OBJ_CALL(::java::util::Locale::setDefault(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 2:
        {
          ::java::util::Locale$Category a0((jobject) NULL);
          PyTypeObject **p0;
          Locale a1((jobject) NULL);

          if (!parseArgs(args, "Kk", ::java::util::Locale$Category::initializeClass, Locale::initializeClass, &a0, &p0, ::java::util::t_Locale$Category::parameters_, &a1))
          {
            OBJ_CALL(::java::util::Locale::setDefault(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError(type, "setDefault", args);
      return NULL;
    }

    static PyObject *t_Locale_stripExtensions(t_Locale *self)
    {
      Locale result((jobject) NULL);
      OBJ_CALL(result = self->object.stripExtensions());
      return t_Locale::wrap_Object(result);
    }

    static PyObject *t_Locale_toLanguageTag(t_Locale *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.toLanguageTag());
      return j2p(result);
    }

    static PyObject *t_Locale_toString(t_Locale *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(Locale), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_Locale_get__availableLocales(t_Locale *self, void *data)
    {
      JArray< Locale > value((jobject) NULL);
      OBJ_CALL(value = self->object.getAvailableLocales());
      return JArray<jobject>(value.this$).wrap(t_Locale::wrap_jobject);
    }

    static PyObject *t_Locale_get__country(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getCountry());
      return j2p(value);
    }

    static PyObject *t_Locale_get__default(t_Locale *self, void *data)
    {
      Locale value((jobject) NULL);
      OBJ_CALL(value = self->object.getDefault());
      return t_Locale::wrap_Object(value);
    }
    static int t_Locale_set__default(t_Locale *self, PyObject *arg, void *data)
    {
      {
        Locale value((jobject) NULL);
        if (!parseArg(arg, "k", Locale::initializeClass, &value))
        {
          INT_CALL(self->object.setDefault(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "default", arg);
      return -1;
    }

    static PyObject *t_Locale_get__displayCountry(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getDisplayCountry());
      return j2p(value);
    }

    static PyObject *t_Locale_get__displayLanguage(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getDisplayLanguage());
      return j2p(value);
    }

    static PyObject *t_Locale_get__displayName(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getDisplayName());
      return j2p(value);
    }

    static PyObject *t_Locale_get__displayScript(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getDisplayScript());
      return j2p(value);
    }

    static PyObject *t_Locale_get__displayVariant(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getDisplayVariant());
      return j2p(value);
    }

    static PyObject *t_Locale_get__extensionKeys(t_Locale *self, void *data)
    {
      ::java::util::Set value((jobject) NULL);
      OBJ_CALL(value = self->object.getExtensionKeys());
      return ::java::util::t_Set::wrap_Object(value);
    }

    static PyObject *t_Locale_get__iSO3Country(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getISO3Country());
      return j2p(value);
    }

    static PyObject *t_Locale_get__iSO3Language(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getISO3Language());
      return j2p(value);
    }

    static PyObject *t_Locale_get__iSOCountries(t_Locale *self, void *data)
    {
      JArray< ::java::lang::String > value((jobject) NULL);
      OBJ_CALL(value = self->object.getISOCountries());
      return JArray<jstring>(value.this$).wrap();
    }

    static PyObject *t_Locale_get__iSOLanguages(t_Locale *self, void *data)
    {
      JArray< ::java::lang::String > value((jobject) NULL);
      OBJ_CALL(value = self->object.getISOLanguages());
      return JArray<jstring>(value.this$).wrap();
    }

    static PyObject *t_Locale_get__language(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getLanguage());
      return j2p(value);
    }

    static PyObject *t_Locale_get__script(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getScript());
      return j2p(value);
    }

    static PyObject *t_Locale_get__unicodeLocaleAttributes(t_Locale *self, void *data)
    {
      ::java::util::Set value((jobject) NULL);
      OBJ_CALL(value = self->object.getUnicodeLocaleAttributes());
      return ::java::util::t_Set::wrap_Object(value);
    }

    static PyObject *t_Locale_get__unicodeLocaleKeys(t_Locale *self, void *data)
    {
      ::java::util::Set value((jobject) NULL);
      OBJ_CALL(value = self->object.getUnicodeLocaleKeys());
      return ::java::util::t_Set::wrap_Object(value);
    }

    static PyObject *t_Locale_get__variant(t_Locale *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getVariant());
      return j2p(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/Closeable.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *Closeable::class$ = NULL;
    jmethodID *Closeable::mids$ = NULL;
    bool Closeable::live$ = false;

    jclass Closeable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/Closeable");

        mids$ = new jmethodID[max_mid];
        mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Closeable::close() const
    {
      env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_Closeable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Closeable_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Closeable_close(t_Closeable *self, PyObject *args);

    static PyMethodDef t_Closeable__methods_[] = {
      DECLARE_METHOD(t_Closeable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Closeable, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Closeable, close, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Closeable)[] = {
      { Py_tp_methods, t_Closeable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Closeable)[] = {
      &PY_TYPE_DEF(::java::lang::AutoCloseable),
      NULL
    };

    DEFINE_TYPE(Closeable, t_Closeable, Closeable);

    void t_Closeable::install(PyObject *module)
    {
      installType(&PY_TYPE(Closeable), &PY_TYPE_DEF(Closeable), module, "Closeable", 0);
    }

    void t_Closeable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Closeable), "class_", make_descriptor(Closeable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Closeable), "wrapfn_", make_descriptor(t_Closeable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Closeable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Closeable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Closeable::initializeClass, 1)))
        return NULL;
      return t_Closeable::wrap_Object(Closeable(((t_Closeable *) arg)->object.this$));
    }
    static PyObject *t_Closeable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Closeable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Closeable_close(t_Closeable *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.close());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(Closeable), (PyObject *) self, "close", args, 2);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/ExecutorService.h"
#include "java/util/Collection.h"
#include "java/util/List.h"
#include "java/lang/Class.h"
#include "java/util/concurrent/ExecutionException.h"
#include "java/lang/Object.h"
#include "java/lang/Runnable.h"
#include "java/util/concurrent/Future.h"
#include "java/util/concurrent/TimeoutException.h"
#include "java/lang/InterruptedException.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/util/concurrent/Callable.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *ExecutorService::class$ = NULL;
      jmethodID *ExecutorService::mids$ = NULL;
      bool ExecutorService::live$ = false;

      jclass ExecutorService::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/ExecutorService");

          mids$ = new jmethodID[max_mid];
          mids$[mid_awaitTermination_30164a42685760d2] = env->getMethodID(cls, "awaitTermination", "(JLjava/util/concurrent/TimeUnit;)Z");
          mids$[mid_invokeAll_a71e1c6683cd688a] = env->getMethodID(cls, "invokeAll", "(Ljava/util/Collection;)Ljava/util/List;");
          mids$[mid_invokeAll_cb2f9bf716428758] = env->getMethodID(cls, "invokeAll", "(Ljava/util/Collection;JLjava/util/concurrent/TimeUnit;)Ljava/util/List;");
          mids$[mid_invokeAny_f186668b4e43c778] = env->getMethodID(cls, "invokeAny", "(Ljava/util/Collection;)Ljava/lang/Object;");
          mids$[mid_invokeAny_1d5f23182fbe7c62] = env->getMethodID(cls, "invokeAny", "(Ljava/util/Collection;JLjava/util/concurrent/TimeUnit;)Ljava/lang/Object;");
          mids$[mid_isShutdown_8454bd5aa23fd11e] = env->getMethodID(cls, "isShutdown", "()Z");
          mids$[mid_isTerminated_8454bd5aa23fd11e] = env->getMethodID(cls, "isTerminated", "()Z");
          mids$[mid_shutdown_f2cc1bce94666404] = env->getMethodID(cls, "shutdown", "()V");
          mids$[mid_shutdownNow_49ec78390f08338a] = env->getMethodID(cls, "shutdownNow", "()Ljava/util/List;");
          mids$[mid_submit_a65cd5a637725e4b] = env->getMethodID(cls, "submit", "(Ljava/lang/Runnable;)Ljava/util/concurrent/Future;");
          mids$[mid_submit_4935160b38dd7a16] = env->getMethodID(cls, "submit", "(Ljava/util/concurrent/Callable;)Ljava/util/concurrent/Future;");
          mids$[mid_submit_d0c4b0810c5b0244] = env->getMethodID(cls, "submit", "(Ljava/lang/Runnable;Ljava/lang/Object;)Ljava/util/concurrent/Future;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jboolean ExecutorService::awaitTermination(jlong a0, const ::java::util::concurrent::TimeUnit & a1) const
      {
        return env->callBooleanMethod(this$, mids$[mid_awaitTermination_30164a42685760d2], a0, a1.this$);
      }

      ::java::util::List ExecutorService::invokeAll(const ::java::util::Collection & a0) const
      {
        return ::java::util::List(env->callObjectMethod(this$, mids$[mid_invokeAll_a71e1c6683cd688a], a0.this$));
      }

      ::java::util::List ExecutorService::invokeAll(const ::java::util::Collection & a0, jlong a1, const ::java::util::concurrent::TimeUnit & a2) const
      {
        return ::java::util::List(env->callObjectMethod(this$, mids$[mid_invokeAll_cb2f9bf716428758], a0.this$, a1, a2.this$));
      }

      ::java::lang::Object ExecutorService::invokeAny(const ::java::util::Collection & a0) const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_invokeAny_f186668b4e43c778], a0.this$));
      }

      ::java::lang::Object ExecutorService::invokeAny(const ::java::util::Collection & a0, jlong a1, const ::java::util::concurrent::TimeUnit & a2) const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_invokeAny_1d5f23182fbe7c62], a0.this$, a1, a2.this$));
      }

      jboolean ExecutorService::isShutdown() const
      {
        return env->callBooleanMethod(this$, mids$[mid_isShutdown_8454bd5aa23fd11e]);
      }

      jboolean ExecutorService::isTerminated() const
      {
        return env->callBooleanMethod(this$, mids$[mid_isTerminated_8454bd5aa23fd11e]);
      }

      void ExecutorService::shutdown() const
      {
        env->callVoidMethod(this$, mids$[mid_shutdown_f2cc1bce94666404]);
      }

      ::java::util::List ExecutorService::shutdownNow() const
      {
        return ::java::util::List(env->callObjectMethod(this$, mids$[mid_shutdownNow_49ec78390f08338a]));
      }

      ::java::util::concurrent::Future ExecutorService::submit(const ::java::lang::Runnable & a0) const
      {
        return ::java::util::concurrent::Future(env->callObjectMethod(this$, mids$[mid_submit_a65cd5a637725e4b], a0.this$));
      }

      ::java::util::concurrent::Future ExecutorService::submit(const ::java::util::concurrent::Callable & a0) const
      {
        return ::java::util::concurrent::Future(env->callObjectMethod(this$, mids$[mid_submit_4935160b38dd7a16], a0.this$));
      }

      ::java::util::concurrent::Future ExecutorService::submit(const ::java::lang::Runnable & a0, const ::java::lang::Object & a1) const
      {
        return ::java::util::concurrent::Future(env->callObjectMethod(this$, mids$[mid_submit_d0c4b0810c5b0244], a0.this$, a1.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_ExecutorService_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ExecutorService_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ExecutorService_awaitTermination(t_ExecutorService *self, PyObject *args);
      static PyObject *t_ExecutorService_invokeAll(t_ExecutorService *self, PyObject *args);
      static PyObject *t_ExecutorService_invokeAny(t_ExecutorService *self, PyObject *args);
      static PyObject *t_ExecutorService_isShutdown(t_ExecutorService *self);
      static PyObject *t_ExecutorService_isTerminated(t_ExecutorService *self);
      static PyObject *t_ExecutorService_shutdown(t_ExecutorService *self);
      static PyObject *t_ExecutorService_shutdownNow(t_ExecutorService *self);
      static PyObject *t_ExecutorService_submit(t_ExecutorService *self, PyObject *args);
      static PyObject *t_ExecutorService_get__terminated(t_ExecutorService *self, void *data);
      static PyGetSetDef t_ExecutorService__fields_[] = {
        DECLARE_GET_FIELD(t_ExecutorService, terminated),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_ExecutorService__methods_[] = {
        DECLARE_METHOD(t_ExecutorService, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ExecutorService, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ExecutorService, awaitTermination, METH_VARARGS),
        DECLARE_METHOD(t_ExecutorService, invokeAll, METH_VARARGS),
        DECLARE_METHOD(t_ExecutorService, invokeAny, METH_VARARGS),
        DECLARE_METHOD(t_ExecutorService, isShutdown, METH_NOARGS),
        DECLARE_METHOD(t_ExecutorService, isTerminated, METH_NOARGS),
        DECLARE_METHOD(t_ExecutorService, shutdown, METH_NOARGS),
        DECLARE_METHOD(t_ExecutorService, shutdownNow, METH_NOARGS),
        DECLARE_METHOD(t_ExecutorService, submit, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(ExecutorService)[] = {
        { Py_tp_methods, t_ExecutorService__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_ExecutorService__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(ExecutorService)[] = {
        &PY_TYPE_DEF(::java::util::concurrent::Executor),
        NULL
      };

      DEFINE_TYPE(ExecutorService, t_ExecutorService, ExecutorService);

      void t_ExecutorService::install(PyObject *module)
      {
        installType(&PY_TYPE(ExecutorService), &PY_TYPE_DEF(ExecutorService), module, "ExecutorService", 0);
      }

      void t_ExecutorService::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(ExecutorService), "class_", make_descriptor(ExecutorService::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ExecutorService), "wrapfn_", make_descriptor(t_ExecutorService::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ExecutorService), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_ExecutorService_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, ExecutorService::initializeClass, 1)))
          return NULL;
        return t_ExecutorService::wrap_Object(ExecutorService(((t_ExecutorService *) arg)->object.this$));
      }
      static PyObject *t_ExecutorService_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, ExecutorService::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_ExecutorService_awaitTermination(t_ExecutorService *self, PyObject *args)
      {
        jlong a0;
        ::java::util::concurrent::TimeUnit a1((jobject) NULL);
        PyTypeObject **p1;
        jboolean result;

        if (!parseArgs(args, "JK", ::java::util::concurrent::TimeUnit::initializeClass, &a0, &a1, &p1, ::java::util::concurrent::t_TimeUnit::parameters_))
        {
          OBJ_CALL(result = self->object.awaitTermination(a0, a1));
          Py_RETURN_BOOL(result);
        }

        PyErr_SetArgsError((PyObject *) self, "awaitTermination", args);
        return NULL;
      }

      static PyObject *t_ExecutorService_invokeAll(t_ExecutorService *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 1:
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            ::java::util::List result((jobject) NULL);

            if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.invokeAll(a0));
              return ::java::util::t_List::wrap_Object(result);
            }
          }
          break;
         case 3:
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jlong a1;
            ::java::util::concurrent::TimeUnit a2((jobject) NULL);
            PyTypeObject **p2;
            ::java::util::List result((jobject) NULL);

            if (!parseArgs(args, "KJK", ::java::util::Collection::initializeClass, ::java::util::concurrent::TimeUnit::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_, &a1, &a2, &p2, ::java::util::concurrent::t_TimeUnit::parameters_))
            {
              OBJ_CALL(result = self->object.invokeAll(a0, a1, a2));
              return ::java::util::t_List::wrap_Object(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "invokeAll", args);
        return NULL;
      }

      static PyObject *t_ExecutorService_invokeAny(t_ExecutorService *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 1:
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            ::java::lang::Object result((jobject) NULL);

            if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.invokeAny(a0));
              return p0 != NULL && p0[0] != NULL ? wrapType(p0[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
            }
          }
          break;
         case 3:
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jlong a1;
            ::java::util::concurrent::TimeUnit a2((jobject) NULL);
            PyTypeObject **p2;
            ::java::lang::Object result((jobject) NULL);

            if (!parseArgs(args, "KJK", ::java::util::Collection::initializeClass, ::java::util::concurrent::TimeUnit::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_, &a1, &a2, &p2, ::java::util::concurrent::t_TimeUnit::parameters_))
            {
              OBJ_CALL(result = self->object.invokeAny(a0, a1, a2));
              return p0 != NULL && p0[0] != NULL ? wrapType(p0[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "invokeAny", args);
        return NULL;
      }

      static PyObject *t_ExecutorService_isShutdown(t_ExecutorService *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.isShutdown());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_ExecutorService_isTerminated(t_ExecutorService *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.isTerminated());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_ExecutorService_shutdown(t_ExecutorService *self)
      {
        OBJ_CALL(self->object.shutdown());
        Py_RETURN_NONE;
      }

      static PyObject *t_ExecutorService_shutdownNow(t_ExecutorService *self)
      {
        ::java::util::List result((jobject) NULL);
        OBJ_CALL(result = self->object.shutdownNow());
        return ::java::util::t_List::wrap_Object(result, ::java::lang::PY_TYPE(Runnable));
      }

      static PyObject *t_ExecutorService_submit(t_ExecutorService *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 1:
          {
            ::java::lang::Runnable a0((jobject) NULL);
            ::java::util::concurrent::Future result((jobject) NULL);

            if (!parseArgs(args, "k", ::java::lang::Runnable::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.submit(a0));
              return ::java::util::concurrent::t_Future::wrap_Object(result);
            }
          }
          {
            ::java::util::concurrent::Callable a0((jobject) NULL);
            PyTypeObject **p0;
            ::java::util::concurrent::Future result((jobject) NULL);

            if (!parseArgs(args, "K", ::java::util::concurrent::Callable::initializeClass, &a0, &p0, ::java::util::concurrent::t_Callable::parameters_))
            {
              OBJ_CALL(result = self->object.submit(a0));
              return ::java::util::concurrent::t_Future::wrap_Object(result);
            }
          }
          break;
         case 2:
          {
            ::java::lang::Runnable a0((jobject) NULL);
            ::java::lang::Object a1((jobject) NULL);
            ::java::util::concurrent::Future result((jobject) NULL);

            if (!parseArgs(args, "ko", ::java::lang::Runnable::initializeClass, &a0, &a1))
            {
              OBJ_CALL(result = self->object.submit(a0, a1));
              return ::java::util::concurrent::t_Future::wrap_Object(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "submit", args);
        return NULL;
      }

      static PyObject *t_ExecutorService_get__terminated(t_ExecutorService *self, void *data)
      {
        jboolean value;
        OBJ_CALL(value = self->object.isTerminated());
        Py_RETURN_BOOL(value);
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/BufferedReader.h"
#include "java/io/IOException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *BufferedReader::class$ = NULL;
    jmethodID *BufferedReader::mids$ = NULL;
    bool BufferedReader::live$ = false;

    jclass BufferedReader::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/BufferedReader");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_b2f3c57f5e6eb3f2] = env->getMethodID(cls, "<init>", "(Ljava/io/Reader;)V");
        mids$[mid_init$_4ed213f23bd909e8] = env->getMethodID(cls, "<init>", "(Ljava/io/Reader;I)V");
        mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");
        mids$[mid_mark_040c4cd0390c5aff] = env->getMethodID(cls, "mark", "(I)V");
        mids$[mid_markSupported_8454bd5aa23fd11e] = env->getMethodID(cls, "markSupported", "()Z");
        mids$[mid_read_9972fcc56b44e79d] = env->getMethodID(cls, "read", "()I");
        mids$[mid_read_644fc0bf0aa7fb26] = env->getMethodID(cls, "read", "([CII)I");
        mids$[mid_readLine_db9b55ba01e03e4b] = env->getMethodID(cls, "readLine", "()Ljava/lang/String;");
        mids$[mid_ready_8454bd5aa23fd11e] = env->getMethodID(cls, "ready", "()Z");
        mids$[mid_reset_f2cc1bce94666404] = env->getMethodID(cls, "reset", "()V");
        mids$[mid_skip_d711eecdc469624a] = env->getMethodID(cls, "skip", "(J)J");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    BufferedReader::BufferedReader(const ::java::io::Reader & a0) : ::java::io::Reader(env->newObject(initializeClass, &mids$, mid_init$_b2f3c57f5e6eb3f2, a0.this$)) {}

    BufferedReader::BufferedReader(const ::java::io::Reader & a0, jint a1) : ::java::io::Reader(env->newObject(initializeClass, &mids$, mid_init$_4ed213f23bd909e8, a0.this$, a1)) {}

    void BufferedReader::close() const
    {
      env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
    }

    void BufferedReader::mark(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_mark_040c4cd0390c5aff], a0);
    }

    jboolean BufferedReader::markSupported() const
    {
      return env->callBooleanMethod(this$, mids$[mid_markSupported_8454bd5aa23fd11e]);
    }

    jint BufferedReader::read() const
    {
      return env->callIntMethod(this$, mids$[mid_read_9972fcc56b44e79d]);
    }

    jint BufferedReader::read(const JArray< jchar > & a0, jint a1, jint a2) const
    {
      return env->callIntMethod(this$, mids$[mid_read_644fc0bf0aa7fb26], a0.this$, a1, a2);
    }

    ::java::lang::String BufferedReader::readLine() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_readLine_db9b55ba01e03e4b]));
    }

    jboolean BufferedReader::ready() const
    {
      return env->callBooleanMethod(this$, mids$[mid_ready_8454bd5aa23fd11e]);
    }

    void BufferedReader::reset() const
    {
      env->callVoidMethod(this$, mids$[mid_reset_f2cc1bce94666404]);
    }

    jlong BufferedReader::skip(jlong a0) const
    {
      return env->callLongMethod(this$, mids$[mid_skip_d711eecdc469624a], a0);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_BufferedReader_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_BufferedReader_instance_(PyTypeObject *type, PyObject *arg);
    static int t_BufferedReader_init_(t_BufferedReader *self, PyObject *args, PyObject *kwds);
    static PyObject *t_BufferedReader_close(t_BufferedReader *self, PyObject *args);
    static PyObject *t_BufferedReader_mark(t_BufferedReader *self, PyObject *args);
    static PyObject *t_BufferedReader_markSupported(t_BufferedReader *self, PyObject *args);
    static PyObject *t_BufferedReader_read(t_BufferedReader *self, PyObject *args);
    static PyObject *t_BufferedReader_readLine(t_BufferedReader *self);
    static PyObject *t_BufferedReader_ready(t_BufferedReader *self, PyObject *args);
    static PyObject *t_BufferedReader_reset(t_BufferedReader *self, PyObject *args);
    static PyObject *t_BufferedReader_skip(t_BufferedReader *self, PyObject *args);

    static PyMethodDef t_BufferedReader__methods_[] = {
      DECLARE_METHOD(t_BufferedReader, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_BufferedReader, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_BufferedReader, close, METH_VARARGS),
      DECLARE_METHOD(t_BufferedReader, mark, METH_VARARGS),
      DECLARE_METHOD(t_BufferedReader, markSupported, METH_VARARGS),
      DECLARE_METHOD(t_BufferedReader, read, METH_VARARGS),
      DECLARE_METHOD(t_BufferedReader, readLine, METH_NOARGS),
      DECLARE_METHOD(t_BufferedReader, ready, METH_VARARGS),
      DECLARE_METHOD(t_BufferedReader, reset, METH_VARARGS),
      DECLARE_METHOD(t_BufferedReader, skip, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(BufferedReader)[] = {
      { Py_tp_methods, t_BufferedReader__methods_ },
      { Py_tp_init, (void *) t_BufferedReader_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(BufferedReader)[] = {
      &PY_TYPE_DEF(::java::io::Reader),
      NULL
    };

    DEFINE_TYPE(BufferedReader, t_BufferedReader, BufferedReader);

    void t_BufferedReader::install(PyObject *module)
    {
      installType(&PY_TYPE(BufferedReader), &PY_TYPE_DEF(BufferedReader), module, "BufferedReader", 0);
    }

    void t_BufferedReader::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(BufferedReader), "class_", make_descriptor(BufferedReader::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(BufferedReader), "wrapfn_", make_descriptor(t_BufferedReader::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(BufferedReader), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_BufferedReader_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, BufferedReader::initializeClass, 1)))
        return NULL;
      return t_BufferedReader::wrap_Object(BufferedReader(((t_BufferedReader *) arg)->object.this$));
    }
    static PyObject *t_BufferedReader_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, BufferedReader::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_BufferedReader_init_(t_BufferedReader *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::io::Reader a0((jobject) NULL);
          BufferedReader object((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::Reader::initializeClass, &a0))
          {
            INT_CALL(object = BufferedReader(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::io::Reader a0((jobject) NULL);
          jint a1;
          BufferedReader object((jobject) NULL);

          if (!parseArgs(args, "kI", ::java::io::Reader::initializeClass, &a0, &a1))
          {
            INT_CALL(object = BufferedReader(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_BufferedReader_close(t_BufferedReader *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.close());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(BufferedReader), (PyObject *) self, "close", args, 2);
    }

    static PyObject *t_BufferedReader_mark(t_BufferedReader *self, PyObject *args)
    {
      jint a0;

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(self->object.mark(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(BufferedReader), (PyObject *) self, "mark", args, 2);
    }

    static PyObject *t_BufferedReader_markSupported(t_BufferedReader *self, PyObject *args)
    {
      jboolean result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.markSupported());
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(BufferedReader), (PyObject *) self, "markSupported", args, 2);
    }

    static PyObject *t_BufferedReader_read(t_BufferedReader *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          jint result;
          OBJ_CALL(result = self->object.read());
          return PyLong_FromLong((long) result);
        }
        break;
       case 3:
        {
          JArray< jchar > a0((jobject) NULL);
          jint a1;
          jint a2;
          jint result;

          if (!parseArgs(args, "[CII", &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.read(a0, a1, a2));
            return PyLong_FromLong((long) result);
          }
        }
      }

      return callSuper(PY_TYPE(BufferedReader), (PyObject *) self, "read", args, 2);
    }

    static PyObject *t_BufferedReader_readLine(t_BufferedReader *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.readLine());
      return j2p(result);
    }

    static PyObject *t_BufferedReader_ready(t_BufferedReader *self, PyObject *args)
    {
      jboolean result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.ready());
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(BufferedReader), (PyObject *) self, "ready", args, 2);
    }

    static PyObject *t_BufferedReader_reset(t_BufferedReader *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.reset());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(BufferedReader), (PyObject *) self, "reset", args, 2);
    }

    static PyObject *t_BufferedReader_skip(t_BufferedReader *self, PyObject *args)
    {
      jlong a0;
      jlong result;

      if (!parseArgs(args, "J", &a0))
      {
        OBJ_CALL(result = self->object.skip(a0));
        return PyLong_FromLongLong((PY_LONG_LONG) result);
      }

      return callSuper(PY_TYPE(BufferedReader), (PyObject *) self, "skip", args, 2);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/AbstractStringBuilder.h"
#include "java/lang/Class.h"
#include "java/lang/CharSequence.h"
#include "java/lang/String.h"
#include "java/lang/Appendable.h"
#include "java/lang/StringBuffer.h"
#include "java/lang/AbstractStringBuilder.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *AbstractStringBuilder::class$ = NULL;
    jmethodID *AbstractStringBuilder::mids$ = NULL;
    bool AbstractStringBuilder::live$ = false;

    jclass AbstractStringBuilder::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/AbstractStringBuilder");

        mids$ = new jmethodID[max_mid];
        mids$[mid_append_e2002d37cf3da336] = env->getMethodID(cls, "append", "(Ljava/lang/StringBuffer;)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_6f8380202126be56] = env->getMethodID(cls, "append", "([C)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_0675466a49f2c0ba] = env->getMethodID(cls, "append", "(Ljava/lang/String;)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_6e3f56662365cdf7] = env->getMethodID(cls, "append", "(Z)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_ec61606ad7d3bac3] = env->getMethodID(cls, "append", "(C)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_44637512db686cff] = env->getMethodID(cls, "append", "(D)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_6457f1cb386e42c9] = env->getMethodID(cls, "append", "(F)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_f5d0029a591c2dd0] = env->getMethodID(cls, "append", "(I)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_6a2e33fb9a81b110] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_021e9fd1072a4d34] = env->getMethodID(cls, "append", "(Ljava/lang/Object;)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_fbbe51b2eb6efd3b] = env->getMethodID(cls, "append", "(J)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_f0a7723684849e55] = env->getMethodID(cls, "append", "([CII)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_append_f6a857741bd25118] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;II)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_appendCodePoint_f5d0029a591c2dd0] = env->getMethodID(cls, "appendCodePoint", "(I)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_capacity_9972fcc56b44e79d] = env->getMethodID(cls, "capacity", "()I");
        mids$[mid_charAt_ebc61ec1e57770d1] = env->getMethodID(cls, "charAt", "(I)C");
        mids$[mid_codePointAt_1e143afe1894d213] = env->getMethodID(cls, "codePointAt", "(I)I");
        mids$[mid_codePointBefore_1e143afe1894d213] = env->getMethodID(cls, "codePointBefore", "(I)I");
        mids$[mid_codePointCount_57a58545eba514db] = env->getMethodID(cls, "codePointCount", "(II)I");
        mids$[mid_delete_619abd4749e7d1c9] = env->getMethodID(cls, "delete", "(II)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_deleteCharAt_f5d0029a591c2dd0] = env->getMethodID(cls, "deleteCharAt", "(I)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_ensureCapacity_040c4cd0390c5aff] = env->getMethodID(cls, "ensureCapacity", "(I)V");
        mids$[mid_getChars_520fb522c03f2e69] = env->getMethodID(cls, "getChars", "(II[CI)V");
        mids$[mid_indexOf_a5a7d1128e9e2bb7] = env->getMethodID(cls, "indexOf", "(Ljava/lang/String;)I");
        mids$[mid_indexOf_30cd5d5b9318bd5d] = env->getMethodID(cls, "indexOf", "(Ljava/lang/String;I)I");
        mids$[mid_insert_a13644e76b3351c1] = env->getMethodID(cls, "insert", "(I[C)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_0c740f9abe213d5b] = env->getMethodID(cls, "insert", "(ILjava/lang/String;)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_5c28ccfdda9a420a] = env->getMethodID(cls, "insert", "(IZ)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_de293e1da241b6b9] = env->getMethodID(cls, "insert", "(IC)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_536eba38a02c4213] = env->getMethodID(cls, "insert", "(ID)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_c3160c5e13325cd5] = env->getMethodID(cls, "insert", "(IF)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_619abd4749e7d1c9] = env->getMethodID(cls, "insert", "(II)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_56ffb6828ae50f6b] = env->getMethodID(cls, "insert", "(ILjava/lang/CharSequence;)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_a756dfa08c065913] = env->getMethodID(cls, "insert", "(ILjava/lang/Object;)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_dd56597accae21c9] = env->getMethodID(cls, "insert", "(IJ)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_1aea9caca8632d82] = env->getMethodID(cls, "insert", "(I[CII)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_insert_65279f9670e156e7] = env->getMethodID(cls, "insert", "(ILjava/lang/CharSequence;II)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_lastIndexOf_a5a7d1128e9e2bb7] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/String;)I");
        mids$[mid_lastIndexOf_30cd5d5b9318bd5d] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/String;I)I");
        mids$[mid_length_9972fcc56b44e79d] = env->getMethodID(cls, "length", "()I");
        mids$[mid_offsetByCodePoints_57a58545eba514db] = env->getMethodID(cls, "offsetByCodePoints", "(II)I");
        mids$[mid_replace_f2e4f17933bb6952] = env->getMethodID(cls, "replace", "(IILjava/lang/String;)Ljava/lang/AbstractStringBuilder;");
        mids$[mid_reverse_1e013b6f66442917] = env->getMethodID(cls, "reverse", "()Ljava/lang/AbstractStringBuilder;");
        mids$[mid_setCharAt_49eec491b83160ef] = env->getMethodID(cls, "setCharAt", "(IC)V");
        mids$[mid_setLength_040c4cd0390c5aff] = env->getMethodID(cls, "setLength", "(I)V");
        mids$[mid_subSequence_26d6f5be97bcdc38] = env->getMethodID(cls, "subSequence", "(II)Ljava/lang/CharSequence;");
        mids$[mid_substring_d7593acad64ef635] = env->getMethodID(cls, "substring", "(I)Ljava/lang/String;");
        mids$[mid_substring_1f239231430be983] = env->getMethodID(cls, "substring", "(II)Ljava/lang/String;");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
        mids$[mid_trimToSize_f2cc1bce94666404] = env->getMethodID(cls, "trimToSize", "()V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    AbstractStringBuilder AbstractStringBuilder::append(const ::java::lang::StringBuffer & a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_e2002d37cf3da336], a0.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::append(const JArray< jchar > & a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_6f8380202126be56], a0.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::append(const ::java::lang::String & a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_0675466a49f2c0ba], a0.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::append(jboolean a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_6e3f56662365cdf7], a0));
    }

    AbstractStringBuilder AbstractStringBuilder::append(jchar a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_ec61606ad7d3bac3], a0));
    }

    AbstractStringBuilder AbstractStringBuilder::append(jdouble a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_44637512db686cff], a0));
    }

    AbstractStringBuilder AbstractStringBuilder::append(jfloat a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_6457f1cb386e42c9], a0));
    }

    AbstractStringBuilder AbstractStringBuilder::append(jint a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_f5d0029a591c2dd0], a0));
    }

    AbstractStringBuilder AbstractStringBuilder::append(const ::java::lang::CharSequence & a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_6a2e33fb9a81b110], a0.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::append(const ::java::lang::Object & a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_021e9fd1072a4d34], a0.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::append(jlong a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_fbbe51b2eb6efd3b], a0));
    }

    AbstractStringBuilder AbstractStringBuilder::append(const JArray< jchar > & a0, jint a1, jint a2) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_f0a7723684849e55], a0.this$, a1, a2));
    }

    AbstractStringBuilder AbstractStringBuilder::append(const ::java::lang::CharSequence & a0, jint a1, jint a2) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_append_f6a857741bd25118], a0.this$, a1, a2));
    }

    AbstractStringBuilder AbstractStringBuilder::appendCodePoint(jint a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_appendCodePoint_f5d0029a591c2dd0], a0));
    }

    jint AbstractStringBuilder::capacity() const
    {
      return env->callIntMethod(this$, mids$[mid_capacity_9972fcc56b44e79d]);
    }

    jchar AbstractStringBuilder::charAt(jint a0) const
    {
      return env->callCharMethod(this$, mids$[mid_charAt_ebc61ec1e57770d1], a0);
    }

    jint AbstractStringBuilder::codePointAt(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_codePointAt_1e143afe1894d213], a0);
    }

    jint AbstractStringBuilder::codePointBefore(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_codePointBefore_1e143afe1894d213], a0);
    }

    jint AbstractStringBuilder::codePointCount(jint a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_codePointCount_57a58545eba514db], a0, a1);
    }

    AbstractStringBuilder AbstractStringBuilder::delete$(jint a0, jint a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_delete_619abd4749e7d1c9], a0, a1));
    }

    AbstractStringBuilder AbstractStringBuilder::deleteCharAt(jint a0) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_deleteCharAt_f5d0029a591c2dd0], a0));
    }

    void AbstractStringBuilder::ensureCapacity(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_ensureCapacity_040c4cd0390c5aff], a0);
    }

    void AbstractStringBuilder::getChars(jint a0, jint a1, const JArray< jchar > & a2, jint a3) const
    {
      env->callVoidMethod(this$, mids$[mid_getChars_520fb522c03f2e69], a0, a1, a2.this$, a3);
    }

    jint AbstractStringBuilder::indexOf(const ::java::lang::String & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_a5a7d1128e9e2bb7], a0.this$);
    }

    jint AbstractStringBuilder::indexOf(const ::java::lang::String & a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_30cd5d5b9318bd5d], a0.this$, a1);
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, const JArray< jchar > & a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_a13644e76b3351c1], a0, a1.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, const ::java::lang::String & a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_0c740f9abe213d5b], a0, a1.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, jboolean a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_5c28ccfdda9a420a], a0, a1));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, jchar a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_de293e1da241b6b9], a0, a1));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, jdouble a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_536eba38a02c4213], a0, a1));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, jfloat a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_c3160c5e13325cd5], a0, a1));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, jint a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_619abd4749e7d1c9], a0, a1));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, const ::java::lang::CharSequence & a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_56ffb6828ae50f6b], a0, a1.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, const ::java::lang::Object & a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_a756dfa08c065913], a0, a1.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, jlong a1) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_dd56597accae21c9], a0, a1));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, const JArray< jchar > & a1, jint a2, jint a3) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_1aea9caca8632d82], a0, a1.this$, a2, a3));
    }

    AbstractStringBuilder AbstractStringBuilder::insert(jint a0, const ::java::lang::CharSequence & a1, jint a2, jint a3) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_insert_65279f9670e156e7], a0, a1.this$, a2, a3));
    }

    jint AbstractStringBuilder::lastIndexOf(const ::java::lang::String & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_a5a7d1128e9e2bb7], a0.this$);
    }

    jint AbstractStringBuilder::lastIndexOf(const ::java::lang::String & a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_30cd5d5b9318bd5d], a0.this$, a1);
    }

    jint AbstractStringBuilder::length() const
    {
      return env->callIntMethod(this$, mids$[mid_length_9972fcc56b44e79d]);
    }

    jint AbstractStringBuilder::offsetByCodePoints(jint a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_offsetByCodePoints_57a58545eba514db], a0, a1);
    }

    AbstractStringBuilder AbstractStringBuilder::replace(jint a0, jint a1, const ::java::lang::String & a2) const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_replace_f2e4f17933bb6952], a0, a1, a2.this$));
    }

    AbstractStringBuilder AbstractStringBuilder::reverse() const
    {
      return AbstractStringBuilder(env->callObjectMethod(this$, mids$[mid_reverse_1e013b6f66442917]));
    }

    void AbstractStringBuilder::setCharAt(jint a0, jchar a1) const
    {
      env->callVoidMethod(this$, mids$[mid_setCharAt_49eec491b83160ef], a0, a1);
    }

    void AbstractStringBuilder::setLength(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setLength_040c4cd0390c5aff], a0);
    }

    ::java::lang::CharSequence AbstractStringBuilder::subSequence(jint a0, jint a1) const
    {
      return ::java::lang::CharSequence(env->callObjectMethod(this$, mids$[mid_subSequence_26d6f5be97bcdc38], a0, a1));
    }

    ::java::lang::String AbstractStringBuilder::substring(jint a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_substring_d7593acad64ef635], a0));
    }

    ::java::lang::String AbstractStringBuilder::substring(jint a0, jint a1) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_substring_1f239231430be983], a0, a1));
    }

    ::java::lang::String AbstractStringBuilder::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }

    void AbstractStringBuilder::trimToSize() const
    {
      env->callVoidMethod(this$, mids$[mid_trimToSize_f2cc1bce94666404]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_AbstractStringBuilder_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_AbstractStringBuilder_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_AbstractStringBuilder_append(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_appendCodePoint(t_AbstractStringBuilder *self, PyObject *arg);
    static PyObject *t_AbstractStringBuilder_capacity(t_AbstractStringBuilder *self);
    static PyObject *t_AbstractStringBuilder_charAt(t_AbstractStringBuilder *self, PyObject *arg);
    static PyObject *t_AbstractStringBuilder_codePointAt(t_AbstractStringBuilder *self, PyObject *arg);
    static PyObject *t_AbstractStringBuilder_codePointBefore(t_AbstractStringBuilder *self, PyObject *arg);
    static PyObject *t_AbstractStringBuilder_codePointCount(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_delete(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_deleteCharAt(t_AbstractStringBuilder *self, PyObject *arg);
    static PyObject *t_AbstractStringBuilder_ensureCapacity(t_AbstractStringBuilder *self, PyObject *arg);
    static PyObject *t_AbstractStringBuilder_getChars(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_indexOf(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_insert(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_lastIndexOf(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_length(t_AbstractStringBuilder *self);
    static PyObject *t_AbstractStringBuilder_offsetByCodePoints(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_replace(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_reverse(t_AbstractStringBuilder *self);
    static PyObject *t_AbstractStringBuilder_setCharAt(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_setLength(t_AbstractStringBuilder *self, PyObject *arg);
    static PyObject *t_AbstractStringBuilder_subSequence(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_substring(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_toString(t_AbstractStringBuilder *self, PyObject *args);
    static PyObject *t_AbstractStringBuilder_trimToSize(t_AbstractStringBuilder *self);

    static PyMethodDef t_AbstractStringBuilder__methods_[] = {
      DECLARE_METHOD(t_AbstractStringBuilder, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_AbstractStringBuilder, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_AbstractStringBuilder, append, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, appendCodePoint, METH_O),
      DECLARE_METHOD(t_AbstractStringBuilder, capacity, METH_NOARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, charAt, METH_O),
      DECLARE_METHOD(t_AbstractStringBuilder, codePointAt, METH_O),
      DECLARE_METHOD(t_AbstractStringBuilder, codePointBefore, METH_O),
      DECLARE_METHOD(t_AbstractStringBuilder, codePointCount, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, delete, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, deleteCharAt, METH_O),
      DECLARE_METHOD(t_AbstractStringBuilder, ensureCapacity, METH_O),
      DECLARE_METHOD(t_AbstractStringBuilder, getChars, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, indexOf, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, insert, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, lastIndexOf, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, length, METH_NOARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, offsetByCodePoints, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, replace, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, reverse, METH_NOARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, setCharAt, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, setLength, METH_O),
      DECLARE_METHOD(t_AbstractStringBuilder, subSequence, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, substring, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, toString, METH_VARARGS),
      DECLARE_METHOD(t_AbstractStringBuilder, trimToSize, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(AbstractStringBuilder)[] = {
      { Py_tp_methods, t_AbstractStringBuilder__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(AbstractStringBuilder)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(AbstractStringBuilder, t_AbstractStringBuilder, AbstractStringBuilder);

    void t_AbstractStringBuilder::install(PyObject *module)
    {
      installType(&PY_TYPE(AbstractStringBuilder), &PY_TYPE_DEF(AbstractStringBuilder), module, "AbstractStringBuilder", 0);
    }

    void t_AbstractStringBuilder::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractStringBuilder), "class_", make_descriptor(AbstractStringBuilder::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractStringBuilder), "wrapfn_", make_descriptor(t_AbstractStringBuilder::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractStringBuilder), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_AbstractStringBuilder_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, AbstractStringBuilder::initializeClass, 1)))
        return NULL;
      return t_AbstractStringBuilder::wrap_Object(AbstractStringBuilder(((t_AbstractStringBuilder *) arg)->object.this$));
    }
    static PyObject *t_AbstractStringBuilder_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, AbstractStringBuilder::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_AbstractStringBuilder_append(t_AbstractStringBuilder *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::StringBuffer a0((jobject) NULL);
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::lang::StringBuffer::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          JArray< jchar > a0((jobject) NULL);
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "[C", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jboolean a0;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "Z", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jchar a0;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "C", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jdouble a0;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "D", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jfloat a0;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "F", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          ::java::lang::Object a0((jobject) NULL);
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jlong a0;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "J", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          JArray< jchar > a0((jobject) NULL);
          jint a1;
          jint a2;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "[CII", &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.append(a0, a1, a2));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          jint a1;
          jint a2;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "OII", ::java::lang::PY_TYPE(CharSequence), &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.append(a0, a1, a2));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "append", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_appendCodePoint(t_AbstractStringBuilder *self, PyObject *arg)
    {
      jint a0;
      AbstractStringBuilder result((jobject) NULL);

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.appendCodePoint(a0));
        return t_AbstractStringBuilder::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "appendCodePoint", arg);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_capacity(t_AbstractStringBuilder *self)
    {
      jint result;
      OBJ_CALL(result = self->object.capacity());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_AbstractStringBuilder_charAt(t_AbstractStringBuilder *self, PyObject *arg)
    {
      jint a0;
      jchar result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.charAt(a0));
        return c2p(result);
      }

      PyErr_SetArgsError((PyObject *) self, "charAt", arg);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_codePointAt(t_AbstractStringBuilder *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.codePointAt(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "codePointAt", arg);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_codePointBefore(t_AbstractStringBuilder *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.codePointBefore(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "codePointBefore", arg);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_codePointCount(t_AbstractStringBuilder *self, PyObject *args)
    {
      jint a0;
      jint a1;
      jint result;

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.codePointCount(a0, a1));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "codePointCount", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_delete(t_AbstractStringBuilder *self, PyObject *args)
    {
      jint a0;
      jint a1;
      AbstractStringBuilder result((jobject) NULL);

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.delete$(a0, a1));
        return t_AbstractStringBuilder::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "delete", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_deleteCharAt(t_AbstractStringBuilder *self, PyObject *arg)
    {
      jint a0;
      AbstractStringBuilder result((jobject) NULL);

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.deleteCharAt(a0));
        return t_AbstractStringBuilder::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "deleteCharAt", arg);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_ensureCapacity(t_AbstractStringBuilder *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.ensureCapacity(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "ensureCapacity", arg);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_getChars(t_AbstractStringBuilder *self, PyObject *args)
    {
      jint a0;
      jint a1;
      JArray< jchar > a2((jobject) NULL);
      jint a3;

      if (!parseArgs(args, "II[CI", &a0, &a1, &a2, &a3))
      {
        OBJ_CALL(self->object.getChars(a0, a1, a2, a3));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "getChars", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_indexOf(t_AbstractStringBuilder *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          jint result;

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.indexOf(a0));
            return PyLong_FromLong((long) result);
          }
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          jint a1;
          jint result;

          if (!parseArgs(args, "sI", &a0, &a1))
          {
            OBJ_CALL(result = self->object.indexOf(a0, a1));
            return PyLong_FromLong((long) result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "indexOf", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_insert(t_AbstractStringBuilder *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          jint a0;
          JArray< jchar > a1((jobject) NULL);
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "I[C", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::String a1((jobject) NULL);
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "Is", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jboolean a1;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IZ", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jchar a1;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IC", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jdouble a1;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "ID", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jfloat a1;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IF", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jint a1;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::CharSequence a1((jobject) NULL);
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IO", ::java::lang::PY_TYPE(CharSequence), &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::Object a1((jobject) NULL);
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "Io", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jlong a1;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IJ", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        break;
       case 4:
        {
          jint a0;
          JArray< jchar > a1((jobject) NULL);
          jint a2;
          jint a3;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "I[CII", &a0, &a1, &a2, &a3))
          {
            OBJ_CALL(result = self->object.insert(a0, a1, a2, a3));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::CharSequence a1((jobject) NULL);
          jint a2;
          jint a3;
          AbstractStringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IOII", ::java::lang::PY_TYPE(CharSequence), &a0, &a1, &a2, &a3))
          {
            OBJ_CALL(result = self->object.insert(a0, a1, a2, a3));
            return t_AbstractStringBuilder::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "insert", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_lastIndexOf(t_AbstractStringBuilder *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          jint result;

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.lastIndexOf(a0));
            return PyLong_FromLong((long) result);
          }
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          jint a1;
          jint result;

          if (!parseArgs(args, "sI", &a0, &a1))
          {
            OBJ_CALL(result = self->object.lastIndexOf(a0, a1));
            return PyLong_FromLong((long) result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "lastIndexOf", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_length(t_AbstractStringBuilder *self)
    {
      jint result;
      OBJ_CALL(result = self->object.length());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_AbstractStringBuilder_offsetByCodePoints(t_AbstractStringBuilder *self, PyObject *args)
    {
      jint a0;
      jint a1;
      jint result;

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.offsetByCodePoints(a0, a1));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "offsetByCodePoints", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_replace(t_AbstractStringBuilder *self, PyObject *args)
    {
      jint a0;
      jint a1;
      ::java::lang::String a2((jobject) NULL);
      AbstractStringBuilder result((jobject) NULL);

      if (!parseArgs(args, "IIs", &a0, &a1, &a2))
      {
        OBJ_CALL(result = self->object.replace(a0, a1, a2));
        return t_AbstractStringBuilder::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "replace", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_reverse(t_AbstractStringBuilder *self)
    {
      AbstractStringBuilder result((jobject) NULL);
      OBJ_CALL(result = self->object.reverse());
      return t_AbstractStringBuilder::wrap_Object(result);
    }

    static PyObject *t_AbstractStringBuilder_setCharAt(t_AbstractStringBuilder *self, PyObject *args)
    {
      jint a0;
      jchar a1;

      if (!parseArgs(args, "IC", &a0, &a1))
      {
        OBJ_CALL(self->object.setCharAt(a0, a1));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setCharAt", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_setLength(t_AbstractStringBuilder *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setLength(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setLength", arg);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_subSequence(t_AbstractStringBuilder *self, PyObject *args)
    {
      jint a0;
      jint a1;
      ::java::lang::CharSequence result((jobject) NULL);

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.subSequence(a0, a1));
        return ::java::lang::t_CharSequence::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "subSequence", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_substring(t_AbstractStringBuilder *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jint a0;
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.substring(a0));
            return j2p(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          jint a1;
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(result = self->object.substring(a0, a1));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "substring", args);
      return NULL;
    }

    static PyObject *t_AbstractStringBuilder_toString(t_AbstractStringBuilder *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(AbstractStringBuilder), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_AbstractStringBuilder_trimToSize(t_AbstractStringBuilder *self)
    {
      OBJ_CALL(self->object.trimToSize());
      Py_RETURN_NONE;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ParserATNSimulator.h"
#include "org/antlr/v4/runtime/NoViableAltException.h"
#include "org/antlr/v4/runtime/atn/ATN.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/ParserRuleContext.h"
#include "org/antlr/v4/runtime/atn/PredictionMode.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "org/antlr/v4/runtime/atn/PrecedencePredicateTransition.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/Parser.h"
#include "org/antlr/v4/runtime/atn/ATNConfig.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ParserATNSimulator::class$ = NULL;
          jmethodID *ParserATNSimulator::mids$ = NULL;
          bool ParserATNSimulator::live$ = false;
          jboolean ParserATNSimulator::debug = (jboolean) 0;
          jboolean ParserATNSimulator::debug_list_atn_decisions = (jboolean) 0;
          jboolean ParserATNSimulator::dfa_debug = (jboolean) 0;
          jboolean ParserATNSimulator::retry_debug = (jboolean) 0;

          jclass ParserATNSimulator::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ParserATNSimulator");

              mids$ = new jmethodID[max_mid];
              mids$[mid_adaptivePredict_72c80921051c0d0f] = env->getMethodID(cls, "adaptivePredict", "(Lorg/antlr/v4/runtime/TokenStream;ILorg/antlr/v4/runtime/ParserRuleContext;)I");
              mids$[mid_clearDFA_f2cc1bce94666404] = env->getMethodID(cls, "clearDFA", "()V");
              mids$[mid_dumpDeadEndConfigs_384976d3ff551b47] = env->getMethodID(cls, "dumpDeadEndConfigs", "(Lorg/antlr/v4/runtime/NoViableAltException;)V");
              mids$[mid_getLookaheadName_58e0d499f5090bc7] = env->getMethodID(cls, "getLookaheadName", "(Lorg/antlr/v4/runtime/TokenStream;)Ljava/lang/String;");
              mids$[mid_getParser_025a8d2d46c1e4a8] = env->getMethodID(cls, "getParser", "()Lorg/antlr/v4/runtime/Parser;");
              mids$[mid_getPredictionMode_39d48f3446be9f6a] = env->getMethodID(cls, "getPredictionMode", "()Lorg/antlr/v4/runtime/atn/PredictionMode;");
              mids$[mid_getRuleName_d7593acad64ef635] = env->getMethodID(cls, "getRuleName", "(I)Ljava/lang/String;");
              mids$[mid_getTokenName_d7593acad64ef635] = env->getMethodID(cls, "getTokenName", "(I)Ljava/lang/String;");
              mids$[mid_precedenceTransition_245cbce290b36e63] = env->getMethodID(cls, "precedenceTransition", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/PrecedencePredicateTransition;ZZZ)Lorg/antlr/v4/runtime/atn/ATNConfig;");
              mids$[mid_reset_f2cc1bce94666404] = env->getMethodID(cls, "reset", "()V");
              mids$[mid_setPredictionMode_f554dbc9fb9d86dc] = env->getMethodID(cls, "setPredictionMode", "(Lorg/antlr/v4/runtime/atn/PredictionMode;)V");
              mids$[mid_execATN_52d9a55747374898] = env->getMethodID(cls, "execATN", "(Lorg/antlr/v4/runtime/dfa/DFA;Lorg/antlr/v4/runtime/dfa/DFAState;Lorg/antlr/v4/runtime/TokenStream;ILorg/antlr/v4/runtime/ParserRuleContext;)I");
              mids$[mid_predicateDFAState_07fe6a95b2decf20] = env->getMethodID(cls, "predicateDFAState", "(Lorg/antlr/v4/runtime/dfa/DFAState;Lorg/antlr/v4/runtime/atn/DecisionState;)V");
              mids$[mid_execATNWithFullContext_14446877c03cd6ab] = env->getMethodID(cls, "execATNWithFullContext", "(Lorg/antlr/v4/runtime/dfa/DFA;Lorg/antlr/v4/runtime/dfa/DFAState;Lorg/antlr/v4/runtime/atn/ATNConfigSet;Lorg/antlr/v4/runtime/TokenStream;ILorg/antlr/v4/runtime/ParserRuleContext;)I");
              mids$[mid_removeAllConfigsNotInRuleStopState_e217dfa54d1278ee] = env->getMethodID(cls, "removeAllConfigsNotInRuleStopState", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;Z)Lorg/antlr/v4/runtime/atn/ATNConfigSet;");
              mids$[mid_computeStartState_efd060098f08ca81] = env->getMethodID(cls, "computeStartState", "(Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/RuleContext;Z)Lorg/antlr/v4/runtime/atn/ATNConfigSet;");
              mids$[mid_applyPrecedenceFilter_77d90be2cc79d26c] = env->getMethodID(cls, "applyPrecedenceFilter", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Lorg/antlr/v4/runtime/atn/ATNConfigSet;");
              mids$[mid_getReachableTarget_88792c9aa2dfa8d2] = env->getMethodID(cls, "getReachableTarget", "(Lorg/antlr/v4/runtime/atn/Transition;I)Lorg/antlr/v4/runtime/atn/ATNState;");
              mids$[mid_getPredsForAmbigAlts_00a73f4bb253e70e] = env->getMethodID(cls, "getPredsForAmbigAlts", "(Ljava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;I)[Lorg/antlr/v4/runtime/atn/SemanticContext;");
              mids$[mid_getPredicatePredictions_c8dda7d50d5ce291] = env->getMethodID(cls, "getPredicatePredictions", "(Ljava/util/BitSet;[Lorg/antlr/v4/runtime/atn/SemanticContext;)[Lorg/antlr/v4/runtime/dfa/DFAState$PredPrediction;");
              mids$[mid_getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule_f7e784c2f9245d46] = env->getMethodID(cls, "getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;Lorg/antlr/v4/runtime/ParserRuleContext;)I");
              mids$[mid_getAltThatFinishedDecisionEntryRule_29e730a5a485819a] = env->getMethodID(cls, "getAltThatFinishedDecisionEntryRule", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)I");
              mids$[mid_splitAccordingToSemanticValidity_4990a1d7308163ce] = env->getMethodID(cls, "splitAccordingToSemanticValidity", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;Lorg/antlr/v4/runtime/ParserRuleContext;)Lorg/antlr/v4/runtime/misc/Pair;");
              mids$[mid_closureCheckingStopState_7118a5ab8439b687] = env->getMethodID(cls, "closureCheckingStopState", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNConfigSet;Ljava/util/Set;ZZIZ)V");
              mids$[mid_closure__7118a5ab8439b687] = env->getMethodID(cls, "closure_", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNConfigSet;Ljava/util/Set;ZZIZ)V");
              mids$[mid_getEpsilonTarget_cd80f8ffa1516647] = env->getMethodID(cls, "getEpsilonTarget", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/Transition;ZZZZ)Lorg/antlr/v4/runtime/atn/ATNConfig;");
              mids$[mid_actionTransition_dfdd9698a4798f4c] = env->getMethodID(cls, "actionTransition", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ActionTransition;)Lorg/antlr/v4/runtime/atn/ATNConfig;");
              mids$[mid_predTransition_d8286df541b0e793] = env->getMethodID(cls, "predTransition", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/PredicateTransition;ZZZ)Lorg/antlr/v4/runtime/atn/ATNConfig;");
              mids$[mid_ruleTransition_a35f30762706461a] = env->getMethodID(cls, "ruleTransition", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/RuleTransition;)Lorg/antlr/v4/runtime/atn/ATNConfig;");
              mids$[mid_getConflictingAlts_d58e25cdab3539e8] = env->getMethodID(cls, "getConflictingAlts", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Ljava/util/BitSet;");
              mids$[mid_getConflictingAltsOrUniqueAlt_d58e25cdab3539e8] = env->getMethodID(cls, "getConflictingAltsOrUniqueAlt", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Ljava/util/BitSet;");
              mids$[mid_noViableAlt_055e0c9132bc03dc] = env->getMethodID(cls, "noViableAlt", "(Lorg/antlr/v4/runtime/TokenStream;Lorg/antlr/v4/runtime/ParserRuleContext;Lorg/antlr/v4/runtime/atn/ATNConfigSet;I)Lorg/antlr/v4/runtime/NoViableAltException;");
              mids$[mid_getUniqueAlt_29e730a5a485819a] = env->getStaticMethodID(cls, "getUniqueAlt", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)I");
              mids$[mid_addDFAEdge_c578743f8a5e0b4e] = env->getMethodID(cls, "addDFAEdge", "(Lorg/antlr/v4/runtime/dfa/DFA;Lorg/antlr/v4/runtime/dfa/DFAState;ILorg/antlr/v4/runtime/dfa/DFAState;)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_addDFAState_9ffdbf1a67a07e8a] = env->getMethodID(cls, "addDFAState", "(Lorg/antlr/v4/runtime/dfa/DFA;Lorg/antlr/v4/runtime/dfa/DFAState;)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_reportAttemptingFullContext_ed6a15b8ee7d4bab] = env->getMethodID(cls, "reportAttemptingFullContext", "(Lorg/antlr/v4/runtime/dfa/DFA;Ljava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;II)V");
              mids$[mid_reportContextSensitivity_e936c26f7898466f] = env->getMethodID(cls, "reportContextSensitivity", "(Lorg/antlr/v4/runtime/dfa/DFA;ILorg/antlr/v4/runtime/atn/ATNConfigSet;II)V");
              mids$[mid_getExistingTargetState_61638a030e2cccdc] = env->getMethodID(cls, "getExistingTargetState", "(Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_computeTargetState_11874a3ad517578a] = env->getMethodID(cls, "computeTargetState", "(Lorg/antlr/v4/runtime/dfa/DFA;Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_computeReachSet_8357bfef0945b314] = env->getMethodID(cls, "computeReachSet", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;IZ)Lorg/antlr/v4/runtime/atn/ATNConfigSet;");
              mids$[mid_evalSemanticContext_9d29981152279d6a] = env->getMethodID(cls, "evalSemanticContext", "([Lorg/antlr/v4/runtime/dfa/DFAState$PredPrediction;Lorg/antlr/v4/runtime/ParserRuleContext;Z)Ljava/util/BitSet;");
              mids$[mid_evalSemanticContext_f2ecdd5ff8d6fb82] = env->getMethodID(cls, "evalSemanticContext", "(Lorg/antlr/v4/runtime/atn/SemanticContext;Lorg/antlr/v4/runtime/ParserRuleContext;IZ)Z");
              mids$[mid_reportAmbiguity_8df929a94940cc45] = env->getMethodID(cls, "reportAmbiguity", "(Lorg/antlr/v4/runtime/dfa/DFA;Lorg/antlr/v4/runtime/dfa/DFAState;IIZLjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V");
              mids$[mid_closure_0139b47bca820f55] = env->getMethodID(cls, "closure", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNConfigSet;Ljava/util/Set;ZZZ)V");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              debug = env->getStaticBooleanField(cls, "debug");
              debug_list_atn_decisions = env->getStaticBooleanField(cls, "debug_list_atn_decisions");
              dfa_debug = env->getStaticBooleanField(cls, "dfa_debug");
              retry_debug = env->getStaticBooleanField(cls, "retry_debug");
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          jint ParserATNSimulator::adaptivePredict(const ::org::antlr::v4::runtime::TokenStream & a0, jint a1, const ::org::antlr::v4::runtime::ParserRuleContext & a2) const
          {
            return env->callIntMethod(this$, mids$[mid_adaptivePredict_72c80921051c0d0f], a0.this$, a1, a2.this$);
          }

          void ParserATNSimulator::clearDFA() const
          {
            env->callVoidMethod(this$, mids$[mid_clearDFA_f2cc1bce94666404]);
          }

          void ParserATNSimulator::dumpDeadEndConfigs(const ::org::antlr::v4::runtime::NoViableAltException & a0) const
          {
            env->callVoidMethod(this$, mids$[mid_dumpDeadEndConfigs_384976d3ff551b47], a0.this$);
          }

          ::java::lang::String ParserATNSimulator::getLookaheadName(const ::org::antlr::v4::runtime::TokenStream & a0) const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getLookaheadName_58e0d499f5090bc7], a0.this$));
          }

          ::org::antlr::v4::runtime::Parser ParserATNSimulator::getParser() const
          {
            return ::org::antlr::v4::runtime::Parser(env->callObjectMethod(this$, mids$[mid_getParser_025a8d2d46c1e4a8]));
          }

          ::org::antlr::v4::runtime::atn::PredictionMode ParserATNSimulator::getPredictionMode() const
          {
            return ::org::antlr::v4::runtime::atn::PredictionMode(env->callObjectMethod(this$, mids$[mid_getPredictionMode_39d48f3446be9f6a]));
          }

          ::java::lang::String ParserATNSimulator::getRuleName(jint a0) const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getRuleName_d7593acad64ef635], a0));
          }

          ::java::lang::String ParserATNSimulator::getTokenName(jint a0) const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getTokenName_d7593acad64ef635], a0));
          }

          ::org::antlr::v4::runtime::atn::ATNConfig ParserATNSimulator::precedenceTransition(const ::org::antlr::v4::runtime::atn::ATNConfig & a0, const ::org::antlr::v4::runtime::atn::PrecedencePredicateTransition & a1, jboolean a2, jboolean a3, jboolean a4) const
          {
            return ::org::antlr::v4::runtime::atn::ATNConfig(env->callObjectMethod(this$, mids$[mid_precedenceTransition_245cbce290b36e63], a0.this$, a1.this$, a2, a3, a4));
          }

          void ParserATNSimulator::reset() const
          {
            env->callVoidMethod(this$, mids$[mid_reset_f2cc1bce94666404]);
          }

          void ParserATNSimulator::setPredictionMode(const ::org::antlr::v4::runtime::atn::PredictionMode & a0) const
          {
            env->callVoidMethod(this$, mids$[mid_setPredictionMode_f554dbc9fb9d86dc], a0.this$);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ParserATNSimulator_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ParserATNSimulator_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ParserATNSimulator_adaptivePredict(t_ParserATNSimulator *self, PyObject *args);
          static PyObject *t_ParserATNSimulator_clearDFA(t_ParserATNSimulator *self, PyObject *args);
          static PyObject *t_ParserATNSimulator_dumpDeadEndConfigs(t_ParserATNSimulator *self, PyObject *arg);
          static PyObject *t_ParserATNSimulator_getLookaheadName(t_ParserATNSimulator *self, PyObject *arg);
          static PyObject *t_ParserATNSimulator_getParser(t_ParserATNSimulator *self);
          static PyObject *t_ParserATNSimulator_getPredictionMode(t_ParserATNSimulator *self);
          static PyObject *t_ParserATNSimulator_getRuleName(t_ParserATNSimulator *self, PyObject *arg);
          static PyObject *t_ParserATNSimulator_getTokenName(t_ParserATNSimulator *self, PyObject *arg);
          static PyObject *t_ParserATNSimulator_precedenceTransition(t_ParserATNSimulator *self, PyObject *args);
          static PyObject *t_ParserATNSimulator_reset(t_ParserATNSimulator *self, PyObject *args);
          static PyObject *t_ParserATNSimulator_setPredictionMode(t_ParserATNSimulator *self, PyObject *arg);
          static PyObject *t_ParserATNSimulator_get__parser(t_ParserATNSimulator *self, void *data);
          static PyObject *t_ParserATNSimulator_get__predictionMode(t_ParserATNSimulator *self, void *data);
          static int t_ParserATNSimulator_set__predictionMode(t_ParserATNSimulator *self, PyObject *arg, void *data);
          static PyGetSetDef t_ParserATNSimulator__fields_[] = {
            DECLARE_GET_FIELD(t_ParserATNSimulator, parser),
            DECLARE_GETSET_FIELD(t_ParserATNSimulator, predictionMode),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ParserATNSimulator__methods_[] = {
            DECLARE_METHOD(t_ParserATNSimulator, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ParserATNSimulator, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ParserATNSimulator, adaptivePredict, METH_VARARGS),
            DECLARE_METHOD(t_ParserATNSimulator, clearDFA, METH_VARARGS),
            DECLARE_METHOD(t_ParserATNSimulator, dumpDeadEndConfigs, METH_O),
            DECLARE_METHOD(t_ParserATNSimulator, getLookaheadName, METH_O),
            DECLARE_METHOD(t_ParserATNSimulator, getParser, METH_NOARGS),
            DECLARE_METHOD(t_ParserATNSimulator, getPredictionMode, METH_NOARGS),
            DECLARE_METHOD(t_ParserATNSimulator, getRuleName, METH_O),
            DECLARE_METHOD(t_ParserATNSimulator, getTokenName, METH_O),
            DECLARE_METHOD(t_ParserATNSimulator, precedenceTransition, METH_VARARGS),
            DECLARE_METHOD(t_ParserATNSimulator, reset, METH_VARARGS),
            DECLARE_METHOD(t_ParserATNSimulator, setPredictionMode, METH_O),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ParserATNSimulator)[] = {
            { Py_tp_methods, t_ParserATNSimulator__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_ParserATNSimulator__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ParserATNSimulator)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::ATNSimulator),
            NULL
          };

          DEFINE_TYPE(ParserATNSimulator, t_ParserATNSimulator, ParserATNSimulator);

          void t_ParserATNSimulator::install(PyObject *module)
          {
            installType(&PY_TYPE(ParserATNSimulator), &PY_TYPE_DEF(ParserATNSimulator), module, "ParserATNSimulator", 0);
          }

          void t_ParserATNSimulator::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParserATNSimulator), "class_", make_descriptor(ParserATNSimulator::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParserATNSimulator), "wrapfn_", make_descriptor(t_ParserATNSimulator::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParserATNSimulator), "boxfn_", make_descriptor(boxObject));
            env->getClass(ParserATNSimulator::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParserATNSimulator), "debug", make_descriptor(ParserATNSimulator::debug));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParserATNSimulator), "debug_list_atn_decisions", make_descriptor(ParserATNSimulator::debug_list_atn_decisions));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParserATNSimulator), "dfa_debug", make_descriptor(ParserATNSimulator::dfa_debug));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParserATNSimulator), "retry_debug", make_descriptor(ParserATNSimulator::retry_debug));
          }

          static PyObject *t_ParserATNSimulator_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ParserATNSimulator::initializeClass, 1)))
              return NULL;
            return t_ParserATNSimulator::wrap_Object(ParserATNSimulator(((t_ParserATNSimulator *) arg)->object.this$));
          }
          static PyObject *t_ParserATNSimulator_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ParserATNSimulator::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_ParserATNSimulator_adaptivePredict(t_ParserATNSimulator *self, PyObject *args)
          {
            ::org::antlr::v4::runtime::TokenStream a0((jobject) NULL);
            jint a1;
            ::org::antlr::v4::runtime::ParserRuleContext a2((jobject) NULL);
            jint result;

            if (!parseArgs(args, "kIk", ::org::antlr::v4::runtime::TokenStream::initializeClass, ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &a1, &a2))
            {
              OBJ_CALL(result = self->object.adaptivePredict(a0, a1, a2));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError((PyObject *) self, "adaptivePredict", args);
            return NULL;
          }

          static PyObject *t_ParserATNSimulator_clearDFA(t_ParserATNSimulator *self, PyObject *args)
          {

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(self->object.clearDFA());
              Py_RETURN_NONE;
            }

            return callSuper(PY_TYPE(ParserATNSimulator), (PyObject *) self, "clearDFA", args, 2);
          }

          static PyObject *t_ParserATNSimulator_dumpDeadEndConfigs(t_ParserATNSimulator *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::NoViableAltException a0((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::NoViableAltException::initializeClass, &a0))
            {
              OBJ_CALL(self->object.dumpDeadEndConfigs(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "dumpDeadEndConfigs", arg);
            return NULL;
          }

          static PyObject *t_ParserATNSimulator_getLookaheadName(t_ParserATNSimulator *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::TokenStream a0((jobject) NULL);
            ::java::lang::String result((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::TokenStream::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.getLookaheadName(a0));
              return j2p(result);
            }

            PyErr_SetArgsError((PyObject *) self, "getLookaheadName", arg);
            return NULL;
          }

          static PyObject *t_ParserATNSimulator_getParser(t_ParserATNSimulator *self)
          {
            ::org::antlr::v4::runtime::Parser result((jobject) NULL);
            OBJ_CALL(result = self->object.getParser());
            return ::org::antlr::v4::runtime::t_Parser::wrap_Object(result);
          }

          static PyObject *t_ParserATNSimulator_getPredictionMode(t_ParserATNSimulator *self)
          {
            ::org::antlr::v4::runtime::atn::PredictionMode result((jobject) NULL);
            OBJ_CALL(result = self->object.getPredictionMode());
            return ::org::antlr::v4::runtime::atn::t_PredictionMode::wrap_Object(result);
          }

          static PyObject *t_ParserATNSimulator_getRuleName(t_ParserATNSimulator *self, PyObject *arg)
          {
            jint a0;
            ::java::lang::String result((jobject) NULL);

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(result = self->object.getRuleName(a0));
              return j2p(result);
            }

            PyErr_SetArgsError((PyObject *) self, "getRuleName", arg);
            return NULL;
          }

          static PyObject *t_ParserATNSimulator_getTokenName(t_ParserATNSimulator *self, PyObject *arg)
          {
            jint a0;
            ::java::lang::String result((jobject) NULL);

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(result = self->object.getTokenName(a0));
              return j2p(result);
            }

            PyErr_SetArgsError((PyObject *) self, "getTokenName", arg);
            return NULL;
          }

          static PyObject *t_ParserATNSimulator_precedenceTransition(t_ParserATNSimulator *self, PyObject *args)
          {
            ::org::antlr::v4::runtime::atn::ATNConfig a0((jobject) NULL);
            ::org::antlr::v4::runtime::atn::PrecedencePredicateTransition a1((jobject) NULL);
            jboolean a2;
            jboolean a3;
            jboolean a4;
            ::org::antlr::v4::runtime::atn::ATNConfig result((jobject) NULL);

            if (!parseArgs(args, "kkZZZ", ::org::antlr::v4::runtime::atn::ATNConfig::initializeClass, ::org::antlr::v4::runtime::atn::PrecedencePredicateTransition::initializeClass, &a0, &a1, &a2, &a3, &a4))
            {
              OBJ_CALL(result = self->object.precedenceTransition(a0, a1, a2, a3, a4));
              return ::org::antlr::v4::runtime::atn::t_ATNConfig::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "precedenceTransition", args);
            return NULL;
          }

          static PyObject *t_ParserATNSimulator_reset(t_ParserATNSimulator *self, PyObject *args)
          {

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(self->object.reset());
              Py_RETURN_NONE;
            }

            return callSuper(PY_TYPE(ParserATNSimulator), (PyObject *) self, "reset", args, 2);
          }

          static PyObject *t_ParserATNSimulator_setPredictionMode(t_ParserATNSimulator *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::PredictionMode a0((jobject) NULL);
            PyTypeObject **p0;

            if (!parseArg(arg, "K", ::org::antlr::v4::runtime::atn::PredictionMode::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::atn::t_PredictionMode::parameters_))
            {
              OBJ_CALL(self->object.setPredictionMode(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "setPredictionMode", arg);
            return NULL;
          }

          static PyObject *t_ParserATNSimulator_get__parser(t_ParserATNSimulator *self, void *data)
          {
            ::org::antlr::v4::runtime::Parser value((jobject) NULL);
            OBJ_CALL(value = self->object.getParser());
            return ::org::antlr::v4::runtime::t_Parser::wrap_Object(value);
          }

          static PyObject *t_ParserATNSimulator_get__predictionMode(t_ParserATNSimulator *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::PredictionMode value((jobject) NULL);
            OBJ_CALL(value = self->object.getPredictionMode());
            return ::org::antlr::v4::runtime::atn::t_PredictionMode::wrap_Object(value);
          }
          static int t_ParserATNSimulator_set__predictionMode(t_ParserATNSimulator *self, PyObject *arg, void *data)
          {
            {
              ::org::antlr::v4::runtime::atn::PredictionMode value((jobject) NULL);
              if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::PredictionMode::initializeClass, &value))
              {
                INT_CALL(self->object.setPredictionMode(value));
                return 0;
              }
            }
            PyErr_SetArgsError((PyObject *) self, "predictionMode", arg);
            return -1;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Map.h"
#include "java/util/Map.h"
#include "java/util/Collection.h"
#include "java/util/Map$Entry.h"
#include "java/util/function/BiConsumer.h"
#include "java/lang/Class.h"
#include "java/util/function/Function.h"
#include "java/util/function/BiFunction.h"
#include "java/util/Set.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Map::class$ = NULL;
    jmethodID *Map::mids$ = NULL;
    bool Map::live$ = false;

    jclass Map::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Map");

        mids$ = new jmethodID[max_mid];
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_compute_a077e9e27d3c234f] = env->getMethodID(cls, "compute", "(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;");
        mids$[mid_computeIfAbsent_d6f5a32db425833f] = env->getMethodID(cls, "computeIfAbsent", "(Ljava/lang/Object;Ljava/util/function/Function;)Ljava/lang/Object;");
        mids$[mid_computeIfPresent_a077e9e27d3c234f] = env->getMethodID(cls, "computeIfPresent", "(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;");
        mids$[mid_containsKey_8b72f2dcdde6fd1d] = env->getMethodID(cls, "containsKey", "(Ljava/lang/Object;)Z");
        mids$[mid_containsValue_8b72f2dcdde6fd1d] = env->getMethodID(cls, "containsValue", "(Ljava/lang/Object;)Z");
        mids$[mid_entrySet_7dcf4034c6d1a92a] = env->getMethodID(cls, "entrySet", "()Ljava/util/Set;");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_forEach_94704ed6ccc48468] = env->getMethodID(cls, "forEach", "(Ljava/util/function/BiConsumer;)V");
        mids$[mid_get_e5ae0f8c04795fa9] = env->getMethodID(cls, "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_getOrDefault_128a89bbc17a8b69] = env->getMethodID(cls, "getOrDefault", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
        mids$[mid_keySet_7dcf4034c6d1a92a] = env->getMethodID(cls, "keySet", "()Ljava/util/Set;");
        mids$[mid_merge_74daa8a3464479e0] = env->getMethodID(cls, "merge", "(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;");
        mids$[mid_put_128a89bbc17a8b69] = env->getMethodID(cls, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_putAll_408bd889ee3beae5] = env->getMethodID(cls, "putAll", "(Ljava/util/Map;)V");
        mids$[mid_putIfAbsent_128a89bbc17a8b69] = env->getMethodID(cls, "putIfAbsent", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_remove_e5ae0f8c04795fa9] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_remove_b06c7be184b2a9ad] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;Ljava/lang/Object;)Z");
        mids$[mid_replace_128a89bbc17a8b69] = env->getMethodID(cls, "replace", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_replace_fe62c765dba52df0] = env->getMethodID(cls, "replace", "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z");
        mids$[mid_replaceAll_22221e328874bd4f] = env->getMethodID(cls, "replaceAll", "(Ljava/util/function/BiFunction;)V");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
        mids$[mid_values_d4dfbf7a26ff41df] = env->getMethodID(cls, "values", "()Ljava/util/Collection;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Map::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    ::java::lang::Object Map::compute(const ::java::lang::Object & a0, const ::java::util::function::BiFunction & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_compute_a077e9e27d3c234f], a0.this$, a1.this$));
    }

    ::java::lang::Object Map::computeIfAbsent(const ::java::lang::Object & a0, const ::java::util::function::Function & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_computeIfAbsent_d6f5a32db425833f], a0.this$, a1.this$));
    }

    ::java::lang::Object Map::computeIfPresent(const ::java::lang::Object & a0, const ::java::util::function::BiFunction & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_computeIfPresent_a077e9e27d3c234f], a0.this$, a1.this$));
    }

    jboolean Map::containsKey(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_containsKey_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Map::containsValue(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_containsValue_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::util::Set Map::entrySet() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_entrySet_7dcf4034c6d1a92a]));
    }

    jboolean Map::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    void Map::forEach(const ::java::util::function::BiConsumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEach_94704ed6ccc48468], a0.this$);
    }

    ::java::lang::Object Map::get(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::lang::Object Map::getOrDefault(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_getOrDefault_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    jint Map::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean Map::isEmpty() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
    }

    ::java::util::Set Map::keySet() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_keySet_7dcf4034c6d1a92a]));
    }

    ::java::lang::Object Map::merge(const ::java::lang::Object & a0, const ::java::lang::Object & a1, const ::java::util::function::BiFunction & a2) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_merge_74daa8a3464479e0], a0.this$, a1.this$, a2.this$));
    }

    ::java::lang::Object Map::put(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_put_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    void Map::putAll(const Map & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_putAll_408bd889ee3beae5], a0.this$);
    }

    ::java::lang::Object Map::putIfAbsent(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_putIfAbsent_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    ::java::lang::Object Map::remove(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_e5ae0f8c04795fa9], a0.this$));
    }

    jboolean Map::remove(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_remove_b06c7be184b2a9ad], a0.this$, a1.this$);
    }

    ::java::lang::Object Map::replace(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_replace_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    jboolean Map::replace(const ::java::lang::Object & a0, const ::java::lang::Object & a1, const ::java::lang::Object & a2) const
    {
      return env->callBooleanMethod(this$, mids$[mid_replace_fe62c765dba52df0], a0.this$, a1.this$, a2.this$);
    }

    void Map::replaceAll(const ::java::util::function::BiFunction & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_replaceAll_22221e328874bd4f], a0.this$);
    }

    jint Map::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }

    ::java::util::Collection Map::values() const
    {
      return ::java::util::Collection(env->callObjectMethod(this$, mids$[mid_values_d4dfbf7a26ff41df]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Map_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Map_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Map_of_(t_Map *self, PyObject *args);
    static PyObject *t_Map_clear(t_Map *self);
    static PyObject *t_Map_compute(t_Map *self, PyObject *args);
    static PyObject *t_Map_computeIfAbsent(t_Map *self, PyObject *args);
    static PyObject *t_Map_computeIfPresent(t_Map *self, PyObject *args);
    static PyObject *t_Map_containsKey(t_Map *self, PyObject *arg);
    static PyObject *t_Map_containsValue(t_Map *self, PyObject *arg);
    static PyObject *t_Map_entrySet(t_Map *self);
    static PyObject *t_Map_equals(t_Map *self, PyObject *args);
    static PyObject *t_Map_forEach(t_Map *self, PyObject *arg);
    static PyObject *t_Map_get(t_Map *self, PyObject *arg);
    static PyObject *t_Map_getOrDefault(t_Map *self, PyObject *args);
    static PyObject *t_Map_hashCode(t_Map *self, PyObject *args);
    static PyObject *t_Map_isEmpty(t_Map *self);
    static PyObject *t_Map_keySet(t_Map *self);
    static PyObject *t_Map_merge(t_Map *self, PyObject *args);
    static PyObject *t_Map_put(t_Map *self, PyObject *args);
    static PyObject *t_Map_putAll(t_Map *self, PyObject *arg);
    static PyObject *t_Map_putIfAbsent(t_Map *self, PyObject *args);
    static PyObject *t_Map_remove(t_Map *self, PyObject *args);
    static PyObject *t_Map_replace(t_Map *self, PyObject *args);
    static PyObject *t_Map_replaceAll(t_Map *self, PyObject *arg);
    static PyObject *t_Map_size(t_Map *self);
    static PyObject *t_Map_values(t_Map *self);
    static PyObject *t_Map_get__empty(t_Map *self, void *data);
    static PyObject *t_Map_get__parameters_(t_Map *self, void *data);
    static PyGetSetDef t_Map__fields_[] = {
      DECLARE_GET_FIELD(t_Map, empty),
      DECLARE_GET_FIELD(t_Map, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Map__methods_[] = {
      DECLARE_METHOD(t_Map, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Map, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Map, of_, METH_VARARGS),
      DECLARE_METHOD(t_Map, clear, METH_NOARGS),
      DECLARE_METHOD(t_Map, compute, METH_VARARGS),
      DECLARE_METHOD(t_Map, computeIfAbsent, METH_VARARGS),
      DECLARE_METHOD(t_Map, computeIfPresent, METH_VARARGS),
      DECLARE_METHOD(t_Map, containsKey, METH_O),
      DECLARE_METHOD(t_Map, containsValue, METH_O),
      DECLARE_METHOD(t_Map, entrySet, METH_NOARGS),
      DECLARE_METHOD(t_Map, equals, METH_VARARGS),
      DECLARE_METHOD(t_Map, forEach, METH_O),
      DECLARE_METHOD(t_Map, get, METH_O),
      DECLARE_METHOD(t_Map, getOrDefault, METH_VARARGS),
      DECLARE_METHOD(t_Map, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_Map, isEmpty, METH_NOARGS),
      DECLARE_METHOD(t_Map, keySet, METH_NOARGS),
      DECLARE_METHOD(t_Map, merge, METH_VARARGS),
      DECLARE_METHOD(t_Map, put, METH_VARARGS),
      DECLARE_METHOD(t_Map, putAll, METH_O),
      DECLARE_METHOD(t_Map, putIfAbsent, METH_VARARGS),
      DECLARE_METHOD(t_Map, remove, METH_VARARGS),
      DECLARE_METHOD(t_Map, replace, METH_VARARGS),
      DECLARE_METHOD(t_Map, replaceAll, METH_O),
      DECLARE_METHOD(t_Map, size, METH_NOARGS),
      DECLARE_METHOD(t_Map, values, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Map)[] = {
      { Py_tp_methods, t_Map__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Map__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Map)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Map, t_Map, Map);
    PyObject *t_Map::wrap_Object(const Map& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_Map::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Map *self = (t_Map *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    PyObject *t_Map::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_Map::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Map *self = (t_Map *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    void t_Map::install(PyObject *module)
    {
      installType(&PY_TYPE(Map), &PY_TYPE_DEF(Map), module, "Map", 0);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Map), "Entry", make_descriptor(&PY_TYPE_DEF(Map$Entry)));
    }

    void t_Map::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Map), "class_", make_descriptor(Map::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Map), "wrapfn_", make_descriptor(t_Map::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Map), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Map_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Map::initializeClass, 1)))
        return NULL;
      return t_Map::wrap_Object(Map(((t_Map *) arg)->object.this$));
    }
    static PyObject *t_Map_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Map::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Map_of_(t_Map *self, PyObject *args)
    {
      if (!parseArg(args, "T", 2, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Map_clear(t_Map *self)
    {
      OBJ_CALL(self->object.clear());
      Py_RETURN_NONE;
    }

    static PyObject *t_Map_compute(t_Map *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::function::BiFunction a1((jobject) NULL);
      PyTypeObject **p1;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OK", self->parameters[0], ::java::util::function::BiFunction::initializeClass, &a0, &a1, &p1, ::java::util::function::t_BiFunction::parameters_))
      {
        OBJ_CALL(result = self->object.compute(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "compute", args);
      return NULL;
    }

    static PyObject *t_Map_computeIfAbsent(t_Map *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::function::Function a1((jobject) NULL);
      PyTypeObject **p1;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OK", self->parameters[0], ::java::util::function::Function::initializeClass, &a0, &a1, &p1, ::java::util::function::t_Function::parameters_))
      {
        OBJ_CALL(result = self->object.computeIfAbsent(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "computeIfAbsent", args);
      return NULL;
    }

    static PyObject *t_Map_computeIfPresent(t_Map *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::function::BiFunction a1((jobject) NULL);
      PyTypeObject **p1;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OK", self->parameters[0], ::java::util::function::BiFunction::initializeClass, &a0, &a1, &p1, ::java::util::function::t_BiFunction::parameters_))
      {
        OBJ_CALL(result = self->object.computeIfPresent(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "computeIfPresent", args);
      return NULL;
    }

    static PyObject *t_Map_containsKey(t_Map *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.containsKey(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "containsKey", arg);
      return NULL;
    }

    static PyObject *t_Map_containsValue(t_Map *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.containsValue(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "containsValue", arg);
      return NULL;
    }

    static PyObject *t_Map_entrySet(t_Map *self)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = self->object.entrySet());
      return ::java::util::t_Set::wrap_Object(result);
    }

    static PyObject *t_Map_equals(t_Map *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Map), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_Map_forEach(t_Map *self, PyObject *arg)
    {
      ::java::util::function::BiConsumer a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", ::java::util::function::BiConsumer::initializeClass, &a0, &p0, ::java::util::function::t_BiConsumer::parameters_))
      {
        OBJ_CALL(self->object.forEach(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "forEach", arg);
      return NULL;
    }

    static PyObject *t_Map_get(t_Map *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "get", arg);
      return NULL;
    }

    static PyObject *t_Map_getOrDefault(t_Map *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "oO", self->parameters[1], &a0, &a1))
      {
        OBJ_CALL(result = self->object.getOrDefault(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "getOrDefault", args);
      return NULL;
    }

    static PyObject *t_Map_hashCode(t_Map *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Map), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_Map_isEmpty(t_Map *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isEmpty());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_Map_keySet(t_Map *self)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = self->object.keySet());
      return ::java::util::t_Set::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_Map_merge(t_Map *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::util::function::BiFunction a2((jobject) NULL);
      PyTypeObject **p2;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OOK", self->parameters[0], self->parameters[1], ::java::util::function::BiFunction::initializeClass, &a0, &a1, &a2, &p2, ::java::util::function::t_BiFunction::parameters_))
      {
        OBJ_CALL(result = self->object.merge(a0, a1, a2));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "merge", args);
      return NULL;
    }

    static PyObject *t_Map_put(t_Map *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
      {
        OBJ_CALL(result = self->object.put(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "put", args);
      return NULL;
    }

    static PyObject *t_Map_putAll(t_Map *self, PyObject *arg)
    {
      Map a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", Map::initializeClass, &a0, &p0, t_Map::parameters_))
      {
        OBJ_CALL(self->object.putAll(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "putAll", arg);
      return NULL;
    }

    static PyObject *t_Map_putIfAbsent(t_Map *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
      {
        OBJ_CALL(result = self->object.putIfAbsent(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "putIfAbsent", args);
      return NULL;
    }

    static PyObject *t_Map_remove(t_Map *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object result((jobject) NULL);

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(result = self->object.remove(a0));
            return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
          }
        }
        break;
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object a1((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "oo", &a0, &a1))
          {
            OBJ_CALL(result = self->object.remove(a0, a1));
            Py_RETURN_BOOL(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "remove", args);
      return NULL;
    }

    static PyObject *t_Map_replace(t_Map *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object a1((jobject) NULL);
          ::java::lang::Object result((jobject) NULL);

          if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
          {
            OBJ_CALL(result = self->object.replace(a0, a1));
            return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object a1((jobject) NULL);
          ::java::lang::Object a2((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "OOO", self->parameters[0], self->parameters[1], self->parameters[1], &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.replace(a0, a1, a2));
            Py_RETURN_BOOL(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "replace", args);
      return NULL;
    }

    static PyObject *t_Map_replaceAll(t_Map *self, PyObject *arg)
    {
      ::java::util::function::BiFunction a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", ::java::util::function::BiFunction::initializeClass, &a0, &p0, ::java::util::function::t_BiFunction::parameters_))
      {
        OBJ_CALL(self->object.replaceAll(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "replaceAll", arg);
      return NULL;
    }

    static PyObject *t_Map_size(t_Map *self)
    {
      jint result;
      OBJ_CALL(result = self->object.size());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Map_values(t_Map *self)
    {
      ::java::util::Collection result((jobject) NULL);
      OBJ_CALL(result = self->object.values());
      return ::java::util::t_Collection::wrap_Object(result, self->parameters[1]);
    }
    static PyObject *t_Map_get__parameters_(t_Map *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_Map_get__empty(t_Map *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isEmpty());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/SecurityException.h"
#include "java/lang/String.h"
#include "java/lang/Throwable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *SecurityException::class$ = NULL;
    jmethodID *SecurityException::mids$ = NULL;
    bool SecurityException::live$ = false;

    jclass SecurityException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/SecurityException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_471cfbdb800444a7] = env->getMethodID(cls, "<init>", "(Ljava/lang/Throwable;)V");
        mids$[mid_init$_2e9d196dc293ffe6] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/Throwable;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    SecurityException::SecurityException() : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    SecurityException::SecurityException(const ::java::lang::String & a0) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    SecurityException::SecurityException(const ::java::lang::Throwable & a0) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_471cfbdb800444a7, a0.this$)) {}

    SecurityException::SecurityException(const ::java::lang::String & a0, const ::java::lang::Throwable & a1) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_2e9d196dc293ffe6, a0.this$, a1.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_SecurityException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_SecurityException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_SecurityException_init_(t_SecurityException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_SecurityException__methods_[] = {
      DECLARE_METHOD(t_SecurityException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_SecurityException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(SecurityException)[] = {
      { Py_tp_methods, t_SecurityException__methods_ },
      { Py_tp_init, (void *) t_SecurityException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(SecurityException)[] = {
      &PY_TYPE_DEF(::java::lang::RuntimeException),
      NULL
    };

    DEFINE_TYPE(SecurityException, t_SecurityException, SecurityException);

    void t_SecurityException::install(PyObject *module)
    {
      installType(&PY_TYPE(SecurityException), &PY_TYPE_DEF(SecurityException), module, "SecurityException", 0);
    }

    void t_SecurityException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(SecurityException), "class_", make_descriptor(SecurityException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SecurityException), "wrapfn_", make_descriptor(t_SecurityException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SecurityException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_SecurityException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, SecurityException::initializeClass, 1)))
        return NULL;
      return t_SecurityException::wrap_Object(SecurityException(((t_SecurityException *) arg)->object.this$));
    }
    static PyObject *t_SecurityException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, SecurityException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_SecurityException_init_(t_SecurityException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          SecurityException object((jobject) NULL);

          INT_CALL(object = SecurityException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          SecurityException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = SecurityException(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::Throwable a0((jobject) NULL);
          SecurityException object((jobject) NULL);

          if (!parseArgs(args, "k", ::java::lang::Throwable::initializeClass, &a0))
          {
            INT_CALL(object = SecurityException(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::Throwable a1((jobject) NULL);
          SecurityException object((jobject) NULL);

          if (!parseArgs(args, "sk", ::java::lang::Throwable::initializeClass, &a0, &a1))
          {
            INT_CALL(object = SecurityException(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/DirectoryStream$Filter.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *DirectoryStream$Filter::class$ = NULL;
      jmethodID *DirectoryStream$Filter::mids$ = NULL;
      bool DirectoryStream$Filter::live$ = false;

      jclass DirectoryStream$Filter::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/DirectoryStream$Filter");

          mids$ = new jmethodID[max_mid];
          mids$[mid_accept_8b72f2dcdde6fd1d] = env->getMethodID(cls, "accept", "(Ljava/lang/Object;)Z");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jboolean DirectoryStream$Filter::accept(const ::java::lang::Object & a0) const
      {
        return env->callBooleanMethod(this$, mids$[mid_accept_8b72f2dcdde6fd1d], a0.this$);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_DirectoryStream$Filter_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DirectoryStream$Filter_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DirectoryStream$Filter_of_(t_DirectoryStream$Filter *self, PyObject *args);
      static PyObject *t_DirectoryStream$Filter_accept(t_DirectoryStream$Filter *self, PyObject *arg);
      static PyObject *t_DirectoryStream$Filter_get__parameters_(t_DirectoryStream$Filter *self, void *data);
      static PyGetSetDef t_DirectoryStream$Filter__fields_[] = {
        DECLARE_GET_FIELD(t_DirectoryStream$Filter, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_DirectoryStream$Filter__methods_[] = {
        DECLARE_METHOD(t_DirectoryStream$Filter, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DirectoryStream$Filter, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DirectoryStream$Filter, of_, METH_VARARGS),
        DECLARE_METHOD(t_DirectoryStream$Filter, accept, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(DirectoryStream$Filter)[] = {
        { Py_tp_methods, t_DirectoryStream$Filter__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_DirectoryStream$Filter__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(DirectoryStream$Filter)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(DirectoryStream$Filter, t_DirectoryStream$Filter, DirectoryStream$Filter);
      PyObject *t_DirectoryStream$Filter::wrap_Object(const DirectoryStream$Filter& object, PyTypeObject *p0)
      {
        PyObject *obj = t_DirectoryStream$Filter::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_DirectoryStream$Filter *self = (t_DirectoryStream$Filter *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_DirectoryStream$Filter::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_DirectoryStream$Filter::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_DirectoryStream$Filter *self = (t_DirectoryStream$Filter *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_DirectoryStream$Filter::install(PyObject *module)
      {
        installType(&PY_TYPE(DirectoryStream$Filter), &PY_TYPE_DEF(DirectoryStream$Filter), module, "DirectoryStream$Filter", 0);
      }

      void t_DirectoryStream$Filter::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(DirectoryStream$Filter), "class_", make_descriptor(DirectoryStream$Filter::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DirectoryStream$Filter), "wrapfn_", make_descriptor(t_DirectoryStream$Filter::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DirectoryStream$Filter), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_DirectoryStream$Filter_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, DirectoryStream$Filter::initializeClass, 1)))
          return NULL;
        return t_DirectoryStream$Filter::wrap_Object(DirectoryStream$Filter(((t_DirectoryStream$Filter *) arg)->object.this$));
      }
      static PyObject *t_DirectoryStream$Filter_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, DirectoryStream$Filter::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_DirectoryStream$Filter_of_(t_DirectoryStream$Filter *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_DirectoryStream$Filter_accept(t_DirectoryStream$Filter *self, PyObject *arg)
      {
        ::java::lang::Object a0((jobject) NULL);
        jboolean result;

        if (!parseArg(arg, "O", self->parameters[0], &a0))
        {
          OBJ_CALL(result = self->object.accept(a0));
          Py_RETURN_BOOL(result);
        }

        PyErr_SetArgsError((PyObject *) self, "accept", arg);
        return NULL;
      }
      static PyObject *t_DirectoryStream$Filter_get__parameters_(t_DirectoryStream$Filter *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/IntToDoubleFunction.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *IntToDoubleFunction::class$ = NULL;
      jmethodID *IntToDoubleFunction::mids$ = NULL;
      bool IntToDoubleFunction::live$ = false;

      jclass IntToDoubleFunction::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/IntToDoubleFunction");

          mids$ = new jmethodID[max_mid];
          mids$[mid_applyAsDouble_f3ddedc0b6f18620] = env->getMethodID(cls, "applyAsDouble", "(I)D");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jdouble IntToDoubleFunction::applyAsDouble(jint a0) const
      {
        return env->callDoubleMethod(this$, mids$[mid_applyAsDouble_f3ddedc0b6f18620], a0);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_IntToDoubleFunction_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntToDoubleFunction_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntToDoubleFunction_applyAsDouble(t_IntToDoubleFunction *self, PyObject *arg);

      static PyMethodDef t_IntToDoubleFunction__methods_[] = {
        DECLARE_METHOD(t_IntToDoubleFunction, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntToDoubleFunction, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntToDoubleFunction, applyAsDouble, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(IntToDoubleFunction)[] = {
        { Py_tp_methods, t_IntToDoubleFunction__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(IntToDoubleFunction)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(IntToDoubleFunction, t_IntToDoubleFunction, IntToDoubleFunction);

      void t_IntToDoubleFunction::install(PyObject *module)
      {
        installType(&PY_TYPE(IntToDoubleFunction), &PY_TYPE_DEF(IntToDoubleFunction), module, "IntToDoubleFunction", 0);
      }

      void t_IntToDoubleFunction::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntToDoubleFunction), "class_", make_descriptor(IntToDoubleFunction::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntToDoubleFunction), "wrapfn_", make_descriptor(t_IntToDoubleFunction::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntToDoubleFunction), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_IntToDoubleFunction_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, IntToDoubleFunction::initializeClass, 1)))
          return NULL;
        return t_IntToDoubleFunction::wrap_Object(IntToDoubleFunction(((t_IntToDoubleFunction *) arg)->object.this$));
      }
      static PyObject *t_IntToDoubleFunction_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, IntToDoubleFunction::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_IntToDoubleFunction_applyAsDouble(t_IntToDoubleFunction *self, PyObject *arg)
      {
        jint a0;
        jdouble result;

        if (!parseArg(arg, "I", &a0))
        {
          OBJ_CALL(result = self->object.applyAsDouble(a0));
          return PyFloat_FromDouble((double) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsDouble", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/Supplier.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *Supplier::class$ = NULL;
      jmethodID *Supplier::mids$ = NULL;
      bool Supplier::live$ = false;

      jclass Supplier::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/Supplier");

          mids$ = new jmethodID[max_mid];
          mids$[mid_get_d6bcd06f3102c4d9] = env->getMethodID(cls, "get", "()Ljava/lang/Object;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::lang::Object Supplier::get() const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_d6bcd06f3102c4d9]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_Supplier_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Supplier_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Supplier_of_(t_Supplier *self, PyObject *args);
      static PyObject *t_Supplier_get(t_Supplier *self);
      static PyObject *t_Supplier_get__parameters_(t_Supplier *self, void *data);
      static PyGetSetDef t_Supplier__fields_[] = {
        DECLARE_GET_FIELD(t_Supplier, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_Supplier__methods_[] = {
        DECLARE_METHOD(t_Supplier, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Supplier, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Supplier, of_, METH_VARARGS),
        DECLARE_METHOD(t_Supplier, get, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Supplier)[] = {
        { Py_tp_methods, t_Supplier__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_Supplier__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Supplier)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Supplier, t_Supplier, Supplier);
      PyObject *t_Supplier::wrap_Object(const Supplier& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Supplier::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Supplier *self = (t_Supplier *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_Supplier::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Supplier::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Supplier *self = (t_Supplier *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_Supplier::install(PyObject *module)
      {
        installType(&PY_TYPE(Supplier), &PY_TYPE_DEF(Supplier), module, "Supplier", 0);
      }

      void t_Supplier::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Supplier), "class_", make_descriptor(Supplier::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Supplier), "wrapfn_", make_descriptor(t_Supplier::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Supplier), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Supplier_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Supplier::initializeClass, 1)))
          return NULL;
        return t_Supplier::wrap_Object(Supplier(((t_Supplier *) arg)->object.this$));
      }
      static PyObject *t_Supplier_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Supplier::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Supplier_of_(t_Supplier *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_Supplier_get(t_Supplier *self)
      {
        ::java::lang::Object result((jobject) NULL);
        OBJ_CALL(result = self->object.get());
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }
      static PyObject *t_Supplier_get__parameters_(t_Supplier *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/DataOutput.h"
#include "java/lang/String.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *DataOutput::class$ = NULL;
    jmethodID *DataOutput::mids$ = NULL;
    bool DataOutput::live$ = false;

    jclass DataOutput::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/DataOutput");

        mids$ = new jmethodID[max_mid];
        mids$[mid_write_9ffdf271836656c4] = env->getMethodID(cls, "write", "([B)V");
        mids$[mid_write_040c4cd0390c5aff] = env->getMethodID(cls, "write", "(I)V");
        mids$[mid_write_43fdd39c09bb2fad] = env->getMethodID(cls, "write", "([BII)V");
        mids$[mid_writeBoolean_9d72768e8fdce2b7] = env->getMethodID(cls, "writeBoolean", "(Z)V");
        mids$[mid_writeByte_040c4cd0390c5aff] = env->getMethodID(cls, "writeByte", "(I)V");
        mids$[mid_writeBytes_9fd2eb66a64e6f0f] = env->getMethodID(cls, "writeBytes", "(Ljava/lang/String;)V");
        mids$[mid_writeChar_040c4cd0390c5aff] = env->getMethodID(cls, "writeChar", "(I)V");
        mids$[mid_writeChars_9fd2eb66a64e6f0f] = env->getMethodID(cls, "writeChars", "(Ljava/lang/String;)V");
        mids$[mid_writeDouble_3c435f10a3b1e038] = env->getMethodID(cls, "writeDouble", "(D)V");
        mids$[mid_writeFloat_8e1d952dd65cdc3a] = env->getMethodID(cls, "writeFloat", "(F)V");
        mids$[mid_writeInt_040c4cd0390c5aff] = env->getMethodID(cls, "writeInt", "(I)V");
        mids$[mid_writeLong_9c778c9bce6694df] = env->getMethodID(cls, "writeLong", "(J)V");
        mids$[mid_writeShort_040c4cd0390c5aff] = env->getMethodID(cls, "writeShort", "(I)V");
        mids$[mid_writeUTF_9fd2eb66a64e6f0f] = env->getMethodID(cls, "writeUTF", "(Ljava/lang/String;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void DataOutput::write(const JArray< jbyte > & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_write_9ffdf271836656c4], a0.this$);
    }

    void DataOutput::write(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_write_040c4cd0390c5aff], a0);
    }

    void DataOutput::write(const JArray< jbyte > & a0, jint a1, jint a2) const
    {
      env->callVoidMethod(this$, mids$[mid_write_43fdd39c09bb2fad], a0.this$, a1, a2);
    }

    void DataOutput::writeBoolean(jboolean a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeBoolean_9d72768e8fdce2b7], a0);
    }

    void DataOutput::writeByte(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeByte_040c4cd0390c5aff], a0);
    }

    void DataOutput::writeBytes(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeBytes_9fd2eb66a64e6f0f], a0.this$);
    }

    void DataOutput::writeChar(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeChar_040c4cd0390c5aff], a0);
    }

    void DataOutput::writeChars(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeChars_9fd2eb66a64e6f0f], a0.this$);
    }

    void DataOutput::writeDouble(jdouble a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeDouble_3c435f10a3b1e038], a0);
    }

    void DataOutput::writeFloat(jfloat a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeFloat_8e1d952dd65cdc3a], a0);
    }

    void DataOutput::writeInt(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeInt_040c4cd0390c5aff], a0);
    }

    void DataOutput::writeLong(jlong a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeLong_9c778c9bce6694df], a0);
    }

    void DataOutput::writeShort(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeShort_040c4cd0390c5aff], a0);
    }

    void DataOutput::writeUTF(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_writeUTF_9fd2eb66a64e6f0f], a0.this$);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_DataOutput_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_DataOutput_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_DataOutput_write(t_DataOutput *self, PyObject *args);
    static PyObject *t_DataOutput_writeBoolean(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeByte(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeBytes(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeChar(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeChars(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeDouble(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeFloat(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeInt(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeLong(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeShort(t_DataOutput *self, PyObject *arg);
    static PyObject *t_DataOutput_writeUTF(t_DataOutput *self, PyObject *arg);

    static PyMethodDef t_DataOutput__methods_[] = {
      DECLARE_METHOD(t_DataOutput, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_DataOutput, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_DataOutput, write, METH_VARARGS),
      DECLARE_METHOD(t_DataOutput, writeBoolean, METH_O),
      DECLARE_METHOD(t_DataOutput, writeByte, METH_O),
      DECLARE_METHOD(t_DataOutput, writeBytes, METH_O),
      DECLARE_METHOD(t_DataOutput, writeChar, METH_O),
      DECLARE_METHOD(t_DataOutput, writeChars, METH_O),
      DECLARE_METHOD(t_DataOutput, writeDouble, METH_O),
      DECLARE_METHOD(t_DataOutput, writeFloat, METH_O),
      DECLARE_METHOD(t_DataOutput, writeInt, METH_O),
      DECLARE_METHOD(t_DataOutput, writeLong, METH_O),
      DECLARE_METHOD(t_DataOutput, writeShort, METH_O),
      DECLARE_METHOD(t_DataOutput, writeUTF, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(DataOutput)[] = {
      { Py_tp_methods, t_DataOutput__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(DataOutput)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(DataOutput, t_DataOutput, DataOutput);

    void t_DataOutput::install(PyObject *module)
    {
      installType(&PY_TYPE(DataOutput), &PY_TYPE_DEF(DataOutput), module, "DataOutput", 0);
    }

    void t_DataOutput::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(DataOutput), "class_", make_descriptor(DataOutput::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(DataOutput), "wrapfn_", make_descriptor(t_DataOutput::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(DataOutput), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_DataOutput_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, DataOutput::initializeClass, 1)))
        return NULL;
      return t_DataOutput::wrap_Object(DataOutput(((t_DataOutput *) arg)->object.this$));
    }
    static PyObject *t_DataOutput_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, DataOutput::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_DataOutput_write(t_DataOutput *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          JArray< jbyte > a0((jobject) NULL);

          if (!parseArgs(args, "[B", &a0))
          {
            OBJ_CALL(self->object.write(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.write(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          JArray< jbyte > a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "[BII", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.write(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "write", args);
      return NULL;
    }

    static PyObject *t_DataOutput_writeBoolean(t_DataOutput *self, PyObject *arg)
    {
      jboolean a0;

      if (!parseArg(arg, "Z", &a0))
      {
        OBJ_CALL(self->object.writeBoolean(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeBoolean", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeByte(t_DataOutput *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.writeByte(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeByte", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeBytes(t_DataOutput *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.writeBytes(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeBytes", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeChar(t_DataOutput *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.writeChar(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeChar", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeChars(t_DataOutput *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.writeChars(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeChars", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeDouble(t_DataOutput *self, PyObject *arg)
    {
      jdouble a0;

      if (!parseArg(arg, "D", &a0))
      {
        OBJ_CALL(self->object.writeDouble(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeDouble", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeFloat(t_DataOutput *self, PyObject *arg)
    {
      jfloat a0;

      if (!parseArg(arg, "F", &a0))
      {
        OBJ_CALL(self->object.writeFloat(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeFloat", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeInt(t_DataOutput *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.writeInt(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeInt", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeLong(t_DataOutput *self, PyObject *arg)
    {
      jlong a0;

      if (!parseArg(arg, "J", &a0))
      {
        OBJ_CALL(self->object.writeLong(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeLong", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeShort(t_DataOutput *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.writeShort(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeShort", arg);
      return NULL;
    }

    static PyObject *t_DataOutput_writeUTF(t_DataOutput *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.writeUTF(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "writeUTF", arg);
      return NULL;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/ClassNotFoundException.h"
#include "java/lang/String.h"
#include "java/lang/Throwable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *ClassNotFoundException::class$ = NULL;
    jmethodID *ClassNotFoundException::mids$ = NULL;
    bool ClassNotFoundException::live$ = false;

    jclass ClassNotFoundException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/ClassNotFoundException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_2e9d196dc293ffe6] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/Throwable;)V");
        mids$[mid_getCause_4d6e2861e0be5c10] = env->getMethodID(cls, "getCause", "()Ljava/lang/Throwable;");
        mids$[mid_getException_4d6e2861e0be5c10] = env->getMethodID(cls, "getException", "()Ljava/lang/Throwable;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ClassNotFoundException::ClassNotFoundException() : ::java::lang::ReflectiveOperationException(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    ClassNotFoundException::ClassNotFoundException(const ::java::lang::String & a0) : ::java::lang::ReflectiveOperationException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    ClassNotFoundException::ClassNotFoundException(const ::java::lang::String & a0, const ::java::lang::Throwable & a1) : ::java::lang::ReflectiveOperationException(env->newObject(initializeClass, &mids$, mid_init$_2e9d196dc293ffe6, a0.this$, a1.this$)) {}

    ::java::lang::Throwable ClassNotFoundException::getCause() const
    {
      return ::java::lang::Throwable(env->callObjectMethod(this$, mids$[mid_getCause_4d6e2861e0be5c10]));
    }

    ::java::lang::Throwable ClassNotFoundException::getException() const
    {
      return ::java::lang::Throwable(env->callObjectMethod(this$, mids$[mid_getException_4d6e2861e0be5c10]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_ClassNotFoundException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ClassNotFoundException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_ClassNotFoundException_init_(t_ClassNotFoundException *self, PyObject *args, PyObject *kwds);
    static PyObject *t_ClassNotFoundException_getCause(t_ClassNotFoundException *self, PyObject *args);
    static PyObject *t_ClassNotFoundException_getException(t_ClassNotFoundException *self);
    static PyObject *t_ClassNotFoundException_get__cause(t_ClassNotFoundException *self, void *data);
    static PyObject *t_ClassNotFoundException_get__exception(t_ClassNotFoundException *self, void *data);
    static PyGetSetDef t_ClassNotFoundException__fields_[] = {
      DECLARE_GET_FIELD(t_ClassNotFoundException, cause),
      DECLARE_GET_FIELD(t_ClassNotFoundException, exception),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_ClassNotFoundException__methods_[] = {
      DECLARE_METHOD(t_ClassNotFoundException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ClassNotFoundException, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ClassNotFoundException, getCause, METH_VARARGS),
      DECLARE_METHOD(t_ClassNotFoundException, getException, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(ClassNotFoundException)[] = {
      { Py_tp_methods, t_ClassNotFoundException__methods_ },
      { Py_tp_init, (void *) t_ClassNotFoundException_init_ },
      { Py_tp_getset, t_ClassNotFoundException__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(ClassNotFoundException)[] = {
      &PY_TYPE_DEF(::java::lang::ReflectiveOperationException),
      NULL
    };

    DEFINE_TYPE(ClassNotFoundException, t_ClassNotFoundException, ClassNotFoundException);

    void t_ClassNotFoundException::install(PyObject *module)
    {
      installType(&PY_TYPE(ClassNotFoundException), &PY_TYPE_DEF(ClassNotFoundException), module, "ClassNotFoundException", 0);
    }

    void t_ClassNotFoundException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(ClassNotFoundException), "class_", make_descriptor(ClassNotFoundException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ClassNotFoundException), "wrapfn_", make_descriptor(t_ClassNotFoundException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ClassNotFoundException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_ClassNotFoundException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, ClassNotFoundException::initializeClass, 1)))
        return NULL;
      return t_ClassNotFoundException::wrap_Object(ClassNotFoundException(((t_ClassNotFoundException *) arg)->object.this$));
    }
    static PyObject *t_ClassNotFoundException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, ClassNotFoundException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_ClassNotFoundException_init_(t_ClassNotFoundException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ClassNotFoundException object((jobject) NULL);

          INT_CALL(object = ClassNotFoundException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          ClassNotFoundException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = ClassNotFoundException(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::Throwable a1((jobject) NULL);
          ClassNotFoundException object((jobject) NULL);

          if (!parseArgs(args, "sk", ::java::lang::Throwable::initializeClass, &a0, &a1))
          {
            INT_CALL(object = ClassNotFoundException(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_ClassNotFoundException_getCause(t_ClassNotFoundException *self, PyObject *args)
    {
      ::java::lang::Throwable result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.getCause());
        return ::java::lang::t_Throwable::wrap_Object(result);
      }

      return callSuper(PY_TYPE(ClassNotFoundException), (PyObject *) self, "getCause", args, 2);
    }

    static PyObject *t_ClassNotFoundException_getException(t_ClassNotFoundException *self)
    {
      ::java::lang::Throwable result((jobject) NULL);
      OBJ_CALL(result = self->object.getException());
      return ::java::lang::t_Throwable::wrap_Object(result);
    }

    static PyObject *t_ClassNotFoundException_get__cause(t_ClassNotFoundException *self, void *data)
    {
      ::java::lang::Throwable value((jobject) NULL);
      OBJ_CALL(value = self->object.getCause());
      return ::java::lang::t_Throwable::wrap_Object(value);
    }

    static PyObject *t_ClassNotFoundException_get__exception(t_ClassNotFoundException *self, void *data)
    {
      ::java::lang::Throwable value((jobject) NULL);
      OBJ_CALL(value = self->object.getException());
      return ::java::lang::t_Throwable::wrap_Object(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/ListIterator.h"
#include "java/lang/Object.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *ListIterator::class$ = NULL;
    jmethodID *ListIterator::mids$ = NULL;
    bool ListIterator::live$ = false;

    jclass ListIterator::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/ListIterator");

        mids$ = new jmethodID[max_mid];
        mids$[mid_add_d20f626183f72f7d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)V");
        mids$[mid_hasNext_8454bd5aa23fd11e] = env->getMethodID(cls, "hasNext", "()Z");
        mids$[mid_hasPrevious_8454bd5aa23fd11e] = env->getMethodID(cls, "hasPrevious", "()Z");
        mids$[mid_next_d6bcd06f3102c4d9] = env->getMethodID(cls, "next", "()Ljava/lang/Object;");
        mids$[mid_nextIndex_9972fcc56b44e79d] = env->getMethodID(cls, "nextIndex", "()I");
        mids$[mid_previous_d6bcd06f3102c4d9] = env->getMethodID(cls, "previous", "()Ljava/lang/Object;");
        mids$[mid_previousIndex_9972fcc56b44e79d] = env->getMethodID(cls, "previousIndex", "()I");
        mids$[mid_remove_f2cc1bce94666404] = env->getMethodID(cls, "remove", "()V");
        mids$[mid_set_d20f626183f72f7d] = env->getMethodID(cls, "set", "(Ljava/lang/Object;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void ListIterator::add(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_add_d20f626183f72f7d], a0.this$);
    }

    jboolean ListIterator::hasNext() const
    {
      return env->callBooleanMethod(this$, mids$[mid_hasNext_8454bd5aa23fd11e]);
    }

    jboolean ListIterator::hasPrevious() const
    {
      return env->callBooleanMethod(this$, mids$[mid_hasPrevious_8454bd5aa23fd11e]);
    }

    ::java::lang::Object ListIterator::next() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_next_d6bcd06f3102c4d9]));
    }

    jint ListIterator::nextIndex() const
    {
      return env->callIntMethod(this$, mids$[mid_nextIndex_9972fcc56b44e79d]);
    }

    ::java::lang::Object ListIterator::previous() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_previous_d6bcd06f3102c4d9]));
    }

    jint ListIterator::previousIndex() const
    {
      return env->callIntMethod(this$, mids$[mid_previousIndex_9972fcc56b44e79d]);
    }

    void ListIterator::remove() const
    {
      env->callVoidMethod(this$, mids$[mid_remove_f2cc1bce94666404]);
    }

    void ListIterator::set(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_set_d20f626183f72f7d], a0.this$);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_ListIterator_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ListIterator_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ListIterator_of_(t_ListIterator *self, PyObject *args);
    static PyObject *t_ListIterator_add(t_ListIterator *self, PyObject *arg);
    static PyObject *t_ListIterator_hasNext(t_ListIterator *self, PyObject *args);
    static PyObject *t_ListIterator_hasPrevious(t_ListIterator *self);
    static PyObject *t_ListIterator_next(t_ListIterator *self, PyObject *args);
    static PyObject *t_ListIterator_nextIndex(t_ListIterator *self);
    static PyObject *t_ListIterator_previous(t_ListIterator *self);
    static PyObject *t_ListIterator_previousIndex(t_ListIterator *self);
    static PyObject *t_ListIterator_remove(t_ListIterator *self, PyObject *args);
    static PyObject *t_ListIterator_set(t_ListIterator *self, PyObject *arg);
    static PyObject *t_ListIterator_get__parameters_(t_ListIterator *self, void *data);
    static PyGetSetDef t_ListIterator__fields_[] = {
      DECLARE_GET_FIELD(t_ListIterator, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_ListIterator__methods_[] = {
      DECLARE_METHOD(t_ListIterator, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ListIterator, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ListIterator, of_, METH_VARARGS),
      DECLARE_METHOD(t_ListIterator, add, METH_O),
      DECLARE_METHOD(t_ListIterator, hasNext, METH_VARARGS),
      DECLARE_METHOD(t_ListIterator, hasPrevious, METH_NOARGS),
      DECLARE_METHOD(t_ListIterator, next, METH_VARARGS),
      DECLARE_METHOD(t_ListIterator, nextIndex, METH_NOARGS),
      DECLARE_METHOD(t_ListIterator, previous, METH_NOARGS),
      DECLARE_METHOD(t_ListIterator, previousIndex, METH_NOARGS),
      DECLARE_METHOD(t_ListIterator, remove, METH_VARARGS),
      DECLARE_METHOD(t_ListIterator, set, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(ListIterator)[] = {
      { Py_tp_methods, t_ListIterator__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_ListIterator__fields_ },
      { Py_tp_iter, (void *) PyObject_SelfIter },
      { Py_tp_iternext, (void *) ((PyObject *(*)(::java::util::t_Iterator *)) get_generic_iterator_next< ::java::util::t_Iterator,::java::lang::t_Object >) },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(ListIterator)[] = {
      &PY_TYPE_DEF(::java::util::Iterator),
      NULL
    };

    DEFINE_TYPE(ListIterator, t_ListIterator, ListIterator);
    PyObject *t_ListIterator::wrap_Object(const ListIterator& object, PyTypeObject *p0)
    {
      PyObject *obj = t_ListIterator::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_ListIterator *self = (t_ListIterator *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_ListIterator::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_ListIterator::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_ListIterator *self = (t_ListIterator *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_ListIterator::install(PyObject *module)
    {
      installType(&PY_TYPE(ListIterator), &PY_TYPE_DEF(ListIterator), module, "ListIterator", 0);
    }

    void t_ListIterator::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(ListIterator), "class_", make_descriptor(ListIterator::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ListIterator), "wrapfn_", make_descriptor(t_ListIterator::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ListIterator), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_ListIterator_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, ListIterator::initializeClass, 1)))
        return NULL;
      return t_ListIterator::wrap_Object(ListIterator(((t_ListIterator *) arg)->object.this$));
    }
    static PyObject *t_ListIterator_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, ListIterator::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_ListIterator_of_(t_ListIterator *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_ListIterator_add(t_ListIterator *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(self->object.add(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "add", arg);
      return NULL;
    }

    static PyObject *t_ListIterator_hasNext(t_ListIterator *self, PyObject *args)
    {
      jboolean result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hasNext());
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(ListIterator), (PyObject *) self, "hasNext", args, 2);
    }

    static PyObject *t_ListIterator_hasPrevious(t_ListIterator *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.hasPrevious());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_ListIterator_next(t_ListIterator *self, PyObject *args)
    {
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.next());
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(ListIterator), (PyObject *) self, "next", args, 2);
    }

    static PyObject *t_ListIterator_nextIndex(t_ListIterator *self)
    {
      jint result;
      OBJ_CALL(result = self->object.nextIndex());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_ListIterator_previous(t_ListIterator *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.previous());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_ListIterator_previousIndex(t_ListIterator *self)
    {
      jint result;
      OBJ_CALL(result = self->object.previousIndex());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_ListIterator_remove(t_ListIterator *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.remove());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(ListIterator), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_ListIterator_set(t_ListIterator *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(self->object.set(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "set", arg);
      return NULL;
    }
    static PyObject *t_ListIterator_get__parameters_(t_ListIterator *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ATNSimulator.h"
#include "org/antlr/v4/runtime/atn/PredictionContextCache.h"
#include "org/antlr/v4/runtime/atn/ATN.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/atn/PredictionContext.h"
#include "java/lang/String.h"
#include "java/util/UUID.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/atn/ATNState.h"
#include "org/antlr/v4/runtime/atn/Transition.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ATNSimulator::class$ = NULL;
          jmethodID *ATNSimulator::mids$ = NULL;
          jfieldID *ATNSimulator::fids$ = NULL;
          bool ATNSimulator::live$ = false;
          ::java::util::UUID *ATNSimulator::SERIALIZED_UUID = NULL;
          jint ATNSimulator::SERIALIZED_VERSION = (jint) 0;

          jclass ATNSimulator::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ATNSimulator");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_6f34f3e649d77815] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATN;Lorg/antlr/v4/runtime/atn/PredictionContextCache;)V");
              mids$[mid_checkCondition_9d72768e8fdce2b7] = env->getStaticMethodID(cls, "checkCondition", "(Z)V");
              mids$[mid_checkCondition_6ac9e7681f42f885] = env->getStaticMethodID(cls, "checkCondition", "(ZLjava/lang/String;)V");
              mids$[mid_clearDFA_f2cc1bce94666404] = env->getMethodID(cls, "clearDFA", "()V");
              mids$[mid_deserialize_b035da34b9807db2] = env->getStaticMethodID(cls, "deserialize", "([C)Lorg/antlr/v4/runtime/atn/ATN;");
              mids$[mid_getCachedContext_48ada528ddd16ee5] = env->getMethodID(cls, "getCachedContext", "(Lorg/antlr/v4/runtime/atn/PredictionContext;)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_getSharedContextCache_324734798e6f785f] = env->getMethodID(cls, "getSharedContextCache", "()Lorg/antlr/v4/runtime/atn/PredictionContextCache;");
              mids$[mid_reset_f2cc1bce94666404] = env->getMethodID(cls, "reset", "()V");
              mids$[mid_stateFactory_88e11c7e1343300f] = env->getStaticMethodID(cls, "stateFactory", "(II)Lorg/antlr/v4/runtime/atn/ATNState;");
              mids$[mid_toInt_6449734bbde5adfd] = env->getStaticMethodID(cls, "toInt", "(C)I");
              mids$[mid_toInt32_d4655f2a19359017] = env->getStaticMethodID(cls, "toInt32", "([CI)I");
              mids$[mid_toLong_68555c6331a7bdf4] = env->getStaticMethodID(cls, "toLong", "([CI)J");
              mids$[mid_toUUID_8e6a1298f3a88129] = env->getStaticMethodID(cls, "toUUID", "([CI)Ljava/util/UUID;");

              fids$ = new jfieldID[max_fid];
              fids$[fid_atn] = env->getFieldID(cls, "atn", "Lorg/antlr/v4/runtime/atn/ATN;");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              SERIALIZED_UUID = new ::java::util::UUID(env->getStaticObjectField(cls, "SERIALIZED_UUID", "Ljava/util/UUID;"));
              SERIALIZED_VERSION = env->getStaticIntField(cls, "SERIALIZED_VERSION");
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ATNSimulator::ATNSimulator(const ::org::antlr::v4::runtime::atn::ATN & a0, const ::org::antlr::v4::runtime::atn::PredictionContextCache & a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_6f34f3e649d77815, a0.this$, a1.this$)) {}

          void ATNSimulator::checkCondition(jboolean a0)
          {
            jclass cls = env->getClass(initializeClass);
            env->callStaticVoidMethod(cls, mids$[mid_checkCondition_9d72768e8fdce2b7], a0);
          }

          void ATNSimulator::checkCondition(jboolean a0, const ::java::lang::String & a1)
          {
            jclass cls = env->getClass(initializeClass);
            env->callStaticVoidMethod(cls, mids$[mid_checkCondition_6ac9e7681f42f885], a0, a1.this$);
          }

          void ATNSimulator::clearDFA() const
          {
            env->callVoidMethod(this$, mids$[mid_clearDFA_f2cc1bce94666404]);
          }

          ::org::antlr::v4::runtime::atn::ATN ATNSimulator::deserialize(const JArray< jchar > & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return ::org::antlr::v4::runtime::atn::ATN(env->callStaticObjectMethod(cls, mids$[mid_deserialize_b035da34b9807db2], a0.this$));
          }

          ::org::antlr::v4::runtime::atn::PredictionContext ATNSimulator::getCachedContext(const ::org::antlr::v4::runtime::atn::PredictionContext & a0) const
          {
            return ::org::antlr::v4::runtime::atn::PredictionContext(env->callObjectMethod(this$, mids$[mid_getCachedContext_48ada528ddd16ee5], a0.this$));
          }

          ::org::antlr::v4::runtime::atn::PredictionContextCache ATNSimulator::getSharedContextCache() const
          {
            return ::org::antlr::v4::runtime::atn::PredictionContextCache(env->callObjectMethod(this$, mids$[mid_getSharedContextCache_324734798e6f785f]));
          }

          void ATNSimulator::reset() const
          {
            env->callVoidMethod(this$, mids$[mid_reset_f2cc1bce94666404]);
          }

          ::org::antlr::v4::runtime::atn::ATNState ATNSimulator::stateFactory(jint a0, jint a1)
          {
            jclass cls = env->getClass(initializeClass);
            return ::org::antlr::v4::runtime::atn::ATNState(env->callStaticObjectMethod(cls, mids$[mid_stateFactory_88e11c7e1343300f], a0, a1));
          }

          jint ATNSimulator::toInt(jchar a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticIntMethod(cls, mids$[mid_toInt_6449734bbde5adfd], a0);
          }

          jint ATNSimulator::toInt32(const JArray< jchar > & a0, jint a1)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticIntMethod(cls, mids$[mid_toInt32_d4655f2a19359017], a0.this$, a1);
          }

          jlong ATNSimulator::toLong(const JArray< jchar > & a0, jint a1)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticLongMethod(cls, mids$[mid_toLong_68555c6331a7bdf4], a0.this$, a1);
          }

          ::java::util::UUID ATNSimulator::toUUID(const JArray< jchar > & a0, jint a1)
          {
            jclass cls = env->getClass(initializeClass);
            return ::java::util::UUID(env->callStaticObjectMethod(cls, mids$[mid_toUUID_8e6a1298f3a88129], a0.this$, a1));
          }

          ::org::antlr::v4::runtime::atn::ATN ATNSimulator::_get_atn() const
          {
            return ::org::antlr::v4::runtime::atn::ATN(env->getObjectField(this$, fids$[fid_atn]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ATNSimulator_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNSimulator_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ATNSimulator_init_(t_ATNSimulator *self, PyObject *args, PyObject *kwds);
          static PyObject *t_ATNSimulator_checkCondition(PyTypeObject *type, PyObject *args);
          static PyObject *t_ATNSimulator_clearDFA(t_ATNSimulator *self);
          static PyObject *t_ATNSimulator_deserialize(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNSimulator_getCachedContext(t_ATNSimulator *self, PyObject *arg);
          static PyObject *t_ATNSimulator_getSharedContextCache(t_ATNSimulator *self);
          static PyObject *t_ATNSimulator_reset(t_ATNSimulator *self);
          static PyObject *t_ATNSimulator_stateFactory(PyTypeObject *type, PyObject *args);
          static PyObject *t_ATNSimulator_toInt(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNSimulator_toInt32(PyTypeObject *type, PyObject *args);
          static PyObject *t_ATNSimulator_toLong(PyTypeObject *type, PyObject *args);
          static PyObject *t_ATNSimulator_toUUID(PyTypeObject *type, PyObject *args);
          static PyObject *t_ATNSimulator_get__atn(t_ATNSimulator *self, void *data);

          static PyObject *t_ATNSimulator_get__sharedContextCache(t_ATNSimulator *self, void *data);
          static PyGetSetDef t_ATNSimulator__fields_[] = {
            DECLARE_GET_FIELD(t_ATNSimulator, atn),
            DECLARE_GET_FIELD(t_ATNSimulator, sharedContextCache),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ATNSimulator__methods_[] = {
            DECLARE_METHOD(t_ATNSimulator, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNSimulator, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNSimulator, checkCondition, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_ATNSimulator, clearDFA, METH_NOARGS),
            DECLARE_METHOD(t_ATNSimulator, deserialize, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNSimulator, getCachedContext, METH_O),
            DECLARE_METHOD(t_ATNSimulator, getSharedContextCache, METH_NOARGS),
            DECLARE_METHOD(t_ATNSimulator, reset, METH_NOARGS),
            DECLARE_METHOD(t_ATNSimulator, stateFactory, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_ATNSimulator, toInt, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNSimulator, toInt32, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_ATNSimulator, toLong, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_ATNSimulator, toUUID, METH_VARARGS | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ATNSimulator)[] = {
            { Py_tp_methods, t_ATNSimulator__methods_ },
            { Py_tp_init, (void *) t_ATNSimulator_init_ },
            { Py_tp_getset, t_ATNSimulator__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ATNSimulator)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(ATNSimulator, t_ATNSimulator, ATNSimulator);

          void t_ATNSimulator::install(PyObject *module)
          {
            installType(&PY_TYPE(ATNSimulator), &PY_TYPE_DEF(ATNSimulator), module, "ATNSimulator", 0);
          }

          void t_ATNSimulator::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNSimulator), "class_", make_descriptor(ATNSimulator::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNSimulator), "wrapfn_", make_descriptor(t_ATNSimulator::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNSimulator), "boxfn_", make_descriptor(boxObject));
            env->getClass(ATNSimulator::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNSimulator), "SERIALIZED_UUID", make_descriptor(::java::util::t_UUID::wrap_Object(*ATNSimulator::SERIALIZED_UUID)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNSimulator), "SERIALIZED_VERSION", make_descriptor(ATNSimulator::SERIALIZED_VERSION));
          }

          static PyObject *t_ATNSimulator_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ATNSimulator::initializeClass, 1)))
              return NULL;
            return t_ATNSimulator::wrap_Object(ATNSimulator(((t_ATNSimulator *) arg)->object.this$));
          }
          static PyObject *t_ATNSimulator_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ATNSimulator::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ATNSimulator_init_(t_ATNSimulator *self, PyObject *args, PyObject *kwds)
          {
            ::org::antlr::v4::runtime::atn::ATN a0((jobject) NULL);
            ::org::antlr::v4::runtime::atn::PredictionContextCache a1((jobject) NULL);
            ATNSimulator object((jobject) NULL);

            if (!parseArgs(args, "kk", ::org::antlr::v4::runtime::atn::ATN::initializeClass, ::org::antlr::v4::runtime::atn::PredictionContextCache::initializeClass, &a0, &a1))
            {
              INT_CALL(object = ATNSimulator(a0, a1));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_ATNSimulator_checkCondition(PyTypeObject *type, PyObject *args)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 1:
              {
                jboolean a0;

                if (!parseArgs(args, "Z", &a0))
                {
                  OBJ_CALL(::org::antlr::v4::runtime::atn::ATNSimulator::checkCondition(a0));
                  Py_RETURN_NONE;
                }
              }
              break;
             case 2:
              {
                jboolean a0;
                ::java::lang::String a1((jobject) NULL);

                if (!parseArgs(args, "Zs", &a0, &a1))
                {
                  OBJ_CALL(::org::antlr::v4::runtime::atn::ATNSimulator::checkCondition(a0, a1));
                  Py_RETURN_NONE;
                }
              }
            }

            PyErr_SetArgsError(type, "checkCondition", args);
            return NULL;
          }

          static PyObject *t_ATNSimulator_clearDFA(t_ATNSimulator *self)
          {
            OBJ_CALL(self->object.clearDFA());
            Py_RETURN_NONE;
          }

          static PyObject *t_ATNSimulator_deserialize(PyTypeObject *type, PyObject *arg)
          {
            JArray< jchar > a0((jobject) NULL);
            ::org::antlr::v4::runtime::atn::ATN result((jobject) NULL);

            if (!parseArg(arg, "[C", &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::ATNSimulator::deserialize(a0));
              return ::org::antlr::v4::runtime::atn::t_ATN::wrap_Object(result);
            }

            PyErr_SetArgsError(type, "deserialize", arg);
            return NULL;
          }

          static PyObject *t_ATNSimulator_getCachedContext(t_ATNSimulator *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::PredictionContext a0((jobject) NULL);
            ::org::antlr::v4::runtime::atn::PredictionContext result((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.getCachedContext(a0));
              return ::org::antlr::v4::runtime::atn::t_PredictionContext::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "getCachedContext", arg);
            return NULL;
          }

          static PyObject *t_ATNSimulator_getSharedContextCache(t_ATNSimulator *self)
          {
            ::org::antlr::v4::runtime::atn::PredictionContextCache result((jobject) NULL);
            OBJ_CALL(result = self->object.getSharedContextCache());
            return ::org::antlr::v4::runtime::atn::t_PredictionContextCache::wrap_Object(result);
          }

          static PyObject *t_ATNSimulator_reset(t_ATNSimulator *self)
          {
            OBJ_CALL(self->object.reset());
            Py_RETURN_NONE;
          }

          static PyObject *t_ATNSimulator_stateFactory(PyTypeObject *type, PyObject *args)
          {
            jint a0;
            jint a1;
            ::org::antlr::v4::runtime::atn::ATNState result((jobject) NULL);

            if (!parseArgs(args, "II", &a0, &a1))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::ATNSimulator::stateFactory(a0, a1));
              return ::org::antlr::v4::runtime::atn::t_ATNState::wrap_Object(result);
            }

            PyErr_SetArgsError(type, "stateFactory", args);
            return NULL;
          }

          static PyObject *t_ATNSimulator_toInt(PyTypeObject *type, PyObject *arg)
          {
            jchar a0;
            jint result;

            if (!parseArg(arg, "C", &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::ATNSimulator::toInt(a0));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError(type, "toInt", arg);
            return NULL;
          }

          static PyObject *t_ATNSimulator_toInt32(PyTypeObject *type, PyObject *args)
          {
            JArray< jchar > a0((jobject) NULL);
            jint a1;
            jint result;

            if (!parseArgs(args, "[CI", &a0, &a1))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::ATNSimulator::toInt32(a0, a1));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError(type, "toInt32", args);
            return NULL;
          }

          static PyObject *t_ATNSimulator_toLong(PyTypeObject *type, PyObject *args)
          {
            JArray< jchar > a0((jobject) NULL);
            jint a1;
            jlong result;

            if (!parseArgs(args, "[CI", &a0, &a1))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::ATNSimulator::toLong(a0, a1));
              return PyLong_FromLongLong((PY_LONG_LONG) result);
            }

            PyErr_SetArgsError(type, "toLong", args);
            return NULL;
          }

          static PyObject *t_ATNSimulator_toUUID(PyTypeObject *type, PyObject *args)
          {
            JArray< jchar > a0((jobject) NULL);
            jint a1;
            ::java::util::UUID result((jobject) NULL);

            if (!parseArgs(args, "[CI", &a0, &a1))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::ATNSimulator::toUUID(a0, a1));
              return ::java::util::t_UUID::wrap_Object(result);
            }

            PyErr_SetArgsError(type, "toUUID", args);
            return NULL;
          }

          static PyObject *t_ATNSimulator_get__atn(t_ATNSimulator *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATN value((jobject) NULL);
            OBJ_CALL(value = self->object._get_atn());
            return ::org::antlr::v4::runtime::atn::t_ATN::wrap_Object(value);
          }

          static PyObject *t_ATNSimulator_get__sharedContextCache(t_ATNSimulator *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::PredictionContextCache value((jobject) NULL);
            OBJ_CALL(value = self->object.getSharedContextCache());
            return ::org::antlr::v4::runtime::atn::t_PredictionContextCache::wrap_Object(value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Currency.h"
#include "java/util/Currency.h"
#include "java/lang/Class.h"
#include "java/util/Locale.h"
#include "java/lang/String.h"
#include "java/util/Set.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Currency::class$ = NULL;
    jmethodID *Currency::mids$ = NULL;
    bool Currency::live$ = false;

    jclass Currency::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Currency");

        mids$ = new jmethodID[max_mid];
        mids$[mid_getAvailableCurrencies_7dcf4034c6d1a92a] = env->getStaticMethodID(cls, "getAvailableCurrencies", "()Ljava/util/Set;");
        mids$[mid_getCurrencyCode_db9b55ba01e03e4b] = env->getMethodID(cls, "getCurrencyCode", "()Ljava/lang/String;");
        mids$[mid_getDefaultFractionDigits_9972fcc56b44e79d] = env->getMethodID(cls, "getDefaultFractionDigits", "()I");
        mids$[mid_getDisplayName_db9b55ba01e03e4b] = env->getMethodID(cls, "getDisplayName", "()Ljava/lang/String;");
        mids$[mid_getDisplayName_8cbdae2bb55ad99c] = env->getMethodID(cls, "getDisplayName", "(Ljava/util/Locale;)Ljava/lang/String;");
        mids$[mid_getInstance_a07f8a4f47bcc5ea] = env->getStaticMethodID(cls, "getInstance", "(Ljava/lang/String;)Ljava/util/Currency;");
        mids$[mid_getInstance_40965d6f85a0b113] = env->getStaticMethodID(cls, "getInstance", "(Ljava/util/Locale;)Ljava/util/Currency;");
        mids$[mid_getNumericCode_9972fcc56b44e79d] = env->getMethodID(cls, "getNumericCode", "()I");
        mids$[mid_getSymbol_db9b55ba01e03e4b] = env->getMethodID(cls, "getSymbol", "()Ljava/lang/String;");
        mids$[mid_getSymbol_8cbdae2bb55ad99c] = env->getMethodID(cls, "getSymbol", "(Ljava/util/Locale;)Ljava/lang/String;");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ::java::util::Set Currency::getAvailableCurrencies()
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::util::Set(env->callStaticObjectMethod(cls, mids$[mid_getAvailableCurrencies_7dcf4034c6d1a92a]));
    }

    ::java::lang::String Currency::getCurrencyCode() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getCurrencyCode_db9b55ba01e03e4b]));
    }

    jint Currency::getDefaultFractionDigits() const
    {
      return env->callIntMethod(this$, mids$[mid_getDefaultFractionDigits_9972fcc56b44e79d]);
    }

    ::java::lang::String Currency::getDisplayName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_db9b55ba01e03e4b]));
    }

    ::java::lang::String Currency::getDisplayName(const ::java::util::Locale & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_8cbdae2bb55ad99c], a0.this$));
    }

    Currency Currency::getInstance(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Currency(env->callStaticObjectMethod(cls, mids$[mid_getInstance_a07f8a4f47bcc5ea], a0.this$));
    }

    Currency Currency::getInstance(const ::java::util::Locale & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Currency(env->callStaticObjectMethod(cls, mids$[mid_getInstance_40965d6f85a0b113], a0.this$));
    }

    jint Currency::getNumericCode() const
    {
      return env->callIntMethod(this$, mids$[mid_getNumericCode_9972fcc56b44e79d]);
    }

    ::java::lang::String Currency::getSymbol() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSymbol_db9b55ba01e03e4b]));
    }

    ::java::lang::String Currency::getSymbol(const ::java::util::Locale & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSymbol_8cbdae2bb55ad99c], a0.this$));
    }

    ::java::lang::String Currency::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Currency_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Currency_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Currency_getAvailableCurrencies(PyTypeObject *type);
    static PyObject *t_Currency_getCurrencyCode(t_Currency *self);
    static PyObject *t_Currency_getDefaultFractionDigits(t_Currency *self);
    static PyObject *t_Currency_getDisplayName(t_Currency *self, PyObject *args);
    static PyObject *t_Currency_getInstance(PyTypeObject *type, PyObject *args);
    static PyObject *t_Currency_getNumericCode(t_Currency *self);
    static PyObject *t_Currency_getSymbol(t_Currency *self, PyObject *args);
    static PyObject *t_Currency_toString(t_Currency *self, PyObject *args);
    static PyObject *t_Currency_get__availableCurrencies(t_Currency *self, void *data);
    static PyObject *t_Currency_get__currencyCode(t_Currency *self, void *data);
    static PyObject *t_Currency_get__defaultFractionDigits(t_Currency *self, void *data);
    static PyObject *t_Currency_get__displayName(t_Currency *self, void *data);
    static PyObject *t_Currency_get__numericCode(t_Currency *self, void *data);
    static PyObject *t_Currency_get__symbol(t_Currency *self, void *data);
    static PyGetSetDef t_Currency__fields_[] = {
      DECLARE_GET_FIELD(t_Currency, availableCurrencies),
      DECLARE_GET_FIELD(t_Currency, currencyCode),
      DECLARE_GET_FIELD(t_Currency, defaultFractionDigits),
      DECLARE_GET_FIELD(t_Currency, displayName),
      DECLARE_GET_FIELD(t_Currency, numericCode),
      DECLARE_GET_FIELD(t_Currency, symbol),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Currency__methods_[] = {
      DECLARE_METHOD(t_Currency, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Currency, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Currency, getAvailableCurrencies, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_Currency, getCurrencyCode, METH_NOARGS),
      DECLARE_METHOD(t_Currency, getDefaultFractionDigits, METH_NOARGS),
      DECLARE_METHOD(t_Currency, getDisplayName, METH_VARARGS),
      DECLARE_METHOD(t_Currency, getInstance, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Currency, getNumericCode, METH_NOARGS),
      DECLARE_METHOD(t_Currency, getSymbol, METH_VARARGS),
      DECLARE_METHOD(t_Currency, toString, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Currency)[] = {
      { Py_tp_methods, t_Currency__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Currency__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Currency)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Currency, t_Currency, Currency);

    void t_Currency::install(PyObject *module)
    {
      installType(&PY_TYPE(Currency), &PY_TYPE_DEF(Currency), module, "Currency", 0);
    }

    void t_Currency::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Currency), "class_", make_descriptor(Currency::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Currency), "wrapfn_", make_descriptor(t_Currency::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Currency), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Currency_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Currency::initializeClass, 1)))
        return NULL;
      return t_Currency::wrap_Object(Currency(((t_Currency *) arg)->object.this$));
    }
    static PyObject *t_Currency_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Currency::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Currency_getAvailableCurrencies(PyTypeObject *type)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Currency::getAvailableCurrencies());
      return ::java::util::t_Set::wrap_Object(result, ::java::util::PY_TYPE(Currency));
    }

    static PyObject *t_Currency_getCurrencyCode(t_Currency *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getCurrencyCode());
      return j2p(result);
    }

    static PyObject *t_Currency_getDefaultFractionDigits(t_Currency *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getDefaultFractionDigits());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Currency_getDisplayName(t_Currency *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getDisplayName());
          return j2p(result);
        }
        break;
       case 1:
        {
          ::java::util::Locale a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::util::Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getDisplayName(a0));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getDisplayName", args);
      return NULL;
    }

    static PyObject *t_Currency_getInstance(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          Currency result((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = ::java::util::Currency::getInstance(a0));
            return t_Currency::wrap_Object(result);
          }
        }
        {
          ::java::util::Locale a0((jobject) NULL);
          Currency result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::util::Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = ::java::util::Currency::getInstance(a0));
            return t_Currency::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError(type, "getInstance", args);
      return NULL;
    }

    static PyObject *t_Currency_getNumericCode(t_Currency *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getNumericCode());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Currency_getSymbol(t_Currency *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getSymbol());
          return j2p(result);
        }
        break;
       case 1:
        {
          ::java::util::Locale a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::util::Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getSymbol(a0));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getSymbol", args);
      return NULL;
    }

    static PyObject *t_Currency_toString(t_Currency *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(Currency), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_Currency_get__availableCurrencies(t_Currency *self, void *data)
    {
      ::java::util::Set value((jobject) NULL);
      OBJ_CALL(value = self->object.getAvailableCurrencies());
      return ::java::util::t_Set::wrap_Object(value);
    }

    static PyObject *t_Currency_get__currencyCode(t_Currency *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getCurrencyCode());
      return j2p(value);
    }

    static PyObject *t_Currency_get__defaultFractionDigits(t_Currency *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getDefaultFractionDigits());
      return PyLong_FromLong((long) value);
    }

    static PyObject *t_Currency_get__displayName(t_Currency *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getDisplayName());
      return j2p(value);
    }

    static PyObject *t_Currency_get__numericCode(t_Currency *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getNumericCode());
      return PyLong_FromLong((long) value);
    }

    static PyObject *t_Currency_get__symbol(t_Currency *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getSymbol());
      return j2p(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/regex/Pattern.h"
#include "java/util/regex/Matcher.h"
#include "java/util/function/Predicate.h"
#include "java/lang/Class.h"
#include "java/util/regex/Pattern.h"
#include "java/lang/String.h"
#include "java/lang/CharSequence.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace regex {

      ::java::lang::Class *Pattern::class$ = NULL;
      jmethodID *Pattern::mids$ = NULL;
      bool Pattern::live$ = false;
      jint Pattern::CANON_EQ = (jint) 0;
      jint Pattern::CASE_INSENSITIVE = (jint) 0;
      jint Pattern::COMMENTS = (jint) 0;
      jint Pattern::DOTALL = (jint) 0;
      jint Pattern::LITERAL = (jint) 0;
      jint Pattern::MULTILINE = (jint) 0;
      jint Pattern::UNICODE_CASE = (jint) 0;
      jint Pattern::UNICODE_CHARACTER_CLASS = (jint) 0;
      jint Pattern::UNIX_LINES = (jint) 0;

      jclass Pattern::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/regex/Pattern");

          mids$ = new jmethodID[max_mid];
          mids$[mid_asPredicate_9642992f11d82349] = env->getMethodID(cls, "asPredicate", "()Ljava/util/function/Predicate;");
          mids$[mid_compile_1635949e7c233ac0] = env->getStaticMethodID(cls, "compile", "(Ljava/lang/String;)Ljava/util/regex/Pattern;");
          mids$[mid_compile_ef7e77280009aac6] = env->getStaticMethodID(cls, "compile", "(Ljava/lang/String;I)Ljava/util/regex/Pattern;");
          mids$[mid_flags_9972fcc56b44e79d] = env->getMethodID(cls, "flags", "()I");
          mids$[mid_matcher_bf97a5101a89a457] = env->getMethodID(cls, "matcher", "(Ljava/lang/CharSequence;)Ljava/util/regex/Matcher;");
          mids$[mid_matches_2d2df9ffe19acb0c] = env->getStaticMethodID(cls, "matches", "(Ljava/lang/String;Ljava/lang/CharSequence;)Z");
          mids$[mid_pattern_db9b55ba01e03e4b] = env->getMethodID(cls, "pattern", "()Ljava/lang/String;");
          mids$[mid_quote_9bfa75c9f141b67f] = env->getStaticMethodID(cls, "quote", "(Ljava/lang/String;)Ljava/lang/String;");
          mids$[mid_split_09e1e00b2b3d0b65] = env->getMethodID(cls, "split", "(Ljava/lang/CharSequence;)[Ljava/lang/String;");
          mids$[mid_split_a860d8e62f08db0d] = env->getMethodID(cls, "split", "(Ljava/lang/CharSequence;I)[Ljava/lang/String;");
          mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

          class$ = new ::java::lang::Class(cls);
          cls = (jclass) class$->this$;

          CANON_EQ = env->getStaticIntField(cls, "CANON_EQ");
          CASE_INSENSITIVE = env->getStaticIntField(cls, "CASE_INSENSITIVE");
          COMMENTS = env->getStaticIntField(cls, "COMMENTS");
          DOTALL = env->getStaticIntField(cls, "DOTALL");
          LITERAL = env->getStaticIntField(cls, "LITERAL");
          MULTILINE = env->getStaticIntField(cls, "MULTILINE");
          UNICODE_CASE = env->getStaticIntField(cls, "UNICODE_CASE");
          UNICODE_CHARACTER_CLASS = env->getStaticIntField(cls, "UNICODE_CHARACTER_CLASS");
          UNIX_LINES = env->getStaticIntField(cls, "UNIX_LINES");
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::util::function::Predicate Pattern::asPredicate() const
      {
        return ::java::util::function::Predicate(env->callObjectMethod(this$, mids$[mid_asPredicate_9642992f11d82349]));
      }

      Pattern Pattern::compile(const ::java::lang::String & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return Pattern(env->callStaticObjectMethod(cls, mids$[mid_compile_1635949e7c233ac0], a0.this$));
      }

      Pattern Pattern::compile(const ::java::lang::String & a0, jint a1)
      {
        jclass cls = env->getClass(initializeClass);
        return Pattern(env->callStaticObjectMethod(cls, mids$[mid_compile_ef7e77280009aac6], a0.this$, a1));
      }

      jint Pattern::flags() const
      {
        return env->callIntMethod(this$, mids$[mid_flags_9972fcc56b44e79d]);
      }

      ::java::util::regex::Matcher Pattern::matcher(const ::java::lang::CharSequence & a0) const
      {
        return ::java::util::regex::Matcher(env->callObjectMethod(this$, mids$[mid_matcher_bf97a5101a89a457], a0.this$));
      }

      jboolean Pattern::matches(const ::java::lang::String & a0, const ::java::lang::CharSequence & a1)
      {
        jclass cls = env->getClass(initializeClass);
        return env->callStaticBooleanMethod(cls, mids$[mid_matches_2d2df9ffe19acb0c], a0.this$, a1.this$);
      }

      ::java::lang::String Pattern::pattern() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_pattern_db9b55ba01e03e4b]));
      }

      ::java::lang::String Pattern::quote(const ::java::lang::String & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return ::java::lang::String(env->callStaticObjectMethod(cls, mids$[mid_quote_9bfa75c9f141b67f], a0.this$));
      }

      JArray< ::java::lang::String > Pattern::split(const ::java::lang::CharSequence & a0) const
      {
        return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_split_09e1e00b2b3d0b65], a0.this$));
      }

      JArray< ::java::lang::String > Pattern::split(const ::java::lang::CharSequence & a0, jint a1) const
      {
        return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_split_a860d8e62f08db0d], a0.this$, a1));
      }

      ::java::lang::String Pattern::toString() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace regex {
      static PyObject *t_Pattern_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Pattern_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Pattern_asPredicate(t_Pattern *self);
      static PyObject *t_Pattern_compile(PyTypeObject *type, PyObject *args);
      static PyObject *t_Pattern_flags(t_Pattern *self);
      static PyObject *t_Pattern_matcher(t_Pattern *self, PyObject *arg);
      static PyObject *t_Pattern_matches(PyTypeObject *type, PyObject *args);
      static PyObject *t_Pattern_pattern(t_Pattern *self);
      static PyObject *t_Pattern_quote(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Pattern_split(t_Pattern *self, PyObject *args);
      static PyObject *t_Pattern_toString(t_Pattern *self, PyObject *args);

      static PyMethodDef t_Pattern__methods_[] = {
        DECLARE_METHOD(t_Pattern, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Pattern, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Pattern, asPredicate, METH_NOARGS),
        DECLARE_METHOD(t_Pattern, compile, METH_VARARGS | METH_CLASS),
        DECLARE_METHOD(t_Pattern, flags, METH_NOARGS),
        DECLARE_METHOD(t_Pattern, matcher, METH_O),
        DECLARE_METHOD(t_Pattern, matches, METH_VARARGS | METH_CLASS),
        DECLARE_METHOD(t_Pattern, pattern, METH_NOARGS),
        DECLARE_METHOD(t_Pattern, quote, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Pattern, split, METH_VARARGS),
        DECLARE_METHOD(t_Pattern, toString, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Pattern)[] = {
        { Py_tp_methods, t_Pattern__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Pattern)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Pattern, t_Pattern, Pattern);

      void t_Pattern::install(PyObject *module)
      {
        installType(&PY_TYPE(Pattern), &PY_TYPE_DEF(Pattern), module, "Pattern", 0);
      }

      void t_Pattern::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "class_", make_descriptor(Pattern::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "wrapfn_", make_descriptor(t_Pattern::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "boxfn_", make_descriptor(boxObject));
        env->getClass(Pattern::initializeClass);
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "CANON_EQ", make_descriptor(Pattern::CANON_EQ));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "CASE_INSENSITIVE", make_descriptor(Pattern::CASE_INSENSITIVE));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "COMMENTS", make_descriptor(Pattern::COMMENTS));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "DOTALL", make_descriptor(Pattern::DOTALL));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "LITERAL", make_descriptor(Pattern::LITERAL));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "MULTILINE", make_descriptor(Pattern::MULTILINE));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "UNICODE_CASE", make_descriptor(Pattern::UNICODE_CASE));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "UNICODE_CHARACTER_CLASS", make_descriptor(Pattern::UNICODE_CHARACTER_CLASS));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Pattern), "UNIX_LINES", make_descriptor(Pattern::UNIX_LINES));
      }

      static PyObject *t_Pattern_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Pattern::initializeClass, 1)))
          return NULL;
        return t_Pattern::wrap_Object(Pattern(((t_Pattern *) arg)->object.this$));
      }
      static PyObject *t_Pattern_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Pattern::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Pattern_asPredicate(t_Pattern *self)
      {
        ::java::util::function::Predicate result((jobject) NULL);
        OBJ_CALL(result = self->object.asPredicate());
        return ::java::util::function::t_Predicate::wrap_Object(result, ::java::lang::PY_TYPE(String));
      }

      static PyObject *t_Pattern_compile(PyTypeObject *type, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 1:
          {
            ::java::lang::String a0((jobject) NULL);
            Pattern result((jobject) NULL);

            if (!parseArgs(args, "s", &a0))
            {
              OBJ_CALL(result = ::java::util::regex::Pattern::compile(a0));
              return t_Pattern::wrap_Object(result);
            }
          }
          break;
         case 2:
          {
            ::java::lang::String a0((jobject) NULL);
            jint a1;
            Pattern result((jobject) NULL);

            if (!parseArgs(args, "sI", &a0, &a1))
            {
              OBJ_CALL(result = ::java::util::regex::Pattern::compile(a0, a1));
              return t_Pattern::wrap_Object(result);
            }
          }
        }

        PyErr_SetArgsError(type, "compile", args);
        return NULL;
      }

      static PyObject *t_Pattern_flags(t_Pattern *self)
      {
        jint result;
        OBJ_CALL(result = self->object.flags());
        return PyLong_FromLong((long) result);
      }

      static PyObject *t_Pattern_matcher(t_Pattern *self, PyObject *arg)
      {
        ::java::lang::CharSequence a0((jobject) NULL);
        ::java::util::regex::Matcher result((jobject) NULL);

        if (!parseArg(arg, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
        {
          OBJ_CALL(result = self->object.matcher(a0));
          return ::java::util::regex::t_Matcher::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "matcher", arg);
        return NULL;
      }

      static PyObject *t_Pattern_matches(PyTypeObject *type, PyObject *args)
      {
        ::java::lang::String a0((jobject) NULL);
        ::java::lang::CharSequence a1((jobject) NULL);
        jboolean result;

        if (!parseArgs(args, "sO", ::java::lang::PY_TYPE(CharSequence), &a0, &a1))
        {
          OBJ_CALL(result = ::java::util::regex::Pattern::matches(a0, a1));
          Py_RETURN_BOOL(result);
        }

        PyErr_SetArgsError(type, "matches", args);
        return NULL;
      }

      static PyObject *t_Pattern_pattern(t_Pattern *self)
      {
        ::java::lang::String result((jobject) NULL);
        OBJ_CALL(result = self->object.pattern());
        return j2p(result);
      }

      static PyObject *t_Pattern_quote(PyTypeObject *type, PyObject *arg)
      {
        ::java::lang::String a0((jobject) NULL);
        ::java::lang::String result((jobject) NULL);

        if (!parseArg(arg, "s", &a0))
        {
          OBJ_CALL(result = ::java::util::regex::Pattern::quote(a0));
          return j2p(result);
        }

        PyErr_SetArgsError(type, "quote", arg);
        return NULL;
      }

      static PyObject *t_Pattern_split(t_Pattern *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 1:
          {
            ::java::lang::CharSequence a0((jobject) NULL);
            JArray< ::java::lang::String > result((jobject) NULL);

            if (!parseArgs(args, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
            {
              OBJ_CALL(result = self->object.split(a0));
              return JArray<jstring>(result.this$).wrap();
            }
          }
          break;
         case 2:
          {
            ::java::lang::CharSequence a0((jobject) NULL);
            jint a1;
            JArray< ::java::lang::String > result((jobject) NULL);

            if (!parseArgs(args, "OI", ::java::lang::PY_TYPE(CharSequence), &a0, &a1))
            {
              OBJ_CALL(result = self->object.split(a0, a1));
              return JArray<jstring>(result.this$).wrap();
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "split", args);
        return NULL;
      }

      static PyObject *t_Pattern_toString(t_Pattern *self, PyObject *args)
      {
        ::java::lang::String result((jobject) NULL);

        if (!parseArgs(args, ""))
        {
          OBJ_CALL(result = self->object.toString());
          return j2p(result);
        }

        return callSuper(PY_TYPE(Pattern), (PyObject *) self, "toString", args, 2);
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Spliterator$OfLong.h"
#include "java/lang/Long.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/Spliterator$OfLong.h"
#include "java/util/function/LongConsumer.h"
#include "java/util/function/Consumer.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Spliterator$OfLong::class$ = NULL;
    jmethodID *Spliterator$OfLong::mids$ = NULL;
    bool Spliterator$OfLong::live$ = false;

    jclass Spliterator$OfLong::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Spliterator$OfLong");

        mids$ = new jmethodID[max_mid];
        mids$[mid_forEachRemaining_39fdd8ee24bf1a00] = env->getMethodID(cls, "forEachRemaining", "(Ljava/util/function/Consumer;)V");
        mids$[mid_forEachRemaining_4e5c29ffb5c9cc85] = env->getMethodID(cls, "forEachRemaining", "(Ljava/util/function/LongConsumer;)V");
        mids$[mid_tryAdvance_9aa53ce3333098c2] = env->getMethodID(cls, "tryAdvance", "(Ljava/util/function/Consumer;)Z");
        mids$[mid_tryAdvance_0a52babb5f5ceee3] = env->getMethodID(cls, "tryAdvance", "(Ljava/util/function/LongConsumer;)Z");
        mids$[mid_trySplit_6e266caebc2ea4d2] = env->getMethodID(cls, "trySplit", "()Ljava/util/Spliterator$OfLong;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Spliterator$OfLong::forEachRemaining(const ::java::util::function::Consumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEachRemaining_39fdd8ee24bf1a00], a0.this$);
    }

    void Spliterator$OfLong::forEachRemaining(const ::java::util::function::LongConsumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEachRemaining_4e5c29ffb5c9cc85], a0.this$);
    }

    jboolean Spliterator$OfLong::tryAdvance(const ::java::util::function::Consumer & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_tryAdvance_9aa53ce3333098c2], a0.this$);
    }

    jboolean Spliterator$OfLong::tryAdvance(const ::java::util::function::LongConsumer & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_tryAdvance_0a52babb5f5ceee3], a0.this$);
    }

    Spliterator$OfLong Spliterator$OfLong::trySplit() const
    {
      return Spliterator$OfLong(env->callObjectMethod(this$, mids$[mid_trySplit_6e266caebc2ea4d2]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Spliterator$OfLong_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator$OfLong_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator$OfLong_of_(t_Spliterator$OfLong *self, PyObject *args);
    static PyObject *t_Spliterator$OfLong_forEachRemaining(t_Spliterator$OfLong *self, PyObject *args);
    static PyObject *t_Spliterator$OfLong_tryAdvance(t_Spliterator$OfLong *self, PyObject *args);
    static PyObject *t_Spliterator$OfLong_trySplit(t_Spliterator$OfLong *self, PyObject *args);
    static PyObject *t_Spliterator$OfLong_get__parameters_(t_Spliterator$OfLong *self, void *data);
    static PyGetSetDef t_Spliterator$OfLong__fields_[] = {
      DECLARE_GET_FIELD(t_Spliterator$OfLong, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Spliterator$OfLong__methods_[] = {
      DECLARE_METHOD(t_Spliterator$OfLong, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator$OfLong, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator$OfLong, of_, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfLong, forEachRemaining, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfLong, tryAdvance, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfLong, trySplit, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Spliterator$OfLong)[] = {
      { Py_tp_methods, t_Spliterator$OfLong__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Spliterator$OfLong__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Spliterator$OfLong)[] = {
      &PY_TYPE_DEF(::java::util::Spliterator$OfPrimitive),
      NULL
    };

    DEFINE_TYPE(Spliterator$OfLong, t_Spliterator$OfLong, Spliterator$OfLong);
    PyObject *t_Spliterator$OfLong::wrap_Object(const Spliterator$OfLong& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Spliterator$OfLong::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator$OfLong *self = (t_Spliterator$OfLong *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Spliterator$OfLong::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Spliterator$OfLong::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator$OfLong *self = (t_Spliterator$OfLong *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Spliterator$OfLong::install(PyObject *module)
    {
      installType(&PY_TYPE(Spliterator$OfLong), &PY_TYPE_DEF(Spliterator$OfLong), module, "Spliterator$OfLong", 0);
    }

    void t_Spliterator$OfLong::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfLong), "class_", make_descriptor(Spliterator$OfLong::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfLong), "wrapfn_", make_descriptor(t_Spliterator$OfLong::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfLong), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Spliterator$OfLong_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Spliterator$OfLong::initializeClass, 1)))
        return NULL;
      return t_Spliterator$OfLong::wrap_Object(Spliterator$OfLong(((t_Spliterator$OfLong *) arg)->object.this$));
    }
    static PyObject *t_Spliterator$OfLong_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Spliterator$OfLong::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Spliterator$OfLong_of_(t_Spliterator$OfLong *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Spliterator$OfLong_forEachRemaining(t_Spliterator$OfLong *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::function::Consumer a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArgs(args, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
          {
            OBJ_CALL(self->object.forEachRemaining(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::util::function::LongConsumer a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::util::function::LongConsumer::initializeClass, &a0))
          {
            OBJ_CALL(self->object.forEachRemaining(a0));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(Spliterator$OfLong), (PyObject *) self, "forEachRemaining", args, 2);
    }

    static PyObject *t_Spliterator$OfLong_tryAdvance(t_Spliterator$OfLong *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::function::Consumer a0((jobject) NULL);
          PyTypeObject **p0;
          jboolean result;

          if (!parseArgs(args, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
          {
            OBJ_CALL(result = self->object.tryAdvance(a0));
            Py_RETURN_BOOL(result);
          }
        }
        {
          ::java::util::function::LongConsumer a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "k", ::java::util::function::LongConsumer::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.tryAdvance(a0));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(Spliterator$OfLong), (PyObject *) self, "tryAdvance", args, 2);
    }

    static PyObject *t_Spliterator$OfLong_trySplit(t_Spliterator$OfLong *self, PyObject *args)
    {
      Spliterator$OfLong result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.trySplit());
        return t_Spliterator$OfLong::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Spliterator$OfLong), (PyObject *) self, "trySplit", args, 2);
    }
    static PyObject *t_Spliterator$OfLong_get__parameters_(t_Spliterator$OfLong *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/EOFException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *EOFException::class$ = NULL;
    jmethodID *EOFException::mids$ = NULL;
    bool EOFException::live$ = false;

    jclass EOFException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/EOFException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    EOFException::EOFException() : ::java::io::IOException(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    EOFException::EOFException(const ::java::lang::String & a0) : ::java::io::IOException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_EOFException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_EOFException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_EOFException_init_(t_EOFException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_EOFException__methods_[] = {
      DECLARE_METHOD(t_EOFException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_EOFException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(EOFException)[] = {
      { Py_tp_methods, t_EOFException__methods_ },
      { Py_tp_init, (void *) t_EOFException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(EOFException)[] = {
      &PY_TYPE_DEF(::java::io::IOException),
      NULL
    };

    DEFINE_TYPE(EOFException, t_EOFException, EOFException);

    void t_EOFException::install(PyObject *module)
    {
      installType(&PY_TYPE(EOFException), &PY_TYPE_DEF(EOFException), module, "EOFException", 0);
    }

    void t_EOFException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(EOFException), "class_", make_descriptor(EOFException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(EOFException), "wrapfn_", make_descriptor(t_EOFException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(EOFException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_EOFException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, EOFException::initializeClass, 1)))
        return NULL;
      return t_EOFException::wrap_Object(EOFException(((t_EOFException *) arg)->object.this$));
    }
    static PyObject *t_EOFException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, EOFException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_EOFException_init_(t_EOFException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          EOFException object((jobject) NULL);

          INT_CALL(object = EOFException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          EOFException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = EOFException(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/SecurityManager.h"
#include "java/lang/ThreadGroup.h"
#include "java/lang/Class.h"
#include "java/io/FileDescriptor.h"
#include "java/lang/String.h"
#include "java/lang/Thread.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *SecurityManager::class$ = NULL;
    jmethodID *SecurityManager::mids$ = NULL;
    bool SecurityManager::live$ = false;

    jclass SecurityManager::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/SecurityManager");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_checkAccept_3fb1dae8d4037984] = env->getMethodID(cls, "checkAccept", "(Ljava/lang/String;I)V");
        mids$[mid_checkAccess_5d5f76d7c905a26c] = env->getMethodID(cls, "checkAccess", "(Ljava/lang/Thread;)V");
        mids$[mid_checkAccess_b520c93262c91c59] = env->getMethodID(cls, "checkAccess", "(Ljava/lang/ThreadGroup;)V");
        mids$[mid_checkAwtEventQueueAccess_f2cc1bce94666404] = env->getMethodID(cls, "checkAwtEventQueueAccess", "()V");
        mids$[mid_checkConnect_3fb1dae8d4037984] = env->getMethodID(cls, "checkConnect", "(Ljava/lang/String;I)V");
        mids$[mid_checkConnect_d6d4bb87abff9d3d] = env->getMethodID(cls, "checkConnect", "(Ljava/lang/String;ILjava/lang/Object;)V");
        mids$[mid_checkCreateClassLoader_f2cc1bce94666404] = env->getMethodID(cls, "checkCreateClassLoader", "()V");
        mids$[mid_checkDelete_9fd2eb66a64e6f0f] = env->getMethodID(cls, "checkDelete", "(Ljava/lang/String;)V");
        mids$[mid_checkExec_9fd2eb66a64e6f0f] = env->getMethodID(cls, "checkExec", "(Ljava/lang/String;)V");
        mids$[mid_checkExit_040c4cd0390c5aff] = env->getMethodID(cls, "checkExit", "(I)V");
        mids$[mid_checkLink_9fd2eb66a64e6f0f] = env->getMethodID(cls, "checkLink", "(Ljava/lang/String;)V");
        mids$[mid_checkListen_040c4cd0390c5aff] = env->getMethodID(cls, "checkListen", "(I)V");
        mids$[mid_checkMemberAccess_b4da22b11eb3f6cc] = env->getMethodID(cls, "checkMemberAccess", "(Ljava/lang/Class;I)V");
        mids$[mid_checkPackageAccess_9fd2eb66a64e6f0f] = env->getMethodID(cls, "checkPackageAccess", "(Ljava/lang/String;)V");
        mids$[mid_checkPackageDefinition_9fd2eb66a64e6f0f] = env->getMethodID(cls, "checkPackageDefinition", "(Ljava/lang/String;)V");
        mids$[mid_checkPrintJobAccess_f2cc1bce94666404] = env->getMethodID(cls, "checkPrintJobAccess", "()V");
        mids$[mid_checkPropertiesAccess_f2cc1bce94666404] = env->getMethodID(cls, "checkPropertiesAccess", "()V");
        mids$[mid_checkPropertyAccess_9fd2eb66a64e6f0f] = env->getMethodID(cls, "checkPropertyAccess", "(Ljava/lang/String;)V");
        mids$[mid_checkRead_777cb188f5616fc7] = env->getMethodID(cls, "checkRead", "(Ljava/io/FileDescriptor;)V");
        mids$[mid_checkRead_9fd2eb66a64e6f0f] = env->getMethodID(cls, "checkRead", "(Ljava/lang/String;)V");
        mids$[mid_checkRead_a814174df0bbb9ee] = env->getMethodID(cls, "checkRead", "(Ljava/lang/String;Ljava/lang/Object;)V");
        mids$[mid_checkSecurityAccess_9fd2eb66a64e6f0f] = env->getMethodID(cls, "checkSecurityAccess", "(Ljava/lang/String;)V");
        mids$[mid_checkSetFactory_f2cc1bce94666404] = env->getMethodID(cls, "checkSetFactory", "()V");
        mids$[mid_checkSystemClipboardAccess_f2cc1bce94666404] = env->getMethodID(cls, "checkSystemClipboardAccess", "()V");
        mids$[mid_checkTopLevelWindow_8b72f2dcdde6fd1d] = env->getMethodID(cls, "checkTopLevelWindow", "(Ljava/lang/Object;)Z");
        mids$[mid_checkWrite_777cb188f5616fc7] = env->getMethodID(cls, "checkWrite", "(Ljava/io/FileDescriptor;)V");
        mids$[mid_checkWrite_9fd2eb66a64e6f0f] = env->getMethodID(cls, "checkWrite", "(Ljava/lang/String;)V");
        mids$[mid_getInCheck_8454bd5aa23fd11e] = env->getMethodID(cls, "getInCheck", "()Z");
        mids$[mid_getSecurityContext_d6bcd06f3102c4d9] = env->getMethodID(cls, "getSecurityContext", "()Ljava/lang/Object;");
        mids$[mid_getThreadGroup_04b6c2a69b2c4912] = env->getMethodID(cls, "getThreadGroup", "()Ljava/lang/ThreadGroup;");
        mids$[mid_getClassContext_2e0bbcab33cbe6ec] = env->getMethodID(cls, "getClassContext", "()[Ljava/lang/Class;");
        mids$[mid_currentClassLoader_62052cb9b95d8b0c] = env->getMethodID(cls, "currentClassLoader", "()Ljava/lang/ClassLoader;");
        mids$[mid_currentLoadedClass_9df2cc6ebce035fe] = env->getMethodID(cls, "currentLoadedClass", "()Ljava/lang/Class;");
        mids$[mid_classDepth_a5a7d1128e9e2bb7] = env->getMethodID(cls, "classDepth", "(Ljava/lang/String;)I");
        mids$[mid_classLoaderDepth_9972fcc56b44e79d] = env->getMethodID(cls, "classLoaderDepth", "()I");
        mids$[mid_inClass_145b2d0af0c06b93] = env->getMethodID(cls, "inClass", "(Ljava/lang/String;)Z");
        mids$[mid_inClassLoader_8454bd5aa23fd11e] = env->getMethodID(cls, "inClassLoader", "()Z");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    SecurityManager::SecurityManager() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    void SecurityManager::checkAccept(const ::java::lang::String & a0, jint a1) const
    {
      env->callVoidMethod(this$, mids$[mid_checkAccept_3fb1dae8d4037984], a0.this$, a1);
    }

    void SecurityManager::checkAccess(const ::java::lang::Thread & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkAccess_5d5f76d7c905a26c], a0.this$);
    }

    void SecurityManager::checkAccess(const ::java::lang::ThreadGroup & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkAccess_b520c93262c91c59], a0.this$);
    }

    void SecurityManager::checkAwtEventQueueAccess() const
    {
      env->callVoidMethod(this$, mids$[mid_checkAwtEventQueueAccess_f2cc1bce94666404]);
    }

    void SecurityManager::checkConnect(const ::java::lang::String & a0, jint a1) const
    {
      env->callVoidMethod(this$, mids$[mid_checkConnect_3fb1dae8d4037984], a0.this$, a1);
    }

    void SecurityManager::checkConnect(const ::java::lang::String & a0, jint a1, const ::java::lang::Object & a2) const
    {
      env->callVoidMethod(this$, mids$[mid_checkConnect_d6d4bb87abff9d3d], a0.this$, a1, a2.this$);
    }

    void SecurityManager::checkCreateClassLoader() const
    {
      env->callVoidMethod(this$, mids$[mid_checkCreateClassLoader_f2cc1bce94666404]);
    }

    void SecurityManager::checkDelete(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkDelete_9fd2eb66a64e6f0f], a0.this$);
    }

    void SecurityManager::checkExec(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkExec_9fd2eb66a64e6f0f], a0.this$);
    }

    void SecurityManager::checkExit(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkExit_040c4cd0390c5aff], a0);
    }

    void SecurityManager::checkLink(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkLink_9fd2eb66a64e6f0f], a0.this$);
    }

    void SecurityManager::checkListen(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkListen_040c4cd0390c5aff], a0);
    }

    void SecurityManager::checkMemberAccess(const ::java::lang::Class & a0, jint a1) const
    {
      env->callVoidMethod(this$, mids$[mid_checkMemberAccess_b4da22b11eb3f6cc], a0.this$, a1);
    }

    void SecurityManager::checkPackageAccess(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkPackageAccess_9fd2eb66a64e6f0f], a0.this$);
    }

    void SecurityManager::checkPackageDefinition(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkPackageDefinition_9fd2eb66a64e6f0f], a0.this$);
    }

    void SecurityManager::checkPrintJobAccess() const
    {
      env->callVoidMethod(this$, mids$[mid_checkPrintJobAccess_f2cc1bce94666404]);
    }

    void SecurityManager::checkPropertiesAccess() const
    {
      env->callVoidMethod(this$, mids$[mid_checkPropertiesAccess_f2cc1bce94666404]);
    }

    void SecurityManager::checkPropertyAccess(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkPropertyAccess_9fd2eb66a64e6f0f], a0.this$);
    }

    void SecurityManager::checkRead(const ::java::io::FileDescriptor & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkRead_777cb188f5616fc7], a0.this$);
    }

    void SecurityManager::checkRead(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkRead_9fd2eb66a64e6f0f], a0.this$);
    }

    void SecurityManager::checkRead(const ::java::lang::String & a0, const ::java::lang::Object & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_checkRead_a814174df0bbb9ee], a0.this$, a1.this$);
    }

    void SecurityManager::checkSecurityAccess(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkSecurityAccess_9fd2eb66a64e6f0f], a0.this$);
    }

    void SecurityManager::checkSetFactory() const
    {
      env->callVoidMethod(this$, mids$[mid_checkSetFactory_f2cc1bce94666404]);
    }

    void SecurityManager::checkSystemClipboardAccess() const
    {
      env->callVoidMethod(this$, mids$[mid_checkSystemClipboardAccess_f2cc1bce94666404]);
    }

    jboolean SecurityManager::checkTopLevelWindow(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_checkTopLevelWindow_8b72f2dcdde6fd1d], a0.this$);
    }

    void SecurityManager::checkWrite(const ::java::io::FileDescriptor & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkWrite_777cb188f5616fc7], a0.this$);
    }

    void SecurityManager::checkWrite(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_checkWrite_9fd2eb66a64e6f0f], a0.this$);
    }

    jboolean SecurityManager::getInCheck() const
    {
      return env->callBooleanMethod(this$, mids$[mid_getInCheck_8454bd5aa23fd11e]);
    }

    ::java::lang::Object SecurityManager::getSecurityContext() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_getSecurityContext_d6bcd06f3102c4d9]));
    }

    ::java::lang::ThreadGroup SecurityManager::getThreadGroup() const
    {
      return ::java::lang::ThreadGroup(env->callObjectMethod(this$, mids$[mid_getThreadGroup_04b6c2a69b2c4912]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_SecurityManager_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_SecurityManager_instance_(PyTypeObject *type, PyObject *arg);
    static int t_SecurityManager_init_(t_SecurityManager *self, PyObject *args, PyObject *kwds);
    static PyObject *t_SecurityManager_checkAccept(t_SecurityManager *self, PyObject *args);
    static PyObject *t_SecurityManager_checkAccess(t_SecurityManager *self, PyObject *args);
    static PyObject *t_SecurityManager_checkAwtEventQueueAccess(t_SecurityManager *self);
    static PyObject *t_SecurityManager_checkConnect(t_SecurityManager *self, PyObject *args);
    static PyObject *t_SecurityManager_checkCreateClassLoader(t_SecurityManager *self);
    static PyObject *t_SecurityManager_checkDelete(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkExec(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkExit(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkLink(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkListen(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkMemberAccess(t_SecurityManager *self, PyObject *args);
    static PyObject *t_SecurityManager_checkPackageAccess(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkPackageDefinition(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkPrintJobAccess(t_SecurityManager *self);
    static PyObject *t_SecurityManager_checkPropertiesAccess(t_SecurityManager *self);
    static PyObject *t_SecurityManager_checkPropertyAccess(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkRead(t_SecurityManager *self, PyObject *args);
    static PyObject *t_SecurityManager_checkSecurityAccess(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkSetFactory(t_SecurityManager *self);
    static PyObject *t_SecurityManager_checkSystemClipboardAccess(t_SecurityManager *self);
    static PyObject *t_SecurityManager_checkTopLevelWindow(t_SecurityManager *self, PyObject *arg);
    static PyObject *t_SecurityManager_checkWrite(t_SecurityManager *self, PyObject *args);
    static PyObject *t_SecurityManager_getInCheck(t_SecurityManager *self);
    static PyObject *t_SecurityManager_getSecurityContext(t_SecurityManager *self);
    static PyObject *t_SecurityManager_getThreadGroup(t_SecurityManager *self);
    static PyObject *t_SecurityManager_get__inCheck(t_SecurityManager *self, void *data);
    static PyObject *t_SecurityManager_get__securityContext(t_SecurityManager *self, void *data);
    static PyObject *t_SecurityManager_get__threadGroup(t_SecurityManager *self, void *data);
    static PyGetSetDef t_SecurityManager__fields_[] = {
      DECLARE_GET_FIELD(t_SecurityManager, inCheck),
      DECLARE_GET_FIELD(t_SecurityManager, securityContext),
      DECLARE_GET_FIELD(t_SecurityManager, threadGroup),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_SecurityManager__methods_[] = {
      DECLARE_METHOD(t_SecurityManager, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_SecurityManager, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_SecurityManager, checkAccept, METH_VARARGS),
      DECLARE_METHOD(t_SecurityManager, checkAccess, METH_VARARGS),
      DECLARE_METHOD(t_SecurityManager, checkAwtEventQueueAccess, METH_NOARGS),
      DECLARE_METHOD(t_SecurityManager, checkConnect, METH_VARARGS),
      DECLARE_METHOD(t_SecurityManager, checkCreateClassLoader, METH_NOARGS),
      DECLARE_METHOD(t_SecurityManager, checkDelete, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkExec, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkExit, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkLink, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkListen, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkMemberAccess, METH_VARARGS),
      DECLARE_METHOD(t_SecurityManager, checkPackageAccess, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkPackageDefinition, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkPrintJobAccess, METH_NOARGS),
      DECLARE_METHOD(t_SecurityManager, checkPropertiesAccess, METH_NOARGS),
      DECLARE_METHOD(t_SecurityManager, checkPropertyAccess, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkRead, METH_VARARGS),
      DECLARE_METHOD(t_SecurityManager, checkSecurityAccess, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkSetFactory, METH_NOARGS),
      DECLARE_METHOD(t_SecurityManager, checkSystemClipboardAccess, METH_NOARGS),
      DECLARE_METHOD(t_SecurityManager, checkTopLevelWindow, METH_O),
      DECLARE_METHOD(t_SecurityManager, checkWrite, METH_VARARGS),
      DECLARE_METHOD(t_SecurityManager, getInCheck, METH_NOARGS),
      DECLARE_METHOD(t_SecurityManager, getSecurityContext, METH_NOARGS),
      DECLARE_METHOD(t_SecurityManager, getThreadGroup, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(SecurityManager)[] = {
      { Py_tp_methods, t_SecurityManager__methods_ },
      { Py_tp_init, (void *) t_SecurityManager_init_ },
      { Py_tp_getset, t_SecurityManager__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(SecurityManager)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(SecurityManager, t_SecurityManager, SecurityManager);

    void t_SecurityManager::install(PyObject *module)
    {
      installType(&PY_TYPE(SecurityManager), &PY_TYPE_DEF(SecurityManager), module, "SecurityManager", 0);
    }

    void t_SecurityManager::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(SecurityManager), "class_", make_descriptor(SecurityManager::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SecurityManager), "wrapfn_", make_descriptor(t_SecurityManager::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SecurityManager), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_SecurityManager_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, SecurityManager::initializeClass, 1)))
        return NULL;
      return t_SecurityManager::wrap_Object(SecurityManager(((t_SecurityManager *) arg)->object.this$));
    }
    static PyObject *t_SecurityManager_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, SecurityManager::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_SecurityManager_init_(t_SecurityManager *self, PyObject *args, PyObject *kwds)
    {
      SecurityManager object((jobject) NULL);

      INT_CALL(object = SecurityManager());
      self->object = object;

      return 0;
    }

    static PyObject *t_SecurityManager_checkAccept(t_SecurityManager *self, PyObject *args)
    {
      ::java::lang::String a0((jobject) NULL);
      jint a1;

      if (!parseArgs(args, "sI", &a0, &a1))
      {
        OBJ_CALL(self->object.checkAccept(a0, a1));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkAccept", args);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkAccess(t_SecurityManager *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Thread a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::lang::Thread::initializeClass, &a0))
          {
            OBJ_CALL(self->object.checkAccess(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::lang::ThreadGroup a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::lang::ThreadGroup::initializeClass, &a0))
          {
            OBJ_CALL(self->object.checkAccess(a0));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "checkAccess", args);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkAwtEventQueueAccess(t_SecurityManager *self)
    {
      OBJ_CALL(self->object.checkAwtEventQueueAccess());
      Py_RETURN_NONE;
    }

    static PyObject *t_SecurityManager_checkConnect(t_SecurityManager *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          jint a1;

          if (!parseArgs(args, "sI", &a0, &a1))
          {
            OBJ_CALL(self->object.checkConnect(a0, a1));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          ::java::lang::String a0((jobject) NULL);
          jint a1;
          ::java::lang::Object a2((jobject) NULL);

          if (!parseArgs(args, "sIo", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.checkConnect(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "checkConnect", args);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkCreateClassLoader(t_SecurityManager *self)
    {
      OBJ_CALL(self->object.checkCreateClassLoader());
      Py_RETURN_NONE;
    }

    static PyObject *t_SecurityManager_checkDelete(t_SecurityManager *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.checkDelete(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkDelete", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkExec(t_SecurityManager *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.checkExec(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkExec", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkExit(t_SecurityManager *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.checkExit(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkExit", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkLink(t_SecurityManager *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.checkLink(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkLink", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkListen(t_SecurityManager *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.checkListen(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkListen", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkMemberAccess(t_SecurityManager *self, PyObject *args)
    {
      ::java::lang::Class a0((jobject) NULL);
      PyTypeObject **p0;
      jint a1;

      if (!parseArgs(args, "KI", ::java::lang::Class::initializeClass, &a0, &p0, ::java::lang::t_Class::parameters_, &a1))
      {
        OBJ_CALL(self->object.checkMemberAccess(a0, a1));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkMemberAccess", args);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkPackageAccess(t_SecurityManager *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.checkPackageAccess(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkPackageAccess", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkPackageDefinition(t_SecurityManager *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.checkPackageDefinition(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkPackageDefinition", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkPrintJobAccess(t_SecurityManager *self)
    {
      OBJ_CALL(self->object.checkPrintJobAccess());
      Py_RETURN_NONE;
    }

    static PyObject *t_SecurityManager_checkPropertiesAccess(t_SecurityManager *self)
    {
      OBJ_CALL(self->object.checkPropertiesAccess());
      Py_RETURN_NONE;
    }

    static PyObject *t_SecurityManager_checkPropertyAccess(t_SecurityManager *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.checkPropertyAccess(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkPropertyAccess", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkRead(t_SecurityManager *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::io::FileDescriptor a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::FileDescriptor::initializeClass, &a0))
          {
            OBJ_CALL(self->object.checkRead(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(self->object.checkRead(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::Object a1((jobject) NULL);

          if (!parseArgs(args, "so", &a0, &a1))
          {
            OBJ_CALL(self->object.checkRead(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "checkRead", args);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkSecurityAccess(t_SecurityManager *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.checkSecurityAccess(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "checkSecurityAccess", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkSetFactory(t_SecurityManager *self)
    {
      OBJ_CALL(self->object.checkSetFactory());
      Py_RETURN_NONE;
    }

    static PyObject *t_SecurityManager_checkSystemClipboardAccess(t_SecurityManager *self)
    {
      OBJ_CALL(self->object.checkSystemClipboardAccess());
      Py_RETURN_NONE;
    }

    static PyObject *t_SecurityManager_checkTopLevelWindow(t_SecurityManager *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.checkTopLevelWindow(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "checkTopLevelWindow", arg);
      return NULL;
    }

    static PyObject *t_SecurityManager_checkWrite(t_SecurityManager *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::io::FileDescriptor a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::FileDescriptor::initializeClass, &a0))
          {
            OBJ_CALL(self->object.checkWrite(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(self->object.checkWrite(a0));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "checkWrite", args);
      return NULL;
    }

    static PyObject *t_SecurityManager_getInCheck(t_SecurityManager *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.getInCheck());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_SecurityManager_getSecurityContext(t_SecurityManager *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.getSecurityContext());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_SecurityManager_getThreadGroup(t_SecurityManager *self)
    {
      ::java::lang::ThreadGroup result((jobject) NULL);
      OBJ_CALL(result = self->object.getThreadGroup());
      return ::java::lang::t_ThreadGroup::wrap_Object(result);
    }

    static PyObject *t_SecurityManager_get__inCheck(t_SecurityManager *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.getInCheck());
      Py_RETURN_BOOL(value);
    }

    static PyObject *t_SecurityManager_get__securityContext(t_SecurityManager *self, void *data)
    {
      ::java::lang::Object value((jobject) NULL);
      OBJ_CALL(value = self->object.getSecurityContext());
      return ::java::lang::t_Object::wrap_Object(value);
    }

    static PyObject *t_SecurityManager_get__threadGroup(t_SecurityManager *self, void *data)
    {
      ::java::lang::ThreadGroup value((jobject) NULL);
      OBJ_CALL(value = self->object.getThreadGroup());
      return ::java::lang::t_ThreadGroup::wrap_Object(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/Callable.h"
#include "java/lang/Exception.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *Callable::class$ = NULL;
      jmethodID *Callable::mids$ = NULL;
      bool Callable::live$ = false;

      jclass Callable::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/Callable");

          mids$ = new jmethodID[max_mid];
          mids$[mid_call_d6bcd06f3102c4d9] = env->getMethodID(cls, "call", "()Ljava/lang/Object;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::lang::Object Callable::call() const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_call_d6bcd06f3102c4d9]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_Callable_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Callable_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Callable_of_(t_Callable *self, PyObject *args);
      static PyObject *t_Callable_call(t_Callable *self);
      static PyObject *t_Callable_get__parameters_(t_Callable *self, void *data);
      static PyGetSetDef t_Callable__fields_[] = {
        DECLARE_GET_FIELD(t_Callable, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_Callable__methods_[] = {
        DECLARE_METHOD(t_Callable, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Callable, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Callable, of_, METH_VARARGS),
        DECLARE_METHOD(t_Callable, call, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Callable)[] = {
        { Py_tp_methods, t_Callable__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_Callable__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Callable)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Callable, t_Callable, Callable);
      PyObject *t_Callable::wrap_Object(const Callable& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Callable::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Callable *self = (t_Callable *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_Callable::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Callable::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Callable *self = (t_Callable *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_Callable::install(PyObject *module)
      {
        installType(&PY_TYPE(Callable), &PY_TYPE_DEF(Callable), module, "Callable", 0);
      }

      void t_Callable::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Callable), "class_", make_descriptor(Callable::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Callable), "wrapfn_", make_descriptor(t_Callable::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Callable), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Callable_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Callable::initializeClass, 1)))
          return NULL;
        return t_Callable::wrap_Object(Callable(((t_Callable *) arg)->object.this$));
      }
      static PyObject *t_Callable_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Callable::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Callable_of_(t_Callable *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_Callable_call(t_Callable *self)
      {
        ::java::lang::Object result((jobject) NULL);
        OBJ_CALL(result = self->object.call());
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }
      static PyObject *t_Callable_get__parameters_(t_Callable *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Cloneable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Cloneable::class$ = NULL;
    jmethodID *Cloneable::mids$ = NULL;
    bool Cloneable::live$ = false;

    jclass Cloneable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Cloneable");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Cloneable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Cloneable_instance_(PyTypeObject *type, PyObject *arg);

    static PyMethodDef t_Cloneable__methods_[] = {
      DECLARE_METHOD(t_Cloneable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Cloneable, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Cloneable)[] = {
      { Py_tp_methods, t_Cloneable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Cloneable)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Cloneable, t_Cloneable, Cloneable);

    void t_Cloneable::install(PyObject *module)
    {
      installType(&PY_TYPE(Cloneable), &PY_TYPE_DEF(Cloneable), module, "Cloneable", 0);
    }

    void t_Cloneable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Cloneable), "class_", make_descriptor(Cloneable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Cloneable), "wrapfn_", make_descriptor(t_Cloneable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Cloneable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Cloneable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Cloneable::initializeClass, 1)))
        return NULL;
      return t_Cloneable::wrap_Object(Cloneable(((t_Cloneable *) arg)->object.this$));
    }
    static PyObject *t_Cloneable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Cloneable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Package.h"
#include "java/lang/Package.h"
#include "java/lang/String.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Package::class$ = NULL;
    jmethodID *Package::mids$ = NULL;
    bool Package::live$ = false;

    jclass Package::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Package");

        mids$ = new jmethodID[max_mid];
        mids$[mid_getImplementationTitle_db9b55ba01e03e4b] = env->getMethodID(cls, "getImplementationTitle", "()Ljava/lang/String;");
        mids$[mid_getImplementationVendor_db9b55ba01e03e4b] = env->getMethodID(cls, "getImplementationVendor", "()Ljava/lang/String;");
        mids$[mid_getImplementationVersion_db9b55ba01e03e4b] = env->getMethodID(cls, "getImplementationVersion", "()Ljava/lang/String;");
        mids$[mid_getName_db9b55ba01e03e4b] = env->getMethodID(cls, "getName", "()Ljava/lang/String;");
        mids$[mid_getPackage_3e5bdfd63170837b] = env->getStaticMethodID(cls, "getPackage", "(Ljava/lang/String;)Ljava/lang/Package;");
        mids$[mid_getPackages_83e3803d8c61a052] = env->getStaticMethodID(cls, "getPackages", "()[Ljava/lang/Package;");
        mids$[mid_getSpecificationTitle_db9b55ba01e03e4b] = env->getMethodID(cls, "getSpecificationTitle", "()Ljava/lang/String;");
        mids$[mid_getSpecificationVendor_db9b55ba01e03e4b] = env->getMethodID(cls, "getSpecificationVendor", "()Ljava/lang/String;");
        mids$[mid_getSpecificationVersion_db9b55ba01e03e4b] = env->getMethodID(cls, "getSpecificationVersion", "()Ljava/lang/String;");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_isCompatibleWith_145b2d0af0c06b93] = env->getMethodID(cls, "isCompatibleWith", "(Ljava/lang/String;)Z");
        mids$[mid_isSealed_8454bd5aa23fd11e] = env->getMethodID(cls, "isSealed", "()Z");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ::java::lang::String Package::getImplementationTitle() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getImplementationTitle_db9b55ba01e03e4b]));
    }

    ::java::lang::String Package::getImplementationVendor() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getImplementationVendor_db9b55ba01e03e4b]));
    }

    ::java::lang::String Package::getImplementationVersion() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getImplementationVersion_db9b55ba01e03e4b]));
    }

    ::java::lang::String Package::getName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getName_db9b55ba01e03e4b]));
    }

    Package Package::getPackage(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Package(env->callStaticObjectMethod(cls, mids$[mid_getPackage_3e5bdfd63170837b], a0.this$));
    }

    JArray< Package > Package::getPackages()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< Package >(env->callStaticObjectMethod(cls, mids$[mid_getPackages_83e3803d8c61a052]));
    }

    ::java::lang::String Package::getSpecificationTitle() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSpecificationTitle_db9b55ba01e03e4b]));
    }

    ::java::lang::String Package::getSpecificationVendor() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSpecificationVendor_db9b55ba01e03e4b]));
    }

    ::java::lang::String Package::getSpecificationVersion() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSpecificationVersion_db9b55ba01e03e4b]));
    }

    jint Package::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean Package::isCompatibleWith(const ::java::lang::String & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_isCompatibleWith_145b2d0af0c06b93], a0.this$);
    }

    jboolean Package::isSealed() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isSealed_8454bd5aa23fd11e]);
    }

    ::java::lang::String Package::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Package_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Package_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Package_getImplementationTitle(t_Package *self);
    static PyObject *t_Package_getImplementationVendor(t_Package *self);
    static PyObject *t_Package_getImplementationVersion(t_Package *self);
    static PyObject *t_Package_getName(t_Package *self);
    static PyObject *t_Package_getPackage(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Package_getPackages(PyTypeObject *type);
    static PyObject *t_Package_getSpecificationTitle(t_Package *self);
    static PyObject *t_Package_getSpecificationVendor(t_Package *self);
    static PyObject *t_Package_getSpecificationVersion(t_Package *self);
    static PyObject *t_Package_hashCode(t_Package *self, PyObject *args);
    static PyObject *t_Package_isCompatibleWith(t_Package *self, PyObject *arg);
    static PyObject *t_Package_isSealed(t_Package *self);
    static PyObject *t_Package_toString(t_Package *self, PyObject *args);
    static PyObject *t_Package_get__implementationTitle(t_Package *self, void *data);
    static PyObject *t_Package_get__implementationVendor(t_Package *self, void *data);
    static PyObject *t_Package_get__implementationVersion(t_Package *self, void *data);
    static PyObject *t_Package_get__name(t_Package *self, void *data);
    static PyObject *t_Package_get__packages(t_Package *self, void *data);
    static PyObject *t_Package_get__sealed(t_Package *self, void *data);
    static PyObject *t_Package_get__specificationTitle(t_Package *self, void *data);
    static PyObject *t_Package_get__specificationVendor(t_Package *self, void *data);
    static PyObject *t_Package_get__specificationVersion(t_Package *self, void *data);
    static PyGetSetDef t_Package__fields_[] = {
      DECLARE_GET_FIELD(t_Package, implementationTitle),
      DECLARE_GET_FIELD(t_Package, implementationVendor),
      DECLARE_GET_FIELD(t_Package, implementationVersion),
      DECLARE_GET_FIELD(t_Package, name),
      DECLARE_GET_FIELD(t_Package, packages),
      DECLARE_GET_FIELD(t_Package, sealed),
      DECLARE_GET_FIELD(t_Package, specificationTitle),
      DECLARE_GET_FIELD(t_Package, specificationVendor),
      DECLARE_GET_FIELD(t_Package, specificationVersion),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Package__methods_[] = {
      DECLARE_METHOD(t_Package, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Package, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Package, getImplementationTitle, METH_NOARGS),
      DECLARE_METHOD(t_Package, getImplementationVendor, METH_NOARGS),
      DECLARE_METHOD(t_Package, getImplementationVersion, METH_NOARGS),
      DECLARE_METHOD(t_Package, getName, METH_NOARGS),
      DECLARE_METHOD(t_Package, getPackage, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Package, getPackages, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_Package, getSpecificationTitle, METH_NOARGS),
      DECLARE_METHOD(t_Package, getSpecificationVendor, METH_NOARGS),
      DECLARE_METHOD(t_Package, getSpecificationVersion, METH_NOARGS),
      DECLARE_METHOD(t_Package, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_Package, isCompatibleWith, METH_O),
      DECLARE_METHOD(t_Package, isSealed, METH_NOARGS),
      DECLARE_METHOD(t_Package, toString, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Package)[] = {
      { Py_tp_methods, t_Package__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Package__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Package)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Package, t_Package, Package);

    void t_Package::install(PyObject *module)
    {
      installType(&PY_TYPE(Package), &PY_TYPE_DEF(Package), module, "Package", 0);
    }

    void t_Package::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Package), "class_", make_descriptor(Package::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Package), "wrapfn_", make_descriptor(t_Package::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Package), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Package_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Package::initializeClass, 1)))
        return NULL;
      return t_Package::wrap_Object(Package(((t_Package *) arg)->object.this$));
    }
    static PyObject *t_Package_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Package::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Package_getImplementationTitle(t_Package *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getImplementationTitle());
      return j2p(result);
    }

    static PyObject *t_Package_getImplementationVendor(t_Package *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getImplementationVendor());
      return j2p(result);
    }

    static PyObject *t_Package_getImplementationVersion(t_Package *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getImplementationVersion());
      return j2p(result);
    }

    static PyObject *t_Package_getName(t_Package *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getName());
      return j2p(result);
    }

    static PyObject *t_Package_getPackage(PyTypeObject *type, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      Package result((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = ::java::lang::Package::getPackage(a0));
        return t_Package::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "getPackage", arg);
      return NULL;
    }

    static PyObject *t_Package_getPackages(PyTypeObject *type)
    {
      JArray< Package > result((jobject) NULL);
      OBJ_CALL(result = ::java::lang::Package::getPackages());
      return JArray<jobject>(result.this$).wrap(t_Package::wrap_jobject);
    }

    static PyObject *t_Package_getSpecificationTitle(t_Package *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getSpecificationTitle());
      return j2p(result);
    }

    static PyObject *t_Package_getSpecificationVendor(t_Package *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getSpecificationVendor());
      return j2p(result);
    }

    static PyObject *t_Package_getSpecificationVersion(t_Package *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getSpecificationVersion());
      return j2p(result);
    }

    static PyObject *t_Package_hashCode(t_Package *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Package), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_Package_isCompatibleWith(t_Package *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = self->object.isCompatibleWith(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "isCompatibleWith", arg);
      return NULL;
    }

    static PyObject *t_Package_isSealed(t_Package *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isSealed());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_Package_toString(t_Package *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(Package), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_Package_get__implementationTitle(t_Package *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getImplementationTitle());
      return j2p(value);
    }

    static PyObject *t_Package_get__implementationVendor(t_Package *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getImplementationVendor());
      return j2p(value);
    }

    static PyObject *t_Package_get__implementationVersion(t_Package *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getImplementationVersion());
      return j2p(value);
    }

    static PyObject *t_Package_get__name(t_Package *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getName());
      return j2p(value);
    }

    static PyObject *t_Package_get__packages(t_Package *self, void *data)
    {
      JArray< Package > value((jobject) NULL);
      OBJ_CALL(value = self->object.getPackages());
      return JArray<jobject>(value.this$).wrap(t_Package::wrap_jobject);
    }

    static PyObject *t_Package_get__sealed(t_Package *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isSealed());
      Py_RETURN_BOOL(value);
    }

    static PyObject *t_Package_get__specificationTitle(t_Package *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getSpecificationTitle());
      return j2p(value);
    }

    static PyObject *t_Package_get__specificationVendor(t_Package *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getSpecificationVendor());
      return j2p(value);
    }

    static PyObject *t_Package_get__specificationVersion(t_Package *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getSpecificationVersion());
      return j2p(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/StackTraceElement.h"
#include "java/io/Serializable.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *StackTraceElement::class$ = NULL;
    jmethodID *StackTraceElement::mids$ = NULL;
    bool StackTraceElement::live$ = false;

    jclass StackTraceElement::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/StackTraceElement");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_8daa3926e89a4889] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_getClassName_db9b55ba01e03e4b] = env->getMethodID(cls, "getClassName", "()Ljava/lang/String;");
        mids$[mid_getFileName_db9b55ba01e03e4b] = env->getMethodID(cls, "getFileName", "()Ljava/lang/String;");
        mids$[mid_getLineNumber_9972fcc56b44e79d] = env->getMethodID(cls, "getLineNumber", "()I");
        mids$[mid_getMethodName_db9b55ba01e03e4b] = env->getMethodID(cls, "getMethodName", "()Ljava/lang/String;");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_isNativeMethod_8454bd5aa23fd11e] = env->getMethodID(cls, "isNativeMethod", "()Z");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    StackTraceElement::StackTraceElement(const ::java::lang::String & a0, const ::java::lang::String & a1, const ::java::lang::String & a2, jint a3) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_8daa3926e89a4889, a0.this$, a1.this$, a2.this$, a3)) {}

    jboolean StackTraceElement::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::String StackTraceElement::getClassName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getClassName_db9b55ba01e03e4b]));
    }

    ::java::lang::String StackTraceElement::getFileName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getFileName_db9b55ba01e03e4b]));
    }

    jint StackTraceElement::getLineNumber() const
    {
      return env->callIntMethod(this$, mids$[mid_getLineNumber_9972fcc56b44e79d]);
    }

    ::java::lang::String StackTraceElement::getMethodName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getMethodName_db9b55ba01e03e4b]));
    }

    jint StackTraceElement::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean StackTraceElement::isNativeMethod() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isNativeMethod_8454bd5aa23fd11e]);
    }

    ::java::lang::String StackTraceElement::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_StackTraceElement_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_StackTraceElement_instance_(PyTypeObject *type, PyObject *arg);
    static int t_StackTraceElement_init_(t_StackTraceElement *self, PyObject *args, PyObject *kwds);
    static PyObject *t_StackTraceElement_equals(t_StackTraceElement *self, PyObject *args);
    static PyObject *t_StackTraceElement_getClassName(t_StackTraceElement *self);
    static PyObject *t_StackTraceElement_getFileName(t_StackTraceElement *self);
    static PyObject *t_StackTraceElement_getLineNumber(t_StackTraceElement *self);
    static PyObject *t_StackTraceElement_getMethodName(t_StackTraceElement *self);
    static PyObject *t_StackTraceElement_hashCode(t_StackTraceElement *self, PyObject *args);
    static PyObject *t_StackTraceElement_isNativeMethod(t_StackTraceElement *self);
    static PyObject *t_StackTraceElement_toString(t_StackTraceElement *self, PyObject *args);
    static PyObject *t_StackTraceElement_get__className(t_StackTraceElement *self, void *data);
    static PyObject *t_StackTraceElement_get__fileName(t_StackTraceElement *self, void *data);
    static PyObject *t_StackTraceElement_get__lineNumber(t_StackTraceElement *self, void *data);
    static PyObject *t_StackTraceElement_get__methodName(t_StackTraceElement *self, void *data);
    static PyObject *t_StackTraceElement_get__nativeMethod(t_StackTraceElement *self, void *data);
    static PyGetSetDef t_StackTraceElement__fields_[] = {
      DECLARE_GET_FIELD(t_StackTraceElement, className),
      DECLARE_GET_FIELD(t_StackTraceElement, fileName),
      DECLARE_GET_FIELD(t_StackTraceElement, lineNumber),
      DECLARE_GET_FIELD(t_StackTraceElement, methodName),
      DECLARE_GET_FIELD(t_StackTraceElement, nativeMethod),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_StackTraceElement__methods_[] = {
      DECLARE_METHOD(t_StackTraceElement, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_StackTraceElement, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_StackTraceElement, equals, METH_VARARGS),
      DECLARE_METHOD(t_StackTraceElement, getClassName, METH_NOARGS),
      DECLARE_METHOD(t_StackTraceElement, getFileName, METH_NOARGS),
      DECLARE_METHOD(t_StackTraceElement, getLineNumber, METH_NOARGS),
      DECLARE_METHOD(t_StackTraceElement, getMethodName, METH_NOARGS),
      DECLARE_METHOD(t_StackTraceElement, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_StackTraceElement, isNativeMethod, METH_NOARGS),
      DECLARE_METHOD(t_StackTraceElement, toString, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(StackTraceElement)[] = {
      { Py_tp_methods, t_StackTraceElement__methods_ },
      { Py_tp_init, (void *) t_StackTraceElement_init_ },
      { Py_tp_getset, t_StackTraceElement__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(StackTraceElement)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(StackTraceElement, t_StackTraceElement, StackTraceElement);

    void t_StackTraceElement::install(PyObject *module)
    {
      installType(&PY_TYPE(StackTraceElement), &PY_TYPE_DEF(StackTraceElement), module, "StackTraceElement", 0);
    }

    void t_StackTraceElement::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(StackTraceElement), "class_", make_descriptor(StackTraceElement::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(StackTraceElement), "wrapfn_", make_descriptor(t_StackTraceElement::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(StackTraceElement), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_StackTraceElement_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, StackTraceElement::initializeClass, 1)))
        return NULL;
      return t_StackTraceElement::wrap_Object(StackTraceElement(((t_StackTraceElement *) arg)->object.this$));
    }
    static PyObject *t_StackTraceElement_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, StackTraceElement::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_StackTraceElement_init_(t_StackTraceElement *self, PyObject *args, PyObject *kwds)
    {
      ::java::lang::String a0((jobject) NULL);
      ::java::lang::String a1((jobject) NULL);
      ::java::lang::String a2((jobject) NULL);
      jint a3;
      StackTraceElement object((jobject) NULL);

      if (!parseArgs(args, "sssI", &a0, &a1, &a2, &a3))
      {
        INT_CALL(object = StackTraceElement(a0, a1, a2, a3));
        self->object = object;
      }
      else
      {
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_StackTraceElement_equals(t_StackTraceElement *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(StackTraceElement), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_StackTraceElement_getClassName(t_StackTraceElement *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getClassName());
      return j2p(result);
    }

    static PyObject *t_StackTraceElement_getFileName(t_StackTraceElement *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getFileName());
      return j2p(result);
    }

    static PyObject *t_StackTraceElement_getLineNumber(t_StackTraceElement *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getLineNumber());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_StackTraceElement_getMethodName(t_StackTraceElement *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getMethodName());
      return j2p(result);
    }

    static PyObject *t_StackTraceElement_hashCode(t_StackTraceElement *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(StackTraceElement), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_StackTraceElement_isNativeMethod(t_StackTraceElement *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isNativeMethod());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_StackTraceElement_toString(t_StackTraceElement *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(StackTraceElement), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_StackTraceElement_get__className(t_StackTraceElement *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getClassName());
      return j2p(value);
    }

    static PyObject *t_StackTraceElement_get__fileName(t_StackTraceElement *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getFileName());
      return j2p(value);
    }

    static PyObject *t_StackTraceElement_get__lineNumber(t_StackTraceElement *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getLineNumber());
      return PyLong_FromLong((long) value);
    }

    static PyObject *t_StackTraceElement_get__methodName(t_StackTraceElement *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getMethodName());
      return j2p(value);
    }

    static PyObject *t_StackTraceElement_get__nativeMethod(t_StackTraceElement *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isNativeMethod());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Iterable.h"
#include "java/lang/Class.h"
#include "java/util/function/Consumer.h"
#include "java/util/Spliterator.h"
#include "java/util/Iterator.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Iterable::class$ = NULL;
    jmethodID *Iterable::mids$ = NULL;
    bool Iterable::live$ = false;

    jclass Iterable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Iterable");

        mids$ = new jmethodID[max_mid];
        mids$[mid_forEach_39fdd8ee24bf1a00] = env->getMethodID(cls, "forEach", "(Ljava/util/function/Consumer;)V");
        mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
        mids$[mid_spliterator_7a761c107a8e14bd] = env->getMethodID(cls, "spliterator", "()Ljava/util/Spliterator;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Iterable::forEach(const ::java::util::function::Consumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEach_39fdd8ee24bf1a00], a0.this$);
    }

    ::java::util::Iterator Iterable::iterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
    }

    ::java::util::Spliterator Iterable::spliterator() const
    {
      return ::java::util::Spliterator(env->callObjectMethod(this$, mids$[mid_spliterator_7a761c107a8e14bd]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Iterable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Iterable_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Iterable_of_(t_Iterable *self, PyObject *args);
    static PyObject *t_Iterable_forEach(t_Iterable *self, PyObject *arg);
    static PyObject *t_Iterable_iterator(t_Iterable *self);
    static PyObject *t_Iterable_spliterator(t_Iterable *self);
    static PyObject *t_Iterable_get__parameters_(t_Iterable *self, void *data);
    static PyGetSetDef t_Iterable__fields_[] = {
      DECLARE_GET_FIELD(t_Iterable, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Iterable__methods_[] = {
      DECLARE_METHOD(t_Iterable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Iterable, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Iterable, of_, METH_VARARGS),
      DECLARE_METHOD(t_Iterable, forEach, METH_O),
      DECLARE_METHOD(t_Iterable, iterator, METH_NOARGS),
      DECLARE_METHOD(t_Iterable, spliterator, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Iterable)[] = {
      { Py_tp_methods, t_Iterable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Iterable__fields_ },
      { Py_tp_iter, (void *) ((PyObject *(*)(t_Iterable *)) get_generic_iterator< t_Iterable >) },
      { Py_tp_iternext, (void *) 0 },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Iterable)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Iterable, t_Iterable, Iterable);
    PyObject *t_Iterable::wrap_Object(const Iterable& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Iterable::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Iterable *self = (t_Iterable *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Iterable::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Iterable::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Iterable *self = (t_Iterable *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Iterable::install(PyObject *module)
    {
      installType(&PY_TYPE(Iterable), &PY_TYPE_DEF(Iterable), module, "Iterable", 0);
    }

    void t_Iterable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Iterable), "class_", make_descriptor(Iterable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Iterable), "wrapfn_", make_descriptor(t_Iterable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Iterable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Iterable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Iterable::initializeClass, 1)))
        return NULL;
      return t_Iterable::wrap_Object(Iterable(((t_Iterable *) arg)->object.this$));
    }
    static PyObject *t_Iterable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Iterable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Iterable_of_(t_Iterable *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Iterable_forEach(t_Iterable *self, PyObject *arg)
    {
      ::java::util::function::Consumer a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
      {
        OBJ_CALL(self->object.forEach(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "forEach", arg);
      return NULL;
    }

    static PyObject *t_Iterable_iterator(t_Iterable *self)
    {
      ::java::util::Iterator result((jobject) NULL);
      OBJ_CALL(result = self->object.iterator());
      return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_Iterable_spliterator(t_Iterable *self)
    {
      ::java::util::Spliterator result((jobject) NULL);
      OBJ_CALL(result = self->object.spliterator());
      return ::java::util::t_Spliterator::wrap_Object(result, self->parameters[0]);
    }
    static PyObject *t_Iterable_get__parameters_(t_Iterable *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/Consumer.h"
#include "java/util/function/Consumer.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *Consumer::class$ = NULL;
      jmethodID *Consumer::mids$ = NULL;
      bool Consumer::live$ = false;

      jclass Consumer::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/Consumer");

          mids$ = new jmethodID[max_mid];
          mids$[mid_accept_d20f626183f72f7d] = env->getMethodID(cls, "accept", "(Ljava/lang/Object;)V");
          mids$[mid_andThen_99c7957c1bca2219] = env->getMethodID(cls, "andThen", "(Ljava/util/function/Consumer;)Ljava/util/function/Consumer;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      void Consumer::accept(const ::java::lang::Object & a0) const
      {
        env->callVoidMethod(this$, mids$[mid_accept_d20f626183f72f7d], a0.this$);
      }

      Consumer Consumer::andThen(const Consumer & a0) const
      {
        return Consumer(env->callObjectMethod(this$, mids$[mid_andThen_99c7957c1bca2219], a0.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_Consumer_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Consumer_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Consumer_of_(t_Consumer *self, PyObject *args);
      static PyObject *t_Consumer_accept(t_Consumer *self, PyObject *arg);
      static PyObject *t_Consumer_andThen(t_Consumer *self, PyObject *arg);
      static PyObject *t_Consumer_get__parameters_(t_Consumer *self, void *data);
      static PyGetSetDef t_Consumer__fields_[] = {
        DECLARE_GET_FIELD(t_Consumer, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_Consumer__methods_[] = {
        DECLARE_METHOD(t_Consumer, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Consumer, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Consumer, of_, METH_VARARGS),
        DECLARE_METHOD(t_Consumer, accept, METH_O),
        DECLARE_METHOD(t_Consumer, andThen, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Consumer)[] = {
        { Py_tp_methods, t_Consumer__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_Consumer__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Consumer)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Consumer, t_Consumer, Consumer);
      PyObject *t_Consumer::wrap_Object(const Consumer& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Consumer::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Consumer *self = (t_Consumer *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_Consumer::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Consumer::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Consumer *self = (t_Consumer *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_Consumer::install(PyObject *module)
      {
        installType(&PY_TYPE(Consumer), &PY_TYPE_DEF(Consumer), module, "Consumer", 0);
      }

      void t_Consumer::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Consumer), "class_", make_descriptor(Consumer::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Consumer), "wrapfn_", make_descriptor(t_Consumer::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Consumer), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Consumer_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Consumer::initializeClass, 1)))
          return NULL;
        return t_Consumer::wrap_Object(Consumer(((t_Consumer *) arg)->object.this$));
      }
      static PyObject *t_Consumer_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Consumer::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Consumer_of_(t_Consumer *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_Consumer_accept(t_Consumer *self, PyObject *arg)
      {
        ::java::lang::Object a0((jobject) NULL);

        if (!parseArg(arg, "O", self->parameters[0], &a0))
        {
          OBJ_CALL(self->object.accept(a0));
          Py_RETURN_NONE;
        }

        PyErr_SetArgsError((PyObject *) self, "accept", arg);
        return NULL;
      }

      static PyObject *t_Consumer_andThen(t_Consumer *self, PyObject *arg)
      {
        Consumer a0((jobject) NULL);
        PyTypeObject **p0;
        Consumer result((jobject) NULL);

        if (!parseArg(arg, "K", Consumer::initializeClass, &a0, &p0, t_Consumer::parameters_))
        {
          OBJ_CALL(result = self->object.andThen(a0));
          return t_Consumer::wrap_Object(result, self->parameters[0]);
        }

        PyErr_SetArgsError((PyObject *) self, "andThen", arg);
        return NULL;
      }
      static PyObject *t_Consumer_get__parameters_(t_Consumer *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/SortedMap.h"
#include "java/util/Comparator.h"
#include "java/util/Collection.h"
#include "java/util/Map$Entry.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/SortedMap.h"
#include "java/util/Set.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *SortedMap::class$ = NULL;
    jmethodID *SortedMap::mids$ = NULL;
    bool SortedMap::live$ = false;

    jclass SortedMap::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/SortedMap");

        mids$ = new jmethodID[max_mid];
        mids$[mid_comparator_beb0414e0ec1de00] = env->getMethodID(cls, "comparator", "()Ljava/util/Comparator;");
        mids$[mid_entrySet_7dcf4034c6d1a92a] = env->getMethodID(cls, "entrySet", "()Ljava/util/Set;");
        mids$[mid_firstKey_d6bcd06f3102c4d9] = env->getMethodID(cls, "firstKey", "()Ljava/lang/Object;");
        mids$[mid_headMap_ebd5eccc289248f0] = env->getMethodID(cls, "headMap", "(Ljava/lang/Object;)Ljava/util/SortedMap;");
        mids$[mid_keySet_7dcf4034c6d1a92a] = env->getMethodID(cls, "keySet", "()Ljava/util/Set;");
        mids$[mid_lastKey_d6bcd06f3102c4d9] = env->getMethodID(cls, "lastKey", "()Ljava/lang/Object;");
        mids$[mid_subMap_5f2ca92e52d24a87] = env->getMethodID(cls, "subMap", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/SortedMap;");
        mids$[mid_tailMap_ebd5eccc289248f0] = env->getMethodID(cls, "tailMap", "(Ljava/lang/Object;)Ljava/util/SortedMap;");
        mids$[mid_values_d4dfbf7a26ff41df] = env->getMethodID(cls, "values", "()Ljava/util/Collection;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ::java::util::Comparator SortedMap::comparator() const
    {
      return ::java::util::Comparator(env->callObjectMethod(this$, mids$[mid_comparator_beb0414e0ec1de00]));
    }

    ::java::util::Set SortedMap::entrySet() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_entrySet_7dcf4034c6d1a92a]));
    }

    ::java::lang::Object SortedMap::firstKey() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_firstKey_d6bcd06f3102c4d9]));
    }

    SortedMap SortedMap::headMap(const ::java::lang::Object & a0) const
    {
      return SortedMap(env->callObjectMethod(this$, mids$[mid_headMap_ebd5eccc289248f0], a0.this$));
    }

    ::java::util::Set SortedMap::keySet() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_keySet_7dcf4034c6d1a92a]));
    }

    ::java::lang::Object SortedMap::lastKey() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_lastKey_d6bcd06f3102c4d9]));
    }

    SortedMap SortedMap::subMap(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return SortedMap(env->callObjectMethod(this$, mids$[mid_subMap_5f2ca92e52d24a87], a0.this$, a1.this$));
    }

    SortedMap SortedMap::tailMap(const ::java::lang::Object & a0) const
    {
      return SortedMap(env->callObjectMethod(this$, mids$[mid_tailMap_ebd5eccc289248f0], a0.this$));
    }

    ::java::util::Collection SortedMap::values() const
    {
      return ::java::util::Collection(env->callObjectMethod(this$, mids$[mid_values_d4dfbf7a26ff41df]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_SortedMap_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_SortedMap_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_SortedMap_of_(t_SortedMap *self, PyObject *args);
    static PyObject *t_SortedMap_comparator(t_SortedMap *self);
    static PyObject *t_SortedMap_entrySet(t_SortedMap *self, PyObject *args);
    static PyObject *t_SortedMap_firstKey(t_SortedMap *self);
    static PyObject *t_SortedMap_headMap(t_SortedMap *self, PyObject *arg);
    static PyObject *t_SortedMap_keySet(t_SortedMap *self, PyObject *args);
    static PyObject *t_SortedMap_lastKey(t_SortedMap *self);
    static PyObject *t_SortedMap_subMap(t_SortedMap *self, PyObject *args);
    static PyObject *t_SortedMap_tailMap(t_SortedMap *self, PyObject *arg);
    static PyObject *t_SortedMap_values(t_SortedMap *self, PyObject *args);
    static PyObject *t_SortedMap_get__parameters_(t_SortedMap *self, void *data);
    static PyGetSetDef t_SortedMap__fields_[] = {
      DECLARE_GET_FIELD(t_SortedMap, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_SortedMap__methods_[] = {
      DECLARE_METHOD(t_SortedMap, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_SortedMap, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_SortedMap, of_, METH_VARARGS),
      DECLARE_METHOD(t_SortedMap, comparator, METH_NOARGS),
      DECLARE_METHOD(t_SortedMap, entrySet, METH_VARARGS),
      DECLARE_METHOD(t_SortedMap, firstKey, METH_NOARGS),
      DECLARE_METHOD(t_SortedMap, headMap, METH_O),
      DECLARE_METHOD(t_SortedMap, keySet, METH_VARARGS),
      DECLARE_METHOD(t_SortedMap, lastKey, METH_NOARGS),
      DECLARE_METHOD(t_SortedMap, subMap, METH_VARARGS),
      DECLARE_METHOD(t_SortedMap, tailMap, METH_O),
      DECLARE_METHOD(t_SortedMap, values, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(SortedMap)[] = {
      { Py_tp_methods, t_SortedMap__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_SortedMap__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(SortedMap)[] = {
      &PY_TYPE_DEF(::java::util::Map),
      NULL
    };

    DEFINE_TYPE(SortedMap, t_SortedMap, SortedMap);
    PyObject *t_SortedMap::wrap_Object(const SortedMap& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_SortedMap::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_SortedMap *self = (t_SortedMap *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    PyObject *t_SortedMap::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_SortedMap::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_SortedMap *self = (t_SortedMap *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    void t_SortedMap::install(PyObject *module)
    {
      installType(&PY_TYPE(SortedMap), &PY_TYPE_DEF(SortedMap), module, "SortedMap", 0);
    }

    void t_SortedMap::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(SortedMap), "class_", make_descriptor(SortedMap::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SortedMap), "wrapfn_", make_descriptor(t_SortedMap::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SortedMap), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_SortedMap_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, SortedMap::initializeClass, 1)))
        return NULL;
      return t_SortedMap::wrap_Object(SortedMap(((t_SortedMap *) arg)->object.this$));
    }
    static PyObject *t_SortedMap_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, SortedMap::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_SortedMap_of_(t_SortedMap *self, PyObject *args)
    {
      if (!parseArg(args, "T", 2, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_SortedMap_comparator(t_SortedMap *self)
    {
      ::java::util::Comparator result((jobject) NULL);
      OBJ_CALL(result = self->object.comparator());
      return ::java::util::t_Comparator::wrap_Object(result);
    }

    static PyObject *t_SortedMap_entrySet(t_SortedMap *self, PyObject *args)
    {
      ::java::util::Set result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.entrySet());
        return ::java::util::t_Set::wrap_Object(result);
      }

      return callSuper(PY_TYPE(SortedMap), (PyObject *) self, "entrySet", args, 2);
    }

    static PyObject *t_SortedMap_firstKey(t_SortedMap *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.firstKey());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_SortedMap_headMap(t_SortedMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      SortedMap result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.headMap(a0));
        return t_SortedMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
      }

      PyErr_SetArgsError((PyObject *) self, "headMap", arg);
      return NULL;
    }

    static PyObject *t_SortedMap_keySet(t_SortedMap *self, PyObject *args)
    {
      ::java::util::Set result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.keySet());
        return ::java::util::t_Set::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(SortedMap), (PyObject *) self, "keySet", args, 2);
    }

    static PyObject *t_SortedMap_lastKey(t_SortedMap *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.lastKey());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_SortedMap_subMap(t_SortedMap *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      SortedMap result((jobject) NULL);

      if (!parseArgs(args, "OO", self->parameters[0], self->parameters[0], &a0, &a1))
      {
        OBJ_CALL(result = self->object.subMap(a0, a1));
        return t_SortedMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
      }

      PyErr_SetArgsError((PyObject *) self, "subMap", args);
      return NULL;
    }

    static PyObject *t_SortedMap_tailMap(t_SortedMap *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      SortedMap result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.tailMap(a0));
        return t_SortedMap::wrap_Object(result, self->parameters[0], self->parameters[1]);
      }

      PyErr_SetArgsError((PyObject *) self, "tailMap", arg);
      return NULL;
    }

    static PyObject *t_SortedMap_values(t_SortedMap *self, PyObject *args)
    {
      ::java::util::Collection result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.values());
        return ::java::util::t_Collection::wrap_Object(result, self->parameters[1]);
      }

      return callSuper(PY_TYPE(SortedMap), (PyObject *) self, "values", args, 2);
    }
    static PyObject *t_SortedMap_get__parameters_(t_SortedMap *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/UnsupportedOperationException.h"
#include "java/lang/String.h"
#include "java/lang/Throwable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *UnsupportedOperationException::class$ = NULL;
    jmethodID *UnsupportedOperationException::mids$ = NULL;
    bool UnsupportedOperationException::live$ = false;

    jclass UnsupportedOperationException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/UnsupportedOperationException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_471cfbdb800444a7] = env->getMethodID(cls, "<init>", "(Ljava/lang/Throwable;)V");
        mids$[mid_init$_2e9d196dc293ffe6] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/Throwable;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    UnsupportedOperationException::UnsupportedOperationException() : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    UnsupportedOperationException::UnsupportedOperationException(const ::java::lang::String & a0) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    UnsupportedOperationException::UnsupportedOperationException(const ::java::lang::Throwable & a0) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_471cfbdb800444a7, a0.this$)) {}

    UnsupportedOperationException::UnsupportedOperationException(const ::java::lang::String & a0, const ::java::lang::Throwable & a1) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_2e9d196dc293ffe6, a0.this$, a1.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_UnsupportedOperationException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_UnsupportedOperationException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_UnsupportedOperationException_init_(t_UnsupportedOperationException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_UnsupportedOperationException__methods_[] = {
      DECLARE_METHOD(t_UnsupportedOperationException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_UnsupportedOperationException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(UnsupportedOperationException)[] = {
      { Py_tp_methods, t_UnsupportedOperationException__methods_ },
      { Py_tp_init, (void *) t_UnsupportedOperationException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(UnsupportedOperationException)[] = {
      &PY_TYPE_DEF(::java::lang::RuntimeException),
      NULL
    };

    DEFINE_TYPE(UnsupportedOperationException, t_UnsupportedOperationException, UnsupportedOperationException);

    void t_UnsupportedOperationException::install(PyObject *module)
    {
      installType(&PY_TYPE(UnsupportedOperationException), &PY_TYPE_DEF(UnsupportedOperationException), module, "UnsupportedOperationException", 0);
    }

    void t_UnsupportedOperationException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(UnsupportedOperationException), "class_", make_descriptor(UnsupportedOperationException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(UnsupportedOperationException), "wrapfn_", make_descriptor(t_UnsupportedOperationException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(UnsupportedOperationException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_UnsupportedOperationException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, UnsupportedOperationException::initializeClass, 1)))
        return NULL;
      return t_UnsupportedOperationException::wrap_Object(UnsupportedOperationException(((t_UnsupportedOperationException *) arg)->object.this$));
    }
    static PyObject *t_UnsupportedOperationException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, UnsupportedOperationException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_UnsupportedOperationException_init_(t_UnsupportedOperationException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          UnsupportedOperationException object((jobject) NULL);

          INT_CALL(object = UnsupportedOperationException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          UnsupportedOperationException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = UnsupportedOperationException(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::Throwable a0((jobject) NULL);
          UnsupportedOperationException object((jobject) NULL);

          if (!parseArgs(args, "k", ::java::lang::Throwable::initializeClass, &a0))
          {
            INT_CALL(object = UnsupportedOperationException(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::Throwable a1((jobject) NULL);
          UnsupportedOperationException object((jobject) NULL);

          if (!parseArgs(args, "sk", ::java::lang::Throwable::initializeClass, &a0, &a1))
          {
            INT_CALL(object = UnsupportedOperationException(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/IntUnaryOperator.h"
#include "java/util/function/IntUnaryOperator.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *IntUnaryOperator::class$ = NULL;
      jmethodID *IntUnaryOperator::mids$ = NULL;
      bool IntUnaryOperator::live$ = false;

      jclass IntUnaryOperator::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/IntUnaryOperator");

          mids$ = new jmethodID[max_mid];
          mids$[mid_andThen_df329c81b5c06786] = env->getMethodID(cls, "andThen", "(Ljava/util/function/IntUnaryOperator;)Ljava/util/function/IntUnaryOperator;");
          mids$[mid_applyAsInt_1e143afe1894d213] = env->getMethodID(cls, "applyAsInt", "(I)I");
          mids$[mid_compose_df329c81b5c06786] = env->getMethodID(cls, "compose", "(Ljava/util/function/IntUnaryOperator;)Ljava/util/function/IntUnaryOperator;");
          mids$[mid_identity_0ab582d2acd53cfc] = env->getStaticMethodID(cls, "identity", "()Ljava/util/function/IntUnaryOperator;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      IntUnaryOperator IntUnaryOperator::andThen(const IntUnaryOperator & a0) const
      {
        return IntUnaryOperator(env->callObjectMethod(this$, mids$[mid_andThen_df329c81b5c06786], a0.this$));
      }

      jint IntUnaryOperator::applyAsInt(jint a0) const
      {
        return env->callIntMethod(this$, mids$[mid_applyAsInt_1e143afe1894d213], a0);
      }

      IntUnaryOperator IntUnaryOperator::compose(const IntUnaryOperator & a0) const
      {
        return IntUnaryOperator(env->callObjectMethod(this$, mids$[mid_compose_df329c81b5c06786], a0.this$));
      }

      IntUnaryOperator IntUnaryOperator::identity()
      {
        jclass cls = env->getClass(initializeClass);
        return IntUnaryOperator(env->callStaticObjectMethod(cls, mids$[mid_identity_0ab582d2acd53cfc]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_IntUnaryOperator_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntUnaryOperator_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntUnaryOperator_andThen(t_IntUnaryOperator *self, PyObject *arg);
      static PyObject *t_IntUnaryOperator_applyAsInt(t_IntUnaryOperator *self, PyObject *arg);
      static PyObject *t_IntUnaryOperator_compose(t_IntUnaryOperator *self, PyObject *arg);
      static PyObject *t_IntUnaryOperator_identity(PyTypeObject *type);

      static PyMethodDef t_IntUnaryOperator__methods_[] = {
        DECLARE_METHOD(t_IntUnaryOperator, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntUnaryOperator, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntUnaryOperator, andThen, METH_O),
        DECLARE_METHOD(t_IntUnaryOperator, applyAsInt, METH_O),
        DECLARE_METHOD(t_IntUnaryOperator, compose, METH_O),
        DECLARE_METHOD(t_IntUnaryOperator, identity, METH_NOARGS | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(IntUnaryOperator)[] = {
        { Py_tp_methods, t_IntUnaryOperator__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(IntUnaryOperator)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(IntUnaryOperator, t_IntUnaryOperator, IntUnaryOperator);

      void t_IntUnaryOperator::install(PyObject *module)
      {
        installType(&PY_TYPE(IntUnaryOperator), &PY_TYPE_DEF(IntUnaryOperator), module, "IntUnaryOperator", 0);
      }

      void t_IntUnaryOperator::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntUnaryOperator), "class_", make_descriptor(IntUnaryOperator::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntUnaryOperator), "wrapfn_", make_descriptor(t_IntUnaryOperator::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntUnaryOperator), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_IntUnaryOperator_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, IntUnaryOperator::initializeClass, 1)))
          return NULL;
        return t_IntUnaryOperator::wrap_Object(IntUnaryOperator(((t_IntUnaryOperator *) arg)->object.this$));
      }
      static PyObject *t_IntUnaryOperator_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, IntUnaryOperator::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_IntUnaryOperator_andThen(t_IntUnaryOperator *self, PyObject *arg)
      {
        IntUnaryOperator a0((jobject) NULL);
        IntUnaryOperator result((jobject) NULL);

        if (!parseArg(arg, "k", IntUnaryOperator::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.andThen(a0));
          return t_IntUnaryOperator::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "andThen", arg);
        return NULL;
      }

      static PyObject *t_IntUnaryOperator_applyAsInt(t_IntUnaryOperator *self, PyObject *arg)
      {
        jint a0;
        jint result;

        if (!parseArg(arg, "I", &a0))
        {
          OBJ_CALL(result = self->object.applyAsInt(a0));
          return PyLong_FromLong((long) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsInt", arg);
        return NULL;
      }

      static PyObject *t_IntUnaryOperator_compose(t_IntUnaryOperator *self, PyObject *arg)
      {
        IntUnaryOperator a0((jobject) NULL);
        IntUnaryOperator result((jobject) NULL);

        if (!parseArg(arg, "k", IntUnaryOperator::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.compose(a0));
          return t_IntUnaryOperator::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "compose", arg);
        return NULL;
      }

      static PyObject *t_IntUnaryOperator_identity(PyTypeObject *type)
      {
        IntUnaryOperator result((jobject) NULL);
        OBJ_CALL(result = ::java::util::function::IntUnaryOperator::identity());
        return t_IntUnaryOperator::wrap_Object(result);
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/OutputStream.h"
#include "java/io/Flushable.h"
#include "java/io/IOException.h"
#include "java/io/Closeable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *OutputStream::class$ = NULL;
    jmethodID *OutputStream::mids$ = NULL;
    bool OutputStream::live$ = false;

    jclass OutputStream::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/OutputStream");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");
        mids$[mid_flush_f2cc1bce94666404] = env->getMethodID(cls, "flush", "()V");
        mids$[mid_write_9ffdf271836656c4] = env->getMethodID(cls, "write", "([B)V");
        mids$[mid_write_040c4cd0390c5aff] = env->getMethodID(cls, "write", "(I)V");
        mids$[mid_write_43fdd39c09bb2fad] = env->getMethodID(cls, "write", "([BII)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    OutputStream::OutputStream() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    void OutputStream::close() const
    {
      env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
    }

    void OutputStream::flush() const
    {
      env->callVoidMethod(this$, mids$[mid_flush_f2cc1bce94666404]);
    }

    void OutputStream::write(const JArray< jbyte > & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_write_9ffdf271836656c4], a0.this$);
    }

    void OutputStream::write(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_write_040c4cd0390c5aff], a0);
    }

    void OutputStream::write(const JArray< jbyte > & a0, jint a1, jint a2) const
    {
      env->callVoidMethod(this$, mids$[mid_write_43fdd39c09bb2fad], a0.this$, a1, a2);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_OutputStream_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_OutputStream_instance_(PyTypeObject *type, PyObject *arg);
    static int t_OutputStream_init_(t_OutputStream *self, PyObject *args, PyObject *kwds);
    static PyObject *t_OutputStream_close(t_OutputStream *self);
    static PyObject *t_OutputStream_flush(t_OutputStream *self);
    static PyObject *t_OutputStream_write(t_OutputStream *self, PyObject *args);

    static PyMethodDef t_OutputStream__methods_[] = {
      DECLARE_METHOD(t_OutputStream, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_OutputStream, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_OutputStream, close, METH_NOARGS),
      DECLARE_METHOD(t_OutputStream, flush, METH_NOARGS),
      DECLARE_METHOD(t_OutputStream, write, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(OutputStream)[] = {
      { Py_tp_methods, t_OutputStream__methods_ },
      { Py_tp_init, (void *) t_OutputStream_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(OutputStream)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(OutputStream, t_OutputStream, OutputStream);

    void t_OutputStream::install(PyObject *module)
    {
      installType(&PY_TYPE(OutputStream), &PY_TYPE_DEF(OutputStream), module, "OutputStream", 0);
    }

    void t_OutputStream::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(OutputStream), "class_", make_descriptor(OutputStream::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(OutputStream), "wrapfn_", make_descriptor(t_OutputStream::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(OutputStream), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_OutputStream_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, OutputStream::initializeClass, 1)))
        return NULL;
      return t_OutputStream::wrap_Object(OutputStream(((t_OutputStream *) arg)->object.this$));
    }
    static PyObject *t_OutputStream_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, OutputStream::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_OutputStream_init_(t_OutputStream *self, PyObject *args, PyObject *kwds)
    {
      OutputStream object((jobject) NULL);

      INT_CALL(object = OutputStream());
      self->object = object;

      return 0;
    }

    static PyObject *t_OutputStream_close(t_OutputStream *self)
    {
      OBJ_CALL(self->object.close());
      Py_RETURN_NONE;
    }

    static PyObject *t_OutputStream_flush(t_OutputStream *self)
    {
      OBJ_CALL(self->object.flush());
      Py_RETURN_NONE;
    }

    static PyObject *t_OutputStream_write(t_OutputStream *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          JArray< jbyte > a0((jobject) NULL);

          if (!parseArgs(args, "[B", &a0))
          {
            OBJ_CALL(self->object.write(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.write(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          JArray< jbyte > a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "[BII", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.write(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "write", args);
      return NULL;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/InstantiationException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *InstantiationException::class$ = NULL;
    jmethodID *InstantiationException::mids$ = NULL;
    bool InstantiationException::live$ = false;

    jclass InstantiationException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/InstantiationException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    InstantiationException::InstantiationException() : ::java::lang::ReflectiveOperationException(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    InstantiationException::InstantiationException(const ::java::lang::String & a0) : ::java::lang::ReflectiveOperationException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_InstantiationException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_InstantiationException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_InstantiationException_init_(t_InstantiationException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_InstantiationException__methods_[] = {
      DECLARE_METHOD(t_InstantiationException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_InstantiationException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(InstantiationException)[] = {
      { Py_tp_methods, t_InstantiationException__methods_ },
      { Py_tp_init, (void *) t_InstantiationException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(InstantiationException)[] = {
      &PY_TYPE_DEF(::java::lang::ReflectiveOperationException),
      NULL
    };

    DEFINE_TYPE(InstantiationException, t_InstantiationException, InstantiationException);

    void t_InstantiationException::install(PyObject *module)
    {
      installType(&PY_TYPE(InstantiationException), &PY_TYPE_DEF(InstantiationException), module, "InstantiationException", 0);
    }

    void t_InstantiationException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(InstantiationException), "class_", make_descriptor(InstantiationException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(InstantiationException), "wrapfn_", make_descriptor(t_InstantiationException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(InstantiationException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_InstantiationException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, InstantiationException::initializeClass, 1)))
        return NULL;
      return t_InstantiationException::wrap_Object(InstantiationException(((t_InstantiationException *) arg)->object.this$));
    }
    static PyObject *t_InstantiationException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, InstantiationException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_InstantiationException_init_(t_InstantiationException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          InstantiationException object((jobject) NULL);

          INT_CALL(object = InstantiationException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          InstantiationException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = InstantiationException(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/lang/String.h"
#include "java/lang/CharSequence.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/StringBuffer.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *StringBuilder::class$ = NULL;
    jmethodID *StringBuilder::mids$ = NULL;
    bool StringBuilder::live$ = false;

    jclass StringBuilder::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/StringBuilder");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_040c4cd0390c5aff] = env->getMethodID(cls, "<init>", "(I)V");
        mids$[mid_init$_4b7f5e38f806ae55] = env->getMethodID(cls, "<init>", "(Ljava/lang/CharSequence;)V");
        mids$[mid_append_9983cc2585c04557] = env->getMethodID(cls, "append", "(Ljava/lang/StringBuffer;)Ljava/lang/StringBuilder;");
        mids$[mid_append_7070a1d54451f771] = env->getMethodID(cls, "append", "([C)Ljava/lang/StringBuilder;");
        mids$[mid_append_b0d900f8619721d9] = env->getMethodID(cls, "append", "(Ljava/lang/String;)Ljava/lang/StringBuilder;");
        mids$[mid_append_c169a6d0633d0e08] = env->getMethodID(cls, "append", "(Z)Ljava/lang/StringBuilder;");
        mids$[mid_append_00e7353da71b80e6] = env->getMethodID(cls, "append", "(C)Ljava/lang/StringBuilder;");
        mids$[mid_append_4e3f3e17cfec4ae4] = env->getMethodID(cls, "append", "(D)Ljava/lang/StringBuilder;");
        mids$[mid_append_59909dbeecefe1f2] = env->getMethodID(cls, "append", "(F)Ljava/lang/StringBuilder;");
        mids$[mid_append_d644ee3e2d4b7a32] = env->getMethodID(cls, "append", "(I)Ljava/lang/StringBuilder;");
        mids$[mid_append_3ff255c2dd86108c] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;)Ljava/lang/StringBuilder;");
        mids$[mid_append_b2d729c0321e2c8c] = env->getMethodID(cls, "append", "(Ljava/lang/Object;)Ljava/lang/StringBuilder;");
        mids$[mid_append_5f30b553a0a522c5] = env->getMethodID(cls, "append", "(J)Ljava/lang/StringBuilder;");
        mids$[mid_append_c22bec30087d1e8e] = env->getMethodID(cls, "append", "([CII)Ljava/lang/StringBuilder;");
        mids$[mid_append_594221b1eb8cb973] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;II)Ljava/lang/StringBuilder;");
        mids$[mid_appendCodePoint_d644ee3e2d4b7a32] = env->getMethodID(cls, "appendCodePoint", "(I)Ljava/lang/StringBuilder;");
        mids$[mid_delete_1ca249816e4537c2] = env->getMethodID(cls, "delete", "(II)Ljava/lang/StringBuilder;");
        mids$[mid_deleteCharAt_d644ee3e2d4b7a32] = env->getMethodID(cls, "deleteCharAt", "(I)Ljava/lang/StringBuilder;");
        mids$[mid_indexOf_a5a7d1128e9e2bb7] = env->getMethodID(cls, "indexOf", "(Ljava/lang/String;)I");
        mids$[mid_indexOf_30cd5d5b9318bd5d] = env->getMethodID(cls, "indexOf", "(Ljava/lang/String;I)I");
        mids$[mid_insert_715f770a66ead7b5] = env->getMethodID(cls, "insert", "(I[C)Ljava/lang/StringBuilder;");
        mids$[mid_insert_81be2976fdd3570e] = env->getMethodID(cls, "insert", "(ILjava/lang/String;)Ljava/lang/StringBuilder;");
        mids$[mid_insert_a1457f7540fdd256] = env->getMethodID(cls, "insert", "(IZ)Ljava/lang/StringBuilder;");
        mids$[mid_insert_8887659d67622e58] = env->getMethodID(cls, "insert", "(IC)Ljava/lang/StringBuilder;");
        mids$[mid_insert_f420a279d8db66df] = env->getMethodID(cls, "insert", "(ID)Ljava/lang/StringBuilder;");
        mids$[mid_insert_d13831895949aaf9] = env->getMethodID(cls, "insert", "(IF)Ljava/lang/StringBuilder;");
        mids$[mid_insert_1ca249816e4537c2] = env->getMethodID(cls, "insert", "(II)Ljava/lang/StringBuilder;");
        mids$[mid_insert_bae7f98d33b24748] = env->getMethodID(cls, "insert", "(ILjava/lang/CharSequence;)Ljava/lang/StringBuilder;");
        mids$[mid_insert_c6033db6ec314fa3] = env->getMethodID(cls, "insert", "(ILjava/lang/Object;)Ljava/lang/StringBuilder;");
        mids$[mid_insert_d865087e672c8091] = env->getMethodID(cls, "insert", "(IJ)Ljava/lang/StringBuilder;");
        mids$[mid_insert_89ffcbda4fb158b4] = env->getMethodID(cls, "insert", "(I[CII)Ljava/lang/StringBuilder;");
        mids$[mid_insert_392aaf29a745d1b8] = env->getMethodID(cls, "insert", "(ILjava/lang/CharSequence;II)Ljava/lang/StringBuilder;");
        mids$[mid_lastIndexOf_a5a7d1128e9e2bb7] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/String;)I");
        mids$[mid_lastIndexOf_30cd5d5b9318bd5d] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/String;I)I");
        mids$[mid_replace_590c15104a3b5a8d] = env->getMethodID(cls, "replace", "(IILjava/lang/String;)Ljava/lang/StringBuilder;");
        mids$[mid_reverse_ffb326b9d303f5a4] = env->getMethodID(cls, "reverse", "()Ljava/lang/StringBuilder;");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    StringBuilder::StringBuilder() : ::java::lang::AbstractStringBuilder(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    StringBuilder::StringBuilder(const ::java::lang::String & a0) : ::java::lang::AbstractStringBuilder(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    StringBuilder::StringBuilder(jint a0) : ::java::lang::AbstractStringBuilder(env->newObject(initializeClass, &mids$, mid_init$_040c4cd0390c5aff, a0)) {}

    StringBuilder::StringBuilder(const ::java::lang::CharSequence & a0) : ::java::lang::AbstractStringBuilder(env->newObject(initializeClass, &mids$, mid_init$_4b7f5e38f806ae55, a0.this$)) {}

    StringBuilder StringBuilder::append(const ::java::lang::StringBuffer & a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_9983cc2585c04557], a0.this$));
    }

    StringBuilder StringBuilder::append(const JArray< jchar > & a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_7070a1d54451f771], a0.this$));
    }

    StringBuilder StringBuilder::append(const ::java::lang::String & a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_b0d900f8619721d9], a0.this$));
    }

    StringBuilder StringBuilder::append(jboolean a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_c169a6d0633d0e08], a0));
    }

    StringBuilder StringBuilder::append(jchar a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_00e7353da71b80e6], a0));
    }

    StringBuilder StringBuilder::append(jdouble a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_4e3f3e17cfec4ae4], a0));
    }

    StringBuilder StringBuilder::append(jfloat a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_59909dbeecefe1f2], a0));
    }

    StringBuilder StringBuilder::append(jint a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_d644ee3e2d4b7a32], a0));
    }

    StringBuilder StringBuilder::append(const ::java::lang::CharSequence & a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_3ff255c2dd86108c], a0.this$));
    }

    StringBuilder StringBuilder::append(const ::java::lang::Object & a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_b2d729c0321e2c8c], a0.this$));
    }

    StringBuilder StringBuilder::append(jlong a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_5f30b553a0a522c5], a0));
    }

    StringBuilder StringBuilder::append(const JArray< jchar > & a0, jint a1, jint a2) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_c22bec30087d1e8e], a0.this$, a1, a2));
    }

    StringBuilder StringBuilder::append(const ::java::lang::CharSequence & a0, jint a1, jint a2) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_append_594221b1eb8cb973], a0.this$, a1, a2));
    }

    StringBuilder StringBuilder::appendCodePoint(jint a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_appendCodePoint_d644ee3e2d4b7a32], a0));
    }

    StringBuilder StringBuilder::delete$(jint a0, jint a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_delete_1ca249816e4537c2], a0, a1));
    }

    StringBuilder StringBuilder::deleteCharAt(jint a0) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_deleteCharAt_d644ee3e2d4b7a32], a0));
    }

    jint StringBuilder::indexOf(const ::java::lang::String & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_a5a7d1128e9e2bb7], a0.this$);
    }

    jint StringBuilder::indexOf(const ::java::lang::String & a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_30cd5d5b9318bd5d], a0.this$, a1);
    }

    StringBuilder StringBuilder::insert(jint a0, const JArray< jchar > & a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_715f770a66ead7b5], a0, a1.this$));
    }

    StringBuilder StringBuilder::insert(jint a0, const ::java::lang::String & a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_81be2976fdd3570e], a0, a1.this$));
    }

    StringBuilder StringBuilder::insert(jint a0, jboolean a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_a1457f7540fdd256], a0, a1));
    }

    StringBuilder StringBuilder::insert(jint a0, jchar a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_8887659d67622e58], a0, a1));
    }

    StringBuilder StringBuilder::insert(jint a0, jdouble a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_f420a279d8db66df], a0, a1));
    }

    StringBuilder StringBuilder::insert(jint a0, jfloat a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_d13831895949aaf9], a0, a1));
    }

    StringBuilder StringBuilder::insert(jint a0, jint a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_1ca249816e4537c2], a0, a1));
    }

    StringBuilder StringBuilder::insert(jint a0, const ::java::lang::CharSequence & a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_bae7f98d33b24748], a0, a1.this$));
    }

    StringBuilder StringBuilder::insert(jint a0, const ::java::lang::Object & a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_c6033db6ec314fa3], a0, a1.this$));
    }

    StringBuilder StringBuilder::insert(jint a0, jlong a1) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_d865087e672c8091], a0, a1));
    }

    StringBuilder StringBuilder::insert(jint a0, const JArray< jchar > & a1, jint a2, jint a3) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_89ffcbda4fb158b4], a0, a1.this$, a2, a3));
    }

    StringBuilder StringBuilder::insert(jint a0, const ::java::lang::CharSequence & a1, jint a2, jint a3) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_insert_392aaf29a745d1b8], a0, a1.this$, a2, a3));
    }

    jint StringBuilder::lastIndexOf(const ::java::lang::String & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_a5a7d1128e9e2bb7], a0.this$);
    }

    jint StringBuilder::lastIndexOf(const ::java::lang::String & a0, jint a1) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_30cd5d5b9318bd5d], a0.this$, a1);
    }

    StringBuilder StringBuilder::replace(jint a0, jint a1, const ::java::lang::String & a2) const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_replace_590c15104a3b5a8d], a0, a1, a2.this$));
    }

    StringBuilder StringBuilder::reverse() const
    {
      return StringBuilder(env->callObjectMethod(this$, mids$[mid_reverse_ffb326b9d303f5a4]));
    }

    ::java::lang::String StringBuilder::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_StringBuilder_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_StringBuilder_instance_(PyTypeObject *type, PyObject *arg);
    static int t_StringBuilder_init_(t_StringBuilder *self, PyObject *args, PyObject *kwds);
    static PyObject *t_StringBuilder_append(t_StringBuilder *self, PyObject *args);
    static PyObject *t_StringBuilder_appendCodePoint(t_StringBuilder *self, PyObject *args);
    static PyObject *t_StringBuilder_delete(t_StringBuilder *self, PyObject *args);
    static PyObject *t_StringBuilder_deleteCharAt(t_StringBuilder *self, PyObject *args);
    static PyObject *t_StringBuilder_indexOf(t_StringBuilder *self, PyObject *args);
    static PyObject *t_StringBuilder_insert(t_StringBuilder *self, PyObject *args);
    static PyObject *t_StringBuilder_lastIndexOf(t_StringBuilder *self, PyObject *args);
    static PyObject *t_StringBuilder_replace(t_StringBuilder *self, PyObject *args);
    static PyObject *t_StringBuilder_reverse(t_StringBuilder *self, PyObject *args);
    static PyObject *t_StringBuilder_toString(t_StringBuilder *self, PyObject *args);

    static PyMethodDef t_StringBuilder__methods_[] = {
      DECLARE_METHOD(t_StringBuilder, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_StringBuilder, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_StringBuilder, append, METH_VARARGS),
      DECLARE_METHOD(t_StringBuilder, appendCodePoint, METH_VARARGS),
      DECLARE_METHOD(t_StringBuilder, delete, METH_VARARGS),
      DECLARE_METHOD(t_StringBuilder, deleteCharAt, METH_VARARGS),
      DECLARE_METHOD(t_StringBuilder, indexOf, METH_VARARGS),
      DECLARE_METHOD(t_StringBuilder, insert, METH_VARARGS),
      DECLARE_METHOD(t_StringBuilder, lastIndexOf, METH_VARARGS),
      DECLARE_METHOD(t_StringBuilder, replace, METH_VARARGS),
      DECLARE_METHOD(t_StringBuilder, reverse, METH_VARARGS),
      DECLARE_METHOD(t_StringBuilder, toString, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(StringBuilder)[] = {
      { Py_tp_methods, t_StringBuilder__methods_ },
      { Py_tp_init, (void *) t_StringBuilder_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(StringBuilder)[] = {
      &PY_TYPE_DEF(::java::lang::AbstractStringBuilder),
      NULL
    };

    DEFINE_TYPE(StringBuilder, t_StringBuilder, StringBuilder);

    void t_StringBuilder::install(PyObject *module)
    {
      installType(&PY_TYPE(StringBuilder), &PY_TYPE_DEF(StringBuilder), module, "StringBuilder", 0);
    }

    void t_StringBuilder::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(StringBuilder), "class_", make_descriptor(StringBuilder::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(StringBuilder), "wrapfn_", make_descriptor(t_StringBuilder::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(StringBuilder), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_StringBuilder_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, StringBuilder::initializeClass, 1)))
        return NULL;
      return t_StringBuilder::wrap_Object(StringBuilder(((t_StringBuilder *) arg)->object.this$));
    }
    static PyObject *t_StringBuilder_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, StringBuilder::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_StringBuilder_init_(t_StringBuilder *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          StringBuilder object((jobject) NULL);

          INT_CALL(object = StringBuilder());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          StringBuilder object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = StringBuilder(a0));
            self->object = object;
            break;
          }
        }
        {
          jint a0;
          StringBuilder object((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            INT_CALL(object = StringBuilder(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          StringBuilder object((jobject) NULL);

          if (!parseArgs(args, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
          {
            INT_CALL(object = StringBuilder(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_StringBuilder_append(t_StringBuilder *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::StringBuffer a0((jobject) NULL);
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::lang::StringBuffer::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          JArray< jchar > a0((jobject) NULL);
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "[C", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jboolean a0;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "Z", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jchar a0;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "C", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jdouble a0;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "D", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jfloat a0;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "F", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          ::java::lang::Object a0((jobject) NULL);
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jlong a0;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "J", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          JArray< jchar > a0((jobject) NULL);
          jint a1;
          jint a2;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "[CII", &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.append(a0, a1, a2));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          jint a1;
          jint a2;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "OII", ::java::lang::PY_TYPE(CharSequence), &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.append(a0, a1, a2));
            return t_StringBuilder::wrap_Object(result);
          }
        }
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "append", args, 2);
    }

    static PyObject *t_StringBuilder_appendCodePoint(t_StringBuilder *self, PyObject *args)
    {
      jint a0;
      StringBuilder result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.appendCodePoint(a0));
        return t_StringBuilder::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "appendCodePoint", args, 2);
    }

    static PyObject *t_StringBuilder_delete(t_StringBuilder *self, PyObject *args)
    {
      jint a0;
      jint a1;
      StringBuilder result((jobject) NULL);

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.delete$(a0, a1));
        return t_StringBuilder::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "delete", args, 2);
    }

    static PyObject *t_StringBuilder_deleteCharAt(t_StringBuilder *self, PyObject *args)
    {
      jint a0;
      StringBuilder result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.deleteCharAt(a0));
        return t_StringBuilder::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "deleteCharAt", args, 2);
    }

    static PyObject *t_StringBuilder_indexOf(t_StringBuilder *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          jint result;

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.indexOf(a0));
            return PyLong_FromLong((long) result);
          }
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          jint a1;
          jint result;

          if (!parseArgs(args, "sI", &a0, &a1))
          {
            OBJ_CALL(result = self->object.indexOf(a0, a1));
            return PyLong_FromLong((long) result);
          }
        }
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "indexOf", args, 2);
    }

    static PyObject *t_StringBuilder_insert(t_StringBuilder *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          jint a0;
          JArray< jchar > a1((jobject) NULL);
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "I[C", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::String a1((jobject) NULL);
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "Is", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jboolean a1;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IZ", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jchar a1;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IC", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jdouble a1;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "ID", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jfloat a1;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IF", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jint a1;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::CharSequence a1((jobject) NULL);
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IO", ::java::lang::PY_TYPE(CharSequence), &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::Object a1((jobject) NULL);
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "Io", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          jlong a1;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IJ", &a0, &a1))
          {
            OBJ_CALL(result = self->object.insert(a0, a1));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        break;
       case 4:
        {
          jint a0;
          JArray< jchar > a1((jobject) NULL);
          jint a2;
          jint a3;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "I[CII", &a0, &a1, &a2, &a3))
          {
            OBJ_CALL(result = self->object.insert(a0, a1, a2, a3));
            return t_StringBuilder::wrap_Object(result);
          }
        }
        {
          jint a0;
          ::java::lang::CharSequence a1((jobject) NULL);
          jint a2;
          jint a3;
          StringBuilder result((jobject) NULL);

          if (!parseArgs(args, "IOII", ::java::lang::PY_TYPE(CharSequence), &a0, &a1, &a2, &a3))
          {
            OBJ_CALL(result = self->object.insert(a0, a1, a2, a3));
            return t_StringBuilder::wrap_Object(result);
          }
        }
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "insert", args, 2);
    }

    static PyObject *t_StringBuilder_lastIndexOf(t_StringBuilder *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          jint result;

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = self->object.lastIndexOf(a0));
            return PyLong_FromLong((long) result);
          }
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          jint a1;
          jint result;

          if (!parseArgs(args, "sI", &a0, &a1))
          {
            OBJ_CALL(result = self->object.lastIndexOf(a0, a1));
            return PyLong_FromLong((long) result);
          }
        }
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "lastIndexOf", args, 2);
    }

    static PyObject *t_StringBuilder_replace(t_StringBuilder *self, PyObject *args)
    {
      jint a0;
      jint a1;
      ::java::lang::String a2((jobject) NULL);
      StringBuilder result((jobject) NULL);

      if (!parseArgs(args, "IIs", &a0, &a1, &a2))
      {
        OBJ_CALL(result = self->object.replace(a0, a1, a2));
        return t_StringBuilder::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "replace", args, 2);
    }

    static PyObject *t_StringBuilder_reverse(t_StringBuilder *self, PyObject *args)
    {
      StringBuilder result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.reverse());
        return t_StringBuilder::wrap_Object(result);
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "reverse", args, 2);
    }

    static PyObject *t_StringBuilder_toString(t_StringBuilder *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(StringBuilder), (PyObject *) self, "toString", args, 2);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Random.h"
#include "java/io/Serializable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Random::class$ = NULL;
    jmethodID *Random::mids$ = NULL;
    bool Random::live$ = false;

    jclass Random::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Random");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9c778c9bce6694df] = env->getMethodID(cls, "<init>", "(J)V");
        mids$[mid_nextBoolean_8454bd5aa23fd11e] = env->getMethodID(cls, "nextBoolean", "()Z");
        mids$[mid_nextBytes_9ffdf271836656c4] = env->getMethodID(cls, "nextBytes", "([B)V");
        mids$[mid_nextDouble_8c74b787998ce4bc] = env->getMethodID(cls, "nextDouble", "()D");
        mids$[mid_nextFloat_58aec2b64dff50c8] = env->getMethodID(cls, "nextFloat", "()F");
        mids$[mid_nextGaussian_8c74b787998ce4bc] = env->getMethodID(cls, "nextGaussian", "()D");
        mids$[mid_nextInt_9972fcc56b44e79d] = env->getMethodID(cls, "nextInt", "()I");
        mids$[mid_nextInt_1e143afe1894d213] = env->getMethodID(cls, "nextInt", "(I)I");
        mids$[mid_nextLong_2e5ae9edcb9b072f] = env->getMethodID(cls, "nextLong", "()J");
        mids$[mid_setSeed_9c778c9bce6694df] = env->getMethodID(cls, "setSeed", "(J)V");
        mids$[mid_next_1e143afe1894d213] = env->getMethodID(cls, "next", "(I)I");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Random::Random() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    Random::Random(jlong a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_9c778c9bce6694df, a0)) {}

    jboolean Random::nextBoolean() const
    {
      return env->callBooleanMethod(this$, mids$[mid_nextBoolean_8454bd5aa23fd11e]);
    }

    void Random::nextBytes(const JArray< jbyte > & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_nextBytes_9ffdf271836656c4], a0.this$);
    }

    jdouble Random::nextDouble() const
    {
      return env->callDoubleMethod(this$, mids$[mid_nextDouble_8c74b787998ce4bc]);
    }

    jfloat Random::nextFloat() const
    {
      return env->callFloatMethod(this$, mids$[mid_nextFloat_58aec2b64dff50c8]);
    }

    jdouble Random::nextGaussian() const
    {
      return env->callDoubleMethod(this$, mids$[mid_nextGaussian_8c74b787998ce4bc]);
    }

    jint Random::nextInt() const
    {
      return env->callIntMethod(this$, mids$[mid_nextInt_9972fcc56b44e79d]);
    }

    jint Random::nextInt(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_nextInt_1e143afe1894d213], a0);
    }

    jlong Random::nextLong() const
    {
      return env->callLongMethod(this$, mids$[mid_nextLong_2e5ae9edcb9b072f]);
    }

    void Random::setSeed(jlong a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setSeed_9c778c9bce6694df], a0);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Random_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Random_instance_(PyTypeObject *type, PyObject *arg);
    static int t_Random_init_(t_Random *self, PyObject *args, PyObject *kwds);
    static PyObject *t_Random_nextBoolean(t_Random *self);
    static PyObject *t_Random_nextBytes(t_Random *self, PyObject *arg);
    static PyObject *t_Random_nextDouble(t_Random *self);
    static PyObject *t_Random_nextFloat(t_Random *self);
    static PyObject *t_Random_nextGaussian(t_Random *self);
    static PyObject *t_Random_nextInt(t_Random *self, PyObject *args);
    static PyObject *t_Random_nextLong(t_Random *self);
    static PyObject *t_Random_setSeed(t_Random *self, PyObject *arg);
    static int t_Random_set__seed(t_Random *self, PyObject *arg, void *data);
    static PyGetSetDef t_Random__fields_[] = {
      DECLARE_SET_FIELD(t_Random, seed),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Random__methods_[] = {
      DECLARE_METHOD(t_Random, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Random, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Random, nextBoolean, METH_NOARGS),
      DECLARE_METHOD(t_Random, nextBytes, METH_O),
      DECLARE_METHOD(t_Random, nextDouble, METH_NOARGS),
      DECLARE_METHOD(t_Random, nextFloat, METH_NOARGS),
      DECLARE_METHOD(t_Random, nextGaussian, METH_NOARGS),
      DECLARE_METHOD(t_Random, nextInt, METH_VARARGS),
      DECLARE_METHOD(t_Random, nextLong, METH_NOARGS),
      DECLARE_METHOD(t_Random, setSeed, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Random)[] = {
      { Py_tp_methods, t_Random__methods_ },
      { Py_tp_init, (void *) t_Random_init_ },
      { Py_tp_getset, t_Random__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Random)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Random, t_Random, Random);

    void t_Random::install(PyObject *module)
    {
      installType(&PY_TYPE(Random), &PY_TYPE_DEF(Random), module, "Random", 0);
    }

    void t_Random::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Random), "class_", make_descriptor(Random::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Random), "wrapfn_", make_descriptor(t_Random::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Random), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Random_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Random::initializeClass, 1)))
        return NULL;
      return t_Random::wrap_Object(Random(((t_Random *) arg)->object.this$));
    }
    static PyObject *t_Random_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Random::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_Random_init_(t_Random *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          Random object((jobject) NULL);

          INT_CALL(object = Random());
          self->object = object;
          break;
        }
       case 1:
        {
          jlong a0;
          Random object((jobject) NULL);

          if (!parseArgs(args, "J", &a0))
          {
            INT_CALL(object = Random(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_Random_nextBoolean(t_Random *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.nextBoolean());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_Random_nextBytes(t_Random *self, PyObject *arg)
    {
      JArray< jbyte > a0((jobject) NULL);

      if (!parseArg(arg, "[B", &a0))
      {
        OBJ_CALL(self->object.nextBytes(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "nextBytes", arg);
      return NULL;
    }

    static PyObject *t_Random_nextDouble(t_Random *self)
    {
      jdouble result;
      OBJ_CALL(result = self->object.nextDouble());
      return PyFloat_FromDouble((double) result);
    }

    static PyObject *t_Random_nextFloat(t_Random *self)
    {
      jfloat result;
      OBJ_CALL(result = self->object.nextFloat());
      return PyFloat_FromDouble((double) result);
    }

    static PyObject *t_Random_nextGaussian(t_Random *self)
    {
      jdouble result;
      OBJ_CALL(result = self->object.nextGaussian());
      return PyFloat_FromDouble((double) result);
    }

    static PyObject *t_Random_nextInt(t_Random *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          jint result;
          OBJ_CALL(result = self->object.nextInt());
          return PyLong_FromLong((long) result);
        }
        break;
       case 1:
        {
          jint a0;
          jint result;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.nextInt(a0));
            return PyLong_FromLong((long) result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "nextInt", args);
      return NULL;
    }

    static PyObject *t_Random_nextLong(t_Random *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.nextLong());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_Random_setSeed(t_Random *self, PyObject *arg)
    {
      jlong a0;

      if (!parseArg(arg, "J", &a0))
      {
        OBJ_CALL(self->object.setSeed(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setSeed", arg);
      return NULL;
    }

    static int t_Random_set__seed(t_Random *self, PyObject *arg, void *data)
    {
      {
        jlong value;
        if (!parseArg(arg, "J", &value))
        {
          INT_CALL(self->object.setSeed(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "seed", arg);
      return -1;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Calendar.h"
#include "java/util/Map.h"
#include "java/lang/Cloneable.h"
#include "java/lang/Comparable.h"
#include "java/lang/Class.h"
#include "java/util/Date.h"
#include "java/util/Locale.h"
#include "java/lang/Integer.h"
#include "java/lang/String.h"
#include "java/util/TimeZone.h"
#include "java/util/Set.h"
#include "java/util/Calendar.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Calendar::class$ = NULL;
    jmethodID *Calendar::mids$ = NULL;
    bool Calendar::live$ = false;
    jint Calendar::ALL_STYLES = (jint) 0;
    jint Calendar::AM = (jint) 0;
    jint Calendar::AM_PM = (jint) 0;
    jint Calendar::APRIL = (jint) 0;
    jint Calendar::AUGUST = (jint) 0;
    jint Calendar::DATE = (jint) 0;
    jint Calendar::DAY_OF_MONTH = (jint) 0;
    jint Calendar::DAY_OF_WEEK = (jint) 0;
    jint Calendar::DAY_OF_WEEK_IN_MONTH = (jint) 0;
    jint Calendar::DAY_OF_YEAR = (jint) 0;
    jint Calendar::DECEMBER = (jint) 0;
    jint Calendar::DST_OFFSET = (jint) 0;
    jint Calendar::ERA = (jint) 0;
    jint Calendar::FEBRUARY = (jint) 0;
    jint Calendar::FIELD_COUNT = (jint) 0;
    jint Calendar::FRIDAY = (jint) 0;
    jint Calendar::HOUR = (jint) 0;
    jint Calendar::HOUR_OF_DAY = (jint) 0;
    jint Calendar::JANUARY = (jint) 0;
    jint Calendar::JULY = (jint) 0;
    jint Calendar::JUNE = (jint) 0;
    jint Calendar::LONG = (jint) 0;
    jint Calendar::LONG_FORMAT = (jint) 0;
    jint Calendar::LONG_STANDALONE = (jint) 0;
    jint Calendar::MARCH = (jint) 0;
    jint Calendar::MAY = (jint) 0;
    jint Calendar::MILLISECOND = (jint) 0;
    jint Calendar::MINUTE = (jint) 0;
    jint Calendar::MONDAY = (jint) 0;
    jint Calendar::MONTH = (jint) 0;
    jint Calendar::NARROW_FORMAT = (jint) 0;
    jint Calendar::NARROW_STANDALONE = (jint) 0;
    jint Calendar::NOVEMBER = (jint) 0;
    jint Calendar::OCTOBER = (jint) 0;
    jint Calendar::PM = (jint) 0;
    jint Calendar::SATURDAY = (jint) 0;
    jint Calendar::SECOND = (jint) 0;
    jint Calendar::SEPTEMBER = (jint) 0;
    jint Calendar::SHORT = (jint) 0;
    jint Calendar::SHORT_FORMAT = (jint) 0;
    jint Calendar::SHORT_STANDALONE = (jint) 0;
    jint Calendar::SUNDAY = (jint) 0;
    jint Calendar::THURSDAY = (jint) 0;
    jint Calendar::TUESDAY = (jint) 0;
    jint Calendar::UNDECIMBER = (jint) 0;
    jint Calendar::WEDNESDAY = (jint) 0;
    jint Calendar::WEEK_OF_MONTH = (jint) 0;
    jint Calendar::WEEK_OF_YEAR = (jint) 0;
    jint Calendar::YEAR = (jint) 0;
    jint Calendar::ZONE_OFFSET = (jint) 0;

    jclass Calendar::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Calendar");

        mids$ = new jmethodID[max_mid];
        mids$[mid_add_438c62480c481c65] = env->getMethodID(cls, "add", "(II)V");
        mids$[mid_after_8b72f2dcdde6fd1d] = env->getMethodID(cls, "after", "(Ljava/lang/Object;)Z");
        mids$[mid_before_8b72f2dcdde6fd1d] = env->getMethodID(cls, "before", "(Ljava/lang/Object;)Z");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_clear_040c4cd0390c5aff] = env->getMethodID(cls, "clear", "(I)V");
        mids$[mid_clone_d6bcd06f3102c4d9] = env->getMethodID(cls, "clone", "()Ljava/lang/Object;");
        mids$[mid_compareTo_252775248db7cef6] = env->getMethodID(cls, "compareTo", "(Ljava/util/Calendar;)I");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_get_1e143afe1894d213] = env->getMethodID(cls, "get", "(I)I");
        mids$[mid_getActualMaximum_1e143afe1894d213] = env->getMethodID(cls, "getActualMaximum", "(I)I");
        mids$[mid_getActualMinimum_1e143afe1894d213] = env->getMethodID(cls, "getActualMinimum", "(I)I");
        mids$[mid_getAvailableCalendarTypes_7dcf4034c6d1a92a] = env->getStaticMethodID(cls, "getAvailableCalendarTypes", "()Ljava/util/Set;");
        mids$[mid_getAvailableLocales_9de0c9f607235a40] = env->getStaticMethodID(cls, "getAvailableLocales", "()[Ljava/util/Locale;");
        mids$[mid_getCalendarType_db9b55ba01e03e4b] = env->getMethodID(cls, "getCalendarType", "()Ljava/lang/String;");
        mids$[mid_getDisplayName_e38df799b3b22f5e] = env->getMethodID(cls, "getDisplayName", "(IILjava/util/Locale;)Ljava/lang/String;");
        mids$[mid_getDisplayNames_74ab0ae88de99037] = env->getMethodID(cls, "getDisplayNames", "(IILjava/util/Locale;)Ljava/util/Map;");
        mids$[mid_getFirstDayOfWeek_9972fcc56b44e79d] = env->getMethodID(cls, "getFirstDayOfWeek", "()I");
        mids$[mid_getGreatestMinimum_1e143afe1894d213] = env->getMethodID(cls, "getGreatestMinimum", "(I)I");
        mids$[mid_getInstance_5d2bf8ea8296abce] = env->getStaticMethodID(cls, "getInstance", "()Ljava/util/Calendar;");
        mids$[mid_getInstance_3b2d94f2d19a38a1] = env->getStaticMethodID(cls, "getInstance", "(Ljava/util/Locale;)Ljava/util/Calendar;");
        mids$[mid_getInstance_62d190eab6e6f1d1] = env->getStaticMethodID(cls, "getInstance", "(Ljava/util/TimeZone;)Ljava/util/Calendar;");
        mids$[mid_getInstance_d74d7afe145e4ffa] = env->getStaticMethodID(cls, "getInstance", "(Ljava/util/TimeZone;Ljava/util/Locale;)Ljava/util/Calendar;");
        mids$[mid_getLeastMaximum_1e143afe1894d213] = env->getMethodID(cls, "getLeastMaximum", "(I)I");
        mids$[mid_getMaximum_1e143afe1894d213] = env->getMethodID(cls, "getMaximum", "(I)I");
        mids$[mid_getMinimalDaysInFirstWeek_9972fcc56b44e79d] = env->getMethodID(cls, "getMinimalDaysInFirstWeek", "()I");
        mids$[mid_getMinimum_1e143afe1894d213] = env->getMethodID(cls, "getMinimum", "(I)I");
        mids$[mid_getTime_7d498bbaa94ff388] = env->getMethodID(cls, "getTime", "()Ljava/util/Date;");
        mids$[mid_getTimeInMillis_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTimeInMillis", "()J");
        mids$[mid_getTimeZone_a00e8b2cc21b09d1] = env->getMethodID(cls, "getTimeZone", "()Ljava/util/TimeZone;");
        mids$[mid_getWeekYear_9972fcc56b44e79d] = env->getMethodID(cls, "getWeekYear", "()I");
        mids$[mid_getWeeksInWeekYear_9972fcc56b44e79d] = env->getMethodID(cls, "getWeeksInWeekYear", "()I");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_isLenient_8454bd5aa23fd11e] = env->getMethodID(cls, "isLenient", "()Z");
        mids$[mid_isSet_a1d30e1ee40c89a2] = env->getMethodID(cls, "isSet", "(I)Z");
        mids$[mid_isWeekDateSupported_8454bd5aa23fd11e] = env->getMethodID(cls, "isWeekDateSupported", "()Z");
        mids$[mid_roll_b8f283cdbda5c964] = env->getMethodID(cls, "roll", "(IZ)V");
        mids$[mid_roll_438c62480c481c65] = env->getMethodID(cls, "roll", "(II)V");
        mids$[mid_set_438c62480c481c65] = env->getMethodID(cls, "set", "(II)V");
        mids$[mid_set_db3e97653d3683f3] = env->getMethodID(cls, "set", "(III)V");
        mids$[mid_set_bfcfa7ea38630f19] = env->getMethodID(cls, "set", "(IIIII)V");
        mids$[mid_set_8a81c36f6bc75ed5] = env->getMethodID(cls, "set", "(IIIIII)V");
        mids$[mid_setFirstDayOfWeek_040c4cd0390c5aff] = env->getMethodID(cls, "setFirstDayOfWeek", "(I)V");
        mids$[mid_setLenient_9d72768e8fdce2b7] = env->getMethodID(cls, "setLenient", "(Z)V");
        mids$[mid_setMinimalDaysInFirstWeek_040c4cd0390c5aff] = env->getMethodID(cls, "setMinimalDaysInFirstWeek", "(I)V");
        mids$[mid_setTime_823e481d02661c07] = env->getMethodID(cls, "setTime", "(Ljava/util/Date;)V");
        mids$[mid_setTimeInMillis_9c778c9bce6694df] = env->getMethodID(cls, "setTimeInMillis", "(J)V");
        mids$[mid_setTimeZone_62cba443b119095c] = env->getMethodID(cls, "setTimeZone", "(Ljava/util/TimeZone;)V");
        mids$[mid_setWeekDate_db3e97653d3683f3] = env->getMethodID(cls, "setWeekDate", "(III)V");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
        mids$[mid_computeTime_f2cc1bce94666404] = env->getMethodID(cls, "computeTime", "()V");
        mids$[mid_computeFields_f2cc1bce94666404] = env->getMethodID(cls, "computeFields", "()V");
        mids$[mid_internalGet_1e143afe1894d213] = env->getMethodID(cls, "internalGet", "(I)I");
        mids$[mid_complete_f2cc1bce94666404] = env->getMethodID(cls, "complete", "()V");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        ALL_STYLES = env->getStaticIntField(cls, "ALL_STYLES");
        AM = env->getStaticIntField(cls, "AM");
        AM_PM = env->getStaticIntField(cls, "AM_PM");
        APRIL = env->getStaticIntField(cls, "APRIL");
        AUGUST = env->getStaticIntField(cls, "AUGUST");
        DATE = env->getStaticIntField(cls, "DATE");
        DAY_OF_MONTH = env->getStaticIntField(cls, "DAY_OF_MONTH");
        DAY_OF_WEEK = env->getStaticIntField(cls, "DAY_OF_WEEK");
        DAY_OF_WEEK_IN_MONTH = env->getStaticIntField(cls, "DAY_OF_WEEK_IN_MONTH");
        DAY_OF_YEAR = env->getStaticIntField(cls, "DAY_OF_YEAR");
        DECEMBER = env->getStaticIntField(cls, "DECEMBER");
        DST_OFFSET = env->getStaticIntField(cls, "DST_OFFSET");
        ERA = env->getStaticIntField(cls, "ERA");
        FEBRUARY = env->getStaticIntField(cls, "FEBRUARY");
        FIELD_COUNT = env->getStaticIntField(cls, "FIELD_COUNT");
        FRIDAY = env->getStaticIntField(cls, "FRIDAY");
        HOUR = env->getStaticIntField(cls, "HOUR");
        HOUR_OF_DAY = env->getStaticIntField(cls, "HOUR_OF_DAY");
        JANUARY = env->getStaticIntField(cls, "JANUARY");
        JULY = env->getStaticIntField(cls, "JULY");
        JUNE = env->getStaticIntField(cls, "JUNE");
        LONG = env->getStaticIntField(cls, "LONG");
        LONG_FORMAT = env->getStaticIntField(cls, "LONG_FORMAT");
        LONG_STANDALONE = env->getStaticIntField(cls, "LONG_STANDALONE");
        MARCH = env->getStaticIntField(cls, "MARCH");
        MAY = env->getStaticIntField(cls, "MAY");
        MILLISECOND = env->getStaticIntField(cls, "MILLISECOND");
        MINUTE = env->getStaticIntField(cls, "MINUTE");
        MONDAY = env->getStaticIntField(cls, "MONDAY");
        MONTH = env->getStaticIntField(cls, "MONTH");
        NARROW_FORMAT = env->getStaticIntField(cls, "NARROW_FORMAT");
        NARROW_STANDALONE = env->getStaticIntField(cls, "NARROW_STANDALONE");
        NOVEMBER = env->getStaticIntField(cls, "NOVEMBER");
        OCTOBER = env->getStaticIntField(cls, "OCTOBER");
        PM = env->getStaticIntField(cls, "PM");
        SATURDAY = env->getStaticIntField(cls, "SATURDAY");
        SECOND = env->getStaticIntField(cls, "SECOND");
        SEPTEMBER = env->getStaticIntField(cls, "SEPTEMBER");
        SHORT = env->getStaticIntField(cls, "SHORT");
        SHORT_FORMAT = env->getStaticIntField(cls, "SHORT_FORMAT");
        SHORT_STANDALONE = env->getStaticIntField(cls, "SHORT_STANDALONE");
        SUNDAY = env->getStaticIntField(cls, "SUNDAY");
        THURSDAY = env->getStaticIntField(cls, "THURSDAY");
        TUESDAY = env->getStaticIntField(cls, "TUESDAY");
        UNDECIMBER = env->getStaticIntField(cls, "UNDECIMBER");
        WEDNESDAY = env->getStaticIntField(cls, "WEDNESDAY");
        WEEK_OF_MONTH = env->getStaticIntField(cls, "WEEK_OF_MONTH");
        WEEK_OF_YEAR = env->getStaticIntField(cls, "WEEK_OF_YEAR");
        YEAR = env->getStaticIntField(cls, "YEAR");
        ZONE_OFFSET = env->getStaticIntField(cls, "ZONE_OFFSET");
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Calendar::add(jint a0, jint a1) const
    {
      env->callVoidMethod(this$, mids$[mid_add_438c62480c481c65], a0, a1);
    }

    jboolean Calendar::after(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_after_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Calendar::before(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_before_8b72f2dcdde6fd1d], a0.this$);
    }

    void Calendar::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    void Calendar::clear(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_clear_040c4cd0390c5aff], a0);
    }

    ::java::lang::Object Calendar::clone() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_clone_d6bcd06f3102c4d9]));
    }

    jint Calendar::compareTo(const Calendar & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_compareTo_252775248db7cef6], a0.this$);
    }

    jboolean Calendar::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    jint Calendar::get(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_get_1e143afe1894d213], a0);
    }

    jint Calendar::getActualMaximum(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_getActualMaximum_1e143afe1894d213], a0);
    }

    jint Calendar::getActualMinimum(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_getActualMinimum_1e143afe1894d213], a0);
    }

    ::java::util::Set Calendar::getAvailableCalendarTypes()
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::util::Set(env->callStaticObjectMethod(cls, mids$[mid_getAvailableCalendarTypes_7dcf4034c6d1a92a]));
    }

    JArray< ::java::util::Locale > Calendar::getAvailableLocales()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< ::java::util::Locale >(env->callStaticObjectMethod(cls, mids$[mid_getAvailableLocales_9de0c9f607235a40]));
    }

    ::java::lang::String Calendar::getCalendarType() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getCalendarType_db9b55ba01e03e4b]));
    }

    ::java::lang::String Calendar::getDisplayName(jint a0, jint a1, const ::java::util::Locale & a2) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_e38df799b3b22f5e], a0, a1, a2.this$));
    }

    ::java::util::Map Calendar::getDisplayNames(jint a0, jint a1, const ::java::util::Locale & a2) const
    {
      return ::java::util::Map(env->callObjectMethod(this$, mids$[mid_getDisplayNames_74ab0ae88de99037], a0, a1, a2.this$));
    }

    jint Calendar::getFirstDayOfWeek() const
    {
      return env->callIntMethod(this$, mids$[mid_getFirstDayOfWeek_9972fcc56b44e79d]);
    }

    jint Calendar::getGreatestMinimum(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_getGreatestMinimum_1e143afe1894d213], a0);
    }

    Calendar Calendar::getInstance()
    {
      jclass cls = env->getClass(initializeClass);
      return Calendar(env->callStaticObjectMethod(cls, mids$[mid_getInstance_5d2bf8ea8296abce]));
    }

    Calendar Calendar::getInstance(const ::java::util::Locale & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Calendar(env->callStaticObjectMethod(cls, mids$[mid_getInstance_3b2d94f2d19a38a1], a0.this$));
    }

    Calendar Calendar::getInstance(const ::java::util::TimeZone & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Calendar(env->callStaticObjectMethod(cls, mids$[mid_getInstance_62d190eab6e6f1d1], a0.this$));
    }

    Calendar Calendar::getInstance(const ::java::util::TimeZone & a0, const ::java::util::Locale & a1)
    {
      jclass cls = env->getClass(initializeClass);
      return Calendar(env->callStaticObjectMethod(cls, mids$[mid_getInstance_d74d7afe145e4ffa], a0.this$, a1.this$));
    }

    jint Calendar::getLeastMaximum(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_getLeastMaximum_1e143afe1894d213], a0);
    }

    jint Calendar::getMaximum(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_getMaximum_1e143afe1894d213], a0);
    }

    jint Calendar::getMinimalDaysInFirstWeek() const
    {
      return env->callIntMethod(this$, mids$[mid_getMinimalDaysInFirstWeek_9972fcc56b44e79d]);
    }

    jint Calendar::getMinimum(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_getMinimum_1e143afe1894d213], a0);
    }

    ::java::util::Date Calendar::getTime() const
    {
      return ::java::util::Date(env->callObjectMethod(this$, mids$[mid_getTime_7d498bbaa94ff388]));
    }

    jlong Calendar::getTimeInMillis() const
    {
      return env->callLongMethod(this$, mids$[mid_getTimeInMillis_2e5ae9edcb9b072f]);
    }

    ::java::util::TimeZone Calendar::getTimeZone() const
    {
      return ::java::util::TimeZone(env->callObjectMethod(this$, mids$[mid_getTimeZone_a00e8b2cc21b09d1]));
    }

    jint Calendar::getWeekYear() const
    {
      return env->callIntMethod(this$, mids$[mid_getWeekYear_9972fcc56b44e79d]);
    }

    jint Calendar::getWeeksInWeekYear() const
    {
      return env->callIntMethod(this$, mids$[mid_getWeeksInWeekYear_9972fcc56b44e79d]);
    }

    jint Calendar::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean Calendar::isLenient() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isLenient_8454bd5aa23fd11e]);
    }

    jboolean Calendar::isSet(jint a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_isSet_a1d30e1ee40c89a2], a0);
    }

    jboolean Calendar::isWeekDateSupported() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isWeekDateSupported_8454bd5aa23fd11e]);
    }

    void Calendar::roll(jint a0, jboolean a1) const
    {
      env->callVoidMethod(this$, mids$[mid_roll_b8f283cdbda5c964], a0, a1);
    }

    void Calendar::roll(jint a0, jint a1) const
    {
      env->callVoidMethod(this$, mids$[mid_roll_438c62480c481c65], a0, a1);
    }

    void Calendar::set(jint a0, jint a1) const
    {
      env->callVoidMethod(this$, mids$[mid_set_438c62480c481c65], a0, a1);
    }

    void Calendar::set(jint a0, jint a1, jint a2) const
    {
      env->callVoidMethod(this$, mids$[mid_set_db3e97653d3683f3], a0, a1, a2);
    }

    void Calendar::set(jint a0, jint a1, jint a2, jint a3, jint a4) const
    {
      env->callVoidMethod(this$, mids$[mid_set_bfcfa7ea38630f19], a0, a1, a2, a3, a4);
    }

    void Calendar::set(jint a0, jint a1, jint a2, jint a3, jint a4, jint a5) const
    {
      env->callVoidMethod(this$, mids$[mid_set_8a81c36f6bc75ed5], a0, a1, a2, a3, a4, a5);
    }

    void Calendar::setFirstDayOfWeek(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setFirstDayOfWeek_040c4cd0390c5aff], a0);
    }

    void Calendar::setLenient(jboolean a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setLenient_9d72768e8fdce2b7], a0);
    }

    void Calendar::setMinimalDaysInFirstWeek(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setMinimalDaysInFirstWeek_040c4cd0390c5aff], a0);
    }

    void Calendar::setTime(const ::java::util::Date & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setTime_823e481d02661c07], a0.this$);
    }

    void Calendar::setTimeInMillis(jlong a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setTimeInMillis_9c778c9bce6694df], a0);
    }

    void Calendar::setTimeZone(const ::java::util::TimeZone & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setTimeZone_62cba443b119095c], a0.this$);
    }

    void Calendar::setWeekDate(jint a0, jint a1, jint a2) const
    {
      env->callVoidMethod(this$, mids$[mid_setWeekDate_db3e97653d3683f3], a0, a1, a2);
    }

    ::java::lang::String Calendar::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Calendar_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Calendar_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Calendar_add(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_after(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_before(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_clear(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_clone(t_Calendar *self);
    static PyObject *t_Calendar_compareTo(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_equals(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_get(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_getActualMaximum(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_getActualMinimum(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_getAvailableCalendarTypes(PyTypeObject *type);
    static PyObject *t_Calendar_getAvailableLocales(PyTypeObject *type);
    static PyObject *t_Calendar_getCalendarType(t_Calendar *self);
    static PyObject *t_Calendar_getDisplayName(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_getDisplayNames(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_getFirstDayOfWeek(t_Calendar *self);
    static PyObject *t_Calendar_getGreatestMinimum(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_getInstance(PyTypeObject *type, PyObject *args);
    static PyObject *t_Calendar_getLeastMaximum(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_getMaximum(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_getMinimalDaysInFirstWeek(t_Calendar *self);
    static PyObject *t_Calendar_getMinimum(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_getTime(t_Calendar *self);
    static PyObject *t_Calendar_getTimeInMillis(t_Calendar *self);
    static PyObject *t_Calendar_getTimeZone(t_Calendar *self);
    static PyObject *t_Calendar_getWeekYear(t_Calendar *self);
    static PyObject *t_Calendar_getWeeksInWeekYear(t_Calendar *self);
    static PyObject *t_Calendar_hashCode(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_isLenient(t_Calendar *self);
    static PyObject *t_Calendar_isSet(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_isWeekDateSupported(t_Calendar *self);
    static PyObject *t_Calendar_roll(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_set(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_setFirstDayOfWeek(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_setLenient(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_setMinimalDaysInFirstWeek(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_setTime(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_setTimeInMillis(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_setTimeZone(t_Calendar *self, PyObject *arg);
    static PyObject *t_Calendar_setWeekDate(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_toString(t_Calendar *self, PyObject *args);
    static PyObject *t_Calendar_get__availableCalendarTypes(t_Calendar *self, void *data);
    static PyObject *t_Calendar_get__availableLocales(t_Calendar *self, void *data);
    static PyObject *t_Calendar_get__calendarType(t_Calendar *self, void *data);
    static PyObject *t_Calendar_get__firstDayOfWeek(t_Calendar *self, void *data);
    static int t_Calendar_set__firstDayOfWeek(t_Calendar *self, PyObject *arg, void *data);
    static PyObject *t_Calendar_get__instance(t_Calendar *self, void *data);
    static PyObject *t_Calendar_get__lenient(t_Calendar *self, void *data);
    static int t_Calendar_set__lenient(t_Calendar *self, PyObject *arg, void *data);
    static PyObject *t_Calendar_get__minimalDaysInFirstWeek(t_Calendar *self, void *data);
    static int t_Calendar_set__minimalDaysInFirstWeek(t_Calendar *self, PyObject *arg, void *data);
    static PyObject *t_Calendar_get__time(t_Calendar *self, void *data);
    static int t_Calendar_set__time(t_Calendar *self, PyObject *arg, void *data);
    static PyObject *t_Calendar_get__timeInMillis(t_Calendar *self, void *data);
    static int t_Calendar_set__timeInMillis(t_Calendar *self, PyObject *arg, void *data);
    static PyObject *t_Calendar_get__timeZone(t_Calendar *self, void *data);
    static int t_Calendar_set__timeZone(t_Calendar *self, PyObject *arg, void *data);
    static PyObject *t_Calendar_get__weekDateSupported(t_Calendar *self, void *data);
    static PyObject *t_Calendar_get__weekYear(t_Calendar *self, void *data);
    static PyObject *t_Calendar_get__weeksInWeekYear(t_Calendar *self, void *data);
    static PyGetSetDef t_Calendar__fields_[] = {
      DECLARE_GET_FIELD(t_Calendar, availableCalendarTypes),
      DECLARE_GET_FIELD(t_Calendar, availableLocales),
      DECLARE_GET_FIELD(t_Calendar, calendarType),
      DECLARE_GETSET_FIELD(t_Calendar, firstDayOfWeek),
      DECLARE_GET_FIELD(t_Calendar, instance),
      DECLARE_GETSET_FIELD(t_Calendar, lenient),
      DECLARE_GETSET_FIELD(t_Calendar, minimalDaysInFirstWeek),
      DECLARE_GETSET_FIELD(t_Calendar, time),
      DECLARE_GETSET_FIELD(t_Calendar, timeInMillis),
      DECLARE_GETSET_FIELD(t_Calendar, timeZone),
      DECLARE_GET_FIELD(t_Calendar, weekDateSupported),
      DECLARE_GET_FIELD(t_Calendar, weekYear),
      DECLARE_GET_FIELD(t_Calendar, weeksInWeekYear),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Calendar__methods_[] = {
      DECLARE_METHOD(t_Calendar, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Calendar, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Calendar, add, METH_VARARGS),
      DECLARE_METHOD(t_Calendar, after, METH_O),
      DECLARE_METHOD(t_Calendar, before, METH_O),
      DECLARE_METHOD(t_Calendar, clear, METH_VARARGS),
      DECLARE_METHOD(t_Calendar, clone, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, compareTo, METH_O),
      DECLARE_METHOD(t_Calendar, equals, METH_VARARGS),
      DECLARE_METHOD(t_Calendar, get, METH_O),
      DECLARE_METHOD(t_Calendar, getActualMaximum, METH_O),
      DECLARE_METHOD(t_Calendar, getActualMinimum, METH_O),
      DECLARE_METHOD(t_Calendar, getAvailableCalendarTypes, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_Calendar, getAvailableLocales, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_Calendar, getCalendarType, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, getDisplayName, METH_VARARGS),
      DECLARE_METHOD(t_Calendar, getDisplayNames, METH_VARARGS),
      DECLARE_METHOD(t_Calendar, getFirstDayOfWeek, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, getGreatestMinimum, METH_O),
      DECLARE_METHOD(t_Calendar, getInstance, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Calendar, getLeastMaximum, METH_O),
      DECLARE_METHOD(t_Calendar, getMaximum, METH_O),
      DECLARE_METHOD(t_Calendar, getMinimalDaysInFirstWeek, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, getMinimum, METH_O),
      DECLARE_METHOD(t_Calendar, getTime, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, getTimeInMillis, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, getTimeZone, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, getWeekYear, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, getWeeksInWeekYear, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_Calendar, isLenient, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, isSet, METH_O),
      DECLARE_METHOD(t_Calendar, isWeekDateSupported, METH_NOARGS),
      DECLARE_METHOD(t_Calendar, roll, METH_VARARGS),
      DECLARE_METHOD(t_Calendar, set, METH_VARARGS),
      DECLARE_METHOD(t_Calendar, setFirstDayOfWeek, METH_O),
      DECLARE_METHOD(t_Calendar, setLenient, METH_O),
      DECLARE_METHOD(t_Calendar, setMinimalDaysInFirstWeek, METH_O),
      DECLARE_METHOD(t_Calendar, setTime, METH_O),
      DECLARE_METHOD(t_Calendar, setTimeInMillis, METH_O),
      DECLARE_METHOD(t_Calendar, setTimeZone, METH_O),
      DECLARE_METHOD(t_Calendar, setWeekDate, METH_VARARGS),
      DECLARE_METHOD(t_Calendar, toString, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Calendar)[] = {
      { Py_tp_methods, t_Calendar__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Calendar__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Calendar)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Calendar, t_Calendar, Calendar);

    void t_Calendar::install(PyObject *module)
    {
      installType(&PY_TYPE(Calendar), &PY_TYPE_DEF(Calendar), module, "Calendar", 0);
    }

    void t_Calendar::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "class_", make_descriptor(Calendar::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "wrapfn_", make_descriptor(t_Calendar::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "boxfn_", make_descriptor(boxObject));
      env->getClass(Calendar::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "ALL_STYLES", make_descriptor(Calendar::ALL_STYLES));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "AM", make_descriptor(Calendar::AM));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "AM_PM", make_descriptor(Calendar::AM_PM));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "APRIL", make_descriptor(Calendar::APRIL));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "AUGUST", make_descriptor(Calendar::AUGUST));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "DATE", make_descriptor(Calendar::DATE));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "DAY_OF_MONTH", make_descriptor(Calendar::DAY_OF_MONTH));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "DAY_OF_WEEK", make_descriptor(Calendar::DAY_OF_WEEK));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "DAY_OF_WEEK_IN_MONTH", make_descriptor(Calendar::DAY_OF_WEEK_IN_MONTH));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "DAY_OF_YEAR", make_descriptor(Calendar::DAY_OF_YEAR));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "DECEMBER", make_descriptor(Calendar::DECEMBER));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "DST_OFFSET", make_descriptor(Calendar::DST_OFFSET));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "ERA", make_descriptor(Calendar::ERA));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "FEBRUARY", make_descriptor(Calendar::FEBRUARY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "FIELD_COUNT", make_descriptor(Calendar::FIELD_COUNT));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "FRIDAY", make_descriptor(Calendar::FRIDAY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "HOUR", make_descriptor(Calendar::HOUR));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "HOUR_OF_DAY", make_descriptor(Calendar::HOUR_OF_DAY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "JANUARY", make_descriptor(Calendar::JANUARY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "JULY", make_descriptor(Calendar::JULY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "JUNE", make_descriptor(Calendar::JUNE));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "LONG", make_descriptor(Calendar::LONG));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "LONG_FORMAT", make_descriptor(Calendar::LONG_FORMAT));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "LONG_STANDALONE", make_descriptor(Calendar::LONG_STANDALONE));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "MARCH", make_descriptor(Calendar::MARCH));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "MAY", make_descriptor(Calendar::MAY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "MILLISECOND", make_descriptor(Calendar::MILLISECOND));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "MINUTE", make_descriptor(Calendar::MINUTE));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "MONDAY", make_descriptor(Calendar::MONDAY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "MONTH", make_descriptor(Calendar::MONTH));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "NARROW_FORMAT", make_descriptor(Calendar::NARROW_FORMAT));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "NARROW_STANDALONE", make_descriptor(Calendar::NARROW_STANDALONE));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "NOVEMBER", make_descriptor(Calendar::NOVEMBER));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "OCTOBER", make_descriptor(Calendar::OCTOBER));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "PM", make_descriptor(Calendar::PM));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "SATURDAY", make_descriptor(Calendar::SATURDAY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "SECOND", make_descriptor(Calendar::SECOND));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "SEPTEMBER", make_descriptor(Calendar::SEPTEMBER));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "SHORT", make_descriptor(Calendar::SHORT));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "SHORT_FORMAT", make_descriptor(Calendar::SHORT_FORMAT));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "SHORT_STANDALONE", make_descriptor(Calendar::SHORT_STANDALONE));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "SUNDAY", make_descriptor(Calendar::SUNDAY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "THURSDAY", make_descriptor(Calendar::THURSDAY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "TUESDAY", make_descriptor(Calendar::TUESDAY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "UNDECIMBER", make_descriptor(Calendar::UNDECIMBER));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "WEDNESDAY", make_descriptor(Calendar::WEDNESDAY));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "WEEK_OF_MONTH", make_descriptor(Calendar::WEEK_OF_MONTH));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "WEEK_OF_YEAR", make_descriptor(Calendar::WEEK_OF_YEAR));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "YEAR", make_descriptor(Calendar::YEAR));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Calendar), "ZONE_OFFSET", make_descriptor(Calendar::ZONE_OFFSET));
    }

    static PyObject *t_Calendar_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Calendar::initializeClass, 1)))
        return NULL;
      return t_Calendar::wrap_Object(Calendar(((t_Calendar *) arg)->object.this$));
    }
    static PyObject *t_Calendar_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Calendar::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Calendar_add(t_Calendar *self, PyObject *args)
    {
      jint a0;
      jint a1;

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(self->object.add(a0, a1));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "add", args);
      return NULL;
    }

    static PyObject *t_Calendar_after(t_Calendar *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.after(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "after", arg);
      return NULL;
    }

    static PyObject *t_Calendar_before(t_Calendar *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.before(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "before", arg);
      return NULL;
    }

    static PyObject *t_Calendar_clear(t_Calendar *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          OBJ_CALL(self->object.clear());
          Py_RETURN_NONE;
        }
        break;
       case 1:
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.clear(a0));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "clear", args);
      return NULL;
    }

    static PyObject *t_Calendar_clone(t_Calendar *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.clone());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Calendar_compareTo(t_Calendar *self, PyObject *arg)
    {
      Calendar a0((jobject) NULL);
      jint result;

      if (!parseArg(arg, "k", Calendar::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.compareTo(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "compareTo", arg);
      return NULL;
    }

    static PyObject *t_Calendar_equals(t_Calendar *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Calendar), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_Calendar_get(t_Calendar *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "get", arg);
      return NULL;
    }

    static PyObject *t_Calendar_getActualMaximum(t_Calendar *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.getActualMaximum(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "getActualMaximum", arg);
      return NULL;
    }

    static PyObject *t_Calendar_getActualMinimum(t_Calendar *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.getActualMinimum(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "getActualMinimum", arg);
      return NULL;
    }

    static PyObject *t_Calendar_getAvailableCalendarTypes(PyTypeObject *type)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Calendar::getAvailableCalendarTypes());
      return ::java::util::t_Set::wrap_Object(result, ::java::lang::PY_TYPE(String));
    }

    static PyObject *t_Calendar_getAvailableLocales(PyTypeObject *type)
    {
      JArray< ::java::util::Locale > result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Calendar::getAvailableLocales());
      return JArray<jobject>(result.this$).wrap(::java::util::t_Locale::wrap_jobject);
    }

    static PyObject *t_Calendar_getCalendarType(t_Calendar *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getCalendarType());
      return j2p(result);
    }

    static PyObject *t_Calendar_getDisplayName(t_Calendar *self, PyObject *args)
    {
      jint a0;
      jint a1;
      ::java::util::Locale a2((jobject) NULL);
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, "IIk", ::java::util::Locale::initializeClass, &a0, &a1, &a2))
      {
        OBJ_CALL(result = self->object.getDisplayName(a0, a1, a2));
        return j2p(result);
      }

      PyErr_SetArgsError((PyObject *) self, "getDisplayName", args);
      return NULL;
    }

    static PyObject *t_Calendar_getDisplayNames(t_Calendar *self, PyObject *args)
    {
      jint a0;
      jint a1;
      ::java::util::Locale a2((jobject) NULL);
      ::java::util::Map result((jobject) NULL);

      if (!parseArgs(args, "IIk", ::java::util::Locale::initializeClass, &a0, &a1, &a2))
      {
        OBJ_CALL(result = self->object.getDisplayNames(a0, a1, a2));
        return ::java::util::t_Map::wrap_Object(result, ::java::lang::PY_TYPE(String), ::java::lang::PY_TYPE(Integer));
      }

      PyErr_SetArgsError((PyObject *) self, "getDisplayNames", args);
      return NULL;
    }

    static PyObject *t_Calendar_getFirstDayOfWeek(t_Calendar *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getFirstDayOfWeek());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Calendar_getGreatestMinimum(t_Calendar *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.getGreatestMinimum(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "getGreatestMinimum", arg);
      return NULL;
    }

    static PyObject *t_Calendar_getInstance(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          Calendar result((jobject) NULL);
          OBJ_CALL(result = ::java::util::Calendar::getInstance());
          return t_Calendar::wrap_Object(result);
        }
        break;
       case 1:
        {
          ::java::util::Locale a0((jobject) NULL);
          Calendar result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::util::Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = ::java::util::Calendar::getInstance(a0));
            return t_Calendar::wrap_Object(result);
          }
        }
        {
          ::java::util::TimeZone a0((jobject) NULL);
          Calendar result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::util::TimeZone::initializeClass, &a0))
          {
            OBJ_CALL(result = ::java::util::Calendar::getInstance(a0));
            return t_Calendar::wrap_Object(result);
          }
        }
        break;
       case 2:
        {
          ::java::util::TimeZone a0((jobject) NULL);
          ::java::util::Locale a1((jobject) NULL);
          Calendar result((jobject) NULL);

          if (!parseArgs(args, "kk", ::java::util::TimeZone::initializeClass, ::java::util::Locale::initializeClass, &a0, &a1))
          {
            OBJ_CALL(result = ::java::util::Calendar::getInstance(a0, a1));
            return t_Calendar::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError(type, "getInstance", args);
      return NULL;
    }

    static PyObject *t_Calendar_getLeastMaximum(t_Calendar *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.getLeastMaximum(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "getLeastMaximum", arg);
      return NULL;
    }

    static PyObject *t_Calendar_getMaximum(t_Calendar *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.getMaximum(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "getMaximum", arg);
      return NULL;
    }

    static PyObject *t_Calendar_getMinimalDaysInFirstWeek(t_Calendar *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getMinimalDaysInFirstWeek());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Calendar_getMinimum(t_Calendar *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.getMinimum(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "getMinimum", arg);
      return NULL;
    }

    static PyObject *t_Calendar_getTime(t_Calendar *self)
    {
      ::java::util::Date result((jobject) NULL);
      OBJ_CALL(result = self->object.getTime());
      return ::java::util::t_Date::wrap_Object(result);
    }

    static PyObject *t_Calendar_getTimeInMillis(t_Calendar *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.getTimeInMillis());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_Calendar_getTimeZone(t_Calendar *self)
    {
      ::java::util::TimeZone result((jobject) NULL);
      OBJ_CALL(result = self->object.getTimeZone());
      return ::java::util::t_TimeZone::wrap_Object(result);
    }

    static PyObject *t_Calendar_getWeekYear(t_Calendar *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getWeekYear());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Calendar_getWeeksInWeekYear(t_Calendar *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getWeeksInWeekYear());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_Calendar_hashCode(t_Calendar *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Calendar), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_Calendar_isLenient(t_Calendar *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isLenient());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_Calendar_isSet(t_Calendar *self, PyObject *arg)
    {
      jint a0;
      jboolean result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.isSet(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "isSet", arg);
      return NULL;
    }

    static PyObject *t_Calendar_isWeekDateSupported(t_Calendar *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isWeekDateSupported());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_Calendar_roll(t_Calendar *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          jint a0;
          jboolean a1;

          if (!parseArgs(args, "IZ", &a0, &a1))
          {
            OBJ_CALL(self->object.roll(a0, a1));
            Py_RETURN_NONE;
          }
        }
        {
          jint a0;
          jint a1;

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(self->object.roll(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "roll", args);
      return NULL;
    }

    static PyObject *t_Calendar_set(t_Calendar *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          jint a0;
          jint a1;

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(self->object.set(a0, a1));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          jint a0;
          jint a1;
          jint a2;

          if (!parseArgs(args, "III", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.set(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
        break;
       case 5:
        {
          jint a0;
          jint a1;
          jint a2;
          jint a3;
          jint a4;

          if (!parseArgs(args, "IIIII", &a0, &a1, &a2, &a3, &a4))
          {
            OBJ_CALL(self->object.set(a0, a1, a2, a3, a4));
            Py_RETURN_NONE;
          }
        }
        break;
       case 6:
        {
          jint a0;
          jint a1;
          jint a2;
          jint a3;
          jint a4;
          jint a5;

          if (!parseArgs(args, "IIIIII", &a0, &a1, &a2, &a3, &a4, &a5))
          {
            OBJ_CALL(self->object.set(a0, a1, a2, a3, a4, a5));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "set", args);
      return NULL;
    }

    static PyObject *t_Calendar_setFirstDayOfWeek(t_Calendar *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setFirstDayOfWeek(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setFirstDayOfWeek", arg);
      return NULL;
    }

    static PyObject *t_Calendar_setLenient(t_Calendar *self, PyObject *arg)
    {
      jboolean a0;

      if (!parseArg(arg, "Z", &a0))
      {
        OBJ_CALL(self->object.setLenient(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setLenient", arg);
      return NULL;
    }

    static PyObject *t_Calendar_setMinimalDaysInFirstWeek(t_Calendar *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setMinimalDaysInFirstWeek(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setMinimalDaysInFirstWeek", arg);
      return NULL;
    }

    static PyObject *t_Calendar_setTime(t_Calendar *self, PyObject *arg)
    {
      ::java::util::Date a0((jobject) NULL);

      if (!parseArg(arg, "k", ::java::util::Date::initializeClass, &a0))
      {
        OBJ_CALL(self->object.setTime(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setTime", arg);
      return NULL;
    }

    static PyObject *t_Calendar_setTimeInMillis(t_Calendar *self, PyObject *arg)
    {
      jlong a0;

      if (!parseArg(arg, "J", &a0))
      {
        OBJ_CALL(self->object.setTimeInMillis(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setTimeInMillis", arg);
      return NULL;
    }

    static PyObject *t_Calendar_setTimeZone(t_Calendar *self, PyObject *arg)
    {
      ::java::util::TimeZone a0((jobject) NULL);

      if (!parseArg(arg, "k", ::java::util::TimeZone::initializeClass, &a0))
      {
        OBJ_CALL(self->object.setTimeZone(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setTimeZone", arg);
      return NULL;
    }

    static PyObject *t_Calendar_setWeekDate(t_Calendar *self, PyObject *args)
    {
      jint a0;
      jint a1;
      jint a2;

      if (!parseArgs(args, "III", &a0, &a1, &a2))
      {
        OBJ_CALL(self->object.setWeekDate(a0, a1, a2));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setWeekDate", args);
      return NULL;
    }

    static PyObject *t_Calendar_toString(t_Calendar *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(Calendar), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_Calendar_get__availableCalendarTypes(t_Calendar *self, void *data)
    {
      ::java::util::Set value((jobject) NULL);
      OBJ_CALL(value = self->object.getAvailableCalendarTypes());
      return ::java::util::t_Set::wrap_Object(value);
    }

    static PyObject *t_Calendar_get__availableLocales(t_Calendar *self, void *data)
    {
      JArray< ::java::util::Locale > value((jobject) NULL);
      OBJ_CALL(value = self->object.getAvailableLocales());
      return JArray<jobject>(value.this$).wrap(::java::util::t_Locale::wrap_jobject);
    }

    static PyObject *t_Calendar_get__calendarType(t_Calendar *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getCalendarType());
      return j2p(value);
    }

    static PyObject *t_Calendar_get__firstDayOfWeek(t_Calendar *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getFirstDayOfWeek());
      return PyLong_FromLong((long) value);
    }
    static int t_Calendar_set__firstDayOfWeek(t_Calendar *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setFirstDayOfWeek(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "firstDayOfWeek", arg);
      return -1;
    }

    static PyObject *t_Calendar_get__instance(t_Calendar *self, void *data)
    {
      Calendar value((jobject) NULL);
      OBJ_CALL(value = self->object.getInstance());
      return t_Calendar::wrap_Object(value);
    }

    static PyObject *t_Calendar_get__lenient(t_Calendar *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isLenient());
      Py_RETURN_BOOL(value);
    }
    static int t_Calendar_set__lenient(t_Calendar *self, PyObject *arg, void *data)
    {
      {
        jboolean value;
        if (!parseArg(arg, "Z", &value))
        {
          INT_CALL(self->object.setLenient(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "lenient", arg);
      return -1;
    }

    static PyObject *t_Calendar_get__minimalDaysInFirstWeek(t_Calendar *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getMinimalDaysInFirstWeek());
      return PyLong_FromLong((long) value);
    }
    static int t_Calendar_set__minimalDaysInFirstWeek(t_Calendar *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setMinimalDaysInFirstWeek(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "minimalDaysInFirstWeek", arg);
      return -1;
    }

    static PyObject *t_Calendar_get__time(t_Calendar *self, void *data)
    {
      ::java::util::Date value((jobject) NULL);
      OBJ_CALL(value = self->object.getTime());
      return ::java::util::t_Date::wrap_Object(value);
    }
    static int t_Calendar_set__time(t_Calendar *self, PyObject *arg, void *data)
    {
      {
        ::java::util::Date value((jobject) NULL);
        if (!parseArg(arg, "k", ::java::util::Date::initializeClass, &value))
        {
          INT_CALL(self->object.setTime(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "time", arg);
      return -1;
    }

    static PyObject *t_Calendar_get__timeInMillis(t_Calendar *self, void *data)
    {
      jlong value;
      OBJ_CALL(value = self->object.getTimeInMillis());
      return PyLong_FromLongLong((PY_LONG_LONG) value);
    }
    static int t_Calendar_set__timeInMillis(t_Calendar *self, PyObject *arg, void *data)
    {
      {
        jlong value;
        if (!parseArg(arg, "J", &value))
        {
          INT_CALL(self->object.setTimeInMillis(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "timeInMillis", arg);
      return -1;
    }

    static PyObject *t_Calendar_get__timeZone(t_Calendar *self, void *data)
    {
      ::java::util::TimeZone value((jobject) NULL);
      OBJ_CALL(value = self->object.getTimeZone());
      return ::java::util::t_TimeZone::wrap_Object(value);
    }
    static int t_Calendar_set__timeZone(t_Calendar *self, PyObject *arg, void *data)
    {
      {
        ::java::util::TimeZone value((jobject) NULL);
        if (!parseArg(arg, "k", ::java::util::TimeZone::initializeClass, &value))
        {
          INT_CALL(self->object.setTimeZone(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "timeZone", arg);
      return -1;
    }

    static PyObject *t_Calendar_get__weekDateSupported(t_Calendar *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isWeekDateSupported());
      Py_RETURN_BOOL(value);
    }

    static PyObject *t_Calendar_get__weekYear(t_Calendar *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getWeekYear());
      return PyLong_FromLong((long) value);
    }

    static PyObject *t_Calendar_get__weeksInWeekYear(t_Calendar *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getWeeksInWeekYear());
      return PyLong_FromLong((long) value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/AbstractSequentialList.h"
#include "java/util/Collection.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/Iterator.h"
#include "java/util/ListIterator.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *AbstractSequentialList::class$ = NULL;
    jmethodID *AbstractSequentialList::mids$ = NULL;
    bool AbstractSequentialList::live$ = false;

    jclass AbstractSequentialList::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/AbstractSequentialList");

        mids$ = new jmethodID[max_mid];
        mids$[mid_add_cf6732d7dfcfc293] = env->getMethodID(cls, "add", "(ILjava/lang/Object;)V");
        mids$[mid_addAll_8980636bfaaa897b] = env->getMethodID(cls, "addAll", "(ILjava/util/Collection;)Z");
        mids$[mid_get_b15c79acb15c2870] = env->getMethodID(cls, "get", "(I)Ljava/lang/Object;");
        mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
        mids$[mid_listIterator_8204cc66da390272] = env->getMethodID(cls, "listIterator", "(I)Ljava/util/ListIterator;");
        mids$[mid_remove_b15c79acb15c2870] = env->getMethodID(cls, "remove", "(I)Ljava/lang/Object;");
        mids$[mid_set_55e2638f354bbf61] = env->getMethodID(cls, "set", "(ILjava/lang/Object;)Ljava/lang/Object;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void AbstractSequentialList::add(jint a0, const ::java::lang::Object & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_add_cf6732d7dfcfc293], a0, a1.this$);
    }

    jboolean AbstractSequentialList::addAll(jint a0, const ::java::util::Collection & a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_8980636bfaaa897b], a0, a1.this$);
    }

    ::java::lang::Object AbstractSequentialList::get(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_b15c79acb15c2870], a0));
    }

    ::java::util::Iterator AbstractSequentialList::iterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
    }

    ::java::util::ListIterator AbstractSequentialList::listIterator(jint a0) const
    {
      return ::java::util::ListIterator(env->callObjectMethod(this$, mids$[mid_listIterator_8204cc66da390272], a0));
    }

    ::java::lang::Object AbstractSequentialList::remove(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_b15c79acb15c2870], a0));
    }

    ::java::lang::Object AbstractSequentialList::set(jint a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_set_55e2638f354bbf61], a0, a1.this$));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_AbstractSequentialList_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_AbstractSequentialList_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_AbstractSequentialList_of_(t_AbstractSequentialList *self, PyObject *args);
    static PyObject *t_AbstractSequentialList_add(t_AbstractSequentialList *self, PyObject *args);
    static PyObject *t_AbstractSequentialList_addAll(t_AbstractSequentialList *self, PyObject *args);
    static PyObject *t_AbstractSequentialList_get(t_AbstractSequentialList *self, PyObject *args);
    static PyObject *t_AbstractSequentialList_iterator(t_AbstractSequentialList *self, PyObject *args);
    static PyObject *t_AbstractSequentialList_listIterator(t_AbstractSequentialList *self, PyObject *args);
    static PyObject *t_AbstractSequentialList_remove(t_AbstractSequentialList *self, PyObject *args);
    static PyObject *t_AbstractSequentialList_set(t_AbstractSequentialList *self, PyObject *args);
    static PyObject *t_AbstractSequentialList_get__parameters_(t_AbstractSequentialList *self, void *data);
    static PyGetSetDef t_AbstractSequentialList__fields_[] = {
      DECLARE_GET_FIELD(t_AbstractSequentialList, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_AbstractSequentialList__methods_[] = {
      DECLARE_METHOD(t_AbstractSequentialList, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_AbstractSequentialList, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_AbstractSequentialList, of_, METH_VARARGS),
      DECLARE_METHOD(t_AbstractSequentialList, add, METH_VARARGS),
      DECLARE_METHOD(t_AbstractSequentialList, addAll, METH_VARARGS),
      DECLARE_METHOD(t_AbstractSequentialList, get, METH_VARARGS),
      DECLARE_METHOD(t_AbstractSequentialList, iterator, METH_VARARGS),
      DECLARE_METHOD(t_AbstractSequentialList, listIterator, METH_VARARGS),
      DECLARE_METHOD(t_AbstractSequentialList, remove, METH_VARARGS),
      DECLARE_METHOD(t_AbstractSequentialList, set, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(AbstractSequentialList)[] = {
      { Py_tp_methods, t_AbstractSequentialList__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_AbstractSequentialList__fields_ },
      { Py_tp_iter, (void *) ((PyObject *(*)(t_AbstractSequentialList *)) get_generic_iterator< t_AbstractSequentialList >) },
      { Py_tp_iternext, (void *) 0 },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(AbstractSequentialList)[] = {
      &PY_TYPE_DEF(::java::util::AbstractList),
      NULL
    };

    DEFINE_TYPE(AbstractSequentialList, t_AbstractSequentialList, AbstractSequentialList);
    PyObject *t_AbstractSequentialList::wrap_Object(const AbstractSequentialList& object, PyTypeObject *p0)
    {
      PyObject *obj = t_AbstractSequentialList::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_AbstractSequentialList *self = (t_AbstractSequentialList *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_AbstractSequentialList::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_AbstractSequentialList::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_AbstractSequentialList *self = (t_AbstractSequentialList *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_AbstractSequentialList::install(PyObject *module)
    {
      installType(&PY_TYPE(AbstractSequentialList), &PY_TYPE_DEF(AbstractSequentialList), module, "AbstractSequentialList", 0);
    }

    void t_AbstractSequentialList::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractSequentialList), "class_", make_descriptor(AbstractSequentialList::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractSequentialList), "wrapfn_", make_descriptor(t_AbstractSequentialList::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractSequentialList), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_AbstractSequentialList_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, AbstractSequentialList::initializeClass, 1)))
        return NULL;
      return t_AbstractSequentialList::wrap_Object(AbstractSequentialList(((t_AbstractSequentialList *) arg)->object.this$));
    }
    static PyObject *t_AbstractSequentialList_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, AbstractSequentialList::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_AbstractSequentialList_of_(t_AbstractSequentialList *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_AbstractSequentialList_add(t_AbstractSequentialList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object a1((jobject) NULL);

      if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
      {
        OBJ_CALL(self->object.add(a0, a1));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(AbstractSequentialList), (PyObject *) self, "add", args, 2);
    }

    static PyObject *t_AbstractSequentialList_addAll(t_AbstractSequentialList *self, PyObject *args)
    {
      jint a0;
      ::java::util::Collection a1((jobject) NULL);
      PyTypeObject **p1;
      jboolean result;

      if (!parseArgs(args, "IK", ::java::util::Collection::initializeClass, &a0, &a1, &p1, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.addAll(a0, a1));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(AbstractSequentialList), (PyObject *) self, "addAll", args, 2);
    }

    static PyObject *t_AbstractSequentialList_get(t_AbstractSequentialList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(AbstractSequentialList), (PyObject *) self, "get", args, 2);
    }

    static PyObject *t_AbstractSequentialList_iterator(t_AbstractSequentialList *self, PyObject *args)
    {
      ::java::util::Iterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.iterator());
        return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(AbstractSequentialList), (PyObject *) self, "iterator", args, 2);
    }

    static PyObject *t_AbstractSequentialList_listIterator(t_AbstractSequentialList *self, PyObject *args)
    {
      jint a0;
      ::java::util::ListIterator result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.listIterator(a0));
        return ::java::util::t_ListIterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(AbstractSequentialList), (PyObject *) self, "listIterator", args, 2);
    }

    static PyObject *t_AbstractSequentialList_remove(t_AbstractSequentialList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.remove(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(AbstractSequentialList), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_AbstractSequentialList_set(t_AbstractSequentialList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
      {
        OBJ_CALL(result = self->object.set(a0, a1));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(AbstractSequentialList), (PyObject *) self, "set", args, 2);
    }
    static PyObject *t_AbstractSequentialList_get__parameters_(t_AbstractSequentialList *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/IntPredicate.h"
#include "java/util/function/IntPredicate.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *IntPredicate::class$ = NULL;
      jmethodID *IntPredicate::mids$ = NULL;
      bool IntPredicate::live$ = false;

      jclass IntPredicate::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/IntPredicate");

          mids$ = new jmethodID[max_mid];
          mids$[mid_and_d2b2daee352ef5df] = env->getMethodID(cls, "and", "(Ljava/util/function/IntPredicate;)Ljava/util/function/IntPredicate;");
          mids$[mid_negate_5e8762d763b30087] = env->getMethodID(cls, "negate", "()Ljava/util/function/IntPredicate;");
          mids$[mid_or_d2b2daee352ef5df] = env->getMethodID(cls, "or", "(Ljava/util/function/IntPredicate;)Ljava/util/function/IntPredicate;");
          mids$[mid_test_a1d30e1ee40c89a2] = env->getMethodID(cls, "test", "(I)Z");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      IntPredicate IntPredicate::and$(const IntPredicate & a0) const
      {
        return IntPredicate(env->callObjectMethod(this$, mids$[mid_and_d2b2daee352ef5df], a0.this$));
      }

      IntPredicate IntPredicate::negate() const
      {
        return IntPredicate(env->callObjectMethod(this$, mids$[mid_negate_5e8762d763b30087]));
      }

      IntPredicate IntPredicate::or$(const IntPredicate & a0) const
      {
        return IntPredicate(env->callObjectMethod(this$, mids$[mid_or_d2b2daee352ef5df], a0.this$));
      }

      jboolean IntPredicate::test(jint a0) const
      {
        return env->callBooleanMethod(this$, mids$[mid_test_a1d30e1ee40c89a2], a0);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_IntPredicate_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntPredicate_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntPredicate_and(t_IntPredicate *self, PyObject *arg);
      static PyObject *t_IntPredicate_negate(t_IntPredicate *self);
      static PyObject *t_IntPredicate_or(t_IntPredicate *self, PyObject *arg);
      static PyObject *t_IntPredicate_test(t_IntPredicate *self, PyObject *arg);

      static PyMethodDef t_IntPredicate__methods_[] = {
        DECLARE_METHOD(t_IntPredicate, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntPredicate, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntPredicate, and, METH_O),
        DECLARE_METHOD(t_IntPredicate, negate, METH_NOARGS),
        DECLARE_METHOD(t_IntPredicate, or, METH_O),
        DECLARE_METHOD(t_IntPredicate, test, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(IntPredicate)[] = {
        { Py_tp_methods, t_IntPredicate__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(IntPredicate)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(IntPredicate, t_IntPredicate, IntPredicate);

      void t_IntPredicate::install(PyObject *module)
      {
        installType(&PY_TYPE(IntPredicate), &PY_TYPE_DEF(IntPredicate), module, "IntPredicate", 0);
      }

      void t_IntPredicate::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntPredicate), "class_", make_descriptor(IntPredicate::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntPredicate), "wrapfn_", make_descriptor(t_IntPredicate::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntPredicate), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_IntPredicate_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, IntPredicate::initializeClass, 1)))
          return NULL;
        return t_IntPredicate::wrap_Object(IntPredicate(((t_IntPredicate *) arg)->object.this$));
      }
      static PyObject *t_IntPredicate_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, IntPredicate::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_IntPredicate_and(t_IntPredicate *self, PyObject *arg)
      {
        IntPredicate a0((jobject) NULL);
        IntPredicate result((jobject) NULL);

        if (!parseArg(arg, "k", IntPredicate::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.and$(a0));
          return t_IntPredicate::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "and", arg);
        return NULL;
      }

      static PyObject *t_IntPredicate_negate(t_IntPredicate *self)
      {
        IntPredicate result((jobject) NULL);
        OBJ_CALL(result = self->object.negate());
        return t_IntPredicate::wrap_Object(result);
      }

      static PyObject *t_IntPredicate_or(t_IntPredicate *self, PyObject *arg)
      {
        IntPredicate a0((jobject) NULL);
        IntPredicate result((jobject) NULL);

        if (!parseArg(arg, "k", IntPredicate::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.or$(a0));
          return t_IntPredicate::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "or", arg);
        return NULL;
      }

      static PyObject *t_IntPredicate_test(t_IntPredicate *self, PyObject *arg)
      {
        jint a0;
        jboolean result;

        if (!parseArg(arg, "I", &a0))
        {
          OBJ_CALL(result = self->object.test(a0));
          Py_RETURN_BOOL(result);
        }

        PyErr_SetArgsError((PyObject *) self, "test", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/WatchService.h"
#include "java/lang/Class.h"
#include "java/nio/file/WatchKey.h"
#include "java/io/IOException.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/lang/InterruptedException.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *WatchService::class$ = NULL;
      jmethodID *WatchService::mids$ = NULL;
      bool WatchService::live$ = false;

      jclass WatchService::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/WatchService");

          mids$ = new jmethodID[max_mid];
          mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");
          mids$[mid_poll_62bbb59ce8b4d37f] = env->getMethodID(cls, "poll", "()Ljava/nio/file/WatchKey;");
          mids$[mid_poll_99c466854a536369] = env->getMethodID(cls, "poll", "(JLjava/util/concurrent/TimeUnit;)Ljava/nio/file/WatchKey;");
          mids$[mid_take_62bbb59ce8b4d37f] = env->getMethodID(cls, "take", "()Ljava/nio/file/WatchKey;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      void WatchService::close() const
      {
        env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
      }

      ::java::nio::file::WatchKey WatchService::poll() const
      {
        return ::java::nio::file::WatchKey(env->callObjectMethod(this$, mids$[mid_poll_62bbb59ce8b4d37f]));
      }

      ::java::nio::file::WatchKey WatchService::poll(jlong a0, const ::java::util::concurrent::TimeUnit & a1) const
      {
        return ::java::nio::file::WatchKey(env->callObjectMethod(this$, mids$[mid_poll_99c466854a536369], a0, a1.this$));
      }

      ::java::nio::file::WatchKey WatchService::take() const
      {
        return ::java::nio::file::WatchKey(env->callObjectMethod(this$, mids$[mid_take_62bbb59ce8b4d37f]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_WatchService_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchService_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchService_close(t_WatchService *self, PyObject *args);
      static PyObject *t_WatchService_poll(t_WatchService *self, PyObject *args);
      static PyObject *t_WatchService_take(t_WatchService *self);

      static PyMethodDef t_WatchService__methods_[] = {
        DECLARE_METHOD(t_WatchService, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchService, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchService, close, METH_VARARGS),
        DECLARE_METHOD(t_WatchService, poll, METH_VARARGS),
        DECLARE_METHOD(t_WatchService, take, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(WatchService)[] = {
        { Py_tp_methods, t_WatchService__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(WatchService)[] = {
        &PY_TYPE_DEF(::java::io::Closeable),
        NULL
      };

      DEFINE_TYPE(WatchService, t_WatchService, WatchService);

      void t_WatchService::install(PyObject *module)
      {
        installType(&PY_TYPE(WatchService), &PY_TYPE_DEF(WatchService), module, "WatchService", 0);
      }

      void t_WatchService::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchService), "class_", make_descriptor(WatchService::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchService), "wrapfn_", make_descriptor(t_WatchService::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchService), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_WatchService_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, WatchService::initializeClass, 1)))
          return NULL;
        return t_WatchService::wrap_Object(WatchService(((t_WatchService *) arg)->object.this$));
      }
      static PyObject *t_WatchService_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, WatchService::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_WatchService_close(t_WatchService *self, PyObject *args)
      {

        if (!parseArgs(args, ""))
        {
          OBJ_CALL(self->object.close());
          Py_RETURN_NONE;
        }

        return callSuper(PY_TYPE(WatchService), (PyObject *) self, "close", args, 2);
      }

      static PyObject *t_WatchService_poll(t_WatchService *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            ::java::nio::file::WatchKey result((jobject) NULL);
            OBJ_CALL(result = self->object.poll());
            return ::java::nio::file::t_WatchKey::wrap_Object(result);
          }
          break;
         case 2:
          {
            jlong a0;
            ::java::util::concurrent::TimeUnit a1((jobject) NULL);
            PyTypeObject **p1;
            ::java::nio::file::WatchKey result((jobject) NULL);

            if (!parseArgs(args, "JK", ::java::util::concurrent::TimeUnit::initializeClass, &a0, &a1, &p1, ::java::util::concurrent::t_TimeUnit::parameters_))
            {
              OBJ_CALL(result = self->object.poll(a0, a1));
              return ::java::nio::file::t_WatchKey::wrap_Object(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "poll", args);
        return NULL;
      }

      static PyObject *t_WatchService_take(t_WatchService *self)
      {
        ::java::nio::file::WatchKey result((jobject) NULL);
        OBJ_CALL(result = self->object.take());
        return ::java::nio::file::t_WatchKey::wrap_Object(result);
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/FilterOutputStream.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *FilterOutputStream::class$ = NULL;
    jmethodID *FilterOutputStream::mids$ = NULL;
    bool FilterOutputStream::live$ = false;

    jclass FilterOutputStream::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/FilterOutputStream");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_02fcdace254a9894] = env->getMethodID(cls, "<init>", "(Ljava/io/OutputStream;)V");
        mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");
        mids$[mid_flush_f2cc1bce94666404] = env->getMethodID(cls, "flush", "()V");
        mids$[mid_write_9ffdf271836656c4] = env->getMethodID(cls, "write", "([B)V");
        mids$[mid_write_040c4cd0390c5aff] = env->getMethodID(cls, "write", "(I)V");
        mids$[mid_write_43fdd39c09bb2fad] = env->getMethodID(cls, "write", "([BII)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    FilterOutputStream::FilterOutputStream(const ::java::io::OutputStream & a0) : ::java::io::OutputStream(env->newObject(initializeClass, &mids$, mid_init$_02fcdace254a9894, a0.this$)) {}

    void FilterOutputStream::close() const
    {
      env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
    }

    void FilterOutputStream::flush() const
    {
      env->callVoidMethod(this$, mids$[mid_flush_f2cc1bce94666404]);
    }

    void FilterOutputStream::write(const JArray< jbyte > & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_write_9ffdf271836656c4], a0.this$);
    }

    void FilterOutputStream::write(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_write_040c4cd0390c5aff], a0);
    }

    void FilterOutputStream::write(const JArray< jbyte > & a0, jint a1, jint a2) const
    {
      env->callVoidMethod(this$, mids$[mid_write_43fdd39c09bb2fad], a0.this$, a1, a2);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_FilterOutputStream_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_FilterOutputStream_instance_(PyTypeObject *type, PyObject *arg);
    static int t_FilterOutputStream_init_(t_FilterOutputStream *self, PyObject *args, PyObject *kwds);
    static PyObject *t_FilterOutputStream_close(t_FilterOutputStream *self, PyObject *args);
    static PyObject *t_FilterOutputStream_flush(t_FilterOutputStream *self, PyObject *args);
    static PyObject *t_FilterOutputStream_write(t_FilterOutputStream *self, PyObject *args);

    static PyMethodDef t_FilterOutputStream__methods_[] = {
      DECLARE_METHOD(t_FilterOutputStream, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_FilterOutputStream, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_FilterOutputStream, close, METH_VARARGS),
      DECLARE_METHOD(t_FilterOutputStream, flush, METH_VARARGS),
      DECLARE_METHOD(t_FilterOutputStream, write, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(FilterOutputStream)[] = {
      { Py_tp_methods, t_FilterOutputStream__methods_ },
      { Py_tp_init, (void *) t_FilterOutputStream_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(FilterOutputStream)[] = {
      &PY_TYPE_DEF(::java::io::OutputStream),
      NULL
    };

    DEFINE_TYPE(FilterOutputStream, t_FilterOutputStream, FilterOutputStream);

    void t_FilterOutputStream::install(PyObject *module)
    {
      installType(&PY_TYPE(FilterOutputStream), &PY_TYPE_DEF(FilterOutputStream), module, "FilterOutputStream", 0);
    }

    void t_FilterOutputStream::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(FilterOutputStream), "class_", make_descriptor(FilterOutputStream::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FilterOutputStream), "wrapfn_", make_descriptor(t_FilterOutputStream::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FilterOutputStream), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_FilterOutputStream_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, FilterOutputStream::initializeClass, 1)))
        return NULL;
      return t_FilterOutputStream::wrap_Object(FilterOutputStream(((t_FilterOutputStream *) arg)->object.this$));
    }
    static PyObject *t_FilterOutputStream_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, FilterOutputStream::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_FilterOutputStream_init_(t_FilterOutputStream *self, PyObject *args, PyObject *kwds)
    {
      ::java::io::OutputStream a0((jobject) NULL);
      FilterOutputStream object((jobject) NULL);

      if (!parseArgs(args, "k", ::java::io::OutputStream::initializeClass, &a0))
      {
        INT_CALL(object = FilterOutputStream(a0));
        self->object = object;
      }
      else
      {
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_FilterOutputStream_close(t_FilterOutputStream *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.close());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(FilterOutputStream), (PyObject *) self, "close", args, 2);
    }

    static PyObject *t_FilterOutputStream_flush(t_FilterOutputStream *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.flush());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(FilterOutputStream), (PyObject *) self, "flush", args, 2);
    }

    static PyObject *t_FilterOutputStream_write(t_FilterOutputStream *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          JArray< jbyte > a0((jobject) NULL);

          if (!parseArgs(args, "[B", &a0))
          {
            OBJ_CALL(self->object.write(a0));
            Py_RETURN_NONE;
          }
        }
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.write(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          JArray< jbyte > a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "[BII", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.write(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(FilterOutputStream), (PyObject *) self, "write", args, 2);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/FileSystem.h"
#include "java/nio/file/FileStore.h"
#include "java/lang/Class.h"
#include "java/lang/Iterable.h"
#include "java/io/Closeable.h"
#include "java/nio/file/PathMatcher.h"
#include "java/lang/String.h"
#include "java/util/Set.h"
#include "java/io/IOException.h"
#include "java/nio/file/Path.h"
#include "java/nio/file/WatchService.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *FileSystem::class$ = NULL;
      jmethodID *FileSystem::mids$ = NULL;
      bool FileSystem::live$ = false;

      jclass FileSystem::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/FileSystem");

          mids$ = new jmethodID[max_mid];
          mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");
          mids$[mid_getFileStores_7a21c115c1b038aa] = env->getMethodID(cls, "getFileStores", "()Ljava/lang/Iterable;");
          mids$[mid_getPath_561e2076b428372b] = env->getMethodID(cls, "getPath", "(Ljava/lang/String;[Ljava/lang/String;)Ljava/nio/file/Path;");
          mids$[mid_getPathMatcher_6fc8f7e1b59b4555] = env->getMethodID(cls, "getPathMatcher", "(Ljava/lang/String;)Ljava/nio/file/PathMatcher;");
          mids$[mid_getRootDirectories_7a21c115c1b038aa] = env->getMethodID(cls, "getRootDirectories", "()Ljava/lang/Iterable;");
          mids$[mid_getSeparator_db9b55ba01e03e4b] = env->getMethodID(cls, "getSeparator", "()Ljava/lang/String;");
          mids$[mid_isOpen_8454bd5aa23fd11e] = env->getMethodID(cls, "isOpen", "()Z");
          mids$[mid_isReadOnly_8454bd5aa23fd11e] = env->getMethodID(cls, "isReadOnly", "()Z");
          mids$[mid_newWatchService_2928d4b3aa01c80e] = env->getMethodID(cls, "newWatchService", "()Ljava/nio/file/WatchService;");
          mids$[mid_supportedFileAttributeViews_7dcf4034c6d1a92a] = env->getMethodID(cls, "supportedFileAttributeViews", "()Ljava/util/Set;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      void FileSystem::close() const
      {
        env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
      }

      ::java::lang::Iterable FileSystem::getFileStores() const
      {
        return ::java::lang::Iterable(env->callObjectMethod(this$, mids$[mid_getFileStores_7a21c115c1b038aa]));
      }

      ::java::nio::file::Path FileSystem::getPath(const ::java::lang::String & a0, const JArray< ::java::lang::String > & a1) const
      {
        return ::java::nio::file::Path(env->callObjectMethod(this$, mids$[mid_getPath_561e2076b428372b], a0.this$, a1.this$));
      }

      ::java::nio::file::PathMatcher FileSystem::getPathMatcher(const ::java::lang::String & a0) const
      {
        return ::java::nio::file::PathMatcher(env->callObjectMethod(this$, mids$[mid_getPathMatcher_6fc8f7e1b59b4555], a0.this$));
      }

      ::java::lang::Iterable FileSystem::getRootDirectories() const
      {
        return ::java::lang::Iterable(env->callObjectMethod(this$, mids$[mid_getRootDirectories_7a21c115c1b038aa]));
      }

      ::java::lang::String FileSystem::getSeparator() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSeparator_db9b55ba01e03e4b]));
      }

      jboolean FileSystem::isOpen() const
      {
        return env->callBooleanMethod(this$, mids$[mid_isOpen_8454bd5aa23fd11e]);
      }

      jboolean FileSystem::isReadOnly() const
      {
        return env->callBooleanMethod(this$, mids$[mid_isReadOnly_8454bd5aa23fd11e]);
      }

      ::java::nio::file::WatchService FileSystem::newWatchService() const
      {
        return ::java::nio::file::WatchService(env->callObjectMethod(this$, mids$[mid_newWatchService_2928d4b3aa01c80e]));
      }

      ::java::util::Set FileSystem::supportedFileAttributeViews() const
      {
        return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_supportedFileAttributeViews_7dcf4034c6d1a92a]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_FileSystem_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileSystem_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileSystem_close(t_FileSystem *self);
      static PyObject *t_FileSystem_getFileStores(t_FileSystem *self);
      static PyObject *t_FileSystem_getPath(t_FileSystem *self, PyObject *args);
      static PyObject *t_FileSystem_getPathMatcher(t_FileSystem *self, PyObject *arg);
      static PyObject *t_FileSystem_getRootDirectories(t_FileSystem *self);
      static PyObject *t_FileSystem_getSeparator(t_FileSystem *self);
      static PyObject *t_FileSystem_isOpen(t_FileSystem *self);
      static PyObject *t_FileSystem_isReadOnly(t_FileSystem *self);
      static PyObject *t_FileSystem_newWatchService(t_FileSystem *self);
      static PyObject *t_FileSystem_supportedFileAttributeViews(t_FileSystem *self);
      static PyObject *t_FileSystem_get__fileStores(t_FileSystem *self, void *data);
      static PyObject *t_FileSystem_get__open(t_FileSystem *self, void *data);
      static PyObject *t_FileSystem_get__readOnly(t_FileSystem *self, void *data);
      static PyObject *t_FileSystem_get__rootDirectories(t_FileSystem *self, void *data);
      static PyObject *t_FileSystem_get__separator(t_FileSystem *self, void *data);
      static PyGetSetDef t_FileSystem__fields_[] = {
        DECLARE_GET_FIELD(t_FileSystem, fileStores),
        DECLARE_GET_FIELD(t_FileSystem, open),
        DECLARE_GET_FIELD(t_FileSystem, readOnly),
        DECLARE_GET_FIELD(t_FileSystem, rootDirectories),
        DECLARE_GET_FIELD(t_FileSystem, separator),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_FileSystem__methods_[] = {
        DECLARE_METHOD(t_FileSystem, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileSystem, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileSystem, close, METH_NOARGS),
        DECLARE_METHOD(t_FileSystem, getFileStores, METH_NOARGS),
        DECLARE_METHOD(t_FileSystem, getPath, METH_VARARGS),
        DECLARE_METHOD(t_FileSystem, getPathMatcher, METH_O),
        DECLARE_METHOD(t_FileSystem, getRootDirectories, METH_NOARGS),
        DECLARE_METHOD(t_FileSystem, getSeparator, METH_NOARGS),
        DECLARE_METHOD(t_FileSystem, isOpen, METH_NOARGS),
        DECLARE_METHOD(t_FileSystem, isReadOnly, METH_NOARGS),
        DECLARE_METHOD(t_FileSystem, newWatchService, METH_NOARGS),
        DECLARE_METHOD(t_FileSystem, supportedFileAttributeViews, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(FileSystem)[] = {
        { Py_tp_methods, t_FileSystem__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_FileSystem__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(FileSystem)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(FileSystem, t_FileSystem, FileSystem);

      void t_FileSystem::install(PyObject *module)
      {
        installType(&PY_TYPE(FileSystem), &PY_TYPE_DEF(FileSystem), module, "FileSystem", 0);
      }

      void t_FileSystem::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileSystem), "class_", make_descriptor(FileSystem::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileSystem), "wrapfn_", make_descriptor(t_FileSystem::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileSystem), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_FileSystem_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, FileSystem::initializeClass, 1)))
          return NULL;
        return t_FileSystem::wrap_Object(FileSystem(((t_FileSystem *) arg)->object.this$));
      }
      static PyObject *t_FileSystem_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, FileSystem::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_FileSystem_close(t_FileSystem *self)
      {
        OBJ_CALL(self->object.close());
        Py_RETURN_NONE;
      }

      static PyObject *t_FileSystem_getFileStores(t_FileSystem *self)
      {
        ::java::lang::Iterable result((jobject) NULL);
        OBJ_CALL(result = self->object.getFileStores());
        return ::java::lang::t_Iterable::wrap_Object(result, ::java::nio::file::PY_TYPE(FileStore));
      }

      static PyObject *t_FileSystem_getPath(t_FileSystem *self, PyObject *args)
      {
        ::java::lang::String a0((jobject) NULL);
        JArray< ::java::lang::String > a1((jobject) NULL);
        ::java::nio::file::Path result((jobject) NULL);

        if (!parseArgs(args, "s[s", &a0, &a1))
        {
          OBJ_CALL(result = self->object.getPath(a0, a1));
          return ::java::nio::file::t_Path::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "getPath", args);
        return NULL;
      }

      static PyObject *t_FileSystem_getPathMatcher(t_FileSystem *self, PyObject *arg)
      {
        ::java::lang::String a0((jobject) NULL);
        ::java::nio::file::PathMatcher result((jobject) NULL);

        if (!parseArg(arg, "s", &a0))
        {
          OBJ_CALL(result = self->object.getPathMatcher(a0));
          return ::java::nio::file::t_PathMatcher::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "getPathMatcher", arg);
        return NULL;
      }

      static PyObject *t_FileSystem_getRootDirectories(t_FileSystem *self)
      {
        ::java::lang::Iterable result((jobject) NULL);
        OBJ_CALL(result = self->object.getRootDirectories());
        return ::java::lang::t_Iterable::wrap_Object(result, ::java::nio::file::PY_TYPE(Path));
      }

      static PyObject *t_FileSystem_getSeparator(t_FileSystem *self)
      {
        ::java::lang::String result((jobject) NULL);
        OBJ_CALL(result = self->object.getSeparator());
        return j2p(result);
      }

      static PyObject *t_FileSystem_isOpen(t_FileSystem *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.isOpen());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_FileSystem_isReadOnly(t_FileSystem *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.isReadOnly());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_FileSystem_newWatchService(t_FileSystem *self)
      {
        ::java::nio::file::WatchService result((jobject) NULL);
        OBJ_CALL(result = self->object.newWatchService());
        return ::java::nio::file::t_WatchService::wrap_Object(result);
      }

      static PyObject *t_FileSystem_supportedFileAttributeViews(t_FileSystem *self)
      {
        ::java::util::Set result((jobject) NULL);
        OBJ_CALL(result = self->object.supportedFileAttributeViews());
        return ::java::util::t_Set::wrap_Object(result, ::java::lang::PY_TYPE(String));
      }

      static PyObject *t_FileSystem_get__fileStores(t_FileSystem *self, void *data)
      {
        ::java::lang::Iterable value((jobject) NULL);
        OBJ_CALL(value = self->object.getFileStores());
        return ::java::lang::t_Iterable::wrap_Object(value);
      }

      static PyObject *t_FileSystem_get__open(t_FileSystem *self, void *data)
      {
        jboolean value;
        OBJ_CALL(value = self->object.isOpen());
        Py_RETURN_BOOL(value);
      }

      static PyObject *t_FileSystem_get__readOnly(t_FileSystem *self, void *data)
      {
        jboolean value;
        OBJ_CALL(value = self->object.isReadOnly());
        Py_RETURN_BOOL(value);
      }

      static PyObject *t_FileSystem_get__rootDirectories(t_FileSystem *self, void *data)
      {
        ::java::lang::Iterable value((jobject) NULL);
        OBJ_CALL(value = self->object.getRootDirectories());
        return ::java::lang::t_Iterable::wrap_Object(value);
      }

      static PyObject *t_FileSystem_get__separator(t_FileSystem *self, void *data)
      {
        ::java::lang::String value((jobject) NULL);
        OBJ_CALL(value = self->object.getSeparator());
        return j2p(value);
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/RecognitionException.h"
#include "org/antlr/v4/runtime/IntStream.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/ParserRuleContext.h"
#include "java/lang/Object.h"
#include "org/antlr/v4/runtime/RuleContext.h"
#include "org/antlr/v4/runtime/Recognizer.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/Token.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *RecognitionException::class$ = NULL;
        jmethodID *RecognitionException::mids$ = NULL;
        bool RecognitionException::live$ = false;

        jclass RecognitionException::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/RecognitionException");

            mids$ = new jmethodID[max_mid];
            mids$[mid_init$_9d5324d082a25483] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/Recognizer;Lorg/antlr/v4/runtime/IntStream;Lorg/antlr/v4/runtime/ParserRuleContext;)V");
            mids$[mid_init$_7417a2d5129a0b6a] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Lorg/antlr/v4/runtime/Recognizer;Lorg/antlr/v4/runtime/IntStream;Lorg/antlr/v4/runtime/ParserRuleContext;)V");
            mids$[mid_getCtx_fb986177668c7223] = env->getMethodID(cls, "getCtx", "()Lorg/antlr/v4/runtime/RuleContext;");
            mids$[mid_getInputStream_6b56ee5e0e064807] = env->getMethodID(cls, "getInputStream", "()Lorg/antlr/v4/runtime/IntStream;");
            mids$[mid_getOffendingState_9972fcc56b44e79d] = env->getMethodID(cls, "getOffendingState", "()I");
            mids$[mid_getOffendingToken_ed548981de5895c4] = env->getMethodID(cls, "getOffendingToken", "()Lorg/antlr/v4/runtime/Token;");
            mids$[mid_getRecognizer_7ada9a48d56325bc] = env->getMethodID(cls, "getRecognizer", "()Lorg/antlr/v4/runtime/Recognizer;");
            mids$[mid_setOffendingState_040c4cd0390c5aff] = env->getMethodID(cls, "setOffendingState", "(I)V");
            mids$[mid_setOffendingToken_9d1d45425dbf6563] = env->getMethodID(cls, "setOffendingToken", "(Lorg/antlr/v4/runtime/Token;)V");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        RecognitionException::RecognitionException(const ::org::antlr::v4::runtime::Recognizer & a0, const ::org::antlr::v4::runtime::IntStream & a1, const ::org::antlr::v4::runtime::ParserRuleContext & a2) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_9d5324d082a25483, a0.this$, a1.this$, a2.this$)) {}

        RecognitionException::RecognitionException(const ::java::lang::String & a0, const ::org::antlr::v4::runtime::Recognizer & a1, const ::org::antlr::v4::runtime::IntStream & a2, const ::org::antlr::v4::runtime::ParserRuleContext & a3) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_7417a2d5129a0b6a, a0.this$, a1.this$, a2.this$, a3.this$)) {}

        ::org::antlr::v4::runtime::RuleContext RecognitionException::getCtx() const
        {
          return ::org::antlr::v4::runtime::RuleContext(env->callObjectMethod(this$, mids$[mid_getCtx_fb986177668c7223]));
        }

        ::org::antlr::v4::runtime::IntStream RecognitionException::getInputStream() const
        {
          return ::org::antlr::v4::runtime::IntStream(env->callObjectMethod(this$, mids$[mid_getInputStream_6b56ee5e0e064807]));
        }

        jint RecognitionException::getOffendingState() const
        {
          return env->callIntMethod(this$, mids$[mid_getOffendingState_9972fcc56b44e79d]);
        }

        ::org::antlr::v4::runtime::Token RecognitionException::getOffendingToken() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_getOffendingToken_ed548981de5895c4]));
        }

        ::org::antlr::v4::runtime::Recognizer RecognitionException::getRecognizer() const
        {
          return ::org::antlr::v4::runtime::Recognizer(env->callObjectMethod(this$, mids$[mid_getRecognizer_7ada9a48d56325bc]));
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_RecognitionException_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_RecognitionException_instance_(PyTypeObject *type, PyObject *arg);
        static int t_RecognitionException_init_(t_RecognitionException *self, PyObject *args, PyObject *kwds);
        static PyObject *t_RecognitionException_getCtx(t_RecognitionException *self);
        static PyObject *t_RecognitionException_getInputStream(t_RecognitionException *self);
        static PyObject *t_RecognitionException_getOffendingState(t_RecognitionException *self);
        static PyObject *t_RecognitionException_getOffendingToken(t_RecognitionException *self);
        static PyObject *t_RecognitionException_getRecognizer(t_RecognitionException *self);
        static PyObject *t_RecognitionException_get__ctx(t_RecognitionException *self, void *data);
        static PyObject *t_RecognitionException_get__inputStream(t_RecognitionException *self, void *data);
        static PyObject *t_RecognitionException_get__offendingState(t_RecognitionException *self, void *data);
        static PyObject *t_RecognitionException_get__offendingToken(t_RecognitionException *self, void *data);
        static PyObject *t_RecognitionException_get__recognizer(t_RecognitionException *self, void *data);
        static PyGetSetDef t_RecognitionException__fields_[] = {
          DECLARE_GET_FIELD(t_RecognitionException, ctx),
          DECLARE_GET_FIELD(t_RecognitionException, inputStream),
          DECLARE_GET_FIELD(t_RecognitionException, offendingState),
          DECLARE_GET_FIELD(t_RecognitionException, offendingToken),
          DECLARE_GET_FIELD(t_RecognitionException, recognizer),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_RecognitionException__methods_[] = {
          DECLARE_METHOD(t_RecognitionException, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_RecognitionException, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_RecognitionException, getCtx, METH_NOARGS),
          DECLARE_METHOD(t_RecognitionException, getInputStream, METH_NOARGS),
          DECLARE_METHOD(t_RecognitionException, getOffendingState, METH_NOARGS),
          DECLARE_METHOD(t_RecognitionException, getOffendingToken, METH_NOARGS),
          DECLARE_METHOD(t_RecognitionException, getRecognizer, METH_NOARGS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(RecognitionException)[] = {
          { Py_tp_methods, t_RecognitionException__methods_ },
          { Py_tp_init, (void *) t_RecognitionException_init_ },
          { Py_tp_getset, t_RecognitionException__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(RecognitionException)[] = {
          &PY_TYPE_DEF(::java::lang::RuntimeException),
          NULL
        };

        DEFINE_TYPE(RecognitionException, t_RecognitionException, RecognitionException);

        void t_RecognitionException::install(PyObject *module)
        {
          installType(&PY_TYPE(RecognitionException), &PY_TYPE_DEF(RecognitionException), module, "RecognitionException", 0);
        }

        void t_RecognitionException::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(RecognitionException), "class_", make_descriptor(RecognitionException::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(RecognitionException), "wrapfn_", make_descriptor(t_RecognitionException::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(RecognitionException), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_RecognitionException_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, RecognitionException::initializeClass, 1)))
            return NULL;
          return t_RecognitionException::wrap_Object(RecognitionException(((t_RecognitionException *) arg)->object.this$));
        }
        static PyObject *t_RecognitionException_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, RecognitionException::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static int t_RecognitionException_init_(t_RecognitionException *self, PyObject *args, PyObject *kwds)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 3:
            {
              ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
              PyTypeObject **p0;
              ::org::antlr::v4::runtime::IntStream a1((jobject) NULL);
              ::org::antlr::v4::runtime::ParserRuleContext a2((jobject) NULL);
              RecognitionException object((jobject) NULL);

              if (!parseArgs(args, "Kkk", ::org::antlr::v4::runtime::Recognizer::initializeClass, ::org::antlr::v4::runtime::IntStream::initializeClass, ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a1, &a2))
              {
                INT_CALL(object = RecognitionException(a0, a1, a2));
                self->object = object;
                break;
              }
            }
            goto err;
           case 4:
            {
              ::java::lang::String a0((jobject) NULL);
              ::org::antlr::v4::runtime::Recognizer a1((jobject) NULL);
              PyTypeObject **p1;
              ::org::antlr::v4::runtime::IntStream a2((jobject) NULL);
              ::org::antlr::v4::runtime::ParserRuleContext a3((jobject) NULL);
              RecognitionException object((jobject) NULL);

              if (!parseArgs(args, "sKkk", ::org::antlr::v4::runtime::Recognizer::initializeClass, ::org::antlr::v4::runtime::IntStream::initializeClass, ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &a1, &p1, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a2, &a3))
              {
                INT_CALL(object = RecognitionException(a0, a1, a2, a3));
                self->object = object;
                break;
              }
            }
           default:
           err:
            PyErr_SetArgsError((PyObject *) self, "__init__", args);
            return -1;
          }

          return 0;
        }

        static PyObject *t_RecognitionException_getCtx(t_RecognitionException *self)
        {
          ::org::antlr::v4::runtime::RuleContext result((jobject) NULL);
          OBJ_CALL(result = self->object.getCtx());
          return ::org::antlr::v4::runtime::t_RuleContext::wrap_Object(result);
        }

        static PyObject *t_RecognitionException_getInputStream(t_RecognitionException *self)
        {
          ::org::antlr::v4::runtime::IntStream result((jobject) NULL);
          OBJ_CALL(result = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_IntStream::wrap_Object(result);
        }

        static PyObject *t_RecognitionException_getOffendingState(t_RecognitionException *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getOffendingState());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_RecognitionException_getOffendingToken(t_RecognitionException *self)
        {
          ::org::antlr::v4::runtime::Token result((jobject) NULL);
          OBJ_CALL(result = self->object.getOffendingToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
        }

        static PyObject *t_RecognitionException_getRecognizer(t_RecognitionException *self)
        {
          ::org::antlr::v4::runtime::Recognizer result((jobject) NULL);
          OBJ_CALL(result = self->object.getRecognizer());
          return ::org::antlr::v4::runtime::t_Recognizer::wrap_Object(result);
        }

        static PyObject *t_RecognitionException_get__ctx(t_RecognitionException *self, void *data)
        {
          ::org::antlr::v4::runtime::RuleContext value((jobject) NULL);
          OBJ_CALL(value = self->object.getCtx());
          return ::org::antlr::v4::runtime::t_RuleContext::wrap_Object(value);
        }

        static PyObject *t_RecognitionException_get__inputStream(t_RecognitionException *self, void *data)
        {
          ::org::antlr::v4::runtime::IntStream value((jobject) NULL);
          OBJ_CALL(value = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_IntStream::wrap_Object(value);
        }

        static PyObject *t_RecognitionException_get__offendingState(t_RecognitionException *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getOffendingState());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_RecognitionException_get__offendingToken(t_RecognitionException *self, void *data)
        {
          ::org::antlr::v4::runtime::Token value((jobject) NULL);
          OBJ_CALL(value = self->object.getOffendingToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(value);
        }

        static PyObject *t_RecognitionException_get__recognizer(t_RecognitionException *self, void *data)
        {
          ::org::antlr::v4::runtime::Recognizer value((jobject) NULL);
          OBJ_CALL(value = self->object.getRecognizer());
          return ::org::antlr::v4::runtime::t_Recognizer::wrap_Object(value);
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Spliterator$OfInt.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/function/IntConsumer.h"
#include "java/util/function/Consumer.h"
#include "java/lang/Integer.h"
#include "java/util/Spliterator$OfInt.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Spliterator$OfInt::class$ = NULL;
    jmethodID *Spliterator$OfInt::mids$ = NULL;
    bool Spliterator$OfInt::live$ = false;

    jclass Spliterator$OfInt::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Spliterator$OfInt");

        mids$ = new jmethodID[max_mid];
        mids$[mid_forEachRemaining_39fdd8ee24bf1a00] = env->getMethodID(cls, "forEachRemaining", "(Ljava/util/function/Consumer;)V");
        mids$[mid_forEachRemaining_873d6a6d61ec8dc3] = env->getMethodID(cls, "forEachRemaining", "(Ljava/util/function/IntConsumer;)V");
        mids$[mid_tryAdvance_9aa53ce3333098c2] = env->getMethodID(cls, "tryAdvance", "(Ljava/util/function/Consumer;)Z");
        mids$[mid_tryAdvance_1e0e4111753bd2b1] = env->getMethodID(cls, "tryAdvance", "(Ljava/util/function/IntConsumer;)Z");
        mids$[mid_trySplit_311bbfb501665b16] = env->getMethodID(cls, "trySplit", "()Ljava/util/Spliterator$OfInt;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Spliterator$OfInt::forEachRemaining(const ::java::util::function::Consumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEachRemaining_39fdd8ee24bf1a00], a0.this$);
    }

    void Spliterator$OfInt::forEachRemaining(const ::java::util::function::IntConsumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEachRemaining_873d6a6d61ec8dc3], a0.this$);
    }

    jboolean Spliterator$OfInt::tryAdvance(const ::java::util::function::Consumer & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_tryAdvance_9aa53ce3333098c2], a0.this$);
    }

    jboolean Spliterator$OfInt::tryAdvance(const ::java::util::function::IntConsumer & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_tryAdvance_1e0e4111753bd2b1], a0.this$);
    }

    Spliterator$OfInt Spliterator$OfInt::trySplit() const
    {
      return Spliterator$OfInt(env->callObjectMethod(this$, mids$[mid_trySplit_311bbfb501665b16]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Spliterator$OfInt_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator$OfInt_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator$OfInt_of_(t_Spliterator$OfInt *self, PyObject *args);
    static PyObject *t_Spliterator$OfInt_forEachRemaining(t_Spliterator$OfInt *self, PyObject *args);
    static PyObject *t_Spliterator$OfInt_tryAdvance(t_Spliterator$OfInt *self, PyObject *args);
    static PyObject *t_Spliterator$OfInt_trySplit(t_Spliterator$OfInt *self, PyObject *args);
    static PyObject *t_Spliterator$OfInt_get__parameters_(t_Spliterator$OfInt *self, void *data);
    static PyGetSetDef t_Spliterator$OfInt__fields_[] = {
      DECLARE_GET_FIELD(t_Spliterator$OfInt, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Spliterator$OfInt__methods_[] = {
      DECLARE_METHOD(t_Spliterator$OfInt, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator$OfInt, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator$OfInt, of_, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfInt, forEachRemaining, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfInt, tryAdvance, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfInt, trySplit, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Spliterator$OfInt)[] = {
      { Py_tp_methods, t_Spliterator$OfInt__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Spliterator$OfInt__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Spliterator$OfInt)[] = {
      &PY_TYPE_DEF(::java::util::Spliterator$OfPrimitive),
      NULL
    };

    DEFINE_TYPE(Spliterator$OfInt, t_Spliterator$OfInt, Spliterator$OfInt);
    PyObject *t_Spliterator$OfInt::wrap_Object(const Spliterator$OfInt& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Spliterator$OfInt::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator$OfInt *self = (t_Spliterator$OfInt *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Spliterator$OfInt::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Spliterator$OfInt::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator$OfInt *self = (t_Spliterator$OfInt *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Spliterator$OfInt::install(PyObject *module)
    {
      installType(&PY_TYPE(Spliterator$OfInt), &PY_TYPE_DEF(Spliterator$OfInt), module, "Spliterator$OfInt", 0);
    }

    void t_Spliterator$OfInt::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfInt), "class_", make_descriptor(Spliterator$OfInt::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfInt), "wrapfn_", make_descriptor(t_Spliterator$OfInt::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfInt), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Spliterator$OfInt_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Spliterator$OfInt::initializeClass, 1)))
        return NULL;
      return t_Spliterator$OfInt::wrap_Object(Spliterator$OfInt(((t_Spliterator$OfInt *) arg)->object.this$));
    }
    static PyObject *t_Spliterator$OfInt_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Spliterator$OfInt::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Spliterator$OfInt_of_(t_Spliterator$OfInt *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Spliterator$OfInt_forEachRemaining(t_Spliterator$OfInt *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::function::Consumer a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArgs(args, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
          {
            OBJ_CALL(self->object.forEachRemaining(a0));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::util::function::IntConsumer a0((jobject) NULL);

          if (!parseArgs(args, "k", ::java::util::function::IntConsumer::initializeClass, &a0))
          {
            OBJ_CALL(self->object.forEachRemaining(a0));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(Spliterator$OfInt), (PyObject *) self, "forEachRemaining", args, 2);
    }

    static PyObject *t_Spliterator$OfInt_tryAdvance(t_Spliterator$OfInt *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::function::Consumer a0((jobject) NULL);
          PyTypeObject **p0;
          jboolean result;

          if (!parseArgs(args, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
          {
            OBJ_CALL(result = self->object.tryAdvance(a0));
            Py_RETURN_BOOL(result);
          }
        }
        {
          ::java::util::function::IntConsumer a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "k", ::java::util::function::IntConsumer::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.tryAdvance(a0));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(Spliterator$OfInt), (PyObject *) self, "tryAdvance", args, 2);
    }

    static PyObject *t_Spliterator$OfInt_trySplit(t_Spliterator$OfInt *self, PyObject *args)
    {
      Spliterator$OfInt result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.trySplit());
        return t_Spliterator$OfInt::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Spliterator$OfInt), (PyObject *) self, "trySplit", args, 2);
    }
    static PyObject *t_Spliterator$OfInt_get__parameters_(t_Spliterator$OfInt *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/WatchEvent$Kind.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *WatchEvent$Kind::class$ = NULL;
      jmethodID *WatchEvent$Kind::mids$ = NULL;
      bool WatchEvent$Kind::live$ = false;

      jclass WatchEvent$Kind::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/WatchEvent$Kind");

          mids$ = new jmethodID[max_mid];
          mids$[mid_name_db9b55ba01e03e4b] = env->getMethodID(cls, "name", "()Ljava/lang/String;");
          mids$[mid_type_9df2cc6ebce035fe] = env->getMethodID(cls, "type", "()Ljava/lang/Class;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::lang::String WatchEvent$Kind::name() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_name_db9b55ba01e03e4b]));
      }

      ::java::lang::Class WatchEvent$Kind::type() const
      {
        return ::java::lang::Class(env->callObjectMethod(this$, mids$[mid_type_9df2cc6ebce035fe]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_WatchEvent$Kind_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchEvent$Kind_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchEvent$Kind_of_(t_WatchEvent$Kind *self, PyObject *args);
      static PyObject *t_WatchEvent$Kind_name(t_WatchEvent$Kind *self);
      static PyObject *t_WatchEvent$Kind_type(t_WatchEvent$Kind *self);
      static PyObject *t_WatchEvent$Kind_get__parameters_(t_WatchEvent$Kind *self, void *data);
      static PyGetSetDef t_WatchEvent$Kind__fields_[] = {
        DECLARE_GET_FIELD(t_WatchEvent$Kind, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_WatchEvent$Kind__methods_[] = {
        DECLARE_METHOD(t_WatchEvent$Kind, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchEvent$Kind, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchEvent$Kind, of_, METH_VARARGS),
        DECLARE_METHOD(t_WatchEvent$Kind, name, METH_NOARGS),
        DECLARE_METHOD(t_WatchEvent$Kind, type, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(WatchEvent$Kind)[] = {
        { Py_tp_methods, t_WatchEvent$Kind__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_WatchEvent$Kind__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(WatchEvent$Kind)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(WatchEvent$Kind, t_WatchEvent$Kind, WatchEvent$Kind);
      PyObject *t_WatchEvent$Kind::wrap_Object(const WatchEvent$Kind& object, PyTypeObject *p0)
      {
        PyObject *obj = t_WatchEvent$Kind::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_WatchEvent$Kind *self = (t_WatchEvent$Kind *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_WatchEvent$Kind::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_WatchEvent$Kind::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_WatchEvent$Kind *self = (t_WatchEvent$Kind *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_WatchEvent$Kind::install(PyObject *module)
      {
        installType(&PY_TYPE(WatchEvent$Kind), &PY_TYPE_DEF(WatchEvent$Kind), module, "WatchEvent$Kind", 0);
      }

      void t_WatchEvent$Kind::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent$Kind), "class_", make_descriptor(WatchEvent$Kind::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent$Kind), "wrapfn_", make_descriptor(t_WatchEvent$Kind::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent$Kind), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_WatchEvent$Kind_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, WatchEvent$Kind::initializeClass, 1)))
          return NULL;
        return t_WatchEvent$Kind::wrap_Object(WatchEvent$Kind(((t_WatchEvent$Kind *) arg)->object.this$));
      }
      static PyObject *t_WatchEvent$Kind_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, WatchEvent$Kind::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_WatchEvent$Kind_of_(t_WatchEvent$Kind *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_WatchEvent$Kind_name(t_WatchEvent$Kind *self)
      {
        ::java::lang::String result((jobject) NULL);
        OBJ_CALL(result = self->object.name());
        return j2p(result);
      }

      static PyObject *t_WatchEvent$Kind_type(t_WatchEvent$Kind *self)
      {
        ::java::lang::Class result((jobject) NULL);
        OBJ_CALL(result = self->object.type());
        return ::java::lang::t_Class::wrap_Object(result, self->parameters[0]);
      }
      static PyObject *t_WatchEvent$Kind_get__parameters_(t_WatchEvent$Kind *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/ArrayList.h"
#include "java/util/function/UnaryOperator.h"
#include "java/util/Collection.h"
#include "java/util/RandomAccess.h"
#include "java/lang/Cloneable.h"
#include "java/util/function/Predicate.h"
#include "java/util/Comparator.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/function/Consumer.h"
#include "java/util/Spliterator.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/ListIterator.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *ArrayList::class$ = NULL;
    jmethodID *ArrayList::mids$ = NULL;
    bool ArrayList::live$ = false;

    jclass ArrayList::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/ArrayList");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_040c4cd0390c5aff] = env->getMethodID(cls, "<init>", "(I)V");
        mids$[mid_init$_50bc3ddc62a19f2d] = env->getMethodID(cls, "<init>", "(Ljava/util/Collection;)V");
        mids$[mid_add_8b72f2dcdde6fd1d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)Z");
        mids$[mid_add_cf6732d7dfcfc293] = env->getMethodID(cls, "add", "(ILjava/lang/Object;)V");
        mids$[mid_addAll_15d9cc2398c22637] = env->getMethodID(cls, "addAll", "(Ljava/util/Collection;)Z");
        mids$[mid_addAll_8980636bfaaa897b] = env->getMethodID(cls, "addAll", "(ILjava/util/Collection;)Z");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_clone_d6bcd06f3102c4d9] = env->getMethodID(cls, "clone", "()Ljava/lang/Object;");
        mids$[mid_contains_8b72f2dcdde6fd1d] = env->getMethodID(cls, "contains", "(Ljava/lang/Object;)Z");
        mids$[mid_ensureCapacity_040c4cd0390c5aff] = env->getMethodID(cls, "ensureCapacity", "(I)V");
        mids$[mid_forEach_39fdd8ee24bf1a00] = env->getMethodID(cls, "forEach", "(Ljava/util/function/Consumer;)V");
        mids$[mid_get_b15c79acb15c2870] = env->getMethodID(cls, "get", "(I)Ljava/lang/Object;");
        mids$[mid_indexOf_5a4805a36cf611e7] = env->getMethodID(cls, "indexOf", "(Ljava/lang/Object;)I");
        mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
        mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
        mids$[mid_lastIndexOf_5a4805a36cf611e7] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/Object;)I");
        mids$[mid_listIterator_78bda7a3d01214c3] = env->getMethodID(cls, "listIterator", "()Ljava/util/ListIterator;");
        mids$[mid_listIterator_8204cc66da390272] = env->getMethodID(cls, "listIterator", "(I)Ljava/util/ListIterator;");
        mids$[mid_remove_b15c79acb15c2870] = env->getMethodID(cls, "remove", "(I)Ljava/lang/Object;");
        mids$[mid_remove_8b72f2dcdde6fd1d] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Z");
        mids$[mid_removeAll_15d9cc2398c22637] = env->getMethodID(cls, "removeAll", "(Ljava/util/Collection;)Z");
        mids$[mid_removeIf_bb7983a2fafd563c] = env->getMethodID(cls, "removeIf", "(Ljava/util/function/Predicate;)Z");
        mids$[mid_replaceAll_9d70603eb4010f27] = env->getMethodID(cls, "replaceAll", "(Ljava/util/function/UnaryOperator;)V");
        mids$[mid_retainAll_15d9cc2398c22637] = env->getMethodID(cls, "retainAll", "(Ljava/util/Collection;)Z");
        mids$[mid_set_55e2638f354bbf61] = env->getMethodID(cls, "set", "(ILjava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
        mids$[mid_sort_4703504c5d45d50f] = env->getMethodID(cls, "sort", "(Ljava/util/Comparator;)V");
        mids$[mid_spliterator_7a761c107a8e14bd] = env->getMethodID(cls, "spliterator", "()Ljava/util/Spliterator;");
        mids$[mid_subList_e1795bf76fe1346f] = env->getMethodID(cls, "subList", "(II)Ljava/util/List;");
        mids$[mid_toArray_6becf78ffd87a9bc] = env->getMethodID(cls, "toArray", "()[Ljava/lang/Object;");
        mids$[mid_toArray_609b05756010dc5d] = env->getMethodID(cls, "toArray", "([Ljava/lang/Object;)[Ljava/lang/Object;");
        mids$[mid_trimToSize_f2cc1bce94666404] = env->getMethodID(cls, "trimToSize", "()V");
        mids$[mid_removeRange_438c62480c481c65] = env->getMethodID(cls, "removeRange", "(II)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ArrayList::ArrayList() : ::java::util::AbstractList(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    ArrayList::ArrayList(jint a0) : ::java::util::AbstractList(env->newObject(initializeClass, &mids$, mid_init$_040c4cd0390c5aff, a0)) {}

    ArrayList::ArrayList(const ::java::util::Collection & a0) : ::java::util::AbstractList(env->newObject(initializeClass, &mids$, mid_init$_50bc3ddc62a19f2d, a0.this$)) {}

    jboolean ArrayList::add(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_add_8b72f2dcdde6fd1d], a0.this$);
    }

    void ArrayList::add(jint a0, const ::java::lang::Object & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_add_cf6732d7dfcfc293], a0, a1.this$);
    }

    jboolean ArrayList::addAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_15d9cc2398c22637], a0.this$);
    }

    jboolean ArrayList::addAll(jint a0, const ::java::util::Collection & a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_8980636bfaaa897b], a0, a1.this$);
    }

    void ArrayList::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    ::java::lang::Object ArrayList::clone() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_clone_d6bcd06f3102c4d9]));
    }

    jboolean ArrayList::contains(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_contains_8b72f2dcdde6fd1d], a0.this$);
    }

    void ArrayList::ensureCapacity(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_ensureCapacity_040c4cd0390c5aff], a0);
    }

    void ArrayList::forEach(const ::java::util::function::Consumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEach_39fdd8ee24bf1a00], a0.this$);
    }

    ::java::lang::Object ArrayList::get(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_b15c79acb15c2870], a0));
    }

    jint ArrayList::indexOf(const ::java::lang::Object & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_5a4805a36cf611e7], a0.this$);
    }

    jboolean ArrayList::isEmpty() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
    }

    ::java::util::Iterator ArrayList::iterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
    }

    jint ArrayList::lastIndexOf(const ::java::lang::Object & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_5a4805a36cf611e7], a0.this$);
    }

    ::java::util::ListIterator ArrayList::listIterator() const
    {
      return ::java::util::ListIterator(env->callObjectMethod(this$, mids$[mid_listIterator_78bda7a3d01214c3]));
    }

    ::java::util::ListIterator ArrayList::listIterator(jint a0) const
    {
      return ::java::util::ListIterator(env->callObjectMethod(this$, mids$[mid_listIterator_8204cc66da390272], a0));
    }

    ::java::lang::Object ArrayList::remove(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_b15c79acb15c2870], a0));
    }

    jboolean ArrayList::remove(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_remove_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean ArrayList::removeAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeAll_15d9cc2398c22637], a0.this$);
    }

    jboolean ArrayList::removeIf(const ::java::util::function::Predicate & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeIf_bb7983a2fafd563c], a0.this$);
    }

    void ArrayList::replaceAll(const ::java::util::function::UnaryOperator & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_replaceAll_9d70603eb4010f27], a0.this$);
    }

    jboolean ArrayList::retainAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_retainAll_15d9cc2398c22637], a0.this$);
    }

    ::java::lang::Object ArrayList::set(jint a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_set_55e2638f354bbf61], a0, a1.this$));
    }

    jint ArrayList::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }

    void ArrayList::sort(const ::java::util::Comparator & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_sort_4703504c5d45d50f], a0.this$);
    }

    ::java::util::Spliterator ArrayList::spliterator() const
    {
      return ::java::util::Spliterator(env->callObjectMethod(this$, mids$[mid_spliterator_7a761c107a8e14bd]));
    }

    ::java::util::List ArrayList::subList(jint a0, jint a1) const
    {
      return ::java::util::List(env->callObjectMethod(this$, mids$[mid_subList_e1795bf76fe1346f], a0, a1));
    }

    JArray< ::java::lang::Object > ArrayList::toArray() const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_6becf78ffd87a9bc]));
    }

    JArray< ::java::lang::Object > ArrayList::toArray(const JArray< ::java::lang::Object > & a0) const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_609b05756010dc5d], a0.this$));
    }

    void ArrayList::trimToSize() const
    {
      env->callVoidMethod(this$, mids$[mid_trimToSize_f2cc1bce94666404]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_ArrayList_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ArrayList_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ArrayList_of_(t_ArrayList *self, PyObject *args);
    static int t_ArrayList_init_(t_ArrayList *self, PyObject *args, PyObject *kwds);
    static PyObject *t_ArrayList_add(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_addAll(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_clear(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_clone(t_ArrayList *self);
    static PyObject *t_ArrayList_contains(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_ensureCapacity(t_ArrayList *self, PyObject *arg);
    static PyObject *t_ArrayList_forEach(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_get(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_indexOf(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_isEmpty(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_iterator(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_lastIndexOf(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_listIterator(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_remove(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_removeAll(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_removeIf(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_replaceAll(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_retainAll(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_set(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_size(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_sort(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_spliterator(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_subList(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_toArray(t_ArrayList *self, PyObject *args);
    static PyObject *t_ArrayList_trimToSize(t_ArrayList *self);
    static PyObject *t_ArrayList_get__empty(t_ArrayList *self, void *data);
    static PyObject *t_ArrayList_get__parameters_(t_ArrayList *self, void *data);
    static PyGetSetDef t_ArrayList__fields_[] = {
      DECLARE_GET_FIELD(t_ArrayList, empty),
      DECLARE_GET_FIELD(t_ArrayList, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_ArrayList__methods_[] = {
      DECLARE_METHOD(t_ArrayList, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ArrayList, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ArrayList, of_, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, add, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, addAll, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, clear, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, clone, METH_NOARGS),
      DECLARE_METHOD(t_ArrayList, contains, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, ensureCapacity, METH_O),
      DECLARE_METHOD(t_ArrayList, forEach, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, get, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, indexOf, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, isEmpty, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, iterator, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, lastIndexOf, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, listIterator, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, remove, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, removeAll, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, removeIf, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, replaceAll, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, retainAll, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, set, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, size, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, sort, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, spliterator, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, subList, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, toArray, METH_VARARGS),
      DECLARE_METHOD(t_ArrayList, trimToSize, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(ArrayList)[] = {
      { Py_tp_methods, t_ArrayList__methods_ },
      { Py_tp_init, (void *) t_ArrayList_init_ },
      { Py_tp_getset, t_ArrayList__fields_ },
      { Py_tp_iter, (void *) ((PyObject *(*)(t_ArrayList *)) get_generic_iterator< t_ArrayList >) },
      { Py_tp_iternext, (void *) 0 },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(ArrayList)[] = {
      &PY_TYPE_DEF(::java::util::AbstractList),
      NULL
    };

    DEFINE_TYPE(ArrayList, t_ArrayList, ArrayList);
    PyObject *t_ArrayList::wrap_Object(const ArrayList& object, PyTypeObject *p0)
    {
      PyObject *obj = t_ArrayList::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_ArrayList *self = (t_ArrayList *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_ArrayList::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_ArrayList::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_ArrayList *self = (t_ArrayList *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_ArrayList::install(PyObject *module)
    {
      installType(&PY_TYPE(ArrayList), &PY_TYPE_DEF(ArrayList), module, "ArrayList", 0);
    }

    void t_ArrayList::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(ArrayList), "class_", make_descriptor(ArrayList::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ArrayList), "wrapfn_", make_descriptor(t_ArrayList::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ArrayList), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_ArrayList_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, ArrayList::initializeClass, 1)))
        return NULL;
      return t_ArrayList::wrap_Object(ArrayList(((t_ArrayList *) arg)->object.this$));
    }
    static PyObject *t_ArrayList_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, ArrayList::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_ArrayList_of_(t_ArrayList *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static int t_ArrayList_init_(t_ArrayList *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ArrayList object((jobject) NULL);

          INT_CALL(object = ArrayList());
          self->object = object;
          break;
        }
       case 1:
        {
          jint a0;
          ArrayList object((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            INT_CALL(object = ArrayList(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::util::Collection a0((jobject) NULL);
          PyTypeObject **p0;
          ArrayList object((jobject) NULL);

          if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
          {
            INT_CALL(object = ArrayList(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_ArrayList_add(t_ArrayList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "O", self->parameters[0], &a0))
          {
            OBJ_CALL(result = self->object.add(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          ::java::lang::Object a1((jobject) NULL);

          if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(self->object.add(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "add", args, 2);
    }

    static PyObject *t_ArrayList_addAll(t_ArrayList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::Collection a0((jobject) NULL);
          PyTypeObject **p0;
          jboolean result;

          if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
          {
            OBJ_CALL(result = self->object.addAll(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          ::java::util::Collection a1((jobject) NULL);
          PyTypeObject **p1;
          jboolean result;

          if (!parseArgs(args, "IK", ::java::util::Collection::initializeClass, &a0, &a1, &p1, ::java::util::t_Collection::parameters_))
          {
            OBJ_CALL(result = self->object.addAll(a0, a1));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "addAll", args, 2);
    }

    static PyObject *t_ArrayList_clear(t_ArrayList *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.clear());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "clear", args, 2);
    }

    static PyObject *t_ArrayList_clone(t_ArrayList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.clone());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_ArrayList_contains(t_ArrayList *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.contains(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "contains", args, 2);
    }

    static PyObject *t_ArrayList_ensureCapacity(t_ArrayList *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.ensureCapacity(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "ensureCapacity", arg);
      return NULL;
    }

    static PyObject *t_ArrayList_forEach(t_ArrayList *self, PyObject *args)
    {
      ::java::util::function::Consumer a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArgs(args, "K", ::java::util::function::Consumer::initializeClass, &a0, &p0, ::java::util::function::t_Consumer::parameters_))
      {
        OBJ_CALL(self->object.forEach(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "forEach", args, 2);
    }

    static PyObject *t_ArrayList_get(t_ArrayList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "get", args, 2);
    }

    static PyObject *t_ArrayList_indexOf(t_ArrayList *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jint result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.indexOf(a0));
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "indexOf", args, 2);
    }

    static PyObject *t_ArrayList_isEmpty(t_ArrayList *self, PyObject *args)
    {
      jboolean result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.isEmpty());
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "isEmpty", args, 2);
    }

    static PyObject *t_ArrayList_iterator(t_ArrayList *self, PyObject *args)
    {
      ::java::util::Iterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.iterator());
        return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "iterator", args, 2);
    }

    static PyObject *t_ArrayList_lastIndexOf(t_ArrayList *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jint result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.lastIndexOf(a0));
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "lastIndexOf", args, 2);
    }

    static PyObject *t_ArrayList_listIterator(t_ArrayList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::util::ListIterator result((jobject) NULL);
          OBJ_CALL(result = self->object.listIterator());
          return ::java::util::t_ListIterator::wrap_Object(result, self->parameters[0]);
        }
        break;
       case 1:
        {
          jint a0;
          ::java::util::ListIterator result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.listIterator(a0));
            return ::java::util::t_ListIterator::wrap_Object(result, self->parameters[0]);
          }
        }
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "listIterator", args, 2);
    }

    static PyObject *t_ArrayList_remove(t_ArrayList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jint a0;
          ::java::lang::Object result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.remove(a0));
            return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
          }
        }
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(result = self->object.remove(a0));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_ArrayList_removeAll(t_ArrayList *self, PyObject *args)
    {
      ::java::util::Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.removeAll(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "removeAll", args, 2);
    }

    static PyObject *t_ArrayList_removeIf(t_ArrayList *self, PyObject *args)
    {
      ::java::util::function::Predicate a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::function::Predicate::initializeClass, &a0, &p0, ::java::util::function::t_Predicate::parameters_))
      {
        OBJ_CALL(result = self->object.removeIf(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "removeIf", args, 2);
    }

    static PyObject *t_ArrayList_replaceAll(t_ArrayList *self, PyObject *args)
    {
      ::java::util::function::UnaryOperator a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArgs(args, "K", ::java::util::function::UnaryOperator::initializeClass, &a0, &p0, ::java::util::function::t_UnaryOperator::parameters_))
      {
        OBJ_CALL(self->object.replaceAll(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "replaceAll", args, 2);
    }

    static PyObject *t_ArrayList_retainAll(t_ArrayList *self, PyObject *args)
    {
      ::java::util::Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.retainAll(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "retainAll", args, 2);
    }

    static PyObject *t_ArrayList_set(t_ArrayList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
      {
        OBJ_CALL(result = self->object.set(a0, a1));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "set", args, 2);
    }

    static PyObject *t_ArrayList_size(t_ArrayList *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.size());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "size", args, 2);
    }

    static PyObject *t_ArrayList_sort(t_ArrayList *self, PyObject *args)
    {
      ::java::util::Comparator a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArgs(args, "K", ::java::util::Comparator::initializeClass, &a0, &p0, ::java::util::t_Comparator::parameters_))
      {
        OBJ_CALL(self->object.sort(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "sort", args, 2);
    }

    static PyObject *t_ArrayList_spliterator(t_ArrayList *self, PyObject *args)
    {
      ::java::util::Spliterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.spliterator());
        return ::java::util::t_Spliterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "spliterator", args, 2);
    }

    static PyObject *t_ArrayList_subList(t_ArrayList *self, PyObject *args)
    {
      jint a0;
      jint a1;
      ::java::util::List result((jobject) NULL);

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.subList(a0, a1));
        return ::java::util::t_List::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "subList", args, 2);
    }

    static PyObject *t_ArrayList_toArray(t_ArrayList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          JArray< ::java::lang::Object > result((jobject) NULL);
          OBJ_CALL(result = self->object.toArray());
          return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
        }
        break;
       case 1:
        {
          JArray< ::java::lang::Object > a0((jobject) NULL);
          JArray< ::java::lang::Object > result((jobject) NULL);

          if (!parseArgs(args, "[o", &a0))
          {
            OBJ_CALL(result = self->object.toArray(a0));
            return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
          }
        }
      }

      return callSuper(PY_TYPE(ArrayList), (PyObject *) self, "toArray", args, 2);
    }

    static PyObject *t_ArrayList_trimToSize(t_ArrayList *self)
    {
      OBJ_CALL(self->object.trimToSize());
      Py_RETURN_NONE;
    }
    static PyObject *t_ArrayList_get__parameters_(t_ArrayList *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_ArrayList_get__empty(t_ArrayList *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isEmpty());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/NavigableSet.h"
#include "java/util/NavigableSet.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/Iterator.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *NavigableSet::class$ = NULL;
    jmethodID *NavigableSet::mids$ = NULL;
    bool NavigableSet::live$ = false;

    jclass NavigableSet::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/NavigableSet");

        mids$ = new jmethodID[max_mid];
        mids$[mid_ceiling_e5ae0f8c04795fa9] = env->getMethodID(cls, "ceiling", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_descendingIterator_233a192dadb0917d] = env->getMethodID(cls, "descendingIterator", "()Ljava/util/Iterator;");
        mids$[mid_descendingSet_69a674c200eed505] = env->getMethodID(cls, "descendingSet", "()Ljava/util/NavigableSet;");
        mids$[mid_floor_e5ae0f8c04795fa9] = env->getMethodID(cls, "floor", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_headSet_53f2bf24b94c5740] = env->getMethodID(cls, "headSet", "(Ljava/lang/Object;)Ljava/util/SortedSet;");
        mids$[mid_headSet_18a0ce538fdac12f] = env->getMethodID(cls, "headSet", "(Ljava/lang/Object;Z)Ljava/util/NavigableSet;");
        mids$[mid_higher_e5ae0f8c04795fa9] = env->getMethodID(cls, "higher", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
        mids$[mid_lower_e5ae0f8c04795fa9] = env->getMethodID(cls, "lower", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_pollFirst_d6bcd06f3102c4d9] = env->getMethodID(cls, "pollFirst", "()Ljava/lang/Object;");
        mids$[mid_pollLast_d6bcd06f3102c4d9] = env->getMethodID(cls, "pollLast", "()Ljava/lang/Object;");
        mids$[mid_subSet_02b9298b38245e1d] = env->getMethodID(cls, "subSet", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/SortedSet;");
        mids$[mid_subSet_f6bf97d8ce23e495] = env->getMethodID(cls, "subSet", "(Ljava/lang/Object;ZLjava/lang/Object;Z)Ljava/util/NavigableSet;");
        mids$[mid_tailSet_53f2bf24b94c5740] = env->getMethodID(cls, "tailSet", "(Ljava/lang/Object;)Ljava/util/SortedSet;");
        mids$[mid_tailSet_18a0ce538fdac12f] = env->getMethodID(cls, "tailSet", "(Ljava/lang/Object;Z)Ljava/util/NavigableSet;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ::java::lang::Object NavigableSet::ceiling(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_ceiling_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::util::Iterator NavigableSet::descendingIterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_descendingIterator_233a192dadb0917d]));
    }

    NavigableSet NavigableSet::descendingSet() const
    {
      return NavigableSet(env->callObjectMethod(this$, mids$[mid_descendingSet_69a674c200eed505]));
    }

    ::java::lang::Object NavigableSet::floor(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_floor_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::util::SortedSet NavigableSet::headSet(const ::java::lang::Object & a0) const
    {
      return ::java::util::SortedSet(env->callObjectMethod(this$, mids$[mid_headSet_53f2bf24b94c5740], a0.this$));
    }

    NavigableSet NavigableSet::headSet(const ::java::lang::Object & a0, jboolean a1) const
    {
      return NavigableSet(env->callObjectMethod(this$, mids$[mid_headSet_18a0ce538fdac12f], a0.this$, a1));
    }

    ::java::lang::Object NavigableSet::higher(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_higher_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::util::Iterator NavigableSet::iterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
    }

    ::java::lang::Object NavigableSet::lower(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_lower_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::lang::Object NavigableSet::pollFirst() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_pollFirst_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object NavigableSet::pollLast() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_pollLast_d6bcd06f3102c4d9]));
    }

    ::java::util::SortedSet NavigableSet::subSet(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::util::SortedSet(env->callObjectMethod(this$, mids$[mid_subSet_02b9298b38245e1d], a0.this$, a1.this$));
    }

    NavigableSet NavigableSet::subSet(const ::java::lang::Object & a0, jboolean a1, const ::java::lang::Object & a2, jboolean a3) const
    {
      return NavigableSet(env->callObjectMethod(this$, mids$[mid_subSet_f6bf97d8ce23e495], a0.this$, a1, a2.this$, a3));
    }

    ::java::util::SortedSet NavigableSet::tailSet(const ::java::lang::Object & a0) const
    {
      return ::java::util::SortedSet(env->callObjectMethod(this$, mids$[mid_tailSet_53f2bf24b94c5740], a0.this$));
    }

    NavigableSet NavigableSet::tailSet(const ::java::lang::Object & a0, jboolean a1) const
    {
      return NavigableSet(env->callObjectMethod(this$, mids$[mid_tailSet_18a0ce538fdac12f], a0.this$, a1));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_NavigableSet_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_NavigableSet_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_NavigableSet_of_(t_NavigableSet *self, PyObject *args);
    static PyObject *t_NavigableSet_ceiling(t_NavigableSet *self, PyObject *arg);
    static PyObject *t_NavigableSet_descendingIterator(t_NavigableSet *self);
    static PyObject *t_NavigableSet_descendingSet(t_NavigableSet *self);
    static PyObject *t_NavigableSet_floor(t_NavigableSet *self, PyObject *arg);
    static PyObject *t_NavigableSet_headSet(t_NavigableSet *self, PyObject *args);
    static PyObject *t_NavigableSet_higher(t_NavigableSet *self, PyObject *arg);
    static PyObject *t_NavigableSet_iterator(t_NavigableSet *self, PyObject *args);
    static PyObject *t_NavigableSet_lower(t_NavigableSet *self, PyObject *arg);
    static PyObject *t_NavigableSet_pollFirst(t_NavigableSet *self);
    static PyObject *t_NavigableSet_pollLast(t_NavigableSet *self);
    static PyObject *t_NavigableSet_subSet(t_NavigableSet *self, PyObject *args);
    static PyObject *t_NavigableSet_tailSet(t_NavigableSet *self, PyObject *args);
    static PyObject *t_NavigableSet_get__parameters_(t_NavigableSet *self, void *data);
    static PyGetSetDef t_NavigableSet__fields_[] = {
      DECLARE_GET_FIELD(t_NavigableSet, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_NavigableSet__methods_[] = {
      DECLARE_METHOD(t_NavigableSet, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_NavigableSet, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_NavigableSet, of_, METH_VARARGS),
      DECLARE_METHOD(t_NavigableSet, ceiling, METH_O),
      DECLARE_METHOD(t_NavigableSet, descendingIterator, METH_NOARGS),
      DECLARE_METHOD(t_NavigableSet, descendingSet, METH_NOARGS),
      DECLARE_METHOD(t_NavigableSet, floor, METH_O),
      DECLARE_METHOD(t_NavigableSet, headSet, METH_VARARGS),
      DECLARE_METHOD(t_NavigableSet, higher, METH_O),
      DECLARE_METHOD(t_NavigableSet, iterator, METH_VARARGS),
      DECLARE_METHOD(t_NavigableSet, lower, METH_O),
      DECLARE_METHOD(t_NavigableSet, pollFirst, METH_NOARGS),
      DECLARE_METHOD(t_NavigableSet, pollLast, METH_NOARGS),
      DECLARE_METHOD(t_NavigableSet, subSet, METH_VARARGS),
      DECLARE_METHOD(t_NavigableSet, tailSet, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(NavigableSet)[] = {
      { Py_tp_methods, t_NavigableSet__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_NavigableSet__fields_ },
      { Py_tp_iter, (void *) ((PyObject *(*)(t_NavigableSet *)) get_generic_iterator< t_NavigableSet >) },
      { Py_tp_iternext, (void *) 0 },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(NavigableSet)[] = {
      &PY_TYPE_DEF(::java::util::SortedSet),
      NULL
    };

    DEFINE_TYPE(NavigableSet, t_NavigableSet, NavigableSet);
    PyObject *t_NavigableSet::wrap_Object(const NavigableSet& object, PyTypeObject *p0)
    {
      PyObject *obj = t_NavigableSet::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_NavigableSet *self = (t_NavigableSet *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_NavigableSet::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_NavigableSet::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_NavigableSet *self = (t_NavigableSet *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_NavigableSet::install(PyObject *module)
    {
      installType(&PY_TYPE(NavigableSet), &PY_TYPE_DEF(NavigableSet), module, "NavigableSet", 0);
    }

    void t_NavigableSet::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(NavigableSet), "class_", make_descriptor(NavigableSet::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(NavigableSet), "wrapfn_", make_descriptor(t_NavigableSet::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(NavigableSet), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_NavigableSet_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, NavigableSet::initializeClass, 1)))
        return NULL;
      return t_NavigableSet::wrap_Object(NavigableSet(((t_NavigableSet *) arg)->object.this$));
    }
    static PyObject *t_NavigableSet_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, NavigableSet::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_NavigableSet_of_(t_NavigableSet *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_NavigableSet_ceiling(t_NavigableSet *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.ceiling(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "ceiling", arg);
      return NULL;
    }

    static PyObject *t_NavigableSet_descendingIterator(t_NavigableSet *self)
    {
      ::java::util::Iterator result((jobject) NULL);
      OBJ_CALL(result = self->object.descendingIterator());
      return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_NavigableSet_descendingSet(t_NavigableSet *self)
    {
      NavigableSet result((jobject) NULL);
      OBJ_CALL(result = self->object.descendingSet());
      return t_NavigableSet::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_NavigableSet_floor(t_NavigableSet *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.floor(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "floor", arg);
      return NULL;
    }

    static PyObject *t_NavigableSet_headSet(t_NavigableSet *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::util::SortedSet result((jobject) NULL);

          if (!parseArgs(args, "O", self->parameters[0], &a0))
          {
            OBJ_CALL(result = self->object.headSet(a0));
            return ::java::util::t_SortedSet::wrap_Object(result, self->parameters[0]);
          }
        }
        break;
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean a1;
          NavigableSet result((jobject) NULL);

          if (!parseArgs(args, "OZ", self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(result = self->object.headSet(a0, a1));
            return t_NavigableSet::wrap_Object(result, self->parameters[0]);
          }
        }
      }

      return callSuper(PY_TYPE(NavigableSet), (PyObject *) self, "headSet", args, 2);
    }

    static PyObject *t_NavigableSet_higher(t_NavigableSet *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.higher(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "higher", arg);
      return NULL;
    }

    static PyObject *t_NavigableSet_iterator(t_NavigableSet *self, PyObject *args)
    {
      ::java::util::Iterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.iterator());
        return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(NavigableSet), (PyObject *) self, "iterator", args, 2);
    }

    static PyObject *t_NavigableSet_lower(t_NavigableSet *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.lower(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "lower", arg);
      return NULL;
    }

    static PyObject *t_NavigableSet_pollFirst(t_NavigableSet *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.pollFirst());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_NavigableSet_pollLast(t_NavigableSet *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.pollLast());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_NavigableSet_subSet(t_NavigableSet *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object a1((jobject) NULL);
          ::java::util::SortedSet result((jobject) NULL);

          if (!parseArgs(args, "OO", self->parameters[0], self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(result = self->object.subSet(a0, a1));
            return ::java::util::t_SortedSet::wrap_Object(result, self->parameters[0]);
          }
        }
        break;
       case 4:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean a1;
          ::java::lang::Object a2((jobject) NULL);
          jboolean a3;
          NavigableSet result((jobject) NULL);

          if (!parseArgs(args, "OZOZ", self->parameters[0], self->parameters[0], &a0, &a1, &a2, &a3))
          {
            OBJ_CALL(result = self->object.subSet(a0, a1, a2, a3));
            return t_NavigableSet::wrap_Object(result, self->parameters[0]);
          }
        }
      }

      return callSuper(PY_TYPE(NavigableSet), (PyObject *) self, "subSet", args, 2);
    }

    static PyObject *t_NavigableSet_tailSet(t_NavigableSet *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::util::SortedSet result((jobject) NULL);

          if (!parseArgs(args, "O", self->parameters[0], &a0))
          {
            OBJ_CALL(result = self->object.tailSet(a0));
            return ::java::util::t_SortedSet::wrap_Object(result, self->parameters[0]);
          }
        }
        break;
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean a1;
          NavigableSet result((jobject) NULL);

          if (!parseArgs(args, "OZ", self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(result = self->object.tailSet(a0, a1));
            return t_NavigableSet::wrap_Object(result, self->parameters[0]);
          }
        }
      }

      return callSuper(PY_TYPE(NavigableSet), (PyObject *) self, "tailSet", args, 2);
    }
    static PyObject *t_NavigableSet_get__parameters_(t_NavigableSet *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/BitSet.h"
#include "java/lang/Cloneable.h"
#include "java/lang/Class.h"
#include "java/util/BitSet.h"
#include "java/lang/String.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *BitSet::class$ = NULL;
    jmethodID *BitSet::mids$ = NULL;
    bool BitSet::live$ = false;

    jclass BitSet::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/BitSet");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_040c4cd0390c5aff] = env->getMethodID(cls, "<init>", "(I)V");
        mids$[mid_and_1b283dd3feee6fc8] = env->getMethodID(cls, "and", "(Ljava/util/BitSet;)V");
        mids$[mid_andNot_1b283dd3feee6fc8] = env->getMethodID(cls, "andNot", "(Ljava/util/BitSet;)V");
        mids$[mid_cardinality_9972fcc56b44e79d] = env->getMethodID(cls, "cardinality", "()I");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_clear_040c4cd0390c5aff] = env->getMethodID(cls, "clear", "(I)V");
        mids$[mid_clear_438c62480c481c65] = env->getMethodID(cls, "clear", "(II)V");
        mids$[mid_clone_d6bcd06f3102c4d9] = env->getMethodID(cls, "clone", "()Ljava/lang/Object;");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_flip_040c4cd0390c5aff] = env->getMethodID(cls, "flip", "(I)V");
        mids$[mid_flip_438c62480c481c65] = env->getMethodID(cls, "flip", "(II)V");
        mids$[mid_get_a1d30e1ee40c89a2] = env->getMethodID(cls, "get", "(I)Z");
        mids$[mid_get_0253fedf405395f2] = env->getMethodID(cls, "get", "(II)Ljava/util/BitSet;");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_intersects_a14d5086e1a1d966] = env->getMethodID(cls, "intersects", "(Ljava/util/BitSet;)Z");
        mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
        mids$[mid_length_9972fcc56b44e79d] = env->getMethodID(cls, "length", "()I");
        mids$[mid_nextClearBit_1e143afe1894d213] = env->getMethodID(cls, "nextClearBit", "(I)I");
        mids$[mid_nextSetBit_1e143afe1894d213] = env->getMethodID(cls, "nextSetBit", "(I)I");
        mids$[mid_or_1b283dd3feee6fc8] = env->getMethodID(cls, "or", "(Ljava/util/BitSet;)V");
        mids$[mid_previousClearBit_1e143afe1894d213] = env->getMethodID(cls, "previousClearBit", "(I)I");
        mids$[mid_previousSetBit_1e143afe1894d213] = env->getMethodID(cls, "previousSetBit", "(I)I");
        mids$[mid_set_040c4cd0390c5aff] = env->getMethodID(cls, "set", "(I)V");
        mids$[mid_set_b8f283cdbda5c964] = env->getMethodID(cls, "set", "(IZ)V");
        mids$[mid_set_438c62480c481c65] = env->getMethodID(cls, "set", "(II)V");
        mids$[mid_set_647417ee2dda92ca] = env->getMethodID(cls, "set", "(IIZ)V");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
        mids$[mid_toByteArray_cf386cdb1bbd339f] = env->getMethodID(cls, "toByteArray", "()[B");
        mids$[mid_toLongArray_d09b715a1c5ddffd] = env->getMethodID(cls, "toLongArray", "()[J");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
        mids$[mid_valueOf_adc7f533af06db5d] = env->getStaticMethodID(cls, "valueOf", "([B)Ljava/util/BitSet;");
        mids$[mid_valueOf_d8ae6001e51610ac] = env->getStaticMethodID(cls, "valueOf", "([J)Ljava/util/BitSet;");
        mids$[mid_xor_1b283dd3feee6fc8] = env->getMethodID(cls, "xor", "(Ljava/util/BitSet;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    BitSet::BitSet() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    BitSet::BitSet(jint a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_040c4cd0390c5aff, a0)) {}

    void BitSet::and$(const BitSet & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_and_1b283dd3feee6fc8], a0.this$);
    }

    void BitSet::andNot(const BitSet & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_andNot_1b283dd3feee6fc8], a0.this$);
    }

    jint BitSet::cardinality() const
    {
      return env->callIntMethod(this$, mids$[mid_cardinality_9972fcc56b44e79d]);
    }

    void BitSet::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    void BitSet::clear(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_clear_040c4cd0390c5aff], a0);
    }

    void BitSet::clear(jint a0, jint a1) const
    {
      env->callVoidMethod(this$, mids$[mid_clear_438c62480c481c65], a0, a1);
    }

    ::java::lang::Object BitSet::clone() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_clone_d6bcd06f3102c4d9]));
    }

    jboolean BitSet::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    void BitSet::flip(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_flip_040c4cd0390c5aff], a0);
    }

    void BitSet::flip(jint a0, jint a1) const
    {
      env->callVoidMethod(this$, mids$[mid_flip_438c62480c481c65], a0, a1);
    }

    jboolean BitSet::get(jint a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_get_a1d30e1ee40c89a2], a0);
    }

    BitSet BitSet::get(jint a0, jint a1) const
    {
      return BitSet(env->callObjectMethod(this$, mids$[mid_get_0253fedf405395f2], a0, a1));
    }

    jint BitSet::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean BitSet::intersects(const BitSet & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_intersects_a14d5086e1a1d966], a0.this$);
    }

    jboolean BitSet::isEmpty() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
    }

    jint BitSet::length() const
    {
      return env->callIntMethod(this$, mids$[mid_length_9972fcc56b44e79d]);
    }

    jint BitSet::nextClearBit(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_nextClearBit_1e143afe1894d213], a0);
    }

    jint BitSet::nextSetBit(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_nextSetBit_1e143afe1894d213], a0);
    }

    void BitSet::or$(const BitSet & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_or_1b283dd3feee6fc8], a0.this$);
    }

    jint BitSet::previousClearBit(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_previousClearBit_1e143afe1894d213], a0);
    }

    jint BitSet::previousSetBit(jint a0) const
    {
      return env->callIntMethod(this$, mids$[mid_previousSetBit_1e143afe1894d213], a0);
    }

    void BitSet::set(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_set_040c4cd0390c5aff], a0);
    }

    void BitSet::set(jint a0, jboolean a1) const
    {
      env->callVoidMethod(this$, mids$[mid_set_b8f283cdbda5c964], a0, a1);
    }

    void BitSet::set(jint a0, jint a1) const
    {
      env->callVoidMethod(this$, mids$[mid_set_438c62480c481c65], a0, a1);
    }

    void BitSet::set(jint a0, jint a1, jboolean a2) const
    {
      env->callVoidMethod(this$, mids$[mid_set_647417ee2dda92ca], a0, a1, a2);
    }

    jint BitSet::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }

    JArray< jbyte > BitSet::toByteArray() const
    {
      return JArray< jbyte >(env->callObjectMethod(this$, mids$[mid_toByteArray_cf386cdb1bbd339f]));
    }

    JArray< jlong > BitSet::toLongArray() const
    {
      return JArray< jlong >(env->callObjectMethod(this$, mids$[mid_toLongArray_d09b715a1c5ddffd]));
    }

    ::java::lang::String BitSet::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }

    BitSet BitSet::valueOf(const JArray< jbyte > & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return BitSet(env->callStaticObjectMethod(cls, mids$[mid_valueOf_adc7f533af06db5d], a0.this$));
    }

    BitSet BitSet::valueOf(const JArray< jlong > & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return BitSet(env->callStaticObjectMethod(cls, mids$[mid_valueOf_d8ae6001e51610ac], a0.this$));
    }

    void BitSet::xor$(const BitSet & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_xor_1b283dd3feee6fc8], a0.this$);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_BitSet_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_BitSet_instance_(PyTypeObject *type, PyObject *arg);
    static int t_BitSet_init_(t_BitSet *self, PyObject *args, PyObject *kwds);
    static PyObject *t_BitSet_and(t_BitSet *self, PyObject *arg);
    static PyObject *t_BitSet_andNot(t_BitSet *self, PyObject *arg);
    static PyObject *t_BitSet_cardinality(t_BitSet *self);
    static PyObject *t_BitSet_clear(t_BitSet *self, PyObject *args);
    static PyObject *t_BitSet_clone(t_BitSet *self);
    static PyObject *t_BitSet_equals(t_BitSet *self, PyObject *args);
    static PyObject *t_BitSet_flip(t_BitSet *self, PyObject *args);
    static PyObject *t_BitSet_get(t_BitSet *self, PyObject *args);
    static PyObject *t_BitSet_hashCode(t_BitSet *self, PyObject *args);
    static PyObject *t_BitSet_intersects(t_BitSet *self, PyObject *arg);
    static PyObject *t_BitSet_isEmpty(t_BitSet *self);
    static PyObject *t_BitSet_length(t_BitSet *self);
    static PyObject *t_BitSet_nextClearBit(t_BitSet *self, PyObject *arg);
    static PyObject *t_BitSet_nextSetBit(t_BitSet *self, PyObject *arg);
    static PyObject *t_BitSet_or(t_BitSet *self, PyObject *arg);
    static PyObject *t_BitSet_previousClearBit(t_BitSet *self, PyObject *arg);
    static PyObject *t_BitSet_previousSetBit(t_BitSet *self, PyObject *arg);
    static PyObject *t_BitSet_set(t_BitSet *self, PyObject *args);
    static PyObject *t_BitSet_size(t_BitSet *self);
    static PyObject *t_BitSet_toByteArray(t_BitSet *self);
    static PyObject *t_BitSet_toLongArray(t_BitSet *self);
    static PyObject *t_BitSet_toString(t_BitSet *self, PyObject *args);
    static PyObject *t_BitSet_valueOf(PyTypeObject *type, PyObject *args);
    static PyObject *t_BitSet_xor(t_BitSet *self, PyObject *arg);
    static PyObject *t_BitSet_get__empty(t_BitSet *self, void *data);
    static PyGetSetDef t_BitSet__fields_[] = {
      DECLARE_GET_FIELD(t_BitSet, empty),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_BitSet__methods_[] = {
      DECLARE_METHOD(t_BitSet, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_BitSet, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_BitSet, and, METH_O),
      DECLARE_METHOD(t_BitSet, andNot, METH_O),
      DECLARE_METHOD(t_BitSet, cardinality, METH_NOARGS),
      DECLARE_METHOD(t_BitSet, clear, METH_VARARGS),
      DECLARE_METHOD(t_BitSet, clone, METH_NOARGS),
      DECLARE_METHOD(t_BitSet, equals, METH_VARARGS),
      DECLARE_METHOD(t_BitSet, flip, METH_VARARGS),
      DECLARE_METHOD(t_BitSet, get, METH_VARARGS),
      DECLARE_METHOD(t_BitSet, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_BitSet, intersects, METH_O),
      DECLARE_METHOD(t_BitSet, isEmpty, METH_NOARGS),
      DECLARE_METHOD(t_BitSet, length, METH_NOARGS),
      DECLARE_METHOD(t_BitSet, nextClearBit, METH_O),
      DECLARE_METHOD(t_BitSet, nextSetBit, METH_O),
      DECLARE_METHOD(t_BitSet, or, METH_O),
      DECLARE_METHOD(t_BitSet, previousClearBit, METH_O),
      DECLARE_METHOD(t_BitSet, previousSetBit, METH_O),
      DECLARE_METHOD(t_BitSet, set, METH_VARARGS),
      DECLARE_METHOD(t_BitSet, size, METH_NOARGS),
      DECLARE_METHOD(t_BitSet, toByteArray, METH_NOARGS),
      DECLARE_METHOD(t_BitSet, toLongArray, METH_NOARGS),
      DECLARE_METHOD(t_BitSet, toString, METH_VARARGS),
      DECLARE_METHOD(t_BitSet, valueOf, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_BitSet, xor, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(BitSet)[] = {
      { Py_tp_methods, t_BitSet__methods_ },
      { Py_tp_init, (void *) t_BitSet_init_ },
      { Py_tp_getset, t_BitSet__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(BitSet)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(BitSet, t_BitSet, BitSet);

    void t_BitSet::install(PyObject *module)
    {
      installType(&PY_TYPE(BitSet), &PY_TYPE_DEF(BitSet), module, "BitSet", 0);
    }

    void t_BitSet::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(BitSet), "class_", make_descriptor(BitSet::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(BitSet), "wrapfn_", make_descriptor(t_BitSet::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(BitSet), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_BitSet_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, BitSet::initializeClass, 1)))
        return NULL;
      return t_BitSet::wrap_Object(BitSet(((t_BitSet *) arg)->object.this$));
    }
    static PyObject *t_BitSet_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, BitSet::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_BitSet_init_(t_BitSet *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          BitSet object((jobject) NULL);

          INT_CALL(object = BitSet());
          self->object = object;
          break;
        }
       case 1:
        {
          jint a0;
          BitSet object((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            INT_CALL(object = BitSet(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_BitSet_and(t_BitSet *self, PyObject *arg)
    {
      BitSet a0((jobject) NULL);

      if (!parseArg(arg, "k", BitSet::initializeClass, &a0))
      {
        OBJ_CALL(self->object.and$(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "and", arg);
      return NULL;
    }

    static PyObject *t_BitSet_andNot(t_BitSet *self, PyObject *arg)
    {
      BitSet a0((jobject) NULL);

      if (!parseArg(arg, "k", BitSet::initializeClass, &a0))
      {
        OBJ_CALL(self->object.andNot(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "andNot", arg);
      return NULL;
    }

    static PyObject *t_BitSet_cardinality(t_BitSet *self)
    {
      jint result;
      OBJ_CALL(result = self->object.cardinality());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_BitSet_clear(t_BitSet *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          OBJ_CALL(self->object.clear());
          Py_RETURN_NONE;
        }
        break;
       case 1:
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.clear(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 2:
        {
          jint a0;
          jint a1;

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(self->object.clear(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "clear", args);
      return NULL;
    }

    static PyObject *t_BitSet_clone(t_BitSet *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.clone());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_BitSet_equals(t_BitSet *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(BitSet), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_BitSet_flip(t_BitSet *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.flip(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 2:
        {
          jint a0;
          jint a1;

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(self->object.flip(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "flip", args);
      return NULL;
    }

    static PyObject *t_BitSet_get(t_BitSet *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jint a0;
          jboolean result;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.get(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          jint a1;
          BitSet result((jobject) NULL);

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(result = self->object.get(a0, a1));
            return t_BitSet::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "get", args);
      return NULL;
    }

    static PyObject *t_BitSet_hashCode(t_BitSet *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(BitSet), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_BitSet_intersects(t_BitSet *self, PyObject *arg)
    {
      BitSet a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "k", BitSet::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.intersects(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "intersects", arg);
      return NULL;
    }

    static PyObject *t_BitSet_isEmpty(t_BitSet *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isEmpty());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_BitSet_length(t_BitSet *self)
    {
      jint result;
      OBJ_CALL(result = self->object.length());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_BitSet_nextClearBit(t_BitSet *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.nextClearBit(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "nextClearBit", arg);
      return NULL;
    }

    static PyObject *t_BitSet_nextSetBit(t_BitSet *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.nextSetBit(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "nextSetBit", arg);
      return NULL;
    }

    static PyObject *t_BitSet_or(t_BitSet *self, PyObject *arg)
    {
      BitSet a0((jobject) NULL);

      if (!parseArg(arg, "k", BitSet::initializeClass, &a0))
      {
        OBJ_CALL(self->object.or$(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "or", arg);
      return NULL;
    }

    static PyObject *t_BitSet_previousClearBit(t_BitSet *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.previousClearBit(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "previousClearBit", arg);
      return NULL;
    }

    static PyObject *t_BitSet_previousSetBit(t_BitSet *self, PyObject *arg)
    {
      jint a0;
      jint result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.previousSetBit(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "previousSetBit", arg);
      return NULL;
    }

    static PyObject *t_BitSet_set(t_BitSet *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.set(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 2:
        {
          jint a0;
          jboolean a1;

          if (!parseArgs(args, "IZ", &a0, &a1))
          {
            OBJ_CALL(self->object.set(a0, a1));
            Py_RETURN_NONE;
          }
        }
        {
          jint a0;
          jint a1;

          if (!parseArgs(args, "II", &a0, &a1))
          {
            OBJ_CALL(self->object.set(a0, a1));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          jint a0;
          jint a1;
          jboolean a2;

          if (!parseArgs(args, "IIZ", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.set(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "set", args);
      return NULL;
    }

    static PyObject *t_BitSet_size(t_BitSet *self)
    {
      jint result;
      OBJ_CALL(result = self->object.size());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_BitSet_toByteArray(t_BitSet *self)
    {
      JArray< jbyte > result((jobject) NULL);
      OBJ_CALL(result = self->object.toByteArray());
      return result.wrap();
    }

    static PyObject *t_BitSet_toLongArray(t_BitSet *self)
    {
      JArray< jlong > result((jobject) NULL);
      OBJ_CALL(result = self->object.toLongArray());
      return result.wrap();
    }

    static PyObject *t_BitSet_toString(t_BitSet *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(BitSet), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_BitSet_valueOf(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          JArray< jbyte > a0((jobject) NULL);
          BitSet result((jobject) NULL);

          if (!parseArgs(args, "[B", &a0))
          {
            OBJ_CALL(result = ::java::util::BitSet::valueOf(a0));
            return t_BitSet::wrap_Object(result);
          }
        }
        {
          JArray< jlong > a0((jobject) NULL);
          BitSet result((jobject) NULL);

          if (!parseArgs(args, "[J", &a0))
          {
            OBJ_CALL(result = ::java::util::BitSet::valueOf(a0));
            return t_BitSet::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError(type, "valueOf", args);
      return NULL;
    }

    static PyObject *t_BitSet_xor(t_BitSet *self, PyObject *arg)
    {
      BitSet a0((jobject) NULL);

      if (!parseArg(arg, "k", BitSet::initializeClass, &a0))
      {
        OBJ_CALL(self->object.xor$(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "xor", arg);
      return NULL;
    }

    static PyObject *t_BitSet_get__empty(t_BitSet *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isEmpty());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/TimeZone.h"
#include "java/lang/Cloneable.h"
#include "java/util/Date.h"
#include "java/lang/Class.h"
#include "java/util/Locale.h"
#include "java/lang/String.h"
#include "java/util/TimeZone.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *TimeZone::class$ = NULL;
    jmethodID *TimeZone::mids$ = NULL;
    bool TimeZone::live$ = false;
    jint TimeZone::LONG = (jint) 0;
    jint TimeZone::SHORT = (jint) 0;

    jclass TimeZone::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/TimeZone");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_clone_d6bcd06f3102c4d9] = env->getMethodID(cls, "clone", "()Ljava/lang/Object;");
        mids$[mid_getAvailableIDs_9865da0b5ee490bc] = env->getStaticMethodID(cls, "getAvailableIDs", "()[Ljava/lang/String;");
        mids$[mid_getAvailableIDs_77baa612666bd4dc] = env->getStaticMethodID(cls, "getAvailableIDs", "(I)[Ljava/lang/String;");
        mids$[mid_getDSTSavings_9972fcc56b44e79d] = env->getMethodID(cls, "getDSTSavings", "()I");
        mids$[mid_getDefault_a00e8b2cc21b09d1] = env->getStaticMethodID(cls, "getDefault", "()Ljava/util/TimeZone;");
        mids$[mid_getDisplayName_db9b55ba01e03e4b] = env->getMethodID(cls, "getDisplayName", "()Ljava/lang/String;");
        mids$[mid_getDisplayName_8cbdae2bb55ad99c] = env->getMethodID(cls, "getDisplayName", "(Ljava/util/Locale;)Ljava/lang/String;");
        mids$[mid_getDisplayName_53d4d2ff38942f2a] = env->getMethodID(cls, "getDisplayName", "(ZI)Ljava/lang/String;");
        mids$[mid_getDisplayName_4c7ef12d57704126] = env->getMethodID(cls, "getDisplayName", "(ZILjava/util/Locale;)Ljava/lang/String;");
        mids$[mid_getID_db9b55ba01e03e4b] = env->getMethodID(cls, "getID", "()Ljava/lang/String;");
        mids$[mid_getOffset_694afffd0eb7dc3c] = env->getMethodID(cls, "getOffset", "(J)I");
        mids$[mid_getOffset_df3fe101c56d5627] = env->getMethodID(cls, "getOffset", "(IIIIII)I");
        mids$[mid_getRawOffset_9972fcc56b44e79d] = env->getMethodID(cls, "getRawOffset", "()I");
        mids$[mid_getTimeZone_c54301b73801429f] = env->getStaticMethodID(cls, "getTimeZone", "(Ljava/lang/String;)Ljava/util/TimeZone;");
        mids$[mid_hasSameRules_4217a0549e90cc09] = env->getMethodID(cls, "hasSameRules", "(Ljava/util/TimeZone;)Z");
        mids$[mid_inDaylightTime_82a07bf228f15954] = env->getMethodID(cls, "inDaylightTime", "(Ljava/util/Date;)Z");
        mids$[mid_observesDaylightTime_8454bd5aa23fd11e] = env->getMethodID(cls, "observesDaylightTime", "()Z");
        mids$[mid_setDefault_62cba443b119095c] = env->getStaticMethodID(cls, "setDefault", "(Ljava/util/TimeZone;)V");
        mids$[mid_setID_9fd2eb66a64e6f0f] = env->getMethodID(cls, "setID", "(Ljava/lang/String;)V");
        mids$[mid_setRawOffset_040c4cd0390c5aff] = env->getMethodID(cls, "setRawOffset", "(I)V");
        mids$[mid_useDaylightTime_8454bd5aa23fd11e] = env->getMethodID(cls, "useDaylightTime", "()Z");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        LONG = env->getStaticIntField(cls, "LONG");
        SHORT = env->getStaticIntField(cls, "SHORT");
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    TimeZone::TimeZone() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    ::java::lang::Object TimeZone::clone() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_clone_d6bcd06f3102c4d9]));
    }

    JArray< ::java::lang::String > TimeZone::getAvailableIDs()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< ::java::lang::String >(env->callStaticObjectMethod(cls, mids$[mid_getAvailableIDs_9865da0b5ee490bc]));
    }

    JArray< ::java::lang::String > TimeZone::getAvailableIDs(jint a0)
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< ::java::lang::String >(env->callStaticObjectMethod(cls, mids$[mid_getAvailableIDs_77baa612666bd4dc], a0));
    }

    jint TimeZone::getDSTSavings() const
    {
      return env->callIntMethod(this$, mids$[mid_getDSTSavings_9972fcc56b44e79d]);
    }

    TimeZone TimeZone::getDefault()
    {
      jclass cls = env->getClass(initializeClass);
      return TimeZone(env->callStaticObjectMethod(cls, mids$[mid_getDefault_a00e8b2cc21b09d1]));
    }

    ::java::lang::String TimeZone::getDisplayName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_db9b55ba01e03e4b]));
    }

    ::java::lang::String TimeZone::getDisplayName(const ::java::util::Locale & a0) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_8cbdae2bb55ad99c], a0.this$));
    }

    ::java::lang::String TimeZone::getDisplayName(jboolean a0, jint a1) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_53d4d2ff38942f2a], a0, a1));
    }

    ::java::lang::String TimeZone::getDisplayName(jboolean a0, jint a1, const ::java::util::Locale & a2) const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_4c7ef12d57704126], a0, a1, a2.this$));
    }

    ::java::lang::String TimeZone::getID() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getID_db9b55ba01e03e4b]));
    }

    jint TimeZone::getOffset(jlong a0) const
    {
      return env->callIntMethod(this$, mids$[mid_getOffset_694afffd0eb7dc3c], a0);
    }

    jint TimeZone::getOffset(jint a0, jint a1, jint a2, jint a3, jint a4, jint a5) const
    {
      return env->callIntMethod(this$, mids$[mid_getOffset_df3fe101c56d5627], a0, a1, a2, a3, a4, a5);
    }

    jint TimeZone::getRawOffset() const
    {
      return env->callIntMethod(this$, mids$[mid_getRawOffset_9972fcc56b44e79d]);
    }

    TimeZone TimeZone::getTimeZone(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return TimeZone(env->callStaticObjectMethod(cls, mids$[mid_getTimeZone_c54301b73801429f], a0.this$));
    }

    jboolean TimeZone::hasSameRules(const TimeZone & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_hasSameRules_4217a0549e90cc09], a0.this$);
    }

    jboolean TimeZone::inDaylightTime(const ::java::util::Date & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_inDaylightTime_82a07bf228f15954], a0.this$);
    }

    jboolean TimeZone::observesDaylightTime() const
    {
      return env->callBooleanMethod(this$, mids$[mid_observesDaylightTime_8454bd5aa23fd11e]);
    }

    void TimeZone::setDefault(const TimeZone & a0)
    {
      jclass cls = env->getClass(initializeClass);
      env->callStaticVoidMethod(cls, mids$[mid_setDefault_62cba443b119095c], a0.this$);
    }

    void TimeZone::setID(const ::java::lang::String & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setID_9fd2eb66a64e6f0f], a0.this$);
    }

    void TimeZone::setRawOffset(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setRawOffset_040c4cd0390c5aff], a0);
    }

    jboolean TimeZone::useDaylightTime() const
    {
      return env->callBooleanMethod(this$, mids$[mid_useDaylightTime_8454bd5aa23fd11e]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_TimeZone_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_TimeZone_instance_(PyTypeObject *type, PyObject *arg);
    static int t_TimeZone_init_(t_TimeZone *self, PyObject *args, PyObject *kwds);
    static PyObject *t_TimeZone_clone(t_TimeZone *self);
    static PyObject *t_TimeZone_getAvailableIDs(PyTypeObject *type, PyObject *args);
    static PyObject *t_TimeZone_getDSTSavings(t_TimeZone *self);
    static PyObject *t_TimeZone_getDefault(PyTypeObject *type);
    static PyObject *t_TimeZone_getDisplayName(t_TimeZone *self, PyObject *args);
    static PyObject *t_TimeZone_getID(t_TimeZone *self);
    static PyObject *t_TimeZone_getOffset(t_TimeZone *self, PyObject *args);
    static PyObject *t_TimeZone_getRawOffset(t_TimeZone *self);
    static PyObject *t_TimeZone_getTimeZone(PyTypeObject *type, PyObject *arg);
    static PyObject *t_TimeZone_hasSameRules(t_TimeZone *self, PyObject *arg);
    static PyObject *t_TimeZone_inDaylightTime(t_TimeZone *self, PyObject *arg);
    static PyObject *t_TimeZone_observesDaylightTime(t_TimeZone *self);
    static PyObject *t_TimeZone_setDefault(PyTypeObject *type, PyObject *arg);
    static PyObject *t_TimeZone_setID(t_TimeZone *self, PyObject *arg);
    static PyObject *t_TimeZone_setRawOffset(t_TimeZone *self, PyObject *arg);
    static PyObject *t_TimeZone_useDaylightTime(t_TimeZone *self);
    static PyObject *t_TimeZone_get__availableIDs(t_TimeZone *self, void *data);
    static PyObject *t_TimeZone_get__dSTSavings(t_TimeZone *self, void *data);
    static PyObject *t_TimeZone_get__default(t_TimeZone *self, void *data);
    static int t_TimeZone_set__default(t_TimeZone *self, PyObject *arg, void *data);
    static PyObject *t_TimeZone_get__displayName(t_TimeZone *self, void *data);
    static PyObject *t_TimeZone_get__iD(t_TimeZone *self, void *data);
    static int t_TimeZone_set__iD(t_TimeZone *self, PyObject *arg, void *data);
    static PyObject *t_TimeZone_get__rawOffset(t_TimeZone *self, void *data);
    static int t_TimeZone_set__rawOffset(t_TimeZone *self, PyObject *arg, void *data);
    static PyGetSetDef t_TimeZone__fields_[] = {
      DECLARE_GET_FIELD(t_TimeZone, availableIDs),
      DECLARE_GET_FIELD(t_TimeZone, dSTSavings),
      DECLARE_GETSET_FIELD(t_TimeZone, default),
      DECLARE_GET_FIELD(t_TimeZone, displayName),
      DECLARE_GETSET_FIELD(t_TimeZone, iD),
      DECLARE_GETSET_FIELD(t_TimeZone, rawOffset),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_TimeZone__methods_[] = {
      DECLARE_METHOD(t_TimeZone, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_TimeZone, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_TimeZone, clone, METH_NOARGS),
      DECLARE_METHOD(t_TimeZone, getAvailableIDs, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_TimeZone, getDSTSavings, METH_NOARGS),
      DECLARE_METHOD(t_TimeZone, getDefault, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_TimeZone, getDisplayName, METH_VARARGS),
      DECLARE_METHOD(t_TimeZone, getID, METH_NOARGS),
      DECLARE_METHOD(t_TimeZone, getOffset, METH_VARARGS),
      DECLARE_METHOD(t_TimeZone, getRawOffset, METH_NOARGS),
      DECLARE_METHOD(t_TimeZone, getTimeZone, METH_O | METH_CLASS),
      DECLARE_METHOD(t_TimeZone, hasSameRules, METH_O),
      DECLARE_METHOD(t_TimeZone, inDaylightTime, METH_O),
      DECLARE_METHOD(t_TimeZone, observesDaylightTime, METH_NOARGS),
      DECLARE_METHOD(t_TimeZone, setDefault, METH_O | METH_CLASS),
      DECLARE_METHOD(t_TimeZone, setID, METH_O),
      DECLARE_METHOD(t_TimeZone, setRawOffset, METH_O),
      DECLARE_METHOD(t_TimeZone, useDaylightTime, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(TimeZone)[] = {
      { Py_tp_methods, t_TimeZone__methods_ },
      { Py_tp_init, (void *) t_TimeZone_init_ },
      { Py_tp_getset, t_TimeZone__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(TimeZone)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(TimeZone, t_TimeZone, TimeZone);

    void t_TimeZone::install(PyObject *module)
    {
      installType(&PY_TYPE(TimeZone), &PY_TYPE_DEF(TimeZone), module, "TimeZone", 0);
    }

    void t_TimeZone::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(TimeZone), "class_", make_descriptor(TimeZone::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(TimeZone), "wrapfn_", make_descriptor(t_TimeZone::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(TimeZone), "boxfn_", make_descriptor(boxObject));
      env->getClass(TimeZone::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(TimeZone), "LONG", make_descriptor(TimeZone::LONG));
      PyObject_SetAttrString((PyObject *) PY_TYPE(TimeZone), "SHORT", make_descriptor(TimeZone::SHORT));
    }

    static PyObject *t_TimeZone_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, TimeZone::initializeClass, 1)))
        return NULL;
      return t_TimeZone::wrap_Object(TimeZone(((t_TimeZone *) arg)->object.this$));
    }
    static PyObject *t_TimeZone_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, TimeZone::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_TimeZone_init_(t_TimeZone *self, PyObject *args, PyObject *kwds)
    {
      TimeZone object((jobject) NULL);

      INT_CALL(object = TimeZone());
      self->object = object;

      return 0;
    }

    static PyObject *t_TimeZone_clone(t_TimeZone *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.clone());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_TimeZone_getAvailableIDs(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          JArray< ::java::lang::String > result((jobject) NULL);
          OBJ_CALL(result = ::java::util::TimeZone::getAvailableIDs());
          return JArray<jstring>(result.this$).wrap();
        }
        break;
       case 1:
        {
          jint a0;
          JArray< ::java::lang::String > result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = ::java::util::TimeZone::getAvailableIDs(a0));
            return JArray<jstring>(result.this$).wrap();
          }
        }
      }

      PyErr_SetArgsError(type, "getAvailableIDs", args);
      return NULL;
    }

    static PyObject *t_TimeZone_getDSTSavings(t_TimeZone *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getDSTSavings());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_TimeZone_getDefault(PyTypeObject *type)
    {
      TimeZone result((jobject) NULL);
      OBJ_CALL(result = ::java::util::TimeZone::getDefault());
      return t_TimeZone::wrap_Object(result);
    }

    static PyObject *t_TimeZone_getDisplayName(t_TimeZone *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getDisplayName());
          return j2p(result);
        }
        break;
       case 1:
        {
          ::java::util::Locale a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::util::Locale::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getDisplayName(a0));
            return j2p(result);
          }
        }
        break;
       case 2:
        {
          jboolean a0;
          jint a1;
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "ZI", &a0, &a1))
          {
            OBJ_CALL(result = self->object.getDisplayName(a0, a1));
            return j2p(result);
          }
        }
        break;
       case 3:
        {
          jboolean a0;
          jint a1;
          ::java::util::Locale a2((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, "ZIk", ::java::util::Locale::initializeClass, &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.getDisplayName(a0, a1, a2));
            return j2p(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getDisplayName", args);
      return NULL;
    }

    static PyObject *t_TimeZone_getID(t_TimeZone *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getID());
      return j2p(result);
    }

    static PyObject *t_TimeZone_getOffset(t_TimeZone *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jlong a0;
          jint result;

          if (!parseArgs(args, "J", &a0))
          {
            OBJ_CALL(result = self->object.getOffset(a0));
            return PyLong_FromLong((long) result);
          }
        }
        break;
       case 6:
        {
          jint a0;
          jint a1;
          jint a2;
          jint a3;
          jint a4;
          jint a5;
          jint result;

          if (!parseArgs(args, "IIIIII", &a0, &a1, &a2, &a3, &a4, &a5))
          {
            OBJ_CALL(result = self->object.getOffset(a0, a1, a2, a3, a4, a5));
            return PyLong_FromLong((long) result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "getOffset", args);
      return NULL;
    }

    static PyObject *t_TimeZone_getRawOffset(t_TimeZone *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getRawOffset());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_TimeZone_getTimeZone(PyTypeObject *type, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      TimeZone result((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = ::java::util::TimeZone::getTimeZone(a0));
        return t_TimeZone::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "getTimeZone", arg);
      return NULL;
    }

    static PyObject *t_TimeZone_hasSameRules(t_TimeZone *self, PyObject *arg)
    {
      TimeZone a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "k", TimeZone::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.hasSameRules(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "hasSameRules", arg);
      return NULL;
    }

    static PyObject *t_TimeZone_inDaylightTime(t_TimeZone *self, PyObject *arg)
    {
      ::java::util::Date a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "k", ::java::util::Date::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.inDaylightTime(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "inDaylightTime", arg);
      return NULL;
    }

    static PyObject *t_TimeZone_observesDaylightTime(t_TimeZone *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.observesDaylightTime());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_TimeZone_setDefault(PyTypeObject *type, PyObject *arg)
    {
      TimeZone a0((jobject) NULL);

      if (!parseArg(arg, "k", TimeZone::initializeClass, &a0))
      {
        OBJ_CALL(::java::util::TimeZone::setDefault(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError(type, "setDefault", arg);
      return NULL;
    }

    static PyObject *t_TimeZone_setID(t_TimeZone *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(self->object.setID(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setID", arg);
      return NULL;
    }

    static PyObject *t_TimeZone_setRawOffset(t_TimeZone *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setRawOffset(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setRawOffset", arg);
      return NULL;
    }

    static PyObject *t_TimeZone_useDaylightTime(t_TimeZone *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.useDaylightTime());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_TimeZone_get__availableIDs(t_TimeZone *self, void *data)
    {
      JArray< ::java::lang::String > value((jobject) NULL);
      OBJ_CALL(value = self->object.getAvailableIDs());
      return JArray<jstring>(value.this$).wrap();
    }

    static PyObject *t_TimeZone_get__dSTSavings(t_TimeZone *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getDSTSavings());
      return PyLong_FromLong((long) value);
    }

    static PyObject *t_TimeZone_get__default(t_TimeZone *self, void *data)
    {
      TimeZone value((jobject) NULL);
      OBJ_CALL(value = self->object.getDefault());
      return t_TimeZone::wrap_Object(value);
    }
    static int t_TimeZone_set__default(t_TimeZone *self, PyObject *arg, void *data)
    {
      {
        TimeZone value((jobject) NULL);
        if (!parseArg(arg, "k", TimeZone::initializeClass, &value))
        {
          INT_CALL(self->object.setDefault(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "default", arg);
      return -1;
    }

    static PyObject *t_TimeZone_get__displayName(t_TimeZone *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getDisplayName());
      return j2p(value);
    }

    static PyObject *t_TimeZone_get__iD(t_TimeZone *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getID());
      return j2p(value);
    }
    static int t_TimeZone_set__iD(t_TimeZone *self, PyObject *arg, void *data)
    {
      {
        ::java::lang::String value((jobject) NULL);
        if (!parseArg(arg, "s", &value))
        {
          INT_CALL(self->object.setID(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "iD", arg);
      return -1;
    }

    static PyObject *t_TimeZone_get__rawOffset(t_TimeZone *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getRawOffset());
      return PyLong_FromLong((long) value);
    }
    static int t_TimeZone_set__rawOffset(t_TimeZone *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setRawOffset(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "rawOffset", arg);
      return -1;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/NumberFormatException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *NumberFormatException::class$ = NULL;
    jmethodID *NumberFormatException::mids$ = NULL;
    bool NumberFormatException::live$ = false;

    jclass NumberFormatException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/NumberFormatException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    NumberFormatException::NumberFormatException() : ::java::lang::IllegalArgumentException(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    NumberFormatException::NumberFormatException(const ::java::lang::String & a0) : ::java::lang::IllegalArgumentException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_NumberFormatException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_NumberFormatException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_NumberFormatException_init_(t_NumberFormatException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_NumberFormatException__methods_[] = {
      DECLARE_METHOD(t_NumberFormatException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_NumberFormatException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(NumberFormatException)[] = {
      { Py_tp_methods, t_NumberFormatException__methods_ },
      { Py_tp_init, (void *) t_NumberFormatException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(NumberFormatException)[] = {
      &PY_TYPE_DEF(::java::lang::IllegalArgumentException),
      NULL
    };

    DEFINE_TYPE(NumberFormatException, t_NumberFormatException, NumberFormatException);

    void t_NumberFormatException::install(PyObject *module)
    {
      installType(&PY_TYPE(NumberFormatException), &PY_TYPE_DEF(NumberFormatException), module, "NumberFormatException", 0);
    }

    void t_NumberFormatException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(NumberFormatException), "class_", make_descriptor(NumberFormatException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(NumberFormatException), "wrapfn_", make_descriptor(t_NumberFormatException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(NumberFormatException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_NumberFormatException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, NumberFormatException::initializeClass, 1)))
        return NULL;
      return t_NumberFormatException::wrap_Object(NumberFormatException(((t_NumberFormatException *) arg)->object.this$));
    }
    static PyObject *t_NumberFormatException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, NumberFormatException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_NumberFormatException_init_(t_NumberFormatException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          NumberFormatException object((jobject) NULL);

          INT_CALL(object = NumberFormatException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          NumberFormatException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = NumberFormatException(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/Parser.h"
#include "org/antlr/v4/runtime/IntStream.h"
#include "org/antlr/v4/runtime/atn/ATN.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/ParserRuleContext.h"
#include "org/antlr/v4/runtime/RecognitionException.h"
#include "java/lang/Object.h"
#include "org/antlr/v4/runtime/RuleContext.h"
#include "org/antlr/v4/runtime/TokenFactory.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "org/antlr/v4/runtime/ANTLRErrorStrategy.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/ParseInfo.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/Token.h"
#include "org/antlr/v4/runtime/atn/ParserATNSimulator.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *Parser::class$ = NULL;
        jmethodID *Parser::mids$ = NULL;
        bool Parser::live$ = false;

        jclass Parser::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/Parser");

            mids$ = new jmethodID[max_mid];
            mids$[mid_init$_c141788a4cff2a87] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/TokenStream;)V");
            mids$[mid_consume_ed548981de5895c4] = env->getMethodID(cls, "consume", "()Lorg/antlr/v4/runtime/Token;");
            mids$[mid_dumpDFA_f2cc1bce94666404] = env->getMethodID(cls, "dumpDFA", "()V");
            mids$[mid_enterOuterAlt_0c6ee6fa39ffeab1] = env->getMethodID(cls, "enterOuterAlt", "(Lorg/antlr/v4/runtime/ParserRuleContext;I)V");
            mids$[mid_enterRecursionRule_0c6ee6fa39ffeab1] = env->getMethodID(cls, "enterRecursionRule", "(Lorg/antlr/v4/runtime/ParserRuleContext;I)V");
            mids$[mid_enterRecursionRule_6175df8c2a6564bc] = env->getMethodID(cls, "enterRecursionRule", "(Lorg/antlr/v4/runtime/ParserRuleContext;III)V");
            mids$[mid_enterRule_f5e293a1e119055d] = env->getMethodID(cls, "enterRule", "(Lorg/antlr/v4/runtime/ParserRuleContext;II)V");
            mids$[mid_exitRule_f2cc1bce94666404] = env->getMethodID(cls, "exitRule", "()V");
            mids$[mid_getATNWithBypassAlts_268a26f1c0f83c9c] = env->getMethodID(cls, "getATNWithBypassAlts", "()Lorg/antlr/v4/runtime/atn/ATN;");
            mids$[mid_getBuildParseTree_8454bd5aa23fd11e] = env->getMethodID(cls, "getBuildParseTree", "()Z");
            mids$[mid_getContext_fcd99d1d10d04c76] = env->getMethodID(cls, "getContext", "()Lorg/antlr/v4/runtime/ParserRuleContext;");
            mids$[mid_getCurrentToken_ed548981de5895c4] = env->getMethodID(cls, "getCurrentToken", "()Lorg/antlr/v4/runtime/Token;");
            mids$[mid_getDFAStrings_49ec78390f08338a] = env->getMethodID(cls, "getDFAStrings", "()Ljava/util/List;");
            mids$[mid_getErrorHandler_282c48c0814cf31d] = env->getMethodID(cls, "getErrorHandler", "()Lorg/antlr/v4/runtime/ANTLRErrorStrategy;");
            mids$[mid_getInputStream_2d614d26bdc04f75] = env->getMethodID(cls, "getInputStream", "()Lorg/antlr/v4/runtime/TokenStream;");
            mids$[mid_getInvokingContext_cb5090fa21804be0] = env->getMethodID(cls, "getInvokingContext", "(I)Lorg/antlr/v4/runtime/ParserRuleContext;");
            mids$[mid_getNumberOfSyntaxErrors_9972fcc56b44e79d] = env->getMethodID(cls, "getNumberOfSyntaxErrors", "()I");
            mids$[mid_getParseInfo_cda268cdd76646ee] = env->getMethodID(cls, "getParseInfo", "()Lorg/antlr/v4/runtime/atn/ParseInfo;");
            mids$[mid_getPrecedence_9972fcc56b44e79d] = env->getMethodID(cls, "getPrecedence", "()I");
            mids$[mid_getRuleContext_fcd99d1d10d04c76] = env->getMethodID(cls, "getRuleContext", "()Lorg/antlr/v4/runtime/ParserRuleContext;");
            mids$[mid_getRuleIndex_a5a7d1128e9e2bb7] = env->getMethodID(cls, "getRuleIndex", "(Ljava/lang/String;)I");
            mids$[mid_getRuleInvocationStack_49ec78390f08338a] = env->getMethodID(cls, "getRuleInvocationStack", "()Ljava/util/List;");
            mids$[mid_getRuleInvocationStack_3fd6c87ab194fccb] = env->getMethodID(cls, "getRuleInvocationStack", "(Lorg/antlr/v4/runtime/RuleContext;)Ljava/util/List;");
            mids$[mid_getSourceName_db9b55ba01e03e4b] = env->getMethodID(cls, "getSourceName", "()Ljava/lang/String;");
            mids$[mid_getTokenFactory_9bf94c5de004cd3c] = env->getMethodID(cls, "getTokenFactory", "()Lorg/antlr/v4/runtime/TokenFactory;");
            mids$[mid_getTokenStream_2d614d26bdc04f75] = env->getMethodID(cls, "getTokenStream", "()Lorg/antlr/v4/runtime/TokenStream;");
            mids$[mid_getTrimParseTree_8454bd5aa23fd11e] = env->getMethodID(cls, "getTrimParseTree", "()Z");
            mids$[mid_inContext_145b2d0af0c06b93] = env->getMethodID(cls, "inContext", "(Ljava/lang/String;)Z");
            mids$[mid_isExpectedToken_a1d30e1ee40c89a2] = env->getMethodID(cls, "isExpectedToken", "(I)Z");
            mids$[mid_isMatchedEOF_8454bd5aa23fd11e] = env->getMethodID(cls, "isMatchedEOF", "()Z");
            mids$[mid_isTrace_8454bd5aa23fd11e] = env->getMethodID(cls, "isTrace", "()Z");
            mids$[mid_match_42cc671c2f94ca07] = env->getMethodID(cls, "match", "(I)Lorg/antlr/v4/runtime/Token;");
            mids$[mid_matchWildcard_ed548981de5895c4] = env->getMethodID(cls, "matchWildcard", "()Lorg/antlr/v4/runtime/Token;");
            mids$[mid_notifyErrorListeners_9fd2eb66a64e6f0f] = env->getMethodID(cls, "notifyErrorListeners", "(Ljava/lang/String;)V");
            mids$[mid_notifyErrorListeners_dee80b059c971fe0] = env->getMethodID(cls, "notifyErrorListeners", "(Lorg/antlr/v4/runtime/Token;Ljava/lang/String;Lorg/antlr/v4/runtime/RecognitionException;)V");
            mids$[mid_precpred_62eb40dbc3bda79d] = env->getMethodID(cls, "precpred", "(Lorg/antlr/v4/runtime/RuleContext;I)Z");
            mids$[mid_pushNewRecursionContext_f5e293a1e119055d] = env->getMethodID(cls, "pushNewRecursionContext", "(Lorg/antlr/v4/runtime/ParserRuleContext;II)V");
            mids$[mid_removeParseListeners_f2cc1bce94666404] = env->getMethodID(cls, "removeParseListeners", "()V");
            mids$[mid_reset_f2cc1bce94666404] = env->getMethodID(cls, "reset", "()V");
            mids$[mid_setBuildParseTree_9d72768e8fdce2b7] = env->getMethodID(cls, "setBuildParseTree", "(Z)V");
            mids$[mid_setContext_a659ccb039b5e018] = env->getMethodID(cls, "setContext", "(Lorg/antlr/v4/runtime/ParserRuleContext;)V");
            mids$[mid_setErrorHandler_a5bd85e4e1bb1a03] = env->getMethodID(cls, "setErrorHandler", "(Lorg/antlr/v4/runtime/ANTLRErrorStrategy;)V");
            mids$[mid_setInputStream_316a0f0e15ab92d4] = env->getMethodID(cls, "setInputStream", "(Lorg/antlr/v4/runtime/IntStream;)V");
            mids$[mid_setProfile_9d72768e8fdce2b7] = env->getMethodID(cls, "setProfile", "(Z)V");
            mids$[mid_setTokenFactory_a25e147938e67e01] = env->getMethodID(cls, "setTokenFactory", "(Lorg/antlr/v4/runtime/TokenFactory;)V");
            mids$[mid_setTokenStream_c141788a4cff2a87] = env->getMethodID(cls, "setTokenStream", "(Lorg/antlr/v4/runtime/TokenStream;)V");
            mids$[mid_setTrace_9d72768e8fdce2b7] = env->getMethodID(cls, "setTrace", "(Z)V");
            mids$[mid_setTrimParseTree_9d72768e8fdce2b7] = env->getMethodID(cls, "setTrimParseTree", "(Z)V");
            mids$[mid_unrollRecursionContexts_a659ccb039b5e018] = env->getMethodID(cls, "unrollRecursionContexts", "(Lorg/antlr/v4/runtime/ParserRuleContext;)V");
            mids$[mid_triggerExitRuleEvent_f2cc1bce94666404] = env->getMethodID(cls, "triggerExitRuleEvent", "()V");
            mids$[mid_triggerEnterRuleEvent_f2cc1bce94666404] = env->getMethodID(cls, "triggerEnterRuleEvent", "()V");
            mids$[mid_addContextToParseTree_f2cc1bce94666404] = env->getMethodID(cls, "addContextToParseTree", "()V");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        Parser::Parser(const ::org::antlr::v4::runtime::TokenStream & a0) : ::org::antlr::v4::runtime::Recognizer(env->newObject(initializeClass, &mids$, mid_init$_c141788a4cff2a87, a0.this$)) {}

        ::org::antlr::v4::runtime::Token Parser::consume() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_consume_ed548981de5895c4]));
        }

        void Parser::dumpDFA() const
        {
          env->callVoidMethod(this$, mids$[mid_dumpDFA_f2cc1bce94666404]);
        }

        void Parser::enterOuterAlt(const ::org::antlr::v4::runtime::ParserRuleContext & a0, jint a1) const
        {
          env->callVoidMethod(this$, mids$[mid_enterOuterAlt_0c6ee6fa39ffeab1], a0.this$, a1);
        }

        void Parser::enterRecursionRule(const ::org::antlr::v4::runtime::ParserRuleContext & a0, jint a1) const
        {
          env->callVoidMethod(this$, mids$[mid_enterRecursionRule_0c6ee6fa39ffeab1], a0.this$, a1);
        }

        void Parser::enterRecursionRule(const ::org::antlr::v4::runtime::ParserRuleContext & a0, jint a1, jint a2, jint a3) const
        {
          env->callVoidMethod(this$, mids$[mid_enterRecursionRule_6175df8c2a6564bc], a0.this$, a1, a2, a3);
        }

        void Parser::enterRule(const ::org::antlr::v4::runtime::ParserRuleContext & a0, jint a1, jint a2) const
        {
          env->callVoidMethod(this$, mids$[mid_enterRule_f5e293a1e119055d], a0.this$, a1, a2);
        }

        void Parser::exitRule() const
        {
          env->callVoidMethod(this$, mids$[mid_exitRule_f2cc1bce94666404]);
        }

        ::org::antlr::v4::runtime::atn::ATN Parser::getATNWithBypassAlts() const
        {
          return ::org::antlr::v4::runtime::atn::ATN(env->callObjectMethod(this$, mids$[mid_getATNWithBypassAlts_268a26f1c0f83c9c]));
        }

        jboolean Parser::getBuildParseTree() const
        {
          return env->callBooleanMethod(this$, mids$[mid_getBuildParseTree_8454bd5aa23fd11e]);
        }

        ::org::antlr::v4::runtime::ParserRuleContext Parser::getContext() const
        {
          return ::org::antlr::v4::runtime::ParserRuleContext(env->callObjectMethod(this$, mids$[mid_getContext_fcd99d1d10d04c76]));
        }

        ::org::antlr::v4::runtime::Token Parser::getCurrentToken() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_getCurrentToken_ed548981de5895c4]));
        }

        ::java::util::List Parser::getDFAStrings() const
        {
          return ::java::util::List(env->callObjectMethod(this$, mids$[mid_getDFAStrings_49ec78390f08338a]));
        }

        ::org::antlr::v4::runtime::ANTLRErrorStrategy Parser::getErrorHandler() const
        {
          return ::org::antlr::v4::runtime::ANTLRErrorStrategy(env->callObjectMethod(this$, mids$[mid_getErrorHandler_282c48c0814cf31d]));
        }

        ::org::antlr::v4::runtime::TokenStream Parser::getInputStream() const
        {
          return ::org::antlr::v4::runtime::TokenStream(env->callObjectMethod(this$, mids$[mid_getInputStream_2d614d26bdc04f75]));
        }

        ::org::antlr::v4::runtime::ParserRuleContext Parser::getInvokingContext(jint a0) const
        {
          return ::org::antlr::v4::runtime::ParserRuleContext(env->callObjectMethod(this$, mids$[mid_getInvokingContext_cb5090fa21804be0], a0));
        }

        jint Parser::getNumberOfSyntaxErrors() const
        {
          return env->callIntMethod(this$, mids$[mid_getNumberOfSyntaxErrors_9972fcc56b44e79d]);
        }

        ::org::antlr::v4::runtime::atn::ParseInfo Parser::getParseInfo() const
        {
          return ::org::antlr::v4::runtime::atn::ParseInfo(env->callObjectMethod(this$, mids$[mid_getParseInfo_cda268cdd76646ee]));
        }

        jint Parser::getPrecedence() const
        {
          return env->callIntMethod(this$, mids$[mid_getPrecedence_9972fcc56b44e79d]);
        }

        ::org::antlr::v4::runtime::ParserRuleContext Parser::getRuleContext() const
        {
          return ::org::antlr::v4::runtime::ParserRuleContext(env->callObjectMethod(this$, mids$[mid_getRuleContext_fcd99d1d10d04c76]));
        }

        jint Parser::getRuleIndex(const ::java::lang::String & a0) const
        {
          return env->callIntMethod(this$, mids$[mid_getRuleIndex_a5a7d1128e9e2bb7], a0.this$);
        }

        ::java::util::List Parser::getRuleInvocationStack() const
        {
          return ::java::util::List(env->callObjectMethod(this$, mids$[mid_getRuleInvocationStack_49ec78390f08338a]));
        }

        ::java::util::List Parser::getRuleInvocationStack(const ::org::antlr::v4::runtime::RuleContext & a0) const
        {
          return ::java::util::List(env->callObjectMethod(this$, mids$[mid_getRuleInvocationStack_3fd6c87ab194fccb], a0.this$));
        }

        ::java::lang::String Parser::getSourceName() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSourceName_db9b55ba01e03e4b]));
        }

        ::org::antlr::v4::runtime::TokenFactory Parser::getTokenFactory() const
        {
          return ::org::antlr::v4::runtime::TokenFactory(env->callObjectMethod(this$, mids$[mid_getTokenFactory_9bf94c5de004cd3c]));
        }

        ::org::antlr::v4::runtime::TokenStream Parser::getTokenStream() const
        {
          return ::org::antlr::v4::runtime::TokenStream(env->callObjectMethod(this$, mids$[mid_getTokenStream_2d614d26bdc04f75]));
        }

        jboolean Parser::getTrimParseTree() const
        {
          return env->callBooleanMethod(this$, mids$[mid_getTrimParseTree_8454bd5aa23fd11e]);
        }

        jboolean Parser::inContext(const ::java::lang::String & a0) const
        {
          return env->callBooleanMethod(this$, mids$[mid_inContext_145b2d0af0c06b93], a0.this$);
        }

        jboolean Parser::isExpectedToken(jint a0) const
        {
          return env->callBooleanMethod(this$, mids$[mid_isExpectedToken_a1d30e1ee40c89a2], a0);
        }

        jboolean Parser::isMatchedEOF() const
        {
          return env->callBooleanMethod(this$, mids$[mid_isMatchedEOF_8454bd5aa23fd11e]);
        }

        jboolean Parser::isTrace() const
        {
          return env->callBooleanMethod(this$, mids$[mid_isTrace_8454bd5aa23fd11e]);
        }

        ::org::antlr::v4::runtime::Token Parser::match(jint a0) const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_match_42cc671c2f94ca07], a0));
        }

        ::org::antlr::v4::runtime::Token Parser::matchWildcard() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_matchWildcard_ed548981de5895c4]));
        }

        void Parser::notifyErrorListeners(const ::java::lang::String & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_notifyErrorListeners_9fd2eb66a64e6f0f], a0.this$);
        }

        void Parser::notifyErrorListeners(const ::org::antlr::v4::runtime::Token & a0, const ::java::lang::String & a1, const ::org::antlr::v4::runtime::RecognitionException & a2) const
        {
          env->callVoidMethod(this$, mids$[mid_notifyErrorListeners_dee80b059c971fe0], a0.this$, a1.this$, a2.this$);
        }

        jboolean Parser::precpred(const ::org::antlr::v4::runtime::RuleContext & a0, jint a1) const
        {
          return env->callBooleanMethod(this$, mids$[mid_precpred_62eb40dbc3bda79d], a0.this$, a1);
        }

        void Parser::pushNewRecursionContext(const ::org::antlr::v4::runtime::ParserRuleContext & a0, jint a1, jint a2) const
        {
          env->callVoidMethod(this$, mids$[mid_pushNewRecursionContext_f5e293a1e119055d], a0.this$, a1, a2);
        }

        void Parser::removeParseListeners() const
        {
          env->callVoidMethod(this$, mids$[mid_removeParseListeners_f2cc1bce94666404]);
        }

        void Parser::reset() const
        {
          env->callVoidMethod(this$, mids$[mid_reset_f2cc1bce94666404]);
        }

        void Parser::setBuildParseTree(jboolean a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setBuildParseTree_9d72768e8fdce2b7], a0);
        }

        void Parser::setContext(const ::org::antlr::v4::runtime::ParserRuleContext & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setContext_a659ccb039b5e018], a0.this$);
        }

        void Parser::setErrorHandler(const ::org::antlr::v4::runtime::ANTLRErrorStrategy & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setErrorHandler_a5bd85e4e1bb1a03], a0.this$);
        }

        void Parser::setInputStream(const ::org::antlr::v4::runtime::IntStream & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setInputStream_316a0f0e15ab92d4], a0.this$);
        }

        void Parser::setProfile(jboolean a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setProfile_9d72768e8fdce2b7], a0);
        }

        void Parser::setTokenFactory(const ::org::antlr::v4::runtime::TokenFactory & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setTokenFactory_a25e147938e67e01], a0.this$);
        }

        void Parser::setTokenStream(const ::org::antlr::v4::runtime::TokenStream & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setTokenStream_c141788a4cff2a87], a0.this$);
        }

        void Parser::setTrace(jboolean a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setTrace_9d72768e8fdce2b7], a0);
        }

        void Parser::setTrimParseTree(jboolean a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setTrimParseTree_9d72768e8fdce2b7], a0);
        }

        void Parser::unrollRecursionContexts(const ::org::antlr::v4::runtime::ParserRuleContext & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_unrollRecursionContexts_a659ccb039b5e018], a0.this$);
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_Parser_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Parser_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Parser_of_(t_Parser *self, PyObject *args);
        static int t_Parser_init_(t_Parser *self, PyObject *args, PyObject *kwds);
        static PyObject *t_Parser_consume(t_Parser *self);
        static PyObject *t_Parser_dumpDFA(t_Parser *self);
        static PyObject *t_Parser_enterOuterAlt(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_enterRecursionRule(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_enterRule(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_exitRule(t_Parser *self);
        static PyObject *t_Parser_getATNWithBypassAlts(t_Parser *self);
        static PyObject *t_Parser_getBuildParseTree(t_Parser *self);
        static PyObject *t_Parser_getContext(t_Parser *self);
        static PyObject *t_Parser_getCurrentToken(t_Parser *self);
        static PyObject *t_Parser_getDFAStrings(t_Parser *self);
        static PyObject *t_Parser_getErrorHandler(t_Parser *self);
        static PyObject *t_Parser_getInputStream(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_getInvokingContext(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_getNumberOfSyntaxErrors(t_Parser *self);
        static PyObject *t_Parser_getParseInfo(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_getPrecedence(t_Parser *self);
        static PyObject *t_Parser_getRuleContext(t_Parser *self);
        static PyObject *t_Parser_getRuleIndex(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_getRuleInvocationStack(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_getSourceName(t_Parser *self);
        static PyObject *t_Parser_getTokenFactory(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_getTokenStream(t_Parser *self);
        static PyObject *t_Parser_getTrimParseTree(t_Parser *self);
        static PyObject *t_Parser_inContext(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_isExpectedToken(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_isMatchedEOF(t_Parser *self);
        static PyObject *t_Parser_isTrace(t_Parser *self);
        static PyObject *t_Parser_match(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_matchWildcard(t_Parser *self);
        static PyObject *t_Parser_notifyErrorListeners(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_precpred(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_pushNewRecursionContext(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_removeParseListeners(t_Parser *self);
        static PyObject *t_Parser_reset(t_Parser *self);
        static PyObject *t_Parser_setBuildParseTree(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_setContext(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_setErrorHandler(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_setInputStream(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_setProfile(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_setTokenFactory(t_Parser *self, PyObject *args);
        static PyObject *t_Parser_setTokenStream(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_setTrace(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_setTrimParseTree(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_unrollRecursionContexts(t_Parser *self, PyObject *arg);
        static PyObject *t_Parser_get__aTNWithBypassAlts(t_Parser *self, void *data);
        static PyObject *t_Parser_get__buildParseTree(t_Parser *self, void *data);
        static int t_Parser_set__buildParseTree(t_Parser *self, PyObject *arg, void *data);
        static PyObject *t_Parser_get__context(t_Parser *self, void *data);
        static int t_Parser_set__context(t_Parser *self, PyObject *arg, void *data);
        static PyObject *t_Parser_get__currentToken(t_Parser *self, void *data);
        static PyObject *t_Parser_get__dFAStrings(t_Parser *self, void *data);
        static PyObject *t_Parser_get__errorHandler(t_Parser *self, void *data);
        static int t_Parser_set__errorHandler(t_Parser *self, PyObject *arg, void *data);
        static PyObject *t_Parser_get__inputStream(t_Parser *self, void *data);
        static int t_Parser_set__inputStream(t_Parser *self, PyObject *arg, void *data);
        static PyObject *t_Parser_get__matchedEOF(t_Parser *self, void *data);
        static PyObject *t_Parser_get__numberOfSyntaxErrors(t_Parser *self, void *data);
        static PyObject *t_Parser_get__parseInfo(t_Parser *self, void *data);
        static PyObject *t_Parser_get__precedence(t_Parser *self, void *data);
        static int t_Parser_set__profile(t_Parser *self, PyObject *arg, void *data);
        static PyObject *t_Parser_get__ruleContext(t_Parser *self, void *data);
        static PyObject *t_Parser_get__ruleInvocationStack(t_Parser *self, void *data);
        static PyObject *t_Parser_get__sourceName(t_Parser *self, void *data);
        static PyObject *t_Parser_get__tokenFactory(t_Parser *self, void *data);
        static int t_Parser_set__tokenFactory(t_Parser *self, PyObject *arg, void *data);
        static PyObject *t_Parser_get__tokenStream(t_Parser *self, void *data);
        static int t_Parser_set__tokenStream(t_Parser *self, PyObject *arg, void *data);
        static PyObject *t_Parser_get__trace(t_Parser *self, void *data);
        static int t_Parser_set__trace(t_Parser *self, PyObject *arg, void *data);
        static PyObject *t_Parser_get__trimParseTree(t_Parser *self, void *data);
        static int t_Parser_set__trimParseTree(t_Parser *self, PyObject *arg, void *data);
        static PyObject *t_Parser_get__parameters_(t_Parser *self, void *data);
        static PyGetSetDef t_Parser__fields_[] = {
          DECLARE_GET_FIELD(t_Parser, aTNWithBypassAlts),
          DECLARE_GETSET_FIELD(t_Parser, buildParseTree),
          DECLARE_GETSET_FIELD(t_Parser, context),
          DECLARE_GET_FIELD(t_Parser, currentToken),
          DECLARE_GET_FIELD(t_Parser, dFAStrings),
          DECLARE_GETSET_FIELD(t_Parser, errorHandler),
          DECLARE_GETSET_FIELD(t_Parser, inputStream),
          DECLARE_GET_FIELD(t_Parser, matchedEOF),
          DECLARE_GET_FIELD(t_Parser, numberOfSyntaxErrors),
          DECLARE_GET_FIELD(t_Parser, parseInfo),
          DECLARE_GET_FIELD(t_Parser, precedence),
          DECLARE_SET_FIELD(t_Parser, profile),
          DECLARE_GET_FIELD(t_Parser, ruleContext),
          DECLARE_GET_FIELD(t_Parser, ruleInvocationStack),
          DECLARE_GET_FIELD(t_Parser, sourceName),
          DECLARE_GETSET_FIELD(t_Parser, tokenFactory),
          DECLARE_GETSET_FIELD(t_Parser, tokenStream),
          DECLARE_GETSET_FIELD(t_Parser, trace),
          DECLARE_GETSET_FIELD(t_Parser, trimParseTree),
          DECLARE_GET_FIELD(t_Parser, parameters_),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_Parser__methods_[] = {
          DECLARE_METHOD(t_Parser, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Parser, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Parser, of_, METH_VARARGS),
          DECLARE_METHOD(t_Parser, consume, METH_NOARGS),
          DECLARE_METHOD(t_Parser, dumpDFA, METH_NOARGS),
          DECLARE_METHOD(t_Parser, enterOuterAlt, METH_VARARGS),
          DECLARE_METHOD(t_Parser, enterRecursionRule, METH_VARARGS),
          DECLARE_METHOD(t_Parser, enterRule, METH_VARARGS),
          DECLARE_METHOD(t_Parser, exitRule, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getATNWithBypassAlts, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getBuildParseTree, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getContext, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getCurrentToken, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getDFAStrings, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getErrorHandler, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getInputStream, METH_VARARGS),
          DECLARE_METHOD(t_Parser, getInvokingContext, METH_O),
          DECLARE_METHOD(t_Parser, getNumberOfSyntaxErrors, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getParseInfo, METH_VARARGS),
          DECLARE_METHOD(t_Parser, getPrecedence, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getRuleContext, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getRuleIndex, METH_O),
          DECLARE_METHOD(t_Parser, getRuleInvocationStack, METH_VARARGS),
          DECLARE_METHOD(t_Parser, getSourceName, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getTokenFactory, METH_VARARGS),
          DECLARE_METHOD(t_Parser, getTokenStream, METH_NOARGS),
          DECLARE_METHOD(t_Parser, getTrimParseTree, METH_NOARGS),
          DECLARE_METHOD(t_Parser, inContext, METH_O),
          DECLARE_METHOD(t_Parser, isExpectedToken, METH_O),
          DECLARE_METHOD(t_Parser, isMatchedEOF, METH_NOARGS),
          DECLARE_METHOD(t_Parser, isTrace, METH_NOARGS),
          DECLARE_METHOD(t_Parser, match, METH_O),
          DECLARE_METHOD(t_Parser, matchWildcard, METH_NOARGS),
          DECLARE_METHOD(t_Parser, notifyErrorListeners, METH_VARARGS),
          DECLARE_METHOD(t_Parser, precpred, METH_VARARGS),
          DECLARE_METHOD(t_Parser, pushNewRecursionContext, METH_VARARGS),
          DECLARE_METHOD(t_Parser, removeParseListeners, METH_NOARGS),
          DECLARE_METHOD(t_Parser, reset, METH_NOARGS),
          DECLARE_METHOD(t_Parser, setBuildParseTree, METH_O),
          DECLARE_METHOD(t_Parser, setContext, METH_O),
          DECLARE_METHOD(t_Parser, setErrorHandler, METH_O),
          DECLARE_METHOD(t_Parser, setInputStream, METH_VARARGS),
          DECLARE_METHOD(t_Parser, setProfile, METH_O),
          DECLARE_METHOD(t_Parser, setTokenFactory, METH_VARARGS),
          DECLARE_METHOD(t_Parser, setTokenStream, METH_O),
          DECLARE_METHOD(t_Parser, setTrace, METH_O),
          DECLARE_METHOD(t_Parser, setTrimParseTree, METH_O),
          DECLARE_METHOD(t_Parser, unrollRecursionContexts, METH_O),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(Parser)[] = {
          { Py_tp_methods, t_Parser__methods_ },
          { Py_tp_init, (void *) t_Parser_init_ },
          { Py_tp_getset, t_Parser__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(Parser)[] = {
          &PY_TYPE_DEF(::org::antlr::v4::runtime::Recognizer),
          NULL
        };

        DEFINE_TYPE(Parser, t_Parser, Parser);
        PyObject *t_Parser::wrap_Object(const Parser& object, PyTypeObject *p0, PyTypeObject *p1)
        {
          PyObject *obj = t_Parser::wrap_Object(object);
          if (obj != NULL && obj != Py_None)
          {
            t_Parser *self = (t_Parser *) obj;
            self->parameters[0] = p0;
            self->parameters[1] = p1;
          }
          return obj;
        }

        PyObject *t_Parser::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
        {
          PyObject *obj = t_Parser::wrap_jobject(object);
          if (obj != NULL && obj != Py_None)
          {
            t_Parser *self = (t_Parser *) obj;
            self->parameters[0] = p0;
            self->parameters[1] = p1;
          }
          return obj;
        }

        void t_Parser::install(PyObject *module)
        {
          installType(&PY_TYPE(Parser), &PY_TYPE_DEF(Parser), module, "Parser", 0);
        }

        void t_Parser::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(Parser), "class_", make_descriptor(Parser::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Parser), "wrapfn_", make_descriptor(t_Parser::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Parser), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_Parser_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, Parser::initializeClass, 1)))
            return NULL;
          return t_Parser::wrap_Object(Parser(((t_Parser *) arg)->object.this$));
        }
        static PyObject *t_Parser_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, Parser::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_Parser_of_(t_Parser *self, PyObject *args)
        {
          if (!parseArg(args, "T", 2, &(self->parameters)))
            Py_RETURN_SELF;
          return PyErr_SetArgsError((PyObject *) self, "of_", args);
        }

        static int t_Parser_init_(t_Parser *self, PyObject *args, PyObject *kwds)
        {
          ::org::antlr::v4::runtime::TokenStream a0((jobject) NULL);
          Parser object((jobject) NULL);

          if (!parseArgs(args, "k", ::org::antlr::v4::runtime::TokenStream::initializeClass, &a0))
          {
            INT_CALL(object = Parser(a0));
            self->object = object;
            self->parameters[0] = ::org::antlr::v4::runtime::PY_TYPE(Token);
            self->parameters[1] = ::org::antlr::v4::runtime::atn::PY_TYPE(ParserATNSimulator);
          }
          else
          {
            PyErr_SetArgsError((PyObject *) self, "__init__", args);
            return -1;
          }

          return 0;
        }

        static PyObject *t_Parser_consume(t_Parser *self)
        {
          ::org::antlr::v4::runtime::Token result((jobject) NULL);
          OBJ_CALL(result = self->object.consume());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
        }

        static PyObject *t_Parser_dumpDFA(t_Parser *self)
        {
          OBJ_CALL(self->object.dumpDFA());
          Py_RETURN_NONE;
        }

        static PyObject *t_Parser_enterOuterAlt(t_Parser *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::ParserRuleContext a0((jobject) NULL);
          jint a1;

          if (!parseArgs(args, "kI", ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &a1))
          {
            OBJ_CALL(self->object.enterOuterAlt(a0, a1));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "enterOuterAlt", args);
          return NULL;
        }

        static PyObject *t_Parser_enterRecursionRule(t_Parser *self, PyObject *args)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 2:
            {
              ::org::antlr::v4::runtime::ParserRuleContext a0((jobject) NULL);
              jint a1;

              if (!parseArgs(args, "kI", ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &a1))
              {
                OBJ_CALL(self->object.enterRecursionRule(a0, a1));
                Py_RETURN_NONE;
              }
            }
            break;
           case 4:
            {
              ::org::antlr::v4::runtime::ParserRuleContext a0((jobject) NULL);
              jint a1;
              jint a2;
              jint a3;

              if (!parseArgs(args, "kIII", ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &a1, &a2, &a3))
              {
                OBJ_CALL(self->object.enterRecursionRule(a0, a1, a2, a3));
                Py_RETURN_NONE;
              }
            }
          }

          PyErr_SetArgsError((PyObject *) self, "enterRecursionRule", args);
          return NULL;
        }

        static PyObject *t_Parser_enterRule(t_Parser *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::ParserRuleContext a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "kII", ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.enterRule(a0, a1, a2));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "enterRule", args);
          return NULL;
        }

        static PyObject *t_Parser_exitRule(t_Parser *self)
        {
          OBJ_CALL(self->object.exitRule());
          Py_RETURN_NONE;
        }

        static PyObject *t_Parser_getATNWithBypassAlts(t_Parser *self)
        {
          ::org::antlr::v4::runtime::atn::ATN result((jobject) NULL);
          OBJ_CALL(result = self->object.getATNWithBypassAlts());
          return ::org::antlr::v4::runtime::atn::t_ATN::wrap_Object(result);
        }

        static PyObject *t_Parser_getBuildParseTree(t_Parser *self)
        {
          jboolean result;
          OBJ_CALL(result = self->object.getBuildParseTree());
          Py_RETURN_BOOL(result);
        }

        static PyObject *t_Parser_getContext(t_Parser *self)
        {
          ::org::antlr::v4::runtime::ParserRuleContext result((jobject) NULL);
          OBJ_CALL(result = self->object.getContext());
          return ::org::antlr::v4::runtime::t_ParserRuleContext::wrap_Object(result);
        }

        static PyObject *t_Parser_getCurrentToken(t_Parser *self)
        {
          ::org::antlr::v4::runtime::Token result((jobject) NULL);
          OBJ_CALL(result = self->object.getCurrentToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
        }

        static PyObject *t_Parser_getDFAStrings(t_Parser *self)
        {
          ::java::util::List result((jobject) NULL);
          OBJ_CALL(result = self->object.getDFAStrings());
          return ::java::util::t_List::wrap_Object(result, ::java::lang::PY_TYPE(String));
        }

        static PyObject *t_Parser_getErrorHandler(t_Parser *self)
        {
          ::org::antlr::v4::runtime::ANTLRErrorStrategy result((jobject) NULL);
          OBJ_CALL(result = self->object.getErrorHandler());
          return ::org::antlr::v4::runtime::t_ANTLRErrorStrategy::wrap_Object(result);
        }

        static PyObject *t_Parser_getInputStream(t_Parser *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::TokenStream result((jobject) NULL);

          if (!parseArgs(args, ""))
          {
            OBJ_CALL(result = self->object.getInputStream());
            return ::org::antlr::v4::runtime::t_TokenStream::wrap_Object(result);
          }

          return callSuper(PY_TYPE(Parser), (PyObject *) self, "getInputStream", args, 2);
        }

        static PyObject *t_Parser_getInvokingContext(t_Parser *self, PyObject *arg)
        {
          jint a0;
          ::org::antlr::v4::runtime::ParserRuleContext result((jobject) NULL);

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.getInvokingContext(a0));
            return ::org::antlr::v4::runtime::t_ParserRuleContext::wrap_Object(result);
          }

          PyErr_SetArgsError((PyObject *) self, "getInvokingContext", arg);
          return NULL;
        }

        static PyObject *t_Parser_getNumberOfSyntaxErrors(t_Parser *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getNumberOfSyntaxErrors());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Parser_getParseInfo(t_Parser *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::atn::ParseInfo result((jobject) NULL);

          if (!parseArgs(args, ""))
          {
            OBJ_CALL(result = self->object.getParseInfo());
            return ::org::antlr::v4::runtime::atn::t_ParseInfo::wrap_Object(result);
          }

          return callSuper(PY_TYPE(Parser), (PyObject *) self, "getParseInfo", args, 2);
        }

        static PyObject *t_Parser_getPrecedence(t_Parser *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getPrecedence());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Parser_getRuleContext(t_Parser *self)
        {
          ::org::antlr::v4::runtime::ParserRuleContext result((jobject) NULL);
          OBJ_CALL(result = self->object.getRuleContext());
          return ::org::antlr::v4::runtime::t_ParserRuleContext::wrap_Object(result);
        }

        static PyObject *t_Parser_getRuleIndex(t_Parser *self, PyObject *arg)
        {
          ::java::lang::String a0((jobject) NULL);
          jint result;

          if (!parseArg(arg, "s", &a0))
          {
            OBJ_CALL(result = self->object.getRuleIndex(a0));
            return PyLong_FromLong((long) result);
          }

          PyErr_SetArgsError((PyObject *) self, "getRuleIndex", arg);
          return NULL;
        }

        static PyObject *t_Parser_getRuleInvocationStack(t_Parser *self, PyObject *args)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 0:
            {
              ::java::util::List result((jobject) NULL);
              OBJ_CALL(result = self->object.getRuleInvocationStack());
              return ::java::util::t_List::wrap_Object(result, ::java::lang::PY_TYPE(String));
            }
            break;
           case 1:
            {
              ::org::antlr::v4::runtime::RuleContext a0((jobject) NULL);
              ::java::util::List result((jobject) NULL);

              if (!parseArgs(args, "k", ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0))
              {
                OBJ_CALL(result = self->object.getRuleInvocationStack(a0));
                return ::java::util::t_List::wrap_Object(result, ::java::lang::PY_TYPE(String));
              }
            }
          }

          PyErr_SetArgsError((PyObject *) self, "getRuleInvocationStack", args);
          return NULL;
        }

        static PyObject *t_Parser_getSourceName(t_Parser *self)
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getSourceName());
          return j2p(result);
        }

        static PyObject *t_Parser_getTokenFactory(t_Parser *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::TokenFactory result((jobject) NULL);

          if (!parseArgs(args, ""))
          {
            OBJ_CALL(result = self->object.getTokenFactory());
            return ::org::antlr::v4::runtime::t_TokenFactory::wrap_Object(result);
          }

          return callSuper(PY_TYPE(Parser), (PyObject *) self, "getTokenFactory", args, 2);
        }

        static PyObject *t_Parser_getTokenStream(t_Parser *self)
        {
          ::org::antlr::v4::runtime::TokenStream result((jobject) NULL);
          OBJ_CALL(result = self->object.getTokenStream());
          return ::org::antlr::v4::runtime::t_TokenStream::wrap_Object(result);
        }

        static PyObject *t_Parser_getTrimParseTree(t_Parser *self)
        {
          jboolean result;
          OBJ_CALL(result = self->object.getTrimParseTree());
          Py_RETURN_BOOL(result);
        }

        static PyObject *t_Parser_inContext(t_Parser *self, PyObject *arg)
        {
          ::java::lang::String a0((jobject) NULL);
          jboolean result;

          if (!parseArg(arg, "s", &a0))
          {
            OBJ_CALL(result = self->object.inContext(a0));
            Py_RETURN_BOOL(result);
          }

          PyErr_SetArgsError((PyObject *) self, "inContext", arg);
          return NULL;
        }

        static PyObject *t_Parser_isExpectedToken(t_Parser *self, PyObject *arg)
        {
          jint a0;
          jboolean result;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.isExpectedToken(a0));
            Py_RETURN_BOOL(result);
          }

          PyErr_SetArgsError((PyObject *) self, "isExpectedToken", arg);
          return NULL;
        }

        static PyObject *t_Parser_isMatchedEOF(t_Parser *self)
        {
          jboolean result;
          OBJ_CALL(result = self->object.isMatchedEOF());
          Py_RETURN_BOOL(result);
        }

        static PyObject *t_Parser_isTrace(t_Parser *self)
        {
          jboolean result;
          OBJ_CALL(result = self->object.isTrace());
          Py_RETURN_BOOL(result);
        }

        static PyObject *t_Parser_match(t_Parser *self, PyObject *arg)
        {
          jint a0;
          ::org::antlr::v4::runtime::Token result((jobject) NULL);

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.match(a0));
            return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
          }

          PyErr_SetArgsError((PyObject *) self, "match", arg);
          return NULL;
        }

        static PyObject *t_Parser_matchWildcard(t_Parser *self)
        {
          ::org::antlr::v4::runtime::Token result((jobject) NULL);
          OBJ_CALL(result = self->object.matchWildcard());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
        }

        static PyObject *t_Parser_notifyErrorListeners(t_Parser *self, PyObject *args)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 1:
            {
              ::java::lang::String a0((jobject) NULL);

              if (!parseArgs(args, "s", &a0))
              {
                OBJ_CALL(self->object.notifyErrorListeners(a0));
                Py_RETURN_NONE;
              }
            }
            break;
           case 3:
            {
              ::org::antlr::v4::runtime::Token a0((jobject) NULL);
              ::java::lang::String a1((jobject) NULL);
              ::org::antlr::v4::runtime::RecognitionException a2((jobject) NULL);

              if (!parseArgs(args, "ksk", ::org::antlr::v4::runtime::Token::initializeClass, ::org::antlr::v4::runtime::RecognitionException::initializeClass, &a0, &a1, &a2))
              {
                OBJ_CALL(self->object.notifyErrorListeners(a0, a1, a2));
                Py_RETURN_NONE;
              }
            }
          }

          PyErr_SetArgsError((PyObject *) self, "notifyErrorListeners", args);
          return NULL;
        }

        static PyObject *t_Parser_precpred(t_Parser *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::RuleContext a0((jobject) NULL);
          jint a1;
          jboolean result;

          if (!parseArgs(args, "kI", ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0, &a1))
          {
            OBJ_CALL(result = self->object.precpred(a0, a1));
            Py_RETURN_BOOL(result);
          }

          return callSuper(PY_TYPE(Parser), (PyObject *) self, "precpred", args, 2);
        }

        static PyObject *t_Parser_pushNewRecursionContext(t_Parser *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::ParserRuleContext a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "kII", ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.pushNewRecursionContext(a0, a1, a2));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "pushNewRecursionContext", args);
          return NULL;
        }

        static PyObject *t_Parser_removeParseListeners(t_Parser *self)
        {
          OBJ_CALL(self->object.removeParseListeners());
          Py_RETURN_NONE;
        }

        static PyObject *t_Parser_reset(t_Parser *self)
        {
          OBJ_CALL(self->object.reset());
          Py_RETURN_NONE;
        }

        static PyObject *t_Parser_setBuildParseTree(t_Parser *self, PyObject *arg)
        {
          jboolean a0;

          if (!parseArg(arg, "Z", &a0))
          {
            OBJ_CALL(self->object.setBuildParseTree(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setBuildParseTree", arg);
          return NULL;
        }

        static PyObject *t_Parser_setContext(t_Parser *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::ParserRuleContext a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0))
          {
            OBJ_CALL(self->object.setContext(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setContext", arg);
          return NULL;
        }

        static PyObject *t_Parser_setErrorHandler(t_Parser *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::ANTLRErrorStrategy a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::ANTLRErrorStrategy::initializeClass, &a0))
          {
            OBJ_CALL(self->object.setErrorHandler(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setErrorHandler", arg);
          return NULL;
        }

        static PyObject *t_Parser_setInputStream(t_Parser *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::IntStream a0((jobject) NULL);

          if (!parseArgs(args, "k", ::org::antlr::v4::runtime::IntStream::initializeClass, &a0))
          {
            OBJ_CALL(self->object.setInputStream(a0));
            Py_RETURN_NONE;
          }

          return callSuper(PY_TYPE(Parser), (PyObject *) self, "setInputStream", args, 2);
        }

        static PyObject *t_Parser_setProfile(t_Parser *self, PyObject *arg)
        {
          jboolean a0;

          if (!parseArg(arg, "Z", &a0))
          {
            OBJ_CALL(self->object.setProfile(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setProfile", arg);
          return NULL;
        }

        static PyObject *t_Parser_setTokenFactory(t_Parser *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::TokenFactory a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArgs(args, "K", ::org::antlr::v4::runtime::TokenFactory::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_TokenFactory::parameters_))
          {
            OBJ_CALL(self->object.setTokenFactory(a0));
            Py_RETURN_NONE;
          }

          return callSuper(PY_TYPE(Parser), (PyObject *) self, "setTokenFactory", args, 2);
        }

        static PyObject *t_Parser_setTokenStream(t_Parser *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::TokenStream a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::TokenStream::initializeClass, &a0))
          {
            OBJ_CALL(self->object.setTokenStream(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setTokenStream", arg);
          return NULL;
        }

        static PyObject *t_Parser_setTrace(t_Parser *self, PyObject *arg)
        {
          jboolean a0;

          if (!parseArg(arg, "Z", &a0))
          {
            OBJ_CALL(self->object.setTrace(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setTrace", arg);
          return NULL;
        }

        static PyObject *t_Parser_setTrimParseTree(t_Parser *self, PyObject *arg)
        {
          jboolean a0;

          if (!parseArg(arg, "Z", &a0))
          {
            OBJ_CALL(self->object.setTrimParseTree(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setTrimParseTree", arg);
          return NULL;
        }

        static PyObject *t_Parser_unrollRecursionContexts(t_Parser *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::ParserRuleContext a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0))
          {
            OBJ_CALL(self->object.unrollRecursionContexts(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "unrollRecursionContexts", arg);
          return NULL;
        }
        static PyObject *t_Parser_get__parameters_(t_Parser *self, void *data)
        {
          return typeParameters(self->parameters, sizeof(self->parameters));
        }

        static PyObject *t_Parser_get__aTNWithBypassAlts(t_Parser *self, void *data)
        {
          ::org::antlr::v4::runtime::atn::ATN value((jobject) NULL);
          OBJ_CALL(value = self->object.getATNWithBypassAlts());
          return ::org::antlr::v4::runtime::atn::t_ATN::wrap_Object(value);
        }

        static PyObject *t_Parser_get__buildParseTree(t_Parser *self, void *data)
        {
          jboolean value;
          OBJ_CALL(value = self->object.getBuildParseTree());
          Py_RETURN_BOOL(value);
        }
        static int t_Parser_set__buildParseTree(t_Parser *self, PyObject *arg, void *data)
        {
          {
            jboolean value;
            if (!parseArg(arg, "Z", &value))
            {
              INT_CALL(self->object.setBuildParseTree(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "buildParseTree", arg);
          return -1;
        }

        static PyObject *t_Parser_get__context(t_Parser *self, void *data)
        {
          ::org::antlr::v4::runtime::ParserRuleContext value((jobject) NULL);
          OBJ_CALL(value = self->object.getContext());
          return ::org::antlr::v4::runtime::t_ParserRuleContext::wrap_Object(value);
        }
        static int t_Parser_set__context(t_Parser *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::ParserRuleContext value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &value))
            {
              INT_CALL(self->object.setContext(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "context", arg);
          return -1;
        }

        static PyObject *t_Parser_get__currentToken(t_Parser *self, void *data)
        {
          ::org::antlr::v4::runtime::Token value((jobject) NULL);
          OBJ_CALL(value = self->object.getCurrentToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(value);
        }

        static PyObject *t_Parser_get__dFAStrings(t_Parser *self, void *data)
        {
          ::java::util::List value((jobject) NULL);
          OBJ_CALL(value = self->object.getDFAStrings());
          return ::java::util::t_List::wrap_Object(value);
        }

        static PyObject *t_Parser_get__errorHandler(t_Parser *self, void *data)
        {
          ::org::antlr::v4::runtime::ANTLRErrorStrategy value((jobject) NULL);
          OBJ_CALL(value = self->object.getErrorHandler());
          return ::org::antlr::v4::runtime::t_ANTLRErrorStrategy::wrap_Object(value);
        }
        static int t_Parser_set__errorHandler(t_Parser *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::ANTLRErrorStrategy value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::ANTLRErrorStrategy::initializeClass, &value))
            {
              INT_CALL(self->object.setErrorHandler(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "errorHandler", arg);
          return -1;
        }

        static PyObject *t_Parser_get__inputStream(t_Parser *self, void *data)
        {
          ::org::antlr::v4::runtime::TokenStream value((jobject) NULL);
          OBJ_CALL(value = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_TokenStream::wrap_Object(value);
        }
        static int t_Parser_set__inputStream(t_Parser *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::IntStream value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::IntStream::initializeClass, &value))
            {
              INT_CALL(self->object.setInputStream(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "inputStream", arg);
          return -1;
        }

        static PyObject *t_Parser_get__matchedEOF(t_Parser *self, void *data)
        {
          jboolean value;
          OBJ_CALL(value = self->object.isMatchedEOF());
          Py_RETURN_BOOL(value);
        }

        static PyObject *t_Parser_get__numberOfSyntaxErrors(t_Parser *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getNumberOfSyntaxErrors());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_Parser_get__parseInfo(t_Parser *self, void *data)
        {
          ::org::antlr::v4::runtime::atn::ParseInfo value((jobject) NULL);
          OBJ_CALL(value = self->object.getParseInfo());
          return ::org::antlr::v4::runtime::atn::t_ParseInfo::wrap_Object(value);
        }

        static PyObject *t_Parser_get__precedence(t_Parser *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getPrecedence());
          return PyLong_FromLong((long) value);
        }

        static int t_Parser_set__profile(t_Parser *self, PyObject *arg, void *data)
        {
          {
            jboolean value;
            if (!parseArg(arg, "Z", &value))
            {
              INT_CALL(self->object.setProfile(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "profile", arg);
          return -1;
        }

        static PyObject *t_Parser_get__ruleContext(t_Parser *self, void *data)
        {
          ::org::antlr::v4::runtime::ParserRuleContext value((jobject) NULL);
          OBJ_CALL(value = self->object.getRuleContext());
          return ::org::antlr::v4::runtime::t_ParserRuleContext::wrap_Object(value);
        }

        static PyObject *t_Parser_get__ruleInvocationStack(t_Parser *self, void *data)
        {
          ::java::util::List value((jobject) NULL);
          OBJ_CALL(value = self->object.getRuleInvocationStack());
          return ::java::util::t_List::wrap_Object(value);
        }

        static PyObject *t_Parser_get__sourceName(t_Parser *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object.getSourceName());
          return j2p(value);
        }

        static PyObject *t_Parser_get__tokenFactory(t_Parser *self, void *data)
        {
          ::org::antlr::v4::runtime::TokenFactory value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenFactory());
          return ::org::antlr::v4::runtime::t_TokenFactory::wrap_Object(value);
        }
        static int t_Parser_set__tokenFactory(t_Parser *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::TokenFactory value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::TokenFactory::initializeClass, &value))
            {
              INT_CALL(self->object.setTokenFactory(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "tokenFactory", arg);
          return -1;
        }

        static PyObject *t_Parser_get__tokenStream(t_Parser *self, void *data)
        {
          ::org::antlr::v4::runtime::TokenStream value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenStream());
          return ::org::antlr::v4::runtime::t_TokenStream::wrap_Object(value);
        }
        static int t_Parser_set__tokenStream(t_Parser *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::TokenStream value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::TokenStream::initializeClass, &value))
            {
              INT_CALL(self->object.setTokenStream(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "tokenStream", arg);
          return -1;
        }

        static PyObject *t_Parser_get__trace(t_Parser *self, void *data)
        {
          jboolean value;
          OBJ_CALL(value = self->object.isTrace());
          Py_RETURN_BOOL(value);
        }
        static int t_Parser_set__trace(t_Parser *self, PyObject *arg, void *data)
        {
          {
            jboolean value;
            if (!parseArg(arg, "Z", &value))
            {
              INT_CALL(self->object.setTrace(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "trace", arg);
          return -1;
        }

        static PyObject *t_Parser_get__trimParseTree(t_Parser *self, void *data)
        {
          jboolean value;
          OBJ_CALL(value = self->object.getTrimParseTree());
          Py_RETURN_BOOL(value);
        }
        static int t_Parser_set__trimParseTree(t_Parser *self, PyObject *arg, void *data)
        {
          {
            jboolean value;
            if (!parseArg(arg, "Z", &value))
            {
              INT_CALL(self->object.setTrimParseTree(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "trimParseTree", arg);
          return -1;
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Appendable.h"
#include "java/lang/Appendable.h"
#include "java/lang/CharSequence.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Appendable::class$ = NULL;
    jmethodID *Appendable::mids$ = NULL;
    bool Appendable::live$ = false;

    jclass Appendable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Appendable");

        mids$ = new jmethodID[max_mid];
        mids$[mid_append_eba659ea75d7ed5a] = env->getMethodID(cls, "append", "(C)Ljava/lang/Appendable;");
        mids$[mid_append_aaf0e49ea847d591] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;)Ljava/lang/Appendable;");
        mids$[mid_append_b7e44439517a620d] = env->getMethodID(cls, "append", "(Ljava/lang/CharSequence;II)Ljava/lang/Appendable;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Appendable Appendable::append(jchar a0) const
    {
      return Appendable(env->callObjectMethod(this$, mids$[mid_append_eba659ea75d7ed5a], a0));
    }

    Appendable Appendable::append(const ::java::lang::CharSequence & a0) const
    {
      return Appendable(env->callObjectMethod(this$, mids$[mid_append_aaf0e49ea847d591], a0.this$));
    }

    Appendable Appendable::append(const ::java::lang::CharSequence & a0, jint a1, jint a2) const
    {
      return Appendable(env->callObjectMethod(this$, mids$[mid_append_b7e44439517a620d], a0.this$, a1, a2));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Appendable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Appendable_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Appendable_append(t_Appendable *self, PyObject *args);

    static PyMethodDef t_Appendable__methods_[] = {
      DECLARE_METHOD(t_Appendable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Appendable, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Appendable, append, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Appendable)[] = {
      { Py_tp_methods, t_Appendable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Appendable)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Appendable, t_Appendable, Appendable);

    void t_Appendable::install(PyObject *module)
    {
      installType(&PY_TYPE(Appendable), &PY_TYPE_DEF(Appendable), module, "Appendable", 0);
    }

    void t_Appendable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Appendable), "class_", make_descriptor(Appendable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Appendable), "wrapfn_", make_descriptor(t_Appendable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Appendable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Appendable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Appendable::initializeClass, 1)))
        return NULL;
      return t_Appendable::wrap_Object(Appendable(((t_Appendable *) arg)->object.this$));
    }
    static PyObject *t_Appendable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Appendable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Appendable_append(t_Appendable *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jchar a0;
          Appendable result((jobject) NULL);

          if (!parseArgs(args, "C", &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_Appendable::wrap_Object(result);
          }
        }
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          Appendable result((jobject) NULL);

          if (!parseArgs(args, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
          {
            OBJ_CALL(result = self->object.append(a0));
            return t_Appendable::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          ::java::lang::CharSequence a0((jobject) NULL);
          jint a1;
          jint a2;
          Appendable result((jobject) NULL);

          if (!parseArgs(args, "OII", ::java::lang::PY_TYPE(CharSequence), &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.append(a0, a1, a2));
            return t_Appendable::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "append", args);
      return NULL;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/LinkedList.h"
#include "java/util/Collection.h"
#include "java/lang/Cloneable.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/Spliterator.h"
#include "java/util/Iterator.h"
#include "java/util/Deque.h"
#include "java/util/ListIterator.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *LinkedList::class$ = NULL;
    jmethodID *LinkedList::mids$ = NULL;
    bool LinkedList::live$ = false;

    jclass LinkedList::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/LinkedList");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_50bc3ddc62a19f2d] = env->getMethodID(cls, "<init>", "(Ljava/util/Collection;)V");
        mids$[mid_add_8b72f2dcdde6fd1d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)Z");
        mids$[mid_add_cf6732d7dfcfc293] = env->getMethodID(cls, "add", "(ILjava/lang/Object;)V");
        mids$[mid_addAll_15d9cc2398c22637] = env->getMethodID(cls, "addAll", "(Ljava/util/Collection;)Z");
        mids$[mid_addAll_8980636bfaaa897b] = env->getMethodID(cls, "addAll", "(ILjava/util/Collection;)Z");
        mids$[mid_addFirst_d20f626183f72f7d] = env->getMethodID(cls, "addFirst", "(Ljava/lang/Object;)V");
        mids$[mid_addLast_d20f626183f72f7d] = env->getMethodID(cls, "addLast", "(Ljava/lang/Object;)V");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_clone_d6bcd06f3102c4d9] = env->getMethodID(cls, "clone", "()Ljava/lang/Object;");
        mids$[mid_contains_8b72f2dcdde6fd1d] = env->getMethodID(cls, "contains", "(Ljava/lang/Object;)Z");
        mids$[mid_descendingIterator_233a192dadb0917d] = env->getMethodID(cls, "descendingIterator", "()Ljava/util/Iterator;");
        mids$[mid_element_d6bcd06f3102c4d9] = env->getMethodID(cls, "element", "()Ljava/lang/Object;");
        mids$[mid_get_b15c79acb15c2870] = env->getMethodID(cls, "get", "(I)Ljava/lang/Object;");
        mids$[mid_getFirst_d6bcd06f3102c4d9] = env->getMethodID(cls, "getFirst", "()Ljava/lang/Object;");
        mids$[mid_getLast_d6bcd06f3102c4d9] = env->getMethodID(cls, "getLast", "()Ljava/lang/Object;");
        mids$[mid_indexOf_5a4805a36cf611e7] = env->getMethodID(cls, "indexOf", "(Ljava/lang/Object;)I");
        mids$[mid_lastIndexOf_5a4805a36cf611e7] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/Object;)I");
        mids$[mid_listIterator_8204cc66da390272] = env->getMethodID(cls, "listIterator", "(I)Ljava/util/ListIterator;");
        mids$[mid_offer_8b72f2dcdde6fd1d] = env->getMethodID(cls, "offer", "(Ljava/lang/Object;)Z");
        mids$[mid_offerFirst_8b72f2dcdde6fd1d] = env->getMethodID(cls, "offerFirst", "(Ljava/lang/Object;)Z");
        mids$[mid_offerLast_8b72f2dcdde6fd1d] = env->getMethodID(cls, "offerLast", "(Ljava/lang/Object;)Z");
        mids$[mid_peek_d6bcd06f3102c4d9] = env->getMethodID(cls, "peek", "()Ljava/lang/Object;");
        mids$[mid_peekFirst_d6bcd06f3102c4d9] = env->getMethodID(cls, "peekFirst", "()Ljava/lang/Object;");
        mids$[mid_peekLast_d6bcd06f3102c4d9] = env->getMethodID(cls, "peekLast", "()Ljava/lang/Object;");
        mids$[mid_poll_d6bcd06f3102c4d9] = env->getMethodID(cls, "poll", "()Ljava/lang/Object;");
        mids$[mid_pollFirst_d6bcd06f3102c4d9] = env->getMethodID(cls, "pollFirst", "()Ljava/lang/Object;");
        mids$[mid_pollLast_d6bcd06f3102c4d9] = env->getMethodID(cls, "pollLast", "()Ljava/lang/Object;");
        mids$[mid_pop_d6bcd06f3102c4d9] = env->getMethodID(cls, "pop", "()Ljava/lang/Object;");
        mids$[mid_push_d20f626183f72f7d] = env->getMethodID(cls, "push", "(Ljava/lang/Object;)V");
        mids$[mid_remove_d6bcd06f3102c4d9] = env->getMethodID(cls, "remove", "()Ljava/lang/Object;");
        mids$[mid_remove_b15c79acb15c2870] = env->getMethodID(cls, "remove", "(I)Ljava/lang/Object;");
        mids$[mid_remove_8b72f2dcdde6fd1d] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Z");
        mids$[mid_removeFirst_d6bcd06f3102c4d9] = env->getMethodID(cls, "removeFirst", "()Ljava/lang/Object;");
        mids$[mid_removeFirstOccurrence_8b72f2dcdde6fd1d] = env->getMethodID(cls, "removeFirstOccurrence", "(Ljava/lang/Object;)Z");
        mids$[mid_removeLast_d6bcd06f3102c4d9] = env->getMethodID(cls, "removeLast", "()Ljava/lang/Object;");
        mids$[mid_removeLastOccurrence_8b72f2dcdde6fd1d] = env->getMethodID(cls, "removeLastOccurrence", "(Ljava/lang/Object;)Z");
        mids$[mid_set_55e2638f354bbf61] = env->getMethodID(cls, "set", "(ILjava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
        mids$[mid_spliterator_7a761c107a8e14bd] = env->getMethodID(cls, "spliterator", "()Ljava/util/Spliterator;");
        mids$[mid_toArray_6becf78ffd87a9bc] = env->getMethodID(cls, "toArray", "()[Ljava/lang/Object;");
        mids$[mid_toArray_609b05756010dc5d] = env->getMethodID(cls, "toArray", "([Ljava/lang/Object;)[Ljava/lang/Object;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    LinkedList::LinkedList() : ::java::util::AbstractSequentialList(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    LinkedList::LinkedList(const ::java::util::Collection & a0) : ::java::util::AbstractSequentialList(env->newObject(initializeClass, &mids$, mid_init$_50bc3ddc62a19f2d, a0.this$)) {}

    jboolean LinkedList::add(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_add_8b72f2dcdde6fd1d], a0.this$);
    }

    void LinkedList::add(jint a0, const ::java::lang::Object & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_add_cf6732d7dfcfc293], a0, a1.this$);
    }

    jboolean LinkedList::addAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_15d9cc2398c22637], a0.this$);
    }

    jboolean LinkedList::addAll(jint a0, const ::java::util::Collection & a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_8980636bfaaa897b], a0, a1.this$);
    }

    void LinkedList::addFirst(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_addFirst_d20f626183f72f7d], a0.this$);
    }

    void LinkedList::addLast(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_addLast_d20f626183f72f7d], a0.this$);
    }

    void LinkedList::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    ::java::lang::Object LinkedList::clone() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_clone_d6bcd06f3102c4d9]));
    }

    jboolean LinkedList::contains(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_contains_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::util::Iterator LinkedList::descendingIterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_descendingIterator_233a192dadb0917d]));
    }

    ::java::lang::Object LinkedList::element() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_element_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object LinkedList::get(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_b15c79acb15c2870], a0));
    }

    ::java::lang::Object LinkedList::getFirst() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_getFirst_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object LinkedList::getLast() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_getLast_d6bcd06f3102c4d9]));
    }

    jint LinkedList::indexOf(const ::java::lang::Object & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_5a4805a36cf611e7], a0.this$);
    }

    jint LinkedList::lastIndexOf(const ::java::lang::Object & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_5a4805a36cf611e7], a0.this$);
    }

    ::java::util::ListIterator LinkedList::listIterator(jint a0) const
    {
      return ::java::util::ListIterator(env->callObjectMethod(this$, mids$[mid_listIterator_8204cc66da390272], a0));
    }

    jboolean LinkedList::offer(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_offer_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean LinkedList::offerFirst(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_offerFirst_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean LinkedList::offerLast(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_offerLast_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object LinkedList::peek() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_peek_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object LinkedList::peekFirst() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_peekFirst_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object LinkedList::peekLast() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_peekLast_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object LinkedList::poll() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_poll_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object LinkedList::pollFirst() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_pollFirst_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object LinkedList::pollLast() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_pollLast_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object LinkedList::pop() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_pop_d6bcd06f3102c4d9]));
    }

    void LinkedList::push(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_push_d20f626183f72f7d], a0.this$);
    }

    ::java::lang::Object LinkedList::remove() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object LinkedList::remove(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_b15c79acb15c2870], a0));
    }

    jboolean LinkedList::remove(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_remove_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object LinkedList::removeFirst() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_removeFirst_d6bcd06f3102c4d9]));
    }

    jboolean LinkedList::removeFirstOccurrence(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeFirstOccurrence_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object LinkedList::removeLast() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_removeLast_d6bcd06f3102c4d9]));
    }

    jboolean LinkedList::removeLastOccurrence(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeLastOccurrence_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object LinkedList::set(jint a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_set_55e2638f354bbf61], a0, a1.this$));
    }

    jint LinkedList::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }

    ::java::util::Spliterator LinkedList::spliterator() const
    {
      return ::java::util::Spliterator(env->callObjectMethod(this$, mids$[mid_spliterator_7a761c107a8e14bd]));
    }

    JArray< ::java::lang::Object > LinkedList::toArray() const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_6becf78ffd87a9bc]));
    }

    JArray< ::java::lang::Object > LinkedList::toArray(const JArray< ::java::lang::Object > & a0) const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_609b05756010dc5d], a0.this$));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_LinkedList_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_LinkedList_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_LinkedList_of_(t_LinkedList *self, PyObject *args);
    static int t_LinkedList_init_(t_LinkedList *self, PyObject *args, PyObject *kwds);
    static PyObject *t_LinkedList_add(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_addAll(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_addFirst(t_LinkedList *self, PyObject *arg);
    static PyObject *t_LinkedList_addLast(t_LinkedList *self, PyObject *arg);
    static PyObject *t_LinkedList_clear(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_clone(t_LinkedList *self);
    static PyObject *t_LinkedList_contains(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_descendingIterator(t_LinkedList *self);
    static PyObject *t_LinkedList_element(t_LinkedList *self);
    static PyObject *t_LinkedList_get(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_getFirst(t_LinkedList *self);
    static PyObject *t_LinkedList_getLast(t_LinkedList *self);
    static PyObject *t_LinkedList_indexOf(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_lastIndexOf(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_listIterator(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_offer(t_LinkedList *self, PyObject *arg);
    static PyObject *t_LinkedList_offerFirst(t_LinkedList *self, PyObject *arg);
    static PyObject *t_LinkedList_offerLast(t_LinkedList *self, PyObject *arg);
    static PyObject *t_LinkedList_peek(t_LinkedList *self);
    static PyObject *t_LinkedList_peekFirst(t_LinkedList *self);
    static PyObject *t_LinkedList_peekLast(t_LinkedList *self);
    static PyObject *t_LinkedList_poll(t_LinkedList *self);
    static PyObject *t_LinkedList_pollFirst(t_LinkedList *self);
    static PyObject *t_LinkedList_pollLast(t_LinkedList *self);
    static PyObject *t_LinkedList_pop(t_LinkedList *self);
    static PyObject *t_LinkedList_push(t_LinkedList *self, PyObject *arg);
    static PyObject *t_LinkedList_remove(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_removeFirst(t_LinkedList *self);
    static PyObject *t_LinkedList_removeFirstOccurrence(t_LinkedList *self, PyObject *arg);
    static PyObject *t_LinkedList_removeLast(t_LinkedList *self);
    static PyObject *t_LinkedList_removeLastOccurrence(t_LinkedList *self, PyObject *arg);
    static PyObject *t_LinkedList_set(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_size(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_spliterator(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_toArray(t_LinkedList *self, PyObject *args);
    static PyObject *t_LinkedList_get__first(t_LinkedList *self, void *data);
    static PyObject *t_LinkedList_get__last(t_LinkedList *self, void *data);
    static PyObject *t_LinkedList_get__parameters_(t_LinkedList *self, void *data);
    static PyGetSetDef t_LinkedList__fields_[] = {
      DECLARE_GET_FIELD(t_LinkedList, first),
      DECLARE_GET_FIELD(t_LinkedList, last),
      DECLARE_GET_FIELD(t_LinkedList, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_LinkedList__methods_[] = {
      DECLARE_METHOD(t_LinkedList, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_LinkedList, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_LinkedList, of_, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, add, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, addAll, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, addFirst, METH_O),
      DECLARE_METHOD(t_LinkedList, addLast, METH_O),
      DECLARE_METHOD(t_LinkedList, clear, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, clone, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, contains, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, descendingIterator, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, element, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, get, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, getFirst, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, getLast, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, indexOf, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, lastIndexOf, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, listIterator, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, offer, METH_O),
      DECLARE_METHOD(t_LinkedList, offerFirst, METH_O),
      DECLARE_METHOD(t_LinkedList, offerLast, METH_O),
      DECLARE_METHOD(t_LinkedList, peek, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, peekFirst, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, peekLast, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, poll, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, pollFirst, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, pollLast, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, pop, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, push, METH_O),
      DECLARE_METHOD(t_LinkedList, remove, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, removeFirst, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, removeFirstOccurrence, METH_O),
      DECLARE_METHOD(t_LinkedList, removeLast, METH_NOARGS),
      DECLARE_METHOD(t_LinkedList, removeLastOccurrence, METH_O),
      DECLARE_METHOD(t_LinkedList, set, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, size, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, spliterator, METH_VARARGS),
      DECLARE_METHOD(t_LinkedList, toArray, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(LinkedList)[] = {
      { Py_tp_methods, t_LinkedList__methods_ },
      { Py_tp_init, (void *) t_LinkedList_init_ },
      { Py_tp_getset, t_LinkedList__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(LinkedList)[] = {
      &PY_TYPE_DEF(::java::util::AbstractSequentialList),
      NULL
    };

    DEFINE_TYPE(LinkedList, t_LinkedList, LinkedList);
    PyObject *t_LinkedList::wrap_Object(const LinkedList& object, PyTypeObject *p0)
    {
      PyObject *obj = t_LinkedList::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_LinkedList *self = (t_LinkedList *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_LinkedList::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_LinkedList::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_LinkedList *self = (t_LinkedList *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_LinkedList::install(PyObject *module)
    {
      installType(&PY_TYPE(LinkedList), &PY_TYPE_DEF(LinkedList), module, "LinkedList", 0);
    }

    void t_LinkedList::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(LinkedList), "class_", make_descriptor(LinkedList::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(LinkedList), "wrapfn_", make_descriptor(t_LinkedList::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(LinkedList), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_LinkedList_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, LinkedList::initializeClass, 1)))
        return NULL;
      return t_LinkedList::wrap_Object(LinkedList(((t_LinkedList *) arg)->object.this$));
    }
    static PyObject *t_LinkedList_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, LinkedList::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_LinkedList_of_(t_LinkedList *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static int t_LinkedList_init_(t_LinkedList *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          LinkedList object((jobject) NULL);

          INT_CALL(object = LinkedList());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::util::Collection a0((jobject) NULL);
          PyTypeObject **p0;
          LinkedList object((jobject) NULL);

          if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
          {
            INT_CALL(object = LinkedList(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_LinkedList_add(t_LinkedList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "O", self->parameters[0], &a0))
          {
            OBJ_CALL(result = self->object.add(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          ::java::lang::Object a1((jobject) NULL);

          if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(self->object.add(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "add", args, 2);
    }

    static PyObject *t_LinkedList_addAll(t_LinkedList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::Collection a0((jobject) NULL);
          PyTypeObject **p0;
          jboolean result;

          if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
          {
            OBJ_CALL(result = self->object.addAll(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          ::java::util::Collection a1((jobject) NULL);
          PyTypeObject **p1;
          jboolean result;

          if (!parseArgs(args, "IK", ::java::util::Collection::initializeClass, &a0, &a1, &p1, ::java::util::t_Collection::parameters_))
          {
            OBJ_CALL(result = self->object.addAll(a0, a1));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "addAll", args, 2);
    }

    static PyObject *t_LinkedList_addFirst(t_LinkedList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(self->object.addFirst(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "addFirst", arg);
      return NULL;
    }

    static PyObject *t_LinkedList_addLast(t_LinkedList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(self->object.addLast(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "addLast", arg);
      return NULL;
    }

    static PyObject *t_LinkedList_clear(t_LinkedList *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.clear());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "clear", args, 2);
    }

    static PyObject *t_LinkedList_clone(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.clone());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_contains(t_LinkedList *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.contains(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "contains", args, 2);
    }

    static PyObject *t_LinkedList_descendingIterator(t_LinkedList *self)
    {
      ::java::util::Iterator result((jobject) NULL);
      OBJ_CALL(result = self->object.descendingIterator());
      return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_LinkedList_element(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.element());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_get(t_LinkedList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "get", args, 2);
    }

    static PyObject *t_LinkedList_getFirst(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.getFirst());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_getLast(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.getLast());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_indexOf(t_LinkedList *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jint result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.indexOf(a0));
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "indexOf", args, 2);
    }

    static PyObject *t_LinkedList_lastIndexOf(t_LinkedList *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jint result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.lastIndexOf(a0));
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "lastIndexOf", args, 2);
    }

    static PyObject *t_LinkedList_listIterator(t_LinkedList *self, PyObject *args)
    {
      jint a0;
      ::java::util::ListIterator result((jobject) NULL);

      if (!parseArgs(args, "I", &a0))
      {
        OBJ_CALL(result = self->object.listIterator(a0));
        return ::java::util::t_ListIterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "listIterator", args, 2);
    }

    static PyObject *t_LinkedList_offer(t_LinkedList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.offer(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "offer", arg);
      return NULL;
    }

    static PyObject *t_LinkedList_offerFirst(t_LinkedList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.offerFirst(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "offerFirst", arg);
      return NULL;
    }

    static PyObject *t_LinkedList_offerLast(t_LinkedList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.offerLast(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "offerLast", arg);
      return NULL;
    }

    static PyObject *t_LinkedList_peek(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.peek());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_peekFirst(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.peekFirst());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_peekLast(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.peekLast());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_poll(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.poll());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_pollFirst(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.pollFirst());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_pollLast(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.pollLast());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_pop(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.pop());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_push(t_LinkedList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(self->object.push(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "push", arg);
      return NULL;
    }

    static PyObject *t_LinkedList_remove(t_LinkedList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::Object result((jobject) NULL);
          OBJ_CALL(result = self->object.remove());
          return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
        }
        break;
       case 1:
        {
          jint a0;
          ::java::lang::Object result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.remove(a0));
            return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
          }
        }
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(result = self->object.remove(a0));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_LinkedList_removeFirst(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.removeFirst());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_removeFirstOccurrence(t_LinkedList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.removeFirstOccurrence(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "removeFirstOccurrence", arg);
      return NULL;
    }

    static PyObject *t_LinkedList_removeLast(t_LinkedList *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.removeLast());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_LinkedList_removeLastOccurrence(t_LinkedList *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.removeLastOccurrence(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "removeLastOccurrence", arg);
      return NULL;
    }

    static PyObject *t_LinkedList_set(t_LinkedList *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
      {
        OBJ_CALL(result = self->object.set(a0, a1));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "set", args, 2);
    }

    static PyObject *t_LinkedList_size(t_LinkedList *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.size());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "size", args, 2);
    }

    static PyObject *t_LinkedList_spliterator(t_LinkedList *self, PyObject *args)
    {
      ::java::util::Spliterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.spliterator());
        return ::java::util::t_Spliterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "spliterator", args, 2);
    }

    static PyObject *t_LinkedList_toArray(t_LinkedList *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          JArray< ::java::lang::Object > result((jobject) NULL);
          OBJ_CALL(result = self->object.toArray());
          return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
        }
        break;
       case 1:
        {
          JArray< ::java::lang::Object > a0((jobject) NULL);
          JArray< ::java::lang::Object > result((jobject) NULL);

          if (!parseArgs(args, "[o", &a0))
          {
            OBJ_CALL(result = self->object.toArray(a0));
            return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
          }
        }
      }

      return callSuper(PY_TYPE(LinkedList), (PyObject *) self, "toArray", args, 2);
    }
    static PyObject *t_LinkedList_get__parameters_(t_LinkedList *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_LinkedList_get__first(t_LinkedList *self, void *data)
    {
      ::java::lang::Object value((jobject) NULL);
      OBJ_CALL(value = self->object.getFirst());
      return ::java::lang::t_Object::wrap_Object(value);
    }

    static PyObject *t_LinkedList_get__last(t_LinkedList *self, void *data)
    {
      ::java::lang::Object value((jobject) NULL);
      OBJ_CALL(value = self->object.getLast());
      return ::java::lang::t_Object::wrap_Object(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Readable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Readable::class$ = NULL;
    jmethodID *Readable::mids$ = NULL;
    bool Readable::live$ = false;

    jclass Readable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Readable");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Readable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Readable_instance_(PyTypeObject *type, PyObject *arg);

    static PyMethodDef t_Readable__methods_[] = {
      DECLARE_METHOD(t_Readable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Readable, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Readable)[] = {
      { Py_tp_methods, t_Readable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Readable)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Readable, t_Readable, Readable);

    void t_Readable::install(PyObject *module)
    {
      installType(&PY_TYPE(Readable), &PY_TYPE_DEF(Readable), module, "Readable", 0);
    }

    void t_Readable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Readable), "class_", make_descriptor(Readable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Readable), "wrapfn_", make_descriptor(t_Readable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Readable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Readable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Readable::initializeClass, 1)))
        return NULL;
      return t_Readable::wrap_Object(Readable(((t_Readable *) arg)->object.this$));
    }
    static PyObject *t_Readable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Readable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/ThreadGroup.h"
#include "java/lang/ThreadGroup.h"
#include "java/lang/Class.h"
#include "java/lang/Thread$UncaughtExceptionHandler.h"
#include "java/lang/String.h"
#include "java/lang/Thread.h"
#include "java/lang/Throwable.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *ThreadGroup::class$ = NULL;
    jmethodID *ThreadGroup::mids$ = NULL;
    bool ThreadGroup::live$ = false;

    jclass ThreadGroup::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/ThreadGroup");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_1dfb4df15ca2768b] = env->getMethodID(cls, "<init>", "(Ljava/lang/ThreadGroup;Ljava/lang/String;)V");
        mids$[mid_activeCount_9972fcc56b44e79d] = env->getMethodID(cls, "activeCount", "()I");
        mids$[mid_activeGroupCount_9972fcc56b44e79d] = env->getMethodID(cls, "activeGroupCount", "()I");
        mids$[mid_allowThreadSuspension_e84cf59305ee1535] = env->getMethodID(cls, "allowThreadSuspension", "(Z)Z");
        mids$[mid_checkAccess_f2cc1bce94666404] = env->getMethodID(cls, "checkAccess", "()V");
        mids$[mid_destroy_f2cc1bce94666404] = env->getMethodID(cls, "destroy", "()V");
        mids$[mid_enumerate_6735bbb14792d0b6] = env->getMethodID(cls, "enumerate", "([Ljava/lang/Thread;)I");
        mids$[mid_enumerate_8010a7e86056d575] = env->getMethodID(cls, "enumerate", "([Ljava/lang/ThreadGroup;)I");
        mids$[mid_enumerate_68712d3d484c4348] = env->getMethodID(cls, "enumerate", "([Ljava/lang/Thread;Z)I");
        mids$[mid_enumerate_047841af37a17082] = env->getMethodID(cls, "enumerate", "([Ljava/lang/ThreadGroup;Z)I");
        mids$[mid_getMaxPriority_9972fcc56b44e79d] = env->getMethodID(cls, "getMaxPriority", "()I");
        mids$[mid_getName_db9b55ba01e03e4b] = env->getMethodID(cls, "getName", "()Ljava/lang/String;");
        mids$[mid_getParent_04b6c2a69b2c4912] = env->getMethodID(cls, "getParent", "()Ljava/lang/ThreadGroup;");
        mids$[mid_interrupt_f2cc1bce94666404] = env->getMethodID(cls, "interrupt", "()V");
        mids$[mid_isDaemon_8454bd5aa23fd11e] = env->getMethodID(cls, "isDaemon", "()Z");
        mids$[mid_isDestroyed_8454bd5aa23fd11e] = env->getMethodID(cls, "isDestroyed", "()Z");
        mids$[mid_list_f2cc1bce94666404] = env->getMethodID(cls, "list", "()V");
        mids$[mid_parentOf_5a154170fc1a395d] = env->getMethodID(cls, "parentOf", "(Ljava/lang/ThreadGroup;)Z");
        mids$[mid_resume_f2cc1bce94666404] = env->getMethodID(cls, "resume", "()V");
        mids$[mid_setDaemon_9d72768e8fdce2b7] = env->getMethodID(cls, "setDaemon", "(Z)V");
        mids$[mid_setMaxPriority_040c4cd0390c5aff] = env->getMethodID(cls, "setMaxPriority", "(I)V");
        mids$[mid_stop_f2cc1bce94666404] = env->getMethodID(cls, "stop", "()V");
        mids$[mid_suspend_f2cc1bce94666404] = env->getMethodID(cls, "suspend", "()V");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
        mids$[mid_uncaughtException_8a0c1817de3dc30e] = env->getMethodID(cls, "uncaughtException", "(Ljava/lang/Thread;Ljava/lang/Throwable;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ThreadGroup::ThreadGroup(const ::java::lang::String & a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    ThreadGroup::ThreadGroup(const ThreadGroup & a0, const ::java::lang::String & a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_1dfb4df15ca2768b, a0.this$, a1.this$)) {}

    jint ThreadGroup::activeCount() const
    {
      return env->callIntMethod(this$, mids$[mid_activeCount_9972fcc56b44e79d]);
    }

    jint ThreadGroup::activeGroupCount() const
    {
      return env->callIntMethod(this$, mids$[mid_activeGroupCount_9972fcc56b44e79d]);
    }

    jboolean ThreadGroup::allowThreadSuspension(jboolean a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_allowThreadSuspension_e84cf59305ee1535], a0);
    }

    void ThreadGroup::checkAccess() const
    {
      env->callVoidMethod(this$, mids$[mid_checkAccess_f2cc1bce94666404]);
    }

    void ThreadGroup::destroy() const
    {
      env->callVoidMethod(this$, mids$[mid_destroy_f2cc1bce94666404]);
    }

    jint ThreadGroup::enumerate(const JArray< ::java::lang::Thread > & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_enumerate_6735bbb14792d0b6], a0.this$);
    }

    jint ThreadGroup::enumerate(const JArray< ThreadGroup > & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_enumerate_8010a7e86056d575], a0.this$);
    }

    jint ThreadGroup::enumerate(const JArray< ::java::lang::Thread > & a0, jboolean a1) const
    {
      return env->callIntMethod(this$, mids$[mid_enumerate_68712d3d484c4348], a0.this$, a1);
    }

    jint ThreadGroup::enumerate(const JArray< ThreadGroup > & a0, jboolean a1) const
    {
      return env->callIntMethod(this$, mids$[mid_enumerate_047841af37a17082], a0.this$, a1);
    }

    jint ThreadGroup::getMaxPriority() const
    {
      return env->callIntMethod(this$, mids$[mid_getMaxPriority_9972fcc56b44e79d]);
    }

    ::java::lang::String ThreadGroup::getName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getName_db9b55ba01e03e4b]));
    }

    ThreadGroup ThreadGroup::getParent() const
    {
      return ThreadGroup(env->callObjectMethod(this$, mids$[mid_getParent_04b6c2a69b2c4912]));
    }

    void ThreadGroup::interrupt() const
    {
      env->callVoidMethod(this$, mids$[mid_interrupt_f2cc1bce94666404]);
    }

    jboolean ThreadGroup::isDaemon() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isDaemon_8454bd5aa23fd11e]);
    }

    jboolean ThreadGroup::isDestroyed() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isDestroyed_8454bd5aa23fd11e]);
    }

    void ThreadGroup::list() const
    {
      env->callVoidMethod(this$, mids$[mid_list_f2cc1bce94666404]);
    }

    jboolean ThreadGroup::parentOf(const ThreadGroup & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_parentOf_5a154170fc1a395d], a0.this$);
    }

    void ThreadGroup::resume() const
    {
      env->callVoidMethod(this$, mids$[mid_resume_f2cc1bce94666404]);
    }

    void ThreadGroup::setDaemon(jboolean a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setDaemon_9d72768e8fdce2b7], a0);
    }

    void ThreadGroup::setMaxPriority(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setMaxPriority_040c4cd0390c5aff], a0);
    }

    void ThreadGroup::stop() const
    {
      env->callVoidMethod(this$, mids$[mid_stop_f2cc1bce94666404]);
    }

    void ThreadGroup::suspend() const
    {
      env->callVoidMethod(this$, mids$[mid_suspend_f2cc1bce94666404]);
    }

    ::java::lang::String ThreadGroup::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }

    void ThreadGroup::uncaughtException(const ::java::lang::Thread & a0, const ::java::lang::Throwable & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_uncaughtException_8a0c1817de3dc30e], a0.this$, a1.this$);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_ThreadGroup_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ThreadGroup_instance_(PyTypeObject *type, PyObject *arg);
    static int t_ThreadGroup_init_(t_ThreadGroup *self, PyObject *args, PyObject *kwds);
    static PyObject *t_ThreadGroup_activeCount(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_activeGroupCount(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_allowThreadSuspension(t_ThreadGroup *self, PyObject *arg);
    static PyObject *t_ThreadGroup_checkAccess(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_destroy(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_enumerate(t_ThreadGroup *self, PyObject *args);
    static PyObject *t_ThreadGroup_getMaxPriority(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_getName(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_getParent(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_interrupt(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_isDaemon(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_isDestroyed(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_list(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_parentOf(t_ThreadGroup *self, PyObject *arg);
    static PyObject *t_ThreadGroup_resume(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_setDaemon(t_ThreadGroup *self, PyObject *arg);
    static PyObject *t_ThreadGroup_setMaxPriority(t_ThreadGroup *self, PyObject *arg);
    static PyObject *t_ThreadGroup_stop(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_suspend(t_ThreadGroup *self);
    static PyObject *t_ThreadGroup_toString(t_ThreadGroup *self, PyObject *args);
    static PyObject *t_ThreadGroup_uncaughtException(t_ThreadGroup *self, PyObject *args);
    static PyObject *t_ThreadGroup_get__daemon(t_ThreadGroup *self, void *data);
    static int t_ThreadGroup_set__daemon(t_ThreadGroup *self, PyObject *arg, void *data);
    static PyObject *t_ThreadGroup_get__destroyed(t_ThreadGroup *self, void *data);
    static PyObject *t_ThreadGroup_get__maxPriority(t_ThreadGroup *self, void *data);
    static int t_ThreadGroup_set__maxPriority(t_ThreadGroup *self, PyObject *arg, void *data);
    static PyObject *t_ThreadGroup_get__name(t_ThreadGroup *self, void *data);
    static PyObject *t_ThreadGroup_get__parent(t_ThreadGroup *self, void *data);
    static PyGetSetDef t_ThreadGroup__fields_[] = {
      DECLARE_GETSET_FIELD(t_ThreadGroup, daemon),
      DECLARE_GET_FIELD(t_ThreadGroup, destroyed),
      DECLARE_GETSET_FIELD(t_ThreadGroup, maxPriority),
      DECLARE_GET_FIELD(t_ThreadGroup, name),
      DECLARE_GET_FIELD(t_ThreadGroup, parent),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_ThreadGroup__methods_[] = {
      DECLARE_METHOD(t_ThreadGroup, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ThreadGroup, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ThreadGroup, activeCount, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, activeGroupCount, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, allowThreadSuspension, METH_O),
      DECLARE_METHOD(t_ThreadGroup, checkAccess, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, destroy, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, enumerate, METH_VARARGS),
      DECLARE_METHOD(t_ThreadGroup, getMaxPriority, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, getName, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, getParent, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, interrupt, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, isDaemon, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, isDestroyed, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, list, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, parentOf, METH_O),
      DECLARE_METHOD(t_ThreadGroup, resume, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, setDaemon, METH_O),
      DECLARE_METHOD(t_ThreadGroup, setMaxPriority, METH_O),
      DECLARE_METHOD(t_ThreadGroup, stop, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, suspend, METH_NOARGS),
      DECLARE_METHOD(t_ThreadGroup, toString, METH_VARARGS),
      DECLARE_METHOD(t_ThreadGroup, uncaughtException, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(ThreadGroup)[] = {
      { Py_tp_methods, t_ThreadGroup__methods_ },
      { Py_tp_init, (void *) t_ThreadGroup_init_ },
      { Py_tp_getset, t_ThreadGroup__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(ThreadGroup)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(ThreadGroup, t_ThreadGroup, ThreadGroup);

    void t_ThreadGroup::install(PyObject *module)
    {
      installType(&PY_TYPE(ThreadGroup), &PY_TYPE_DEF(ThreadGroup), module, "ThreadGroup", 0);
    }

    void t_ThreadGroup::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(ThreadGroup), "class_", make_descriptor(ThreadGroup::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ThreadGroup), "wrapfn_", make_descriptor(t_ThreadGroup::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ThreadGroup), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_ThreadGroup_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, ThreadGroup::initializeClass, 1)))
        return NULL;
      return t_ThreadGroup::wrap_Object(ThreadGroup(((t_ThreadGroup *) arg)->object.this$));
    }
    static PyObject *t_ThreadGroup_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, ThreadGroup::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_ThreadGroup_init_(t_ThreadGroup *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          ThreadGroup object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = ThreadGroup(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ThreadGroup a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          ThreadGroup object((jobject) NULL);

          if (!parseArgs(args, "ks", ThreadGroup::initializeClass, &a0, &a1))
          {
            INT_CALL(object = ThreadGroup(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_ThreadGroup_activeCount(t_ThreadGroup *self)
    {
      jint result;
      OBJ_CALL(result = self->object.activeCount());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_ThreadGroup_activeGroupCount(t_ThreadGroup *self)
    {
      jint result;
      OBJ_CALL(result = self->object.activeGroupCount());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_ThreadGroup_allowThreadSuspension(t_ThreadGroup *self, PyObject *arg)
    {
      jboolean a0;
      jboolean result;

      if (!parseArg(arg, "Z", &a0))
      {
        OBJ_CALL(result = self->object.allowThreadSuspension(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "allowThreadSuspension", arg);
      return NULL;
    }

    static PyObject *t_ThreadGroup_checkAccess(t_ThreadGroup *self)
    {
      OBJ_CALL(self->object.checkAccess());
      Py_RETURN_NONE;
    }

    static PyObject *t_ThreadGroup_destroy(t_ThreadGroup *self)
    {
      OBJ_CALL(self->object.destroy());
      Py_RETURN_NONE;
    }

    static PyObject *t_ThreadGroup_enumerate(t_ThreadGroup *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          JArray< ::java::lang::Thread > a0((jobject) NULL);
          jint result;

          if (!parseArgs(args, "[k", ::java::lang::Thread::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.enumerate(a0));
            return PyLong_FromLong((long) result);
          }
        }
        {
          JArray< ThreadGroup > a0((jobject) NULL);
          jint result;

          if (!parseArgs(args, "[k", ThreadGroup::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.enumerate(a0));
            return PyLong_FromLong((long) result);
          }
        }
        break;
       case 2:
        {
          JArray< ::java::lang::Thread > a0((jobject) NULL);
          jboolean a1;
          jint result;

          if (!parseArgs(args, "[kZ", ::java::lang::Thread::initializeClass, &a0, &a1))
          {
            OBJ_CALL(result = self->object.enumerate(a0, a1));
            return PyLong_FromLong((long) result);
          }
        }
        {
          JArray< ThreadGroup > a0((jobject) NULL);
          jboolean a1;
          jint result;

          if (!parseArgs(args, "[kZ", ThreadGroup::initializeClass, &a0, &a1))
          {
            OBJ_CALL(result = self->object.enumerate(a0, a1));
            return PyLong_FromLong((long) result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "enumerate", args);
      return NULL;
    }

    static PyObject *t_ThreadGroup_getMaxPriority(t_ThreadGroup *self)
    {
      jint result;
      OBJ_CALL(result = self->object.getMaxPriority());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_ThreadGroup_getName(t_ThreadGroup *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getName());
      return j2p(result);
    }

    static PyObject *t_ThreadGroup_getParent(t_ThreadGroup *self)
    {
      ThreadGroup result((jobject) NULL);
      OBJ_CALL(result = self->object.getParent());
      return t_ThreadGroup::wrap_Object(result);
    }

    static PyObject *t_ThreadGroup_interrupt(t_ThreadGroup *self)
    {
      OBJ_CALL(self->object.interrupt());
      Py_RETURN_NONE;
    }

    static PyObject *t_ThreadGroup_isDaemon(t_ThreadGroup *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isDaemon());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_ThreadGroup_isDestroyed(t_ThreadGroup *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isDestroyed());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_ThreadGroup_list(t_ThreadGroup *self)
    {
      OBJ_CALL(self->object.list());
      Py_RETURN_NONE;
    }

    static PyObject *t_ThreadGroup_parentOf(t_ThreadGroup *self, PyObject *arg)
    {
      ThreadGroup a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "k", ThreadGroup::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.parentOf(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "parentOf", arg);
      return NULL;
    }

    static PyObject *t_ThreadGroup_resume(t_ThreadGroup *self)
    {
      OBJ_CALL(self->object.resume());
      Py_RETURN_NONE;
    }

    static PyObject *t_ThreadGroup_setDaemon(t_ThreadGroup *self, PyObject *arg)
    {
      jboolean a0;

      if (!parseArg(arg, "Z", &a0))
      {
        OBJ_CALL(self->object.setDaemon(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setDaemon", arg);
      return NULL;
    }

    static PyObject *t_ThreadGroup_setMaxPriority(t_ThreadGroup *self, PyObject *arg)
    {
      jint a0;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(self->object.setMaxPriority(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setMaxPriority", arg);
      return NULL;
    }

    static PyObject *t_ThreadGroup_stop(t_ThreadGroup *self)
    {
      OBJ_CALL(self->object.stop());
      Py_RETURN_NONE;
    }

    static PyObject *t_ThreadGroup_suspend(t_ThreadGroup *self)
    {
      OBJ_CALL(self->object.suspend());
      Py_RETURN_NONE;
    }

    static PyObject *t_ThreadGroup_toString(t_ThreadGroup *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(ThreadGroup), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_ThreadGroup_uncaughtException(t_ThreadGroup *self, PyObject *args)
    {
      ::java::lang::Thread a0((jobject) NULL);
      ::java::lang::Throwable a1((jobject) NULL);

      if (!parseArgs(args, "kk", ::java::lang::Thread::initializeClass, ::java::lang::Throwable::initializeClass, &a0, &a1))
      {
        OBJ_CALL(self->object.uncaughtException(a0, a1));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "uncaughtException", args);
      return NULL;
    }

    static PyObject *t_ThreadGroup_get__daemon(t_ThreadGroup *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isDaemon());
      Py_RETURN_BOOL(value);
    }
    static int t_ThreadGroup_set__daemon(t_ThreadGroup *self, PyObject *arg, void *data)
    {
      {
        jboolean value;
        if (!parseArg(arg, "Z", &value))
        {
          INT_CALL(self->object.setDaemon(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "daemon", arg);
      return -1;
    }

    static PyObject *t_ThreadGroup_get__destroyed(t_ThreadGroup *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isDestroyed());
      Py_RETURN_BOOL(value);
    }

    static PyObject *t_ThreadGroup_get__maxPriority(t_ThreadGroup *self, void *data)
    {
      jint value;
      OBJ_CALL(value = self->object.getMaxPriority());
      return PyLong_FromLong((long) value);
    }
    static int t_ThreadGroup_set__maxPriority(t_ThreadGroup *self, PyObject *arg, void *data)
    {
      {
        jint value;
        if (!parseArg(arg, "I", &value))
        {
          INT_CALL(self->object.setMaxPriority(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "maxPriority", arg);
      return -1;
    }

    static PyObject *t_ThreadGroup_get__name(t_ThreadGroup *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getName());
      return j2p(value);
    }

    static PyObject *t_ThreadGroup_get__parent(t_ThreadGroup *self, void *data)
    {
      ThreadGroup value((jobject) NULL);
      OBJ_CALL(value = self->object.getParent());
      return t_ThreadGroup::wrap_Object(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/BufferedWriter.h"
#include "java/lang/String.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *BufferedWriter::class$ = NULL;
    jmethodID *BufferedWriter::mids$ = NULL;
    bool BufferedWriter::live$ = false;

    jclass BufferedWriter::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/BufferedWriter");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_86f814b19baecb9d] = env->getMethodID(cls, "<init>", "(Ljava/io/Writer;)V");
        mids$[mid_init$_cb6f61479f506b95] = env->getMethodID(cls, "<init>", "(Ljava/io/Writer;I)V");
        mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");
        mids$[mid_flush_f2cc1bce94666404] = env->getMethodID(cls, "flush", "()V");
        mids$[mid_newLine_f2cc1bce94666404] = env->getMethodID(cls, "newLine", "()V");
        mids$[mid_write_040c4cd0390c5aff] = env->getMethodID(cls, "write", "(I)V");
        mids$[mid_write_d5128be76a214037] = env->getMethodID(cls, "write", "([CII)V");
        mids$[mid_write_08af6957f9159d4d] = env->getMethodID(cls, "write", "(Ljava/lang/String;II)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    BufferedWriter::BufferedWriter(const ::java::io::Writer & a0) : ::java::io::Writer(env->newObject(initializeClass, &mids$, mid_init$_86f814b19baecb9d, a0.this$)) {}

    BufferedWriter::BufferedWriter(const ::java::io::Writer & a0, jint a1) : ::java::io::Writer(env->newObject(initializeClass, &mids$, mid_init$_cb6f61479f506b95, a0.this$, a1)) {}

    void BufferedWriter::close() const
    {
      env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
    }

    void BufferedWriter::flush() const
    {
      env->callVoidMethod(this$, mids$[mid_flush_f2cc1bce94666404]);
    }

    void BufferedWriter::newLine() const
    {
      env->callVoidMethod(this$, mids$[mid_newLine_f2cc1bce94666404]);
    }

    void BufferedWriter::write(jint a0) const
    {
      env->callVoidMethod(this$, mids$[mid_write_040c4cd0390c5aff], a0);
    }

    void BufferedWriter::write(const JArray< jchar > & a0, jint a1, jint a2) const
    {
      env->callVoidMethod(this$, mids$[mid_write_d5128be76a214037], a0.this$, a1, a2);
    }

    void BufferedWriter::write(const ::java::lang::String & a0, jint a1, jint a2) const
    {
      env->callVoidMethod(this$, mids$[mid_write_08af6957f9159d4d], a0.this$, a1, a2);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_BufferedWriter_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_BufferedWriter_instance_(PyTypeObject *type, PyObject *arg);
    static int t_BufferedWriter_init_(t_BufferedWriter *self, PyObject *args, PyObject *kwds);
    static PyObject *t_BufferedWriter_close(t_BufferedWriter *self, PyObject *args);
    static PyObject *t_BufferedWriter_flush(t_BufferedWriter *self, PyObject *args);
    static PyObject *t_BufferedWriter_newLine(t_BufferedWriter *self);
    static PyObject *t_BufferedWriter_write(t_BufferedWriter *self, PyObject *args);

    static PyMethodDef t_BufferedWriter__methods_[] = {
      DECLARE_METHOD(t_BufferedWriter, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_BufferedWriter, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_BufferedWriter, close, METH_VARARGS),
      DECLARE_METHOD(t_BufferedWriter, flush, METH_VARARGS),
      DECLARE_METHOD(t_BufferedWriter, newLine, METH_NOARGS),
      DECLARE_METHOD(t_BufferedWriter, write, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(BufferedWriter)[] = {
      { Py_tp_methods, t_BufferedWriter__methods_ },
      { Py_tp_init, (void *) t_BufferedWriter_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(BufferedWriter)[] = {
      &PY_TYPE_DEF(::java::io::Writer),
      NULL
    };

    DEFINE_TYPE(BufferedWriter, t_BufferedWriter, BufferedWriter);

    void t_BufferedWriter::install(PyObject *module)
    {
      installType(&PY_TYPE(BufferedWriter), &PY_TYPE_DEF(BufferedWriter), module, "BufferedWriter", 0);
    }

    void t_BufferedWriter::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(BufferedWriter), "class_", make_descriptor(BufferedWriter::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(BufferedWriter), "wrapfn_", make_descriptor(t_BufferedWriter::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(BufferedWriter), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_BufferedWriter_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, BufferedWriter::initializeClass, 1)))
        return NULL;
      return t_BufferedWriter::wrap_Object(BufferedWriter(((t_BufferedWriter *) arg)->object.this$));
    }
    static PyObject *t_BufferedWriter_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, BufferedWriter::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_BufferedWriter_init_(t_BufferedWriter *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::io::Writer a0((jobject) NULL);
          BufferedWriter object((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::Writer::initializeClass, &a0))
          {
            INT_CALL(object = BufferedWriter(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::io::Writer a0((jobject) NULL);
          jint a1;
          BufferedWriter object((jobject) NULL);

          if (!parseArgs(args, "kI", ::java::io::Writer::initializeClass, &a0, &a1))
          {
            INT_CALL(object = BufferedWriter(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_BufferedWriter_close(t_BufferedWriter *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.close());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(BufferedWriter), (PyObject *) self, "close", args, 2);
    }

    static PyObject *t_BufferedWriter_flush(t_BufferedWriter *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.flush());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(BufferedWriter), (PyObject *) self, "flush", args, 2);
    }

    static PyObject *t_BufferedWriter_newLine(t_BufferedWriter *self)
    {
      OBJ_CALL(self->object.newLine());
      Py_RETURN_NONE;
    }

    static PyObject *t_BufferedWriter_write(t_BufferedWriter *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jint a0;

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(self->object.write(a0));
            Py_RETURN_NONE;
          }
        }
        break;
       case 3:
        {
          JArray< jchar > a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "[CII", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.write(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "sII", &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.write(a0, a1, a2));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(BufferedWriter), (PyObject *) self, "write", args, 2);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/CharSequence.h"
#include "java/lang/CharSequence.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *CharSequence::class$ = NULL;
    jmethodID *CharSequence::mids$ = NULL;
    bool CharSequence::live$ = false;

    jclass CharSequence::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/CharSequence");

        mids$ = new jmethodID[max_mid];
        mids$[mid_charAt_ebc61ec1e57770d1] = env->getMethodID(cls, "charAt", "(I)C");
        mids$[mid_length_9972fcc56b44e79d] = env->getMethodID(cls, "length", "()I");
        mids$[mid_subSequence_26d6f5be97bcdc38] = env->getMethodID(cls, "subSequence", "(II)Ljava/lang/CharSequence;");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jchar CharSequence::charAt(jint a0) const
    {
      return env->callCharMethod(this$, mids$[mid_charAt_ebc61ec1e57770d1], a0);
    }

    jint CharSequence::length() const
    {
      return env->callIntMethod(this$, mids$[mid_length_9972fcc56b44e79d]);
    }

    CharSequence CharSequence::subSequence(jint a0, jint a1) const
    {
      return CharSequence(env->callObjectMethod(this$, mids$[mid_subSequence_26d6f5be97bcdc38], a0, a1));
    }

    ::java::lang::String CharSequence::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_CharSequence_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_CharSequence_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_CharSequence_charAt(t_CharSequence *self, PyObject *arg);
    static PyObject *t_CharSequence_length(t_CharSequence *self);
    static PyObject *t_CharSequence_subSequence(t_CharSequence *self, PyObject *args);
    static PyObject *t_CharSequence_toString(t_CharSequence *self, PyObject *args);

    static PyMethodDef t_CharSequence__methods_[] = {
      DECLARE_METHOD(t_CharSequence, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_CharSequence, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_CharSequence, charAt, METH_O),
      DECLARE_METHOD(t_CharSequence, length, METH_NOARGS),
      DECLARE_METHOD(t_CharSequence, subSequence, METH_VARARGS),
      DECLARE_METHOD(t_CharSequence, toString, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(CharSequence)[] = {
      { Py_tp_methods, t_CharSequence__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(CharSequence)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(CharSequence, t_CharSequence, CharSequence);

    void t_CharSequence::install(PyObject *module)
    {
      installType(&PY_TYPE(CharSequence), &PY_TYPE_DEF(CharSequence), module, "CharSequence", 0);
    }

    void t_CharSequence::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(CharSequence), "class_", make_descriptor(CharSequence::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(CharSequence), "wrapfn_", make_descriptor(t_CharSequence::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(CharSequence), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_CharSequence_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, CharSequence::initializeClass, 1)))
        return NULL;
      return t_CharSequence::wrap_Object(CharSequence(((t_CharSequence *) arg)->object.this$));
    }
    static PyObject *t_CharSequence_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, CharSequence::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_CharSequence_charAt(t_CharSequence *self, PyObject *arg)
    {
      jint a0;
      jchar result;

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.charAt(a0));
        return c2p(result);
      }

      PyErr_SetArgsError((PyObject *) self, "charAt", arg);
      return NULL;
    }

    static PyObject *t_CharSequence_length(t_CharSequence *self)
    {
      jint result;
      OBJ_CALL(result = self->object.length());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_CharSequence_subSequence(t_CharSequence *self, PyObject *args)
    {
      jint a0;
      jint a1;
      CharSequence result((jobject) NULL);

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.subSequence(a0, a1));
        return t_CharSequence::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "subSequence", args);
      return NULL;
    }

    static PyObject *t_CharSequence_toString(t_CharSequence *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(CharSequence), (PyObject *) self, "toString", args, 2);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/List.h"
#include "java/util/function/UnaryOperator.h"
#include "java/util/Comparator.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/Spliterator.h"
#include "java/util/Iterator.h"
#include "java/util/List.h"
#include "java/util/ListIterator.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *List::class$ = NULL;
    jmethodID *List::mids$ = NULL;
    bool List::live$ = false;

    jclass List::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/List");

        mids$ = new jmethodID[max_mid];
        mids$[mid_add_8b72f2dcdde6fd1d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)Z");
        mids$[mid_add_cf6732d7dfcfc293] = env->getMethodID(cls, "add", "(ILjava/lang/Object;)V");
        mids$[mid_addAll_15d9cc2398c22637] = env->getMethodID(cls, "addAll", "(Ljava/util/Collection;)Z");
        mids$[mid_addAll_8980636bfaaa897b] = env->getMethodID(cls, "addAll", "(ILjava/util/Collection;)Z");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_contains_8b72f2dcdde6fd1d] = env->getMethodID(cls, "contains", "(Ljava/lang/Object;)Z");
        mids$[mid_containsAll_15d9cc2398c22637] = env->getMethodID(cls, "containsAll", "(Ljava/util/Collection;)Z");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_get_b15c79acb15c2870] = env->getMethodID(cls, "get", "(I)Ljava/lang/Object;");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_indexOf_5a4805a36cf611e7] = env->getMethodID(cls, "indexOf", "(Ljava/lang/Object;)I");
        mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
        mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
        mids$[mid_lastIndexOf_5a4805a36cf611e7] = env->getMethodID(cls, "lastIndexOf", "(Ljava/lang/Object;)I");
        mids$[mid_listIterator_78bda7a3d01214c3] = env->getMethodID(cls, "listIterator", "()Ljava/util/ListIterator;");
        mids$[mid_listIterator_8204cc66da390272] = env->getMethodID(cls, "listIterator", "(I)Ljava/util/ListIterator;");
        mids$[mid_remove_b15c79acb15c2870] = env->getMethodID(cls, "remove", "(I)Ljava/lang/Object;");
        mids$[mid_remove_8b72f2dcdde6fd1d] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Z");
        mids$[mid_removeAll_15d9cc2398c22637] = env->getMethodID(cls, "removeAll", "(Ljava/util/Collection;)Z");
        mids$[mid_replaceAll_9d70603eb4010f27] = env->getMethodID(cls, "replaceAll", "(Ljava/util/function/UnaryOperator;)V");
        mids$[mid_retainAll_15d9cc2398c22637] = env->getMethodID(cls, "retainAll", "(Ljava/util/Collection;)Z");
        mids$[mid_set_55e2638f354bbf61] = env->getMethodID(cls, "set", "(ILjava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
        mids$[mid_sort_4703504c5d45d50f] = env->getMethodID(cls, "sort", "(Ljava/util/Comparator;)V");
        mids$[mid_spliterator_7a761c107a8e14bd] = env->getMethodID(cls, "spliterator", "()Ljava/util/Spliterator;");
        mids$[mid_subList_e1795bf76fe1346f] = env->getMethodID(cls, "subList", "(II)Ljava/util/List;");
        mids$[mid_toArray_6becf78ffd87a9bc] = env->getMethodID(cls, "toArray", "()[Ljava/lang/Object;");
        mids$[mid_toArray_609b05756010dc5d] = env->getMethodID(cls, "toArray", "([Ljava/lang/Object;)[Ljava/lang/Object;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jboolean List::add(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_add_8b72f2dcdde6fd1d], a0.this$);
    }

    void List::add(jint a0, const ::java::lang::Object & a1) const
    {
      env->callVoidMethod(this$, mids$[mid_add_cf6732d7dfcfc293], a0, a1.this$);
    }

    jboolean List::addAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_15d9cc2398c22637], a0.this$);
    }

    jboolean List::addAll(jint a0, const ::java::util::Collection & a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_addAll_8980636bfaaa897b], a0, a1.this$);
    }

    void List::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    jboolean List::contains(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_contains_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean List::containsAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_containsAll_15d9cc2398c22637], a0.this$);
    }

    jboolean List::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object List::get(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_b15c79acb15c2870], a0));
    }

    jint List::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jint List::indexOf(const ::java::lang::Object & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_indexOf_5a4805a36cf611e7], a0.this$);
    }

    jboolean List::isEmpty() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
    }

    ::java::util::Iterator List::iterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
    }

    jint List::lastIndexOf(const ::java::lang::Object & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_lastIndexOf_5a4805a36cf611e7], a0.this$);
    }

    ::java::util::ListIterator List::listIterator() const
    {
      return ::java::util::ListIterator(env->callObjectMethod(this$, mids$[mid_listIterator_78bda7a3d01214c3]));
    }

    ::java::util::ListIterator List::listIterator(jint a0) const
    {
      return ::java::util::ListIterator(env->callObjectMethod(this$, mids$[mid_listIterator_8204cc66da390272], a0));
    }

    ::java::lang::Object List::remove(jint a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_b15c79acb15c2870], a0));
    }

    jboolean List::remove(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_remove_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean List::removeAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeAll_15d9cc2398c22637], a0.this$);
    }

    void List::replaceAll(const ::java::util::function::UnaryOperator & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_replaceAll_9d70603eb4010f27], a0.this$);
    }

    jboolean List::retainAll(const ::java::util::Collection & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_retainAll_15d9cc2398c22637], a0.this$);
    }

    ::java::lang::Object List::set(jint a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_set_55e2638f354bbf61], a0, a1.this$));
    }

    jint List::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }

    void List::sort(const ::java::util::Comparator & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_sort_4703504c5d45d50f], a0.this$);
    }

    ::java::util::Spliterator List::spliterator() const
    {
      return ::java::util::Spliterator(env->callObjectMethod(this$, mids$[mid_spliterator_7a761c107a8e14bd]));
    }

    List List::subList(jint a0, jint a1) const
    {
      return List(env->callObjectMethod(this$, mids$[mid_subList_e1795bf76fe1346f], a0, a1));
    }

    JArray< ::java::lang::Object > List::toArray() const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_6becf78ffd87a9bc]));
    }

    JArray< ::java::lang::Object > List::toArray(const JArray< ::java::lang::Object > & a0) const
    {
      return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_609b05756010dc5d], a0.this$));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_List_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_List_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_List_of_(t_List *self, PyObject *args);
    static PyObject *t_List_add(t_List *self, PyObject *args);
    static PyObject *t_List_addAll(t_List *self, PyObject *args);
    static PyObject *t_List_clear(t_List *self, PyObject *args);
    static PyObject *t_List_contains(t_List *self, PyObject *args);
    static PyObject *t_List_containsAll(t_List *self, PyObject *args);
    static PyObject *t_List_equals(t_List *self, PyObject *args);
    static PyObject *t_List_get(t_List *self, PyObject *arg);
    static PyObject *t_List_hashCode(t_List *self, PyObject *args);
    static PyObject *t_List_indexOf(t_List *self, PyObject *arg);
    static PyObject *t_List_isEmpty(t_List *self, PyObject *args);
    static PyObject *t_List_iterator(t_List *self, PyObject *args);
    static PyObject *t_List_lastIndexOf(t_List *self, PyObject *arg);
    static PyObject *t_List_listIterator(t_List *self, PyObject *args);
    static PyObject *t_List_remove(t_List *self, PyObject *args);
    static PyObject *t_List_removeAll(t_List *self, PyObject *args);
    static PyObject *t_List_replaceAll(t_List *self, PyObject *arg);
    static PyObject *t_List_retainAll(t_List *self, PyObject *args);
    static PyObject *t_List_set(t_List *self, PyObject *args);
    static PyObject *t_List_size(t_List *self, PyObject *args);
    static PyObject *t_List_sort(t_List *self, PyObject *arg);
    static PyObject *t_List_spliterator(t_List *self, PyObject *args);
    static PyObject *t_List_subList(t_List *self, PyObject *args);
    static PyObject *t_List_toArray(t_List *self, PyObject *args);
    static PyObject *t_List_get__empty(t_List *self, void *data);
    static PyObject *t_List_get__parameters_(t_List *self, void *data);
    static PyGetSetDef t_List__fields_[] = {
      DECLARE_GET_FIELD(t_List, empty),
      DECLARE_GET_FIELD(t_List, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_List__methods_[] = {
      DECLARE_METHOD(t_List, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_List, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_List, of_, METH_VARARGS),
      DECLARE_METHOD(t_List, add, METH_VARARGS),
      DECLARE_METHOD(t_List, addAll, METH_VARARGS),
      DECLARE_METHOD(t_List, clear, METH_VARARGS),
      DECLARE_METHOD(t_List, contains, METH_VARARGS),
      DECLARE_METHOD(t_List, containsAll, METH_VARARGS),
      DECLARE_METHOD(t_List, equals, METH_VARARGS),
      DECLARE_METHOD(t_List, get, METH_O),
      DECLARE_METHOD(t_List, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_List, indexOf, METH_O),
      DECLARE_METHOD(t_List, isEmpty, METH_VARARGS),
      DECLARE_METHOD(t_List, iterator, METH_VARARGS),
      DECLARE_METHOD(t_List, lastIndexOf, METH_O),
      DECLARE_METHOD(t_List, listIterator, METH_VARARGS),
      DECLARE_METHOD(t_List, remove, METH_VARARGS),
      DECLARE_METHOD(t_List, removeAll, METH_VARARGS),
      DECLARE_METHOD(t_List, replaceAll, METH_O),
      DECLARE_METHOD(t_List, retainAll, METH_VARARGS),
      DECLARE_METHOD(t_List, set, METH_VARARGS),
      DECLARE_METHOD(t_List, size, METH_VARARGS),
      DECLARE_METHOD(t_List, sort, METH_O),
      DECLARE_METHOD(t_List, spliterator, METH_VARARGS),
      DECLARE_METHOD(t_List, subList, METH_VARARGS),
      DECLARE_METHOD(t_List, toArray, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(List)[] = {
      { Py_tp_methods, t_List__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_List__fields_ },
      { Py_tp_iter, (void *) ((PyObject *(*)(t_List *)) get_generic_iterator< t_List >) },
      { Py_tp_iternext, (void *) 0 },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(List)[] = {
      &PY_TYPE_DEF(::java::util::Collection),
      NULL
    };

    DEFINE_TYPE(List, t_List, List);
    PyObject *t_List::wrap_Object(const List& object, PyTypeObject *p0)
    {
      PyObject *obj = t_List::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_List *self = (t_List *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_List::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_List::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_List *self = (t_List *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_List::install(PyObject *module)
    {
      installType(&PY_TYPE(List), &PY_TYPE_DEF(List), module, "List", 0);
    }

    void t_List::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(List), "class_", make_descriptor(List::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(List), "wrapfn_", make_descriptor(t_List::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(List), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_List_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, List::initializeClass, 1)))
        return NULL;
      return t_List::wrap_Object(List(((t_List *) arg)->object.this$));
    }
    static PyObject *t_List_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, List::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_List_of_(t_List *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_List_add(t_List *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "O", self->parameters[0], &a0))
          {
            OBJ_CALL(result = self->object.add(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          ::java::lang::Object a1((jobject) NULL);

          if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
          {
            OBJ_CALL(self->object.add(a0, a1));
            Py_RETURN_NONE;
          }
        }
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "add", args, 2);
    }

    static PyObject *t_List_addAll(t_List *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::util::Collection a0((jobject) NULL);
          PyTypeObject **p0;
          jboolean result;

          if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
          {
            OBJ_CALL(result = self->object.addAll(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jint a0;
          ::java::util::Collection a1((jobject) NULL);
          PyTypeObject **p1;
          jboolean result;

          if (!parseArgs(args, "IK", ::java::util::Collection::initializeClass, &a0, &a1, &p1, ::java::util::t_Collection::parameters_))
          {
            OBJ_CALL(result = self->object.addAll(a0, a1));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "addAll", args, 2);
    }

    static PyObject *t_List_clear(t_List *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.clear());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "clear", args, 2);
    }

    static PyObject *t_List_contains(t_List *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.contains(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "contains", args, 2);
    }

    static PyObject *t_List_containsAll(t_List *self, PyObject *args)
    {
      ::java::util::Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.containsAll(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "containsAll", args, 2);
    }

    static PyObject *t_List_equals(t_List *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_List_get(t_List *self, PyObject *arg)
    {
      jint a0;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArg(arg, "I", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "get", arg);
      return NULL;
    }

    static PyObject *t_List_hashCode(t_List *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_List_indexOf(t_List *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jint result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.indexOf(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "indexOf", arg);
      return NULL;
    }

    static PyObject *t_List_isEmpty(t_List *self, PyObject *args)
    {
      jboolean result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.isEmpty());
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "isEmpty", args, 2);
    }

    static PyObject *t_List_iterator(t_List *self, PyObject *args)
    {
      ::java::util::Iterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.iterator());
        return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "iterator", args, 2);
    }

    static PyObject *t_List_lastIndexOf(t_List *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jint result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.lastIndexOf(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "lastIndexOf", arg);
      return NULL;
    }

    static PyObject *t_List_listIterator(t_List *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::util::ListIterator result((jobject) NULL);
          OBJ_CALL(result = self->object.listIterator());
          return ::java::util::t_ListIterator::wrap_Object(result, self->parameters[0]);
        }
        break;
       case 1:
        {
          jint a0;
          ::java::util::ListIterator result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.listIterator(a0));
            return ::java::util::t_ListIterator::wrap_Object(result, self->parameters[0]);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "listIterator", args);
      return NULL;
    }

    static PyObject *t_List_remove(t_List *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jint a0;
          ::java::lang::Object result((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            OBJ_CALL(result = self->object.remove(a0));
            return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
          }
        }
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(result = self->object.remove(a0));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_List_removeAll(t_List *self, PyObject *args)
    {
      ::java::util::Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.removeAll(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "removeAll", args, 2);
    }

    static PyObject *t_List_replaceAll(t_List *self, PyObject *arg)
    {
      ::java::util::function::UnaryOperator a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", ::java::util::function::UnaryOperator::initializeClass, &a0, &p0, ::java::util::function::t_UnaryOperator::parameters_))
      {
        OBJ_CALL(self->object.replaceAll(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "replaceAll", arg);
      return NULL;
    }

    static PyObject *t_List_retainAll(t_List *self, PyObject *args)
    {
      ::java::util::Collection a0((jobject) NULL);
      PyTypeObject **p0;
      jboolean result;

      if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
      {
        OBJ_CALL(result = self->object.retainAll(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "retainAll", args, 2);
    }

    static PyObject *t_List_set(t_List *self, PyObject *args)
    {
      jint a0;
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "IO", self->parameters[0], &a0, &a1))
      {
        OBJ_CALL(result = self->object.set(a0, a1));
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "set", args);
      return NULL;
    }

    static PyObject *t_List_size(t_List *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.size());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "size", args, 2);
    }

    static PyObject *t_List_sort(t_List *self, PyObject *arg)
    {
      ::java::util::Comparator a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", ::java::util::Comparator::initializeClass, &a0, &p0, ::java::util::t_Comparator::parameters_))
      {
        OBJ_CALL(self->object.sort(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "sort", arg);
      return NULL;
    }

    static PyObject *t_List_spliterator(t_List *self, PyObject *args)
    {
      ::java::util::Spliterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.spliterator());
        return ::java::util::t_Spliterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "spliterator", args, 2);
    }

    static PyObject *t_List_subList(t_List *self, PyObject *args)
    {
      jint a0;
      jint a1;
      List result((jobject) NULL);

      if (!parseArgs(args, "II", &a0, &a1))
      {
        OBJ_CALL(result = self->object.subList(a0, a1));
        return t_List::wrap_Object(result, self->parameters[0]);
      }

      PyErr_SetArgsError((PyObject *) self, "subList", args);
      return NULL;
    }

    static PyObject *t_List_toArray(t_List *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          JArray< ::java::lang::Object > result((jobject) NULL);
          OBJ_CALL(result = self->object.toArray());
          return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
        }
        break;
       case 1:
        {
          JArray< ::java::lang::Object > a0((jobject) NULL);
          JArray< ::java::lang::Object > result((jobject) NULL);

          if (!parseArgs(args, "[o", &a0))
          {
            OBJ_CALL(result = self->object.toArray(a0));
            return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
          }
        }
      }

      return callSuper(PY_TYPE(List), (PyObject *) self, "toArray", args, 2);
    }
    static PyObject *t_List_get__parameters_(t_List *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_List_get__empty(t_List *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isEmpty());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/Predicate.h"
#include "java/util/function/Predicate.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *Predicate::class$ = NULL;
      jmethodID *Predicate::mids$ = NULL;
      bool Predicate::live$ = false;

      jclass Predicate::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/Predicate");

          mids$ = new jmethodID[max_mid];
          mids$[mid_and_515452f524aa22ff] = env->getMethodID(cls, "and", "(Ljava/util/function/Predicate;)Ljava/util/function/Predicate;");
          mids$[mid_isEqual_cf4e7bc1de6991d3] = env->getStaticMethodID(cls, "isEqual", "(Ljava/lang/Object;)Ljava/util/function/Predicate;");
          mids$[mid_negate_9642992f11d82349] = env->getMethodID(cls, "negate", "()Ljava/util/function/Predicate;");
          mids$[mid_or_515452f524aa22ff] = env->getMethodID(cls, "or", "(Ljava/util/function/Predicate;)Ljava/util/function/Predicate;");
          mids$[mid_test_8b72f2dcdde6fd1d] = env->getMethodID(cls, "test", "(Ljava/lang/Object;)Z");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      Predicate Predicate::and$(const Predicate & a0) const
      {
        return Predicate(env->callObjectMethod(this$, mids$[mid_and_515452f524aa22ff], a0.this$));
      }

      Predicate Predicate::isEqual(const ::java::lang::Object & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return Predicate(env->callStaticObjectMethod(cls, mids$[mid_isEqual_cf4e7bc1de6991d3], a0.this$));
      }

      Predicate Predicate::negate() const
      {
        return Predicate(env->callObjectMethod(this$, mids$[mid_negate_9642992f11d82349]));
      }

      Predicate Predicate::or$(const Predicate & a0) const
      {
        return Predicate(env->callObjectMethod(this$, mids$[mid_or_515452f524aa22ff], a0.this$));
      }

      jboolean Predicate::test(const ::java::lang::Object & a0) const
      {
        return env->callBooleanMethod(this$, mids$[mid_test_8b72f2dcdde6fd1d], a0.this$);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_Predicate_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Predicate_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Predicate_of_(t_Predicate *self, PyObject *args);
      static PyObject *t_Predicate_and(t_Predicate *self, PyObject *arg);
      static PyObject *t_Predicate_isEqual(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Predicate_negate(t_Predicate *self);
      static PyObject *t_Predicate_or(t_Predicate *self, PyObject *arg);
      static PyObject *t_Predicate_test(t_Predicate *self, PyObject *arg);
      static PyObject *t_Predicate_get__parameters_(t_Predicate *self, void *data);
      static PyGetSetDef t_Predicate__fields_[] = {
        DECLARE_GET_FIELD(t_Predicate, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_Predicate__methods_[] = {
        DECLARE_METHOD(t_Predicate, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Predicate, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Predicate, of_, METH_VARARGS),
        DECLARE_METHOD(t_Predicate, and, METH_O),
        DECLARE_METHOD(t_Predicate, isEqual, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Predicate, negate, METH_NOARGS),
        DECLARE_METHOD(t_Predicate, or, METH_O),
        DECLARE_METHOD(t_Predicate, test, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Predicate)[] = {
        { Py_tp_methods, t_Predicate__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_Predicate__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Predicate)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Predicate, t_Predicate, Predicate);
      PyObject *t_Predicate::wrap_Object(const Predicate& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Predicate::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Predicate *self = (t_Predicate *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_Predicate::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_Predicate::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_Predicate *self = (t_Predicate *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_Predicate::install(PyObject *module)
      {
        installType(&PY_TYPE(Predicate), &PY_TYPE_DEF(Predicate), module, "Predicate", 0);
      }

      void t_Predicate::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Predicate), "class_", make_descriptor(Predicate::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Predicate), "wrapfn_", make_descriptor(t_Predicate::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Predicate), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Predicate_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Predicate::initializeClass, 1)))
          return NULL;
        return t_Predicate::wrap_Object(Predicate(((t_Predicate *) arg)->object.this$));
      }
      static PyObject *t_Predicate_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Predicate::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Predicate_of_(t_Predicate *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_Predicate_and(t_Predicate *self, PyObject *arg)
      {
        Predicate a0((jobject) NULL);
        PyTypeObject **p0;
        Predicate result((jobject) NULL);

        if (!parseArg(arg, "K", Predicate::initializeClass, &a0, &p0, t_Predicate::parameters_))
        {
          OBJ_CALL(result = self->object.and$(a0));
          return t_Predicate::wrap_Object(result, self->parameters[0]);
        }

        PyErr_SetArgsError((PyObject *) self, "and", arg);
        return NULL;
      }

      static PyObject *t_Predicate_isEqual(PyTypeObject *type, PyObject *arg)
      {
        ::java::lang::Object a0((jobject) NULL);
        Predicate result((jobject) NULL);

        if (!parseArg(arg, "o", &a0))
        {
          OBJ_CALL(result = ::java::util::function::Predicate::isEqual(a0));
          return t_Predicate::wrap_Object(result);
        }

        PyErr_SetArgsError(type, "isEqual", arg);
        return NULL;
      }

      static PyObject *t_Predicate_negate(t_Predicate *self)
      {
        Predicate result((jobject) NULL);
        OBJ_CALL(result = self->object.negate());
        return t_Predicate::wrap_Object(result, self->parameters[0]);
      }

      static PyObject *t_Predicate_or(t_Predicate *self, PyObject *arg)
      {
        Predicate a0((jobject) NULL);
        PyTypeObject **p0;
        Predicate result((jobject) NULL);

        if (!parseArg(arg, "K", Predicate::initializeClass, &a0, &p0, t_Predicate::parameters_))
        {
          OBJ_CALL(result = self->object.or$(a0));
          return t_Predicate::wrap_Object(result, self->parameters[0]);
        }

        PyErr_SetArgsError((PyObject *) self, "or", arg);
        return NULL;
      }

      static PyObject *t_Predicate_test(t_Predicate *self, PyObject *arg)
      {
        ::java::lang::Object a0((jobject) NULL);
        jboolean result;

        if (!parseArg(arg, "O", self->parameters[0], &a0))
        {
          OBJ_CALL(result = self->object.test(a0));
          Py_RETURN_BOOL(result);
        }

        PyErr_SetArgsError((PyObject *) self, "test", arg);
        return NULL;
      }
      static PyObject *t_Predicate_get__parameters_(t_Predicate *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Comparable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Comparable::class$ = NULL;
    jmethodID *Comparable::mids$ = NULL;
    bool Comparable::live$ = false;

    jclass Comparable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Comparable");

        mids$ = new jmethodID[max_mid];
        mids$[mid_compareTo_5a4805a36cf611e7] = env->getMethodID(cls, "compareTo", "(Ljava/lang/Object;)I");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jint Comparable::compareTo(const ::java::lang::Object & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_compareTo_5a4805a36cf611e7], a0.this$);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Comparable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Comparable_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Comparable_of_(t_Comparable *self, PyObject *args);
    static PyObject *t_Comparable_compareTo(t_Comparable *self, PyObject *arg);
    static PyObject *t_Comparable_get__parameters_(t_Comparable *self, void *data);
    static PyGetSetDef t_Comparable__fields_[] = {
      DECLARE_GET_FIELD(t_Comparable, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Comparable__methods_[] = {
      DECLARE_METHOD(t_Comparable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Comparable, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Comparable, of_, METH_VARARGS),
      DECLARE_METHOD(t_Comparable, compareTo, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Comparable)[] = {
      { Py_tp_methods, t_Comparable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Comparable__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Comparable)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Comparable, t_Comparable, Comparable);
    PyObject *t_Comparable::wrap_Object(const Comparable& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Comparable::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Comparable *self = (t_Comparable *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Comparable::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Comparable::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Comparable *self = (t_Comparable *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Comparable::install(PyObject *module)
    {
      installType(&PY_TYPE(Comparable), &PY_TYPE_DEF(Comparable), module, "Comparable", 0);
    }

    void t_Comparable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Comparable), "class_", make_descriptor(Comparable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Comparable), "wrapfn_", make_descriptor(t_Comparable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Comparable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Comparable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Comparable::initializeClass, 1)))
        return NULL;
      return t_Comparable::wrap_Object(Comparable(((t_Comparable *) arg)->object.this$));
    }
    static PyObject *t_Comparable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Comparable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Comparable_of_(t_Comparable *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Comparable_compareTo(t_Comparable *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jint result;

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.compareTo(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "compareTo", arg);
      return NULL;
    }
    static PyObject *t_Comparable_get__parameters_(t_Comparable *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/BooleanSupplier.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *BooleanSupplier::class$ = NULL;
      jmethodID *BooleanSupplier::mids$ = NULL;
      bool BooleanSupplier::live$ = false;

      jclass BooleanSupplier::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/BooleanSupplier");

          mids$ = new jmethodID[max_mid];
          mids$[mid_getAsBoolean_8454bd5aa23fd11e] = env->getMethodID(cls, "getAsBoolean", "()Z");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jboolean BooleanSupplier::getAsBoolean() const
      {
        return env->callBooleanMethod(this$, mids$[mid_getAsBoolean_8454bd5aa23fd11e]);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_BooleanSupplier_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BooleanSupplier_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BooleanSupplier_getAsBoolean(t_BooleanSupplier *self);
      static PyObject *t_BooleanSupplier_get__asBoolean(t_BooleanSupplier *self, void *data);
      static PyGetSetDef t_BooleanSupplier__fields_[] = {
        DECLARE_GET_FIELD(t_BooleanSupplier, asBoolean),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_BooleanSupplier__methods_[] = {
        DECLARE_METHOD(t_BooleanSupplier, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_BooleanSupplier, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_BooleanSupplier, getAsBoolean, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(BooleanSupplier)[] = {
        { Py_tp_methods, t_BooleanSupplier__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_BooleanSupplier__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(BooleanSupplier)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(BooleanSupplier, t_BooleanSupplier, BooleanSupplier);

      void t_BooleanSupplier::install(PyObject *module)
      {
        installType(&PY_TYPE(BooleanSupplier), &PY_TYPE_DEF(BooleanSupplier), module, "BooleanSupplier", 0);
      }

      void t_BooleanSupplier::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(BooleanSupplier), "class_", make_descriptor(BooleanSupplier::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(BooleanSupplier), "wrapfn_", make_descriptor(t_BooleanSupplier::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(BooleanSupplier), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_BooleanSupplier_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, BooleanSupplier::initializeClass, 1)))
          return NULL;
        return t_BooleanSupplier::wrap_Object(BooleanSupplier(((t_BooleanSupplier *) arg)->object.this$));
      }
      static PyObject *t_BooleanSupplier_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, BooleanSupplier::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_BooleanSupplier_getAsBoolean(t_BooleanSupplier *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.getAsBoolean());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_BooleanSupplier_get__asBoolean(t_BooleanSupplier *self, void *data)
      {
        jboolean value;
        OBJ_CALL(value = self->object.getAsBoolean());
        Py_RETURN_BOOL(value);
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/BinaryOperator.h"
#include "java/util/Comparator.h"
#include "java/util/function/BinaryOperator.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *BinaryOperator::class$ = NULL;
      jmethodID *BinaryOperator::mids$ = NULL;
      bool BinaryOperator::live$ = false;

      jclass BinaryOperator::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/BinaryOperator");

          mids$ = new jmethodID[max_mid];
          mids$[mid_maxBy_659eecfd02c0231c] = env->getStaticMethodID(cls, "maxBy", "(Ljava/util/Comparator;)Ljava/util/function/BinaryOperator;");
          mids$[mid_minBy_659eecfd02c0231c] = env->getStaticMethodID(cls, "minBy", "(Ljava/util/Comparator;)Ljava/util/function/BinaryOperator;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      BinaryOperator BinaryOperator::maxBy(const ::java::util::Comparator & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return BinaryOperator(env->callStaticObjectMethod(cls, mids$[mid_maxBy_659eecfd02c0231c], a0.this$));
      }

      BinaryOperator BinaryOperator::minBy(const ::java::util::Comparator & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return BinaryOperator(env->callStaticObjectMethod(cls, mids$[mid_minBy_659eecfd02c0231c], a0.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_BinaryOperator_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BinaryOperator_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BinaryOperator_of_(t_BinaryOperator *self, PyObject *args);
      static PyObject *t_BinaryOperator_maxBy(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BinaryOperator_minBy(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BinaryOperator_get__parameters_(t_BinaryOperator *self, void *data);
      static PyGetSetDef t_BinaryOperator__fields_[] = {
        DECLARE_GET_FIELD(t_BinaryOperator, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_BinaryOperator__methods_[] = {
        DECLARE_METHOD(t_BinaryOperator, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_BinaryOperator, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_BinaryOperator, of_, METH_VARARGS),
        DECLARE_METHOD(t_BinaryOperator, maxBy, METH_O | METH_CLASS),
        DECLARE_METHOD(t_BinaryOperator, minBy, METH_O | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(BinaryOperator)[] = {
        { Py_tp_methods, t_BinaryOperator__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_BinaryOperator__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(BinaryOperator)[] = {
        &PY_TYPE_DEF(::java::util::function::BiFunction),
        NULL
      };

      DEFINE_TYPE(BinaryOperator, t_BinaryOperator, BinaryOperator);
      PyObject *t_BinaryOperator::wrap_Object(const BinaryOperator& object, PyTypeObject *p0)
      {
        PyObject *obj = t_BinaryOperator::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_BinaryOperator *self = (t_BinaryOperator *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_BinaryOperator::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_BinaryOperator::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_BinaryOperator *self = (t_BinaryOperator *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_BinaryOperator::install(PyObject *module)
      {
        installType(&PY_TYPE(BinaryOperator), &PY_TYPE_DEF(BinaryOperator), module, "BinaryOperator", 0);
      }

      void t_BinaryOperator::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(BinaryOperator), "class_", make_descriptor(BinaryOperator::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(BinaryOperator), "wrapfn_", make_descriptor(t_BinaryOperator::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(BinaryOperator), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_BinaryOperator_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, BinaryOperator::initializeClass, 1)))
          return NULL;
        return t_BinaryOperator::wrap_Object(BinaryOperator(((t_BinaryOperator *) arg)->object.this$));
      }
      static PyObject *t_BinaryOperator_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, BinaryOperator::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_BinaryOperator_of_(t_BinaryOperator *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_BinaryOperator_maxBy(PyTypeObject *type, PyObject *arg)
      {
        ::java::util::Comparator a0((jobject) NULL);
        PyTypeObject **p0;
        BinaryOperator result((jobject) NULL);

        if (!parseArg(arg, "K", ::java::util::Comparator::initializeClass, &a0, &p0, ::java::util::t_Comparator::parameters_))
        {
          OBJ_CALL(result = ::java::util::function::BinaryOperator::maxBy(a0));
          return t_BinaryOperator::wrap_Object(result);
        }

        PyErr_SetArgsError(type, "maxBy", arg);
        return NULL;
      }

      static PyObject *t_BinaryOperator_minBy(PyTypeObject *type, PyObject *arg)
      {
        ::java::util::Comparator a0((jobject) NULL);
        PyTypeObject **p0;
        BinaryOperator result((jobject) NULL);

        if (!parseArg(arg, "K", ::java::util::Comparator::initializeClass, &a0, &p0, ::java::util::t_Comparator::parameters_))
        {
          OBJ_CALL(result = ::java::util::function::BinaryOperator::minBy(a0));
          return t_BinaryOperator::wrap_Object(result);
        }

        PyErr_SetArgsError(type, "minBy", arg);
        return NULL;
      }
      static PyObject *t_BinaryOperator_get__parameters_(t_BinaryOperator *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/Flushable.h"
#include "java/io/IOException.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *Flushable::class$ = NULL;
    jmethodID *Flushable::mids$ = NULL;
    bool Flushable::live$ = false;

    jclass Flushable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/Flushable");

        mids$ = new jmethodID[max_mid];
        mids$[mid_flush_f2cc1bce94666404] = env->getMethodID(cls, "flush", "()V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Flushable::flush() const
    {
      env->callVoidMethod(this$, mids$[mid_flush_f2cc1bce94666404]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_Flushable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Flushable_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Flushable_flush(t_Flushable *self);

    static PyMethodDef t_Flushable__methods_[] = {
      DECLARE_METHOD(t_Flushable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Flushable, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Flushable, flush, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Flushable)[] = {
      { Py_tp_methods, t_Flushable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Flushable)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Flushable, t_Flushable, Flushable);

    void t_Flushable::install(PyObject *module)
    {
      installType(&PY_TYPE(Flushable), &PY_TYPE_DEF(Flushable), module, "Flushable", 0);
    }

    void t_Flushable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Flushable), "class_", make_descriptor(Flushable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Flushable), "wrapfn_", make_descriptor(t_Flushable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Flushable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Flushable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Flushable::initializeClass, 1)))
        return NULL;
      return t_Flushable::wrap_Object(Flushable(((t_Flushable *) arg)->object.this$));
    }
    static PyObject *t_Flushable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Flushable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Flushable_flush(t_Flushable *self)
    {
      OBJ_CALL(self->object.flush());
      Py_RETURN_NONE;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/Runnable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *Runnable::class$ = NULL;
    jmethodID *Runnable::mids$ = NULL;
    bool Runnable::live$ = false;

    jclass Runnable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/Runnable");

        mids$ = new jmethodID[max_mid];
        mids$[mid_run_f2cc1bce94666404] = env->getMethodID(cls, "run", "()V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Runnable::run() const
    {
      env->callVoidMethod(this$, mids$[mid_run_f2cc1bce94666404]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_Runnable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Runnable_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Runnable_run(t_Runnable *self);

    static PyMethodDef t_Runnable__methods_[] = {
      DECLARE_METHOD(t_Runnable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Runnable, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Runnable, run, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Runnable)[] = {
      { Py_tp_methods, t_Runnable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Runnable)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Runnable, t_Runnable, Runnable);

    void t_Runnable::install(PyObject *module)
    {
      installType(&PY_TYPE(Runnable), &PY_TYPE_DEF(Runnable), module, "Runnable", 0);
    }

    void t_Runnable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Runnable), "class_", make_descriptor(Runnable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Runnable), "wrapfn_", make_descriptor(t_Runnable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Runnable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Runnable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Runnable::initializeClass, 1)))
        return NULL;
      return t_Runnable::wrap_Object(Runnable(((t_Runnable *) arg)->object.this$));
    }
    static PyObject *t_Runnable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Runnable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Runnable_run(t_Runnable *self)
    {
      OBJ_CALL(self->object.run());
      Py_RETURN_NONE;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/IntFunction.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *IntFunction::class$ = NULL;
      jmethodID *IntFunction::mids$ = NULL;
      bool IntFunction::live$ = false;

      jclass IntFunction::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/IntFunction");

          mids$ = new jmethodID[max_mid];
          mids$[mid_apply_b15c79acb15c2870] = env->getMethodID(cls, "apply", "(I)Ljava/lang/Object;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::lang::Object IntFunction::apply(jint a0) const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_apply_b15c79acb15c2870], a0));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_IntFunction_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntFunction_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntFunction_of_(t_IntFunction *self, PyObject *args);
      static PyObject *t_IntFunction_apply(t_IntFunction *self, PyObject *arg);
      static PyObject *t_IntFunction_get__parameters_(t_IntFunction *self, void *data);
      static PyGetSetDef t_IntFunction__fields_[] = {
        DECLARE_GET_FIELD(t_IntFunction, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_IntFunction__methods_[] = {
        DECLARE_METHOD(t_IntFunction, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntFunction, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntFunction, of_, METH_VARARGS),
        DECLARE_METHOD(t_IntFunction, apply, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(IntFunction)[] = {
        { Py_tp_methods, t_IntFunction__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_IntFunction__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(IntFunction)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(IntFunction, t_IntFunction, IntFunction);
      PyObject *t_IntFunction::wrap_Object(const IntFunction& object, PyTypeObject *p0)
      {
        PyObject *obj = t_IntFunction::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_IntFunction *self = (t_IntFunction *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_IntFunction::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_IntFunction::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_IntFunction *self = (t_IntFunction *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_IntFunction::install(PyObject *module)
      {
        installType(&PY_TYPE(IntFunction), &PY_TYPE_DEF(IntFunction), module, "IntFunction", 0);
      }

      void t_IntFunction::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntFunction), "class_", make_descriptor(IntFunction::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntFunction), "wrapfn_", make_descriptor(t_IntFunction::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntFunction), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_IntFunction_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, IntFunction::initializeClass, 1)))
          return NULL;
        return t_IntFunction::wrap_Object(IntFunction(((t_IntFunction *) arg)->object.this$));
      }
      static PyObject *t_IntFunction_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, IntFunction::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_IntFunction_of_(t_IntFunction *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_IntFunction_apply(t_IntFunction *self, PyObject *arg)
      {
        jint a0;
        ::java::lang::Object result((jobject) NULL);

        if (!parseArg(arg, "I", &a0))
        {
          OBJ_CALL(result = self->object.apply(a0));
          return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "apply", arg);
        return NULL;
      }
      static PyObject *t_IntFunction_get__parameters_(t_IntFunction *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/Recognizer.h"
#include "org/antlr/v4/runtime/IntStream.h"
#include "java/util/Map.h"
#include "org/antlr/v4/runtime/atn/ATN.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/RecognitionException.h"
#include "org/antlr/v4/runtime/RuleContext.h"
#include "org/antlr/v4/runtime/TokenFactory.h"
#include "org/antlr/v4/runtime/Vocabulary.h"
#include "java/lang/Integer.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/ParseInfo.h"
#include "org/antlr/v4/runtime/ANTLRErrorListener.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/Token.h"
#include "org/antlr/v4/runtime/atn/ATNSimulator.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *Recognizer::class$ = NULL;
        jmethodID *Recognizer::mids$ = NULL;
        bool Recognizer::live$ = false;
        jint Recognizer::EOF = (jint) 0;

        jclass Recognizer::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/Recognizer");

            mids$ = new jmethodID[max_mid];
            mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
            mids$[mid_action_e8b0b6e737ed4ff0] = env->getMethodID(cls, "action", "(Lorg/antlr/v4/runtime/RuleContext;II)V");
            mids$[mid_addErrorListener_014abbe861a0405a] = env->getMethodID(cls, "addErrorListener", "(Lorg/antlr/v4/runtime/ANTLRErrorListener;)V");
            mids$[mid_getATN_268a26f1c0f83c9c] = env->getMethodID(cls, "getATN", "()Lorg/antlr/v4/runtime/atn/ATN;");
            mids$[mid_getErrorHeader_e10658582431be7e] = env->getMethodID(cls, "getErrorHeader", "(Lorg/antlr/v4/runtime/RecognitionException;)Ljava/lang/String;");
            mids$[mid_getErrorListenerDispatch_93cb7fdaf3ee9844] = env->getMethodID(cls, "getErrorListenerDispatch", "()Lorg/antlr/v4/runtime/ANTLRErrorListener;");
            mids$[mid_getErrorListeners_49ec78390f08338a] = env->getMethodID(cls, "getErrorListeners", "()Ljava/util/List;");
            mids$[mid_getGrammarFileName_db9b55ba01e03e4b] = env->getMethodID(cls, "getGrammarFileName", "()Ljava/lang/String;");
            mids$[mid_getInputStream_6b56ee5e0e064807] = env->getMethodID(cls, "getInputStream", "()Lorg/antlr/v4/runtime/IntStream;");
            mids$[mid_getInterpreter_c761e9c4ef94aa29] = env->getMethodID(cls, "getInterpreter", "()Lorg/antlr/v4/runtime/atn/ATNSimulator;");
            mids$[mid_getParseInfo_cda268cdd76646ee] = env->getMethodID(cls, "getParseInfo", "()Lorg/antlr/v4/runtime/atn/ParseInfo;");
            mids$[mid_getRuleIndexMap_1c3426541413a55d] = env->getMethodID(cls, "getRuleIndexMap", "()Ljava/util/Map;");
            mids$[mid_getRuleNames_9865da0b5ee490bc] = env->getMethodID(cls, "getRuleNames", "()[Ljava/lang/String;");
            mids$[mid_getSerializedATN_db9b55ba01e03e4b] = env->getMethodID(cls, "getSerializedATN", "()Ljava/lang/String;");
            mids$[mid_getState_9972fcc56b44e79d] = env->getMethodID(cls, "getState", "()I");
            mids$[mid_getTokenErrorDisplay_c9d1abb290ba4cd0] = env->getMethodID(cls, "getTokenErrorDisplay", "(Lorg/antlr/v4/runtime/Token;)Ljava/lang/String;");
            mids$[mid_getTokenFactory_9bf94c5de004cd3c] = env->getMethodID(cls, "getTokenFactory", "()Lorg/antlr/v4/runtime/TokenFactory;");
            mids$[mid_getTokenNames_9865da0b5ee490bc] = env->getMethodID(cls, "getTokenNames", "()[Ljava/lang/String;");
            mids$[mid_getTokenType_a5a7d1128e9e2bb7] = env->getMethodID(cls, "getTokenType", "(Ljava/lang/String;)I");
            mids$[mid_getTokenTypeMap_1c3426541413a55d] = env->getMethodID(cls, "getTokenTypeMap", "()Ljava/util/Map;");
            mids$[mid_getVocabulary_91f19806a4a1e6fd] = env->getMethodID(cls, "getVocabulary", "()Lorg/antlr/v4/runtime/Vocabulary;");
            mids$[mid_precpred_62eb40dbc3bda79d] = env->getMethodID(cls, "precpred", "(Lorg/antlr/v4/runtime/RuleContext;I)Z");
            mids$[mid_removeErrorListener_014abbe861a0405a] = env->getMethodID(cls, "removeErrorListener", "(Lorg/antlr/v4/runtime/ANTLRErrorListener;)V");
            mids$[mid_removeErrorListeners_f2cc1bce94666404] = env->getMethodID(cls, "removeErrorListeners", "()V");
            mids$[mid_sempred_62b88308de4b734a] = env->getMethodID(cls, "sempred", "(Lorg/antlr/v4/runtime/RuleContext;II)Z");
            mids$[mid_setInputStream_316a0f0e15ab92d4] = env->getMethodID(cls, "setInputStream", "(Lorg/antlr/v4/runtime/IntStream;)V");
            mids$[mid_setInterpreter_4bd1fd6f8f3ec57e] = env->getMethodID(cls, "setInterpreter", "(Lorg/antlr/v4/runtime/atn/ATNSimulator;)V");
            mids$[mid_setState_040c4cd0390c5aff] = env->getMethodID(cls, "setState", "(I)V");
            mids$[mid_setTokenFactory_a25e147938e67e01] = env->getMethodID(cls, "setTokenFactory", "(Lorg/antlr/v4/runtime/TokenFactory;)V");

            class$ = new ::java::lang::Class(cls);
            cls = (jclass) class$->this$;

            EOF = env->getStaticIntField(cls, "EOF");
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        Recognizer::Recognizer() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

        void Recognizer::action(const ::org::antlr::v4::runtime::RuleContext & a0, jint a1, jint a2) const
        {
          env->callVoidMethod(this$, mids$[mid_action_e8b0b6e737ed4ff0], a0.this$, a1, a2);
        }

        void Recognizer::addErrorListener(const ::org::antlr::v4::runtime::ANTLRErrorListener & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_addErrorListener_014abbe861a0405a], a0.this$);
        }

        ::org::antlr::v4::runtime::atn::ATN Recognizer::getATN() const
        {
          return ::org::antlr::v4::runtime::atn::ATN(env->callObjectMethod(this$, mids$[mid_getATN_268a26f1c0f83c9c]));
        }

        ::java::lang::String Recognizer::getErrorHeader(const ::org::antlr::v4::runtime::RecognitionException & a0) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getErrorHeader_e10658582431be7e], a0.this$));
        }

        ::org::antlr::v4::runtime::ANTLRErrorListener Recognizer::getErrorListenerDispatch() const
        {
          return ::org::antlr::v4::runtime::ANTLRErrorListener(env->callObjectMethod(this$, mids$[mid_getErrorListenerDispatch_93cb7fdaf3ee9844]));
        }

        ::java::util::List Recognizer::getErrorListeners() const
        {
          return ::java::util::List(env->callObjectMethod(this$, mids$[mid_getErrorListeners_49ec78390f08338a]));
        }

        ::java::lang::String Recognizer::getGrammarFileName() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getGrammarFileName_db9b55ba01e03e4b]));
        }

        ::org::antlr::v4::runtime::IntStream Recognizer::getInputStream() const
        {
          return ::org::antlr::v4::runtime::IntStream(env->callObjectMethod(this$, mids$[mid_getInputStream_6b56ee5e0e064807]));
        }

        ::org::antlr::v4::runtime::atn::ATNSimulator Recognizer::getInterpreter() const
        {
          return ::org::antlr::v4::runtime::atn::ATNSimulator(env->callObjectMethod(this$, mids$[mid_getInterpreter_c761e9c4ef94aa29]));
        }

        ::org::antlr::v4::runtime::atn::ParseInfo Recognizer::getParseInfo() const
        {
          return ::org::antlr::v4::runtime::atn::ParseInfo(env->callObjectMethod(this$, mids$[mid_getParseInfo_cda268cdd76646ee]));
        }

        ::java::util::Map Recognizer::getRuleIndexMap() const
        {
          return ::java::util::Map(env->callObjectMethod(this$, mids$[mid_getRuleIndexMap_1c3426541413a55d]));
        }

        JArray< ::java::lang::String > Recognizer::getRuleNames() const
        {
          return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_getRuleNames_9865da0b5ee490bc]));
        }

        ::java::lang::String Recognizer::getSerializedATN() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSerializedATN_db9b55ba01e03e4b]));
        }

        jint Recognizer::getState() const
        {
          return env->callIntMethod(this$, mids$[mid_getState_9972fcc56b44e79d]);
        }

        ::java::lang::String Recognizer::getTokenErrorDisplay(const ::org::antlr::v4::runtime::Token & a0) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getTokenErrorDisplay_c9d1abb290ba4cd0], a0.this$));
        }

        ::org::antlr::v4::runtime::TokenFactory Recognizer::getTokenFactory() const
        {
          return ::org::antlr::v4::runtime::TokenFactory(env->callObjectMethod(this$, mids$[mid_getTokenFactory_9bf94c5de004cd3c]));
        }

        JArray< ::java::lang::String > Recognizer::getTokenNames() const
        {
          return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_getTokenNames_9865da0b5ee490bc]));
        }

        jint Recognizer::getTokenType(const ::java::lang::String & a0) const
        {
          return env->callIntMethod(this$, mids$[mid_getTokenType_a5a7d1128e9e2bb7], a0.this$);
        }

        ::java::util::Map Recognizer::getTokenTypeMap() const
        {
          return ::java::util::Map(env->callObjectMethod(this$, mids$[mid_getTokenTypeMap_1c3426541413a55d]));
        }

        ::org::antlr::v4::runtime::Vocabulary Recognizer::getVocabulary() const
        {
          return ::org::antlr::v4::runtime::Vocabulary(env->callObjectMethod(this$, mids$[mid_getVocabulary_91f19806a4a1e6fd]));
        }

        jboolean Recognizer::precpred(const ::org::antlr::v4::runtime::RuleContext & a0, jint a1) const
        {
          return env->callBooleanMethod(this$, mids$[mid_precpred_62eb40dbc3bda79d], a0.this$, a1);
        }

        void Recognizer::removeErrorListener(const ::org::antlr::v4::runtime::ANTLRErrorListener & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_removeErrorListener_014abbe861a0405a], a0.this$);
        }

        void Recognizer::removeErrorListeners() const
        {
          env->callVoidMethod(this$, mids$[mid_removeErrorListeners_f2cc1bce94666404]);
        }

        jboolean Recognizer::sempred(const ::org::antlr::v4::runtime::RuleContext & a0, jint a1, jint a2) const
        {
          return env->callBooleanMethod(this$, mids$[mid_sempred_62b88308de4b734a], a0.this$, a1, a2);
        }

        void Recognizer::setInputStream(const ::org::antlr::v4::runtime::IntStream & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setInputStream_316a0f0e15ab92d4], a0.this$);
        }

        void Recognizer::setInterpreter(const ::org::antlr::v4::runtime::atn::ATNSimulator & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setInterpreter_4bd1fd6f8f3ec57e], a0.this$);
        }

        void Recognizer::setState(jint a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setState_040c4cd0390c5aff], a0);
        }

        void Recognizer::setTokenFactory(const ::org::antlr::v4::runtime::TokenFactory & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setTokenFactory_a25e147938e67e01], a0.this$);
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_Recognizer_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Recognizer_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Recognizer_of_(t_Recognizer *self, PyObject *args);
        static int t_Recognizer_init_(t_Recognizer *self, PyObject *args, PyObject *kwds);
        static PyObject *t_Recognizer_action(t_Recognizer *self, PyObject *args);
        static PyObject *t_Recognizer_addErrorListener(t_Recognizer *self, PyObject *arg);
        static PyObject *t_Recognizer_getATN(t_Recognizer *self);
        static PyObject *t_Recognizer_getErrorHeader(t_Recognizer *self, PyObject *arg);
        static PyObject *t_Recognizer_getErrorListenerDispatch(t_Recognizer *self);
        static PyObject *t_Recognizer_getErrorListeners(t_Recognizer *self);
        static PyObject *t_Recognizer_getGrammarFileName(t_Recognizer *self);
        static PyObject *t_Recognizer_getInputStream(t_Recognizer *self);
        static PyObject *t_Recognizer_getInterpreter(t_Recognizer *self);
        static PyObject *t_Recognizer_getParseInfo(t_Recognizer *self);
        static PyObject *t_Recognizer_getRuleIndexMap(t_Recognizer *self);
        static PyObject *t_Recognizer_getRuleNames(t_Recognizer *self);
        static PyObject *t_Recognizer_getSerializedATN(t_Recognizer *self);
        static PyObject *t_Recognizer_getState(t_Recognizer *self);
        static PyObject *t_Recognizer_getTokenErrorDisplay(t_Recognizer *self, PyObject *arg);
        static PyObject *t_Recognizer_getTokenFactory(t_Recognizer *self);
        static PyObject *t_Recognizer_getTokenNames(t_Recognizer *self);
        static PyObject *t_Recognizer_getTokenType(t_Recognizer *self, PyObject *arg);
        static PyObject *t_Recognizer_getTokenTypeMap(t_Recognizer *self);
        static PyObject *t_Recognizer_getVocabulary(t_Recognizer *self);
        static PyObject *t_Recognizer_precpred(t_Recognizer *self, PyObject *args);
        static PyObject *t_Recognizer_removeErrorListener(t_Recognizer *self, PyObject *arg);
        static PyObject *t_Recognizer_removeErrorListeners(t_Recognizer *self);
        static PyObject *t_Recognizer_sempred(t_Recognizer *self, PyObject *args);
        static PyObject *t_Recognizer_setInputStream(t_Recognizer *self, PyObject *arg);
        static PyObject *t_Recognizer_setInterpreter(t_Recognizer *self, PyObject *arg);
        static PyObject *t_Recognizer_setState(t_Recognizer *self, PyObject *arg);
        static PyObject *t_Recognizer_setTokenFactory(t_Recognizer *self, PyObject *arg);
        static PyObject *t_Recognizer_get__aTN(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__errorListenerDispatch(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__errorListeners(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__grammarFileName(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__inputStream(t_Recognizer *self, void *data);
        static int t_Recognizer_set__inputStream(t_Recognizer *self, PyObject *arg, void *data);
        static PyObject *t_Recognizer_get__interpreter(t_Recognizer *self, void *data);
        static int t_Recognizer_set__interpreter(t_Recognizer *self, PyObject *arg, void *data);
        static PyObject *t_Recognizer_get__parseInfo(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__ruleIndexMap(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__ruleNames(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__serializedATN(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__state(t_Recognizer *self, void *data);
        static int t_Recognizer_set__state(t_Recognizer *self, PyObject *arg, void *data);
        static PyObject *t_Recognizer_get__tokenFactory(t_Recognizer *self, void *data);
        static int t_Recognizer_set__tokenFactory(t_Recognizer *self, PyObject *arg, void *data);
        static PyObject *t_Recognizer_get__tokenNames(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__tokenTypeMap(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__vocabulary(t_Recognizer *self, void *data);
        static PyObject *t_Recognizer_get__parameters_(t_Recognizer *self, void *data);
        static PyGetSetDef t_Recognizer__fields_[] = {
          DECLARE_GET_FIELD(t_Recognizer, aTN),
          DECLARE_GET_FIELD(t_Recognizer, errorListenerDispatch),
          DECLARE_GET_FIELD(t_Recognizer, errorListeners),
          DECLARE_GET_FIELD(t_Recognizer, grammarFileName),
          DECLARE_GETSET_FIELD(t_Recognizer, inputStream),
          DECLARE_GETSET_FIELD(t_Recognizer, interpreter),
          DECLARE_GET_FIELD(t_Recognizer, parseInfo),
          DECLARE_GET_FIELD(t_Recognizer, ruleIndexMap),
          DECLARE_GET_FIELD(t_Recognizer, ruleNames),
          DECLARE_GET_FIELD(t_Recognizer, serializedATN),
          DECLARE_GETSET_FIELD(t_Recognizer, state),
          DECLARE_GETSET_FIELD(t_Recognizer, tokenFactory),
          DECLARE_GET_FIELD(t_Recognizer, tokenNames),
          DECLARE_GET_FIELD(t_Recognizer, tokenTypeMap),
          DECLARE_GET_FIELD(t_Recognizer, vocabulary),
          DECLARE_GET_FIELD(t_Recognizer, parameters_),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_Recognizer__methods_[] = {
          DECLARE_METHOD(t_Recognizer, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Recognizer, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Recognizer, of_, METH_VARARGS),
          DECLARE_METHOD(t_Recognizer, action, METH_VARARGS),
          DECLARE_METHOD(t_Recognizer, addErrorListener, METH_O),
          DECLARE_METHOD(t_Recognizer, getATN, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getErrorHeader, METH_O),
          DECLARE_METHOD(t_Recognizer, getErrorListenerDispatch, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getErrorListeners, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getGrammarFileName, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getInputStream, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getInterpreter, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getParseInfo, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getRuleIndexMap, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getRuleNames, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getSerializedATN, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getState, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getTokenErrorDisplay, METH_O),
          DECLARE_METHOD(t_Recognizer, getTokenFactory, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getTokenNames, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getTokenType, METH_O),
          DECLARE_METHOD(t_Recognizer, getTokenTypeMap, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, getVocabulary, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, precpred, METH_VARARGS),
          DECLARE_METHOD(t_Recognizer, removeErrorListener, METH_O),
          DECLARE_METHOD(t_Recognizer, removeErrorListeners, METH_NOARGS),
          DECLARE_METHOD(t_Recognizer, sempred, METH_VARARGS),
          DECLARE_METHOD(t_Recognizer, setInputStream, METH_O),
          DECLARE_METHOD(t_Recognizer, setInterpreter, METH_O),
          DECLARE_METHOD(t_Recognizer, setState, METH_O),
          DECLARE_METHOD(t_Recognizer, setTokenFactory, METH_O),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(Recognizer)[] = {
          { Py_tp_methods, t_Recognizer__methods_ },
          { Py_tp_init, (void *) t_Recognizer_init_ },
          { Py_tp_getset, t_Recognizer__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(Recognizer)[] = {
          &PY_TYPE_DEF(::java::lang::Object),
          NULL
        };

        DEFINE_TYPE(Recognizer, t_Recognizer, Recognizer);
        PyObject *t_Recognizer::wrap_Object(const Recognizer& object, PyTypeObject *p0, PyTypeObject *p1)
        {
          PyObject *obj = t_Recognizer::wrap_Object(object);
          if (obj != NULL && obj != Py_None)
          {
            t_Recognizer *self = (t_Recognizer *) obj;
            self->parameters[0] = p0;
            self->parameters[1] = p1;
          }
          return obj;
        }

        PyObject *t_Recognizer::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
        {
          PyObject *obj = t_Recognizer::wrap_jobject(object);
          if (obj != NULL && obj != Py_None)
          {
            t_Recognizer *self = (t_Recognizer *) obj;
            self->parameters[0] = p0;
            self->parameters[1] = p1;
          }
          return obj;
        }

        void t_Recognizer::install(PyObject *module)
        {
          installType(&PY_TYPE(Recognizer), &PY_TYPE_DEF(Recognizer), module, "Recognizer", 0);
        }

        void t_Recognizer::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(Recognizer), "class_", make_descriptor(Recognizer::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Recognizer), "wrapfn_", make_descriptor(t_Recognizer::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Recognizer), "boxfn_", make_descriptor(boxObject));
          env->getClass(Recognizer::initializeClass);
          PyObject_SetAttrString((PyObject *) PY_TYPE(Recognizer), "EOF", make_descriptor(Recognizer::EOF));
        }

        static PyObject *t_Recognizer_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, Recognizer::initializeClass, 1)))
            return NULL;
          return t_Recognizer::wrap_Object(Recognizer(((t_Recognizer *) arg)->object.this$));
        }
        static PyObject *t_Recognizer_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, Recognizer::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_Recognizer_of_(t_Recognizer *self, PyObject *args)
        {
          if (!parseArg(args, "T", 2, &(self->parameters)))
            Py_RETURN_SELF;
          return PyErr_SetArgsError((PyObject *) self, "of_", args);
        }

        static int t_Recognizer_init_(t_Recognizer *self, PyObject *args, PyObject *kwds)
        {
          Recognizer object((jobject) NULL);

          INT_CALL(object = Recognizer());
          self->object = object;

          return 0;
        }

        static PyObject *t_Recognizer_action(t_Recognizer *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::RuleContext a0((jobject) NULL);
          jint a1;
          jint a2;

          if (!parseArgs(args, "kII", ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0, &a1, &a2))
          {
            OBJ_CALL(self->object.action(a0, a1, a2));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "action", args);
          return NULL;
        }

        static PyObject *t_Recognizer_addErrorListener(t_Recognizer *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::ANTLRErrorListener a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::ANTLRErrorListener::initializeClass, &a0))
          {
            OBJ_CALL(self->object.addErrorListener(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "addErrorListener", arg);
          return NULL;
        }

        static PyObject *t_Recognizer_getATN(t_Recognizer *self)
        {
          ::org::antlr::v4::runtime::atn::ATN result((jobject) NULL);
          OBJ_CALL(result = self->object.getATN());
          return ::org::antlr::v4::runtime::atn::t_ATN::wrap_Object(result);
        }

        static PyObject *t_Recognizer_getErrorHeader(t_Recognizer *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::RecognitionException a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::RecognitionException::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getErrorHeader(a0));
            return j2p(result);
          }

          PyErr_SetArgsError((PyObject *) self, "getErrorHeader", arg);
          return NULL;
        }

        static PyObject *t_Recognizer_getErrorListenerDispatch(t_Recognizer *self)
        {
          ::org::antlr::v4::runtime::ANTLRErrorListener result((jobject) NULL);
          OBJ_CALL(result = self->object.getErrorListenerDispatch());
          return ::org::antlr::v4::runtime::t_ANTLRErrorListener::wrap_Object(result);
        }

        static PyObject *t_Recognizer_getErrorListeners(t_Recognizer *self)
        {
          ::java::util::List result((jobject) NULL);
          OBJ_CALL(result = self->object.getErrorListeners());
          return ::java::util::t_List::wrap_Object(result);
        }

        static PyObject *t_Recognizer_getGrammarFileName(t_Recognizer *self)
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getGrammarFileName());
          return j2p(result);
        }

        static PyObject *t_Recognizer_getInputStream(t_Recognizer *self)
        {
          ::org::antlr::v4::runtime::IntStream result((jobject) NULL);
          OBJ_CALL(result = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_IntStream::wrap_Object(result);
        }

        static PyObject *t_Recognizer_getInterpreter(t_Recognizer *self)
        {
          ::org::antlr::v4::runtime::atn::ATNSimulator result((jobject) NULL);
          OBJ_CALL(result = self->object.getInterpreter());
          return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::org::antlr::v4::runtime::atn::t_ATNSimulator::wrap_Object(result);
        }

        static PyObject *t_Recognizer_getParseInfo(t_Recognizer *self)
        {
          ::org::antlr::v4::runtime::atn::ParseInfo result((jobject) NULL);
          OBJ_CALL(result = self->object.getParseInfo());
          return ::org::antlr::v4::runtime::atn::t_ParseInfo::wrap_Object(result);
        }

        static PyObject *t_Recognizer_getRuleIndexMap(t_Recognizer *self)
        {
          ::java::util::Map result((jobject) NULL);
          OBJ_CALL(result = self->object.getRuleIndexMap());
          return ::java::util::t_Map::wrap_Object(result, ::java::lang::PY_TYPE(String), ::java::lang::PY_TYPE(Integer));
        }

        static PyObject *t_Recognizer_getRuleNames(t_Recognizer *self)
        {
          JArray< ::java::lang::String > result((jobject) NULL);
          OBJ_CALL(result = self->object.getRuleNames());
          return JArray<jstring>(result.this$).wrap();
        }

        static PyObject *t_Recognizer_getSerializedATN(t_Recognizer *self)
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getSerializedATN());
          return j2p(result);
        }

        static PyObject *t_Recognizer_getState(t_Recognizer *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getState());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Recognizer_getTokenErrorDisplay(t_Recognizer *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::Token a0((jobject) NULL);
          ::java::lang::String result((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::Token::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.getTokenErrorDisplay(a0));
            return j2p(result);
          }

          PyErr_SetArgsError((PyObject *) self, "getTokenErrorDisplay", arg);
          return NULL;
        }

        static PyObject *t_Recognizer_getTokenFactory(t_Recognizer *self)
        {
          ::org::antlr::v4::runtime::TokenFactory result((jobject) NULL);
          OBJ_CALL(result = self->object.getTokenFactory());
          return ::org::antlr::v4::runtime::t_TokenFactory::wrap_Object(result);
        }

        static PyObject *t_Recognizer_getTokenNames(t_Recognizer *self)
        {
          JArray< ::java::lang::String > result((jobject) NULL);
          OBJ_CALL(result = self->object.getTokenNames());
          return JArray<jstring>(result.this$).wrap();
        }

        static PyObject *t_Recognizer_getTokenType(t_Recognizer *self, PyObject *arg)
        {
          ::java::lang::String a0((jobject) NULL);
          jint result;

          if (!parseArg(arg, "s", &a0))
          {
            OBJ_CALL(result = self->object.getTokenType(a0));
            return PyLong_FromLong((long) result);
          }

          PyErr_SetArgsError((PyObject *) self, "getTokenType", arg);
          return NULL;
        }

        static PyObject *t_Recognizer_getTokenTypeMap(t_Recognizer *self)
        {
          ::java::util::Map result((jobject) NULL);
          OBJ_CALL(result = self->object.getTokenTypeMap());
          return ::java::util::t_Map::wrap_Object(result, ::java::lang::PY_TYPE(String), ::java::lang::PY_TYPE(Integer));
        }

        static PyObject *t_Recognizer_getVocabulary(t_Recognizer *self)
        {
          ::org::antlr::v4::runtime::Vocabulary result((jobject) NULL);
          OBJ_CALL(result = self->object.getVocabulary());
          return ::org::antlr::v4::runtime::t_Vocabulary::wrap_Object(result);
        }

        static PyObject *t_Recognizer_precpred(t_Recognizer *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::RuleContext a0((jobject) NULL);
          jint a1;
          jboolean result;

          if (!parseArgs(args, "kI", ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0, &a1))
          {
            OBJ_CALL(result = self->object.precpred(a0, a1));
            Py_RETURN_BOOL(result);
          }

          PyErr_SetArgsError((PyObject *) self, "precpred", args);
          return NULL;
        }

        static PyObject *t_Recognizer_removeErrorListener(t_Recognizer *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::ANTLRErrorListener a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::ANTLRErrorListener::initializeClass, &a0))
          {
            OBJ_CALL(self->object.removeErrorListener(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "removeErrorListener", arg);
          return NULL;
        }

        static PyObject *t_Recognizer_removeErrorListeners(t_Recognizer *self)
        {
          OBJ_CALL(self->object.removeErrorListeners());
          Py_RETURN_NONE;
        }

        static PyObject *t_Recognizer_sempred(t_Recognizer *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::RuleContext a0((jobject) NULL);
          jint a1;
          jint a2;
          jboolean result;

          if (!parseArgs(args, "kII", ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.sempred(a0, a1, a2));
            Py_RETURN_BOOL(result);
          }

          PyErr_SetArgsError((PyObject *) self, "sempred", args);
          return NULL;
        }

        static PyObject *t_Recognizer_setInputStream(t_Recognizer *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::IntStream a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::IntStream::initializeClass, &a0))
          {
            OBJ_CALL(self->object.setInputStream(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setInputStream", arg);
          return NULL;
        }

        static PyObject *t_Recognizer_setInterpreter(t_Recognizer *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::atn::ATNSimulator a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNSimulator::initializeClass, &a0))
          {
            OBJ_CALL(self->object.setInterpreter(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setInterpreter", arg);
          return NULL;
        }

        static PyObject *t_Recognizer_setState(t_Recognizer *self, PyObject *arg)
        {
          jint a0;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(self->object.setState(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setState", arg);
          return NULL;
        }

        static PyObject *t_Recognizer_setTokenFactory(t_Recognizer *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::TokenFactory a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArg(arg, "K", ::org::antlr::v4::runtime::TokenFactory::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_TokenFactory::parameters_))
          {
            OBJ_CALL(self->object.setTokenFactory(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setTokenFactory", arg);
          return NULL;
        }
        static PyObject *t_Recognizer_get__parameters_(t_Recognizer *self, void *data)
        {
          return typeParameters(self->parameters, sizeof(self->parameters));
        }

        static PyObject *t_Recognizer_get__aTN(t_Recognizer *self, void *data)
        {
          ::org::antlr::v4::runtime::atn::ATN value((jobject) NULL);
          OBJ_CALL(value = self->object.getATN());
          return ::org::antlr::v4::runtime::atn::t_ATN::wrap_Object(value);
        }

        static PyObject *t_Recognizer_get__errorListenerDispatch(t_Recognizer *self, void *data)
        {
          ::org::antlr::v4::runtime::ANTLRErrorListener value((jobject) NULL);
          OBJ_CALL(value = self->object.getErrorListenerDispatch());
          return ::org::antlr::v4::runtime::t_ANTLRErrorListener::wrap_Object(value);
        }

        static PyObject *t_Recognizer_get__errorListeners(t_Recognizer *self, void *data)
        {
          ::java::util::List value((jobject) NULL);
          OBJ_CALL(value = self->object.getErrorListeners());
          return ::java::util::t_List::wrap_Object(value);
        }

        static PyObject *t_Recognizer_get__grammarFileName(t_Recognizer *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object.getGrammarFileName());
          return j2p(value);
        }

        static PyObject *t_Recognizer_get__inputStream(t_Recognizer *self, void *data)
        {
          ::org::antlr::v4::runtime::IntStream value((jobject) NULL);
          OBJ_CALL(value = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_IntStream::wrap_Object(value);
        }
        static int t_Recognizer_set__inputStream(t_Recognizer *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::IntStream value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::IntStream::initializeClass, &value))
            {
              INT_CALL(self->object.setInputStream(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "inputStream", arg);
          return -1;
        }

        static PyObject *t_Recognizer_get__interpreter(t_Recognizer *self, void *data)
        {
          ::org::antlr::v4::runtime::atn::ATNSimulator value((jobject) NULL);
          OBJ_CALL(value = self->object.getInterpreter());
          return ::org::antlr::v4::runtime::atn::t_ATNSimulator::wrap_Object(value);
        }
        static int t_Recognizer_set__interpreter(t_Recognizer *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::atn::ATNSimulator value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNSimulator::initializeClass, &value))
            {
              INT_CALL(self->object.setInterpreter(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "interpreter", arg);
          return -1;
        }

        static PyObject *t_Recognizer_get__parseInfo(t_Recognizer *self, void *data)
        {
          ::org::antlr::v4::runtime::atn::ParseInfo value((jobject) NULL);
          OBJ_CALL(value = self->object.getParseInfo());
          return ::org::antlr::v4::runtime::atn::t_ParseInfo::wrap_Object(value);
        }

        static PyObject *t_Recognizer_get__ruleIndexMap(t_Recognizer *self, void *data)
        {
          ::java::util::Map value((jobject) NULL);
          OBJ_CALL(value = self->object.getRuleIndexMap());
          return ::java::util::t_Map::wrap_Object(value);
        }

        static PyObject *t_Recognizer_get__ruleNames(t_Recognizer *self, void *data)
        {
          JArray< ::java::lang::String > value((jobject) NULL);
          OBJ_CALL(value = self->object.getRuleNames());
          return JArray<jstring>(value.this$).wrap();
        }

        static PyObject *t_Recognizer_get__serializedATN(t_Recognizer *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object.getSerializedATN());
          return j2p(value);
        }

        static PyObject *t_Recognizer_get__state(t_Recognizer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getState());
          return PyLong_FromLong((long) value);
        }
        static int t_Recognizer_set__state(t_Recognizer *self, PyObject *arg, void *data)
        {
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object.setState(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "state", arg);
          return -1;
        }

        static PyObject *t_Recognizer_get__tokenFactory(t_Recognizer *self, void *data)
        {
          ::org::antlr::v4::runtime::TokenFactory value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenFactory());
          return ::org::antlr::v4::runtime::t_TokenFactory::wrap_Object(value);
        }
        static int t_Recognizer_set__tokenFactory(t_Recognizer *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::TokenFactory value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::TokenFactory::initializeClass, &value))
            {
              INT_CALL(self->object.setTokenFactory(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "tokenFactory", arg);
          return -1;
        }

        static PyObject *t_Recognizer_get__tokenNames(t_Recognizer *self, void *data)
        {
          JArray< ::java::lang::String > value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenNames());
          return JArray<jstring>(value.this$).wrap();
        }

        static PyObject *t_Recognizer_get__tokenTypeMap(t_Recognizer *self, void *data)
        {
          ::java::util::Map value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenTypeMap());
          return ::java::util::t_Map::wrap_Object(value);
        }

        static PyObject *t_Recognizer_get__vocabulary(t_Recognizer *self, void *data)
        {
          ::org::antlr::v4::runtime::Vocabulary value((jobject) NULL);
          OBJ_CALL(value = self->object.getVocabulary());
          return ::org::antlr::v4::runtime::t_Vocabulary::wrap_Object(value);
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Deque.h"
#include "java/lang/Object.h"
#include "java/util/Iterator.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Deque::class$ = NULL;
    jmethodID *Deque::mids$ = NULL;
    bool Deque::live$ = false;

    jclass Deque::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Deque");

        mids$ = new jmethodID[max_mid];
        mids$[mid_add_8b72f2dcdde6fd1d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)Z");
        mids$[mid_addFirst_d20f626183f72f7d] = env->getMethodID(cls, "addFirst", "(Ljava/lang/Object;)V");
        mids$[mid_addLast_d20f626183f72f7d] = env->getMethodID(cls, "addLast", "(Ljava/lang/Object;)V");
        mids$[mid_contains_8b72f2dcdde6fd1d] = env->getMethodID(cls, "contains", "(Ljava/lang/Object;)Z");
        mids$[mid_descendingIterator_233a192dadb0917d] = env->getMethodID(cls, "descendingIterator", "()Ljava/util/Iterator;");
        mids$[mid_element_d6bcd06f3102c4d9] = env->getMethodID(cls, "element", "()Ljava/lang/Object;");
        mids$[mid_getFirst_d6bcd06f3102c4d9] = env->getMethodID(cls, "getFirst", "()Ljava/lang/Object;");
        mids$[mid_getLast_d6bcd06f3102c4d9] = env->getMethodID(cls, "getLast", "()Ljava/lang/Object;");
        mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
        mids$[mid_offer_8b72f2dcdde6fd1d] = env->getMethodID(cls, "offer", "(Ljava/lang/Object;)Z");
        mids$[mid_offerFirst_8b72f2dcdde6fd1d] = env->getMethodID(cls, "offerFirst", "(Ljava/lang/Object;)Z");
        mids$[mid_offerLast_8b72f2dcdde6fd1d] = env->getMethodID(cls, "offerLast", "(Ljava/lang/Object;)Z");
        mids$[mid_peek_d6bcd06f3102c4d9] = env->getMethodID(cls, "peek", "()Ljava/lang/Object;");
        mids$[mid_peekFirst_d6bcd06f3102c4d9] = env->getMethodID(cls, "peekFirst", "()Ljava/lang/Object;");
        mids$[mid_peekLast_d6bcd06f3102c4d9] = env->getMethodID(cls, "peekLast", "()Ljava/lang/Object;");
        mids$[mid_poll_d6bcd06f3102c4d9] = env->getMethodID(cls, "poll", "()Ljava/lang/Object;");
        mids$[mid_pollFirst_d6bcd06f3102c4d9] = env->getMethodID(cls, "pollFirst", "()Ljava/lang/Object;");
        mids$[mid_pollLast_d6bcd06f3102c4d9] = env->getMethodID(cls, "pollLast", "()Ljava/lang/Object;");
        mids$[mid_pop_d6bcd06f3102c4d9] = env->getMethodID(cls, "pop", "()Ljava/lang/Object;");
        mids$[mid_push_d20f626183f72f7d] = env->getMethodID(cls, "push", "(Ljava/lang/Object;)V");
        mids$[mid_remove_d6bcd06f3102c4d9] = env->getMethodID(cls, "remove", "()Ljava/lang/Object;");
        mids$[mid_remove_8b72f2dcdde6fd1d] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Z");
        mids$[mid_removeFirst_d6bcd06f3102c4d9] = env->getMethodID(cls, "removeFirst", "()Ljava/lang/Object;");
        mids$[mid_removeFirstOccurrence_8b72f2dcdde6fd1d] = env->getMethodID(cls, "removeFirstOccurrence", "(Ljava/lang/Object;)Z");
        mids$[mid_removeLast_d6bcd06f3102c4d9] = env->getMethodID(cls, "removeLast", "()Ljava/lang/Object;");
        mids$[mid_removeLastOccurrence_8b72f2dcdde6fd1d] = env->getMethodID(cls, "removeLastOccurrence", "(Ljava/lang/Object;)Z");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jboolean Deque::add(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_add_8b72f2dcdde6fd1d], a0.this$);
    }

    void Deque::addFirst(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_addFirst_d20f626183f72f7d], a0.this$);
    }

    void Deque::addLast(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_addLast_d20f626183f72f7d], a0.this$);
    }

    jboolean Deque::contains(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_contains_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::util::Iterator Deque::descendingIterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_descendingIterator_233a192dadb0917d]));
    }

    ::java::lang::Object Deque::element() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_element_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Deque::getFirst() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_getFirst_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Deque::getLast() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_getLast_d6bcd06f3102c4d9]));
    }

    ::java::util::Iterator Deque::iterator() const
    {
      return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
    }

    jboolean Deque::offer(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_offer_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Deque::offerFirst(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_offerFirst_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Deque::offerLast(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_offerLast_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object Deque::peek() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_peek_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Deque::peekFirst() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_peekFirst_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Deque::peekLast() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_peekLast_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Deque::poll() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_poll_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Deque::pollFirst() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_pollFirst_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Deque::pollLast() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_pollLast_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Deque::pop() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_pop_d6bcd06f3102c4d9]));
    }

    void Deque::push(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_push_d20f626183f72f7d], a0.this$);
    }

    ::java::lang::Object Deque::remove() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_d6bcd06f3102c4d9]));
    }

    jboolean Deque::remove(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_remove_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object Deque::removeFirst() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_removeFirst_d6bcd06f3102c4d9]));
    }

    jboolean Deque::removeFirstOccurrence(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeFirstOccurrence_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::Object Deque::removeLast() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_removeLast_d6bcd06f3102c4d9]));
    }

    jboolean Deque::removeLastOccurrence(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_removeLastOccurrence_8b72f2dcdde6fd1d], a0.this$);
    }

    jint Deque::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Deque_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Deque_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Deque_of_(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_add(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_addFirst(t_Deque *self, PyObject *arg);
    static PyObject *t_Deque_addLast(t_Deque *self, PyObject *arg);
    static PyObject *t_Deque_contains(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_descendingIterator(t_Deque *self);
    static PyObject *t_Deque_element(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_getFirst(t_Deque *self);
    static PyObject *t_Deque_getLast(t_Deque *self);
    static PyObject *t_Deque_iterator(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_offer(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_offerFirst(t_Deque *self, PyObject *arg);
    static PyObject *t_Deque_offerLast(t_Deque *self, PyObject *arg);
    static PyObject *t_Deque_peek(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_peekFirst(t_Deque *self);
    static PyObject *t_Deque_peekLast(t_Deque *self);
    static PyObject *t_Deque_poll(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_pollFirst(t_Deque *self);
    static PyObject *t_Deque_pollLast(t_Deque *self);
    static PyObject *t_Deque_pop(t_Deque *self);
    static PyObject *t_Deque_push(t_Deque *self, PyObject *arg);
    static PyObject *t_Deque_remove(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_removeFirst(t_Deque *self);
    static PyObject *t_Deque_removeFirstOccurrence(t_Deque *self, PyObject *arg);
    static PyObject *t_Deque_removeLast(t_Deque *self);
    static PyObject *t_Deque_removeLastOccurrence(t_Deque *self, PyObject *arg);
    static PyObject *t_Deque_size(t_Deque *self, PyObject *args);
    static PyObject *t_Deque_get__first(t_Deque *self, void *data);
    static PyObject *t_Deque_get__last(t_Deque *self, void *data);
    static PyObject *t_Deque_get__parameters_(t_Deque *self, void *data);
    static PyGetSetDef t_Deque__fields_[] = {
      DECLARE_GET_FIELD(t_Deque, first),
      DECLARE_GET_FIELD(t_Deque, last),
      DECLARE_GET_FIELD(t_Deque, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Deque__methods_[] = {
      DECLARE_METHOD(t_Deque, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Deque, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Deque, of_, METH_VARARGS),
      DECLARE_METHOD(t_Deque, add, METH_VARARGS),
      DECLARE_METHOD(t_Deque, addFirst, METH_O),
      DECLARE_METHOD(t_Deque, addLast, METH_O),
      DECLARE_METHOD(t_Deque, contains, METH_VARARGS),
      DECLARE_METHOD(t_Deque, descendingIterator, METH_NOARGS),
      DECLARE_METHOD(t_Deque, element, METH_VARARGS),
      DECLARE_METHOD(t_Deque, getFirst, METH_NOARGS),
      DECLARE_METHOD(t_Deque, getLast, METH_NOARGS),
      DECLARE_METHOD(t_Deque, iterator, METH_VARARGS),
      DECLARE_METHOD(t_Deque, offer, METH_VARARGS),
      DECLARE_METHOD(t_Deque, offerFirst, METH_O),
      DECLARE_METHOD(t_Deque, offerLast, METH_O),
      DECLARE_METHOD(t_Deque, peek, METH_VARARGS),
      DECLARE_METHOD(t_Deque, peekFirst, METH_NOARGS),
      DECLARE_METHOD(t_Deque, peekLast, METH_NOARGS),
      DECLARE_METHOD(t_Deque, poll, METH_VARARGS),
      DECLARE_METHOD(t_Deque, pollFirst, METH_NOARGS),
      DECLARE_METHOD(t_Deque, pollLast, METH_NOARGS),
      DECLARE_METHOD(t_Deque, pop, METH_NOARGS),
      DECLARE_METHOD(t_Deque, push, METH_O),
      DECLARE_METHOD(t_Deque, remove, METH_VARARGS),
      DECLARE_METHOD(t_Deque, removeFirst, METH_NOARGS),
      DECLARE_METHOD(t_Deque, removeFirstOccurrence, METH_O),
      DECLARE_METHOD(t_Deque, removeLast, METH_NOARGS),
      DECLARE_METHOD(t_Deque, removeLastOccurrence, METH_O),
      DECLARE_METHOD(t_Deque, size, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Deque)[] = {
      { Py_tp_methods, t_Deque__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Deque__fields_ },
      { Py_tp_iter, (void *) ((PyObject *(*)(t_Deque *)) get_generic_iterator< t_Deque >) },
      { Py_tp_iternext, (void *) 0 },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Deque)[] = {
      &PY_TYPE_DEF(::java::util::Queue),
      NULL
    };

    DEFINE_TYPE(Deque, t_Deque, Deque);
    PyObject *t_Deque::wrap_Object(const Deque& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Deque::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Deque *self = (t_Deque *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Deque::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Deque::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Deque *self = (t_Deque *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Deque::install(PyObject *module)
    {
      installType(&PY_TYPE(Deque), &PY_TYPE_DEF(Deque), module, "Deque", 0);
    }

    void t_Deque::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Deque), "class_", make_descriptor(Deque::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Deque), "wrapfn_", make_descriptor(t_Deque::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Deque), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Deque_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Deque::initializeClass, 1)))
        return NULL;
      return t_Deque::wrap_Object(Deque(((t_Deque *) arg)->object.this$));
    }
    static PyObject *t_Deque_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Deque::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Deque_of_(t_Deque *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Deque_add(t_Deque *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.add(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Deque), (PyObject *) self, "add", args, 2);
    }

    static PyObject *t_Deque_addFirst(t_Deque *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(self->object.addFirst(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "addFirst", arg);
      return NULL;
    }

    static PyObject *t_Deque_addLast(t_Deque *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(self->object.addLast(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "addLast", arg);
      return NULL;
    }

    static PyObject *t_Deque_contains(t_Deque *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.contains(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Deque), (PyObject *) self, "contains", args, 2);
    }

    static PyObject *t_Deque_descendingIterator(t_Deque *self)
    {
      ::java::util::Iterator result((jobject) NULL);
      OBJ_CALL(result = self->object.descendingIterator());
      return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_Deque_element(t_Deque *self, PyObject *args)
    {
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.element());
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Deque), (PyObject *) self, "element", args, 2);
    }

    static PyObject *t_Deque_getFirst(t_Deque *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.getFirst());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Deque_getLast(t_Deque *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.getLast());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Deque_iterator(t_Deque *self, PyObject *args)
    {
      ::java::util::Iterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.iterator());
        return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(Deque), (PyObject *) self, "iterator", args, 2);
    }

    static PyObject *t_Deque_offer(t_Deque *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.offer(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Deque), (PyObject *) self, "offer", args, 2);
    }

    static PyObject *t_Deque_offerFirst(t_Deque *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.offerFirst(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "offerFirst", arg);
      return NULL;
    }

    static PyObject *t_Deque_offerLast(t_Deque *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.offerLast(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "offerLast", arg);
      return NULL;
    }

    static PyObject *t_Deque_peek(t_Deque *self, PyObject *args)
    {
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.peek());
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Deque), (PyObject *) self, "peek", args, 2);
    }

    static PyObject *t_Deque_peekFirst(t_Deque *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.peekFirst());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Deque_peekLast(t_Deque *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.peekLast());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Deque_poll(t_Deque *self, PyObject *args)
    {
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.poll());
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Deque), (PyObject *) self, "poll", args, 2);
    }

    static PyObject *t_Deque_pollFirst(t_Deque *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.pollFirst());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Deque_pollLast(t_Deque *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.pollLast());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Deque_pop(t_Deque *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.pop());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Deque_push(t_Deque *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(self->object.push(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "push", arg);
      return NULL;
    }

    static PyObject *t_Deque_remove(t_Deque *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          ::java::lang::Object result((jobject) NULL);
          OBJ_CALL(result = self->object.remove());
          return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
        }
        break;
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(result = self->object.remove(a0));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(Deque), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_Deque_removeFirst(t_Deque *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.removeFirst());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Deque_removeFirstOccurrence(t_Deque *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.removeFirstOccurrence(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "removeFirstOccurrence", arg);
      return NULL;
    }

    static PyObject *t_Deque_removeLast(t_Deque *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.removeLast());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Deque_removeLastOccurrence(t_Deque *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.removeLastOccurrence(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "removeLastOccurrence", arg);
      return NULL;
    }

    static PyObject *t_Deque_size(t_Deque *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.size());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Deque), (PyObject *) self, "size", args, 2);
    }
    static PyObject *t_Deque_get__parameters_(t_Deque *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_Deque_get__first(t_Deque *self, void *data)
    {
      ::java::lang::Object value((jobject) NULL);
      OBJ_CALL(value = self->object.getFirst());
      return ::java::lang::t_Object::wrap_Object(value);
    }

    static PyObject *t_Deque_get__last(t_Deque *self, void *data)
    {
      ::java::lang::Object value((jobject) NULL);
      OBJ_CALL(value = self->object.getLast());
      return ::java::lang::t_Object::wrap_Object(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/InterruptedException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *InterruptedException::class$ = NULL;
    jmethodID *InterruptedException::mids$ = NULL;
    bool InterruptedException::live$ = false;

    jclass InterruptedException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/InterruptedException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    InterruptedException::InterruptedException() : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    InterruptedException::InterruptedException(const ::java::lang::String & a0) : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_InterruptedException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_InterruptedException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_InterruptedException_init_(t_InterruptedException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_InterruptedException__methods_[] = {
      DECLARE_METHOD(t_InterruptedException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_InterruptedException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(InterruptedException)[] = {
      { Py_tp_methods, t_InterruptedException__methods_ },
      { Py_tp_init, (void *) t_InterruptedException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(InterruptedException)[] = {
      &PY_TYPE_DEF(::java::lang::Exception),
      NULL
    };

    DEFINE_TYPE(InterruptedException, t_InterruptedException, InterruptedException);

    void t_InterruptedException::install(PyObject *module)
    {
      installType(&PY_TYPE(InterruptedException), &PY_TYPE_DEF(InterruptedException), module, "InterruptedException", 0);
    }

    void t_InterruptedException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(InterruptedException), "class_", make_descriptor(InterruptedException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(InterruptedException), "wrapfn_", make_descriptor(t_InterruptedException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(InterruptedException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_InterruptedException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, InterruptedException::initializeClass, 1)))
        return NULL;
      return t_InterruptedException::wrap_Object(InterruptedException(((t_InterruptedException *) arg)->object.this$));
    }
    static PyObject *t_InterruptedException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, InterruptedException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_InterruptedException_init_(t_InterruptedException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          InterruptedException object((jobject) NULL);

          INT_CALL(object = InterruptedException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          InterruptedException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = InterruptedException(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/ClassLoader.h"
#include "java/io/InputStream.h"
#include "java/lang/Class.h"
#include "java/util/Enumeration.h"
#include "java/lang/String.h"
#include "java/lang/ClassNotFoundException.h"
#include "java/lang/ClassLoader.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *ClassLoader::class$ = NULL;
    jmethodID *ClassLoader::mids$ = NULL;
    bool ClassLoader::live$ = false;

    jclass ClassLoader::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/ClassLoader");

        mids$ = new jmethodID[max_mid];
        mids$[mid_clearAssertionStatus_f2cc1bce94666404] = env->getMethodID(cls, "clearAssertionStatus", "()V");
        mids$[mid_getParent_62052cb9b95d8b0c] = env->getMethodID(cls, "getParent", "()Ljava/lang/ClassLoader;");
        mids$[mid_getResourceAsStream_f9a3577e7bead470] = env->getMethodID(cls, "getResourceAsStream", "(Ljava/lang/String;)Ljava/io/InputStream;");
        mids$[mid_getSystemClassLoader_62052cb9b95d8b0c] = env->getStaticMethodID(cls, "getSystemClassLoader", "()Ljava/lang/ClassLoader;");
        mids$[mid_getSystemResourceAsStream_f9a3577e7bead470] = env->getStaticMethodID(cls, "getSystemResourceAsStream", "(Ljava/lang/String;)Ljava/io/InputStream;");
        mids$[mid_loadClass_337d52b895d55b49] = env->getMethodID(cls, "loadClass", "(Ljava/lang/String;)Ljava/lang/Class;");
        mids$[mid_setClassAssertionStatus_b1180807b87ba737] = env->getMethodID(cls, "setClassAssertionStatus", "(Ljava/lang/String;Z)V");
        mids$[mid_setDefaultAssertionStatus_9d72768e8fdce2b7] = env->getMethodID(cls, "setDefaultAssertionStatus", "(Z)V");
        mids$[mid_setPackageAssertionStatus_b1180807b87ba737] = env->getMethodID(cls, "setPackageAssertionStatus", "(Ljava/lang/String;Z)V");
        mids$[mid_loadClass_07cacfd51914a29b] = env->getMethodID(cls, "loadClass", "(Ljava/lang/String;Z)Ljava/lang/Class;");
        mids$[mid_getPackage_3e5bdfd63170837b] = env->getMethodID(cls, "getPackage", "(Ljava/lang/String;)Ljava/lang/Package;");
        mids$[mid_setSigners_95e87f089eee7e59] = env->getMethodID(cls, "setSigners", "(Ljava/lang/Class;[Ljava/lang/Object;)V");
        mids$[mid_getClassLoadingLock_c0a3c3394484d296] = env->getMethodID(cls, "getClassLoadingLock", "(Ljava/lang/String;)Ljava/lang/Object;");
        mids$[mid_findClass_337d52b895d55b49] = env->getMethodID(cls, "findClass", "(Ljava/lang/String;)Ljava/lang/Class;");
        mids$[mid_defineClass_ddd9b40425608e2d] = env->getMethodID(cls, "defineClass", "([BII)Ljava/lang/Class;");
        mids$[mid_defineClass_440c7446fa471578] = env->getMethodID(cls, "defineClass", "(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;");
        mids$[mid_defineClass_a79265bc4665fb67] = env->getMethodID(cls, "defineClass", "(Ljava/lang/String;[BII)Ljava/lang/Class;");
        mids$[mid_defineClass_ebc2298a3275b0c9] = env->getMethodID(cls, "defineClass", "(Ljava/lang/String;Ljava/nio/ByteBuffer;Ljava/security/ProtectionDomain;)Ljava/lang/Class;");
        mids$[mid_resolveClass_67ec072891501dcc] = env->getMethodID(cls, "resolveClass", "(Ljava/lang/Class;)V");
        mids$[mid_findSystemClass_337d52b895d55b49] = env->getMethodID(cls, "findSystemClass", "(Ljava/lang/String;)Ljava/lang/Class;");
        mids$[mid_findLoadedClass_337d52b895d55b49] = env->getMethodID(cls, "findLoadedClass", "(Ljava/lang/String;)Ljava/lang/Class;");
        mids$[mid_findResource_4fb0b493534ff9d9] = env->getMethodID(cls, "findResource", "(Ljava/lang/String;)Ljava/net/URL;");
        mids$[mid_findResources_2b96784a99c14cfc] = env->getMethodID(cls, "findResources", "(Ljava/lang/String;)Ljava/util/Enumeration;");
        mids$[mid_registerAsParallelCapable_8454bd5aa23fd11e] = env->getStaticMethodID(cls, "registerAsParallelCapable", "()Z");
        mids$[mid_definePackage_b972141526a39935] = env->getMethodID(cls, "definePackage", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/net/URL;)Ljava/lang/Package;");
        mids$[mid_getPackages_83e3803d8c61a052] = env->getMethodID(cls, "getPackages", "()[Ljava/lang/Package;");
        mids$[mid_findLibrary_9bfa75c9f141b67f] = env->getMethodID(cls, "findLibrary", "(Ljava/lang/String;)Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void ClassLoader::clearAssertionStatus() const
    {
      env->callVoidMethod(this$, mids$[mid_clearAssertionStatus_f2cc1bce94666404]);
    }

    ClassLoader ClassLoader::getParent() const
    {
      return ClassLoader(env->callObjectMethod(this$, mids$[mid_getParent_62052cb9b95d8b0c]));
    }

    ::java::io::InputStream ClassLoader::getResourceAsStream(const ::java::lang::String & a0) const
    {
      return ::java::io::InputStream(env->callObjectMethod(this$, mids$[mid_getResourceAsStream_f9a3577e7bead470], a0.this$));
    }

    ClassLoader ClassLoader::getSystemClassLoader()
    {
      jclass cls = env->getClass(initializeClass);
      return ClassLoader(env->callStaticObjectMethod(cls, mids$[mid_getSystemClassLoader_62052cb9b95d8b0c]));
    }

    ::java::io::InputStream ClassLoader::getSystemResourceAsStream(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::io::InputStream(env->callStaticObjectMethod(cls, mids$[mid_getSystemResourceAsStream_f9a3577e7bead470], a0.this$));
    }

    ::java::lang::Class ClassLoader::loadClass(const ::java::lang::String & a0) const
    {
      return ::java::lang::Class(env->callObjectMethod(this$, mids$[mid_loadClass_337d52b895d55b49], a0.this$));
    }

    void ClassLoader::setClassAssertionStatus(const ::java::lang::String & a0, jboolean a1) const
    {
      env->callVoidMethod(this$, mids$[mid_setClassAssertionStatus_b1180807b87ba737], a0.this$, a1);
    }

    void ClassLoader::setDefaultAssertionStatus(jboolean a0) const
    {
      env->callVoidMethod(this$, mids$[mid_setDefaultAssertionStatus_9d72768e8fdce2b7], a0);
    }

    void ClassLoader::setPackageAssertionStatus(const ::java::lang::String & a0, jboolean a1) const
    {
      env->callVoidMethod(this$, mids$[mid_setPackageAssertionStatus_b1180807b87ba737], a0.this$, a1);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_ClassLoader_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ClassLoader_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ClassLoader_clearAssertionStatus(t_ClassLoader *self);
    static PyObject *t_ClassLoader_getParent(t_ClassLoader *self);
    static PyObject *t_ClassLoader_getResourceAsStream(t_ClassLoader *self, PyObject *arg);
    static PyObject *t_ClassLoader_getSystemClassLoader(PyTypeObject *type);
    static PyObject *t_ClassLoader_getSystemResourceAsStream(PyTypeObject *type, PyObject *arg);
    static PyObject *t_ClassLoader_loadClass(t_ClassLoader *self, PyObject *arg);
    static PyObject *t_ClassLoader_setClassAssertionStatus(t_ClassLoader *self, PyObject *args);
    static PyObject *t_ClassLoader_setDefaultAssertionStatus(t_ClassLoader *self, PyObject *arg);
    static PyObject *t_ClassLoader_setPackageAssertionStatus(t_ClassLoader *self, PyObject *args);
    static int t_ClassLoader_set__defaultAssertionStatus(t_ClassLoader *self, PyObject *arg, void *data);
    static PyObject *t_ClassLoader_get__parent(t_ClassLoader *self, void *data);
    static PyObject *t_ClassLoader_get__systemClassLoader(t_ClassLoader *self, void *data);
    static PyGetSetDef t_ClassLoader__fields_[] = {
      DECLARE_SET_FIELD(t_ClassLoader, defaultAssertionStatus),
      DECLARE_GET_FIELD(t_ClassLoader, parent),
      DECLARE_GET_FIELD(t_ClassLoader, systemClassLoader),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_ClassLoader__methods_[] = {
      DECLARE_METHOD(t_ClassLoader, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ClassLoader, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ClassLoader, clearAssertionStatus, METH_NOARGS),
      DECLARE_METHOD(t_ClassLoader, getParent, METH_NOARGS),
      DECLARE_METHOD(t_ClassLoader, getResourceAsStream, METH_O),
      DECLARE_METHOD(t_ClassLoader, getSystemClassLoader, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_ClassLoader, getSystemResourceAsStream, METH_O | METH_CLASS),
      DECLARE_METHOD(t_ClassLoader, loadClass, METH_O),
      DECLARE_METHOD(t_ClassLoader, setClassAssertionStatus, METH_VARARGS),
      DECLARE_METHOD(t_ClassLoader, setDefaultAssertionStatus, METH_O),
      DECLARE_METHOD(t_ClassLoader, setPackageAssertionStatus, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(ClassLoader)[] = {
      { Py_tp_methods, t_ClassLoader__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_ClassLoader__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(ClassLoader)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(ClassLoader, t_ClassLoader, ClassLoader);

    void t_ClassLoader::install(PyObject *module)
    {
      installType(&PY_TYPE(ClassLoader), &PY_TYPE_DEF(ClassLoader), module, "ClassLoader", 0);
    }

    void t_ClassLoader::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(ClassLoader), "class_", make_descriptor(ClassLoader::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ClassLoader), "wrapfn_", make_descriptor(t_ClassLoader::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(ClassLoader), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_ClassLoader_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, ClassLoader::initializeClass, 1)))
        return NULL;
      return t_ClassLoader::wrap_Object(ClassLoader(((t_ClassLoader *) arg)->object.this$));
    }
    static PyObject *t_ClassLoader_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, ClassLoader::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_ClassLoader_clearAssertionStatus(t_ClassLoader *self)
    {
      OBJ_CALL(self->object.clearAssertionStatus());
      Py_RETURN_NONE;
    }

    static PyObject *t_ClassLoader_getParent(t_ClassLoader *self)
    {
      ClassLoader result((jobject) NULL);
      OBJ_CALL(result = self->object.getParent());
      return t_ClassLoader::wrap_Object(result);
    }

    static PyObject *t_ClassLoader_getResourceAsStream(t_ClassLoader *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      ::java::io::InputStream result((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = self->object.getResourceAsStream(a0));
        return ::java::io::t_InputStream::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "getResourceAsStream", arg);
      return NULL;
    }

    static PyObject *t_ClassLoader_getSystemClassLoader(PyTypeObject *type)
    {
      ClassLoader result((jobject) NULL);
      OBJ_CALL(result = ::java::lang::ClassLoader::getSystemClassLoader());
      return t_ClassLoader::wrap_Object(result);
    }

    static PyObject *t_ClassLoader_getSystemResourceAsStream(PyTypeObject *type, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      ::java::io::InputStream result((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = ::java::lang::ClassLoader::getSystemResourceAsStream(a0));
        return ::java::io::t_InputStream::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "getSystemResourceAsStream", arg);
      return NULL;
    }

    static PyObject *t_ClassLoader_loadClass(t_ClassLoader *self, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      ::java::lang::Class result((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = self->object.loadClass(a0));
        return ::java::lang::t_Class::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "loadClass", arg);
      return NULL;
    }

    static PyObject *t_ClassLoader_setClassAssertionStatus(t_ClassLoader *self, PyObject *args)
    {
      ::java::lang::String a0((jobject) NULL);
      jboolean a1;

      if (!parseArgs(args, "sZ", &a0, &a1))
      {
        OBJ_CALL(self->object.setClassAssertionStatus(a0, a1));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setClassAssertionStatus", args);
      return NULL;
    }

    static PyObject *t_ClassLoader_setDefaultAssertionStatus(t_ClassLoader *self, PyObject *arg)
    {
      jboolean a0;

      if (!parseArg(arg, "Z", &a0))
      {
        OBJ_CALL(self->object.setDefaultAssertionStatus(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setDefaultAssertionStatus", arg);
      return NULL;
    }

    static PyObject *t_ClassLoader_setPackageAssertionStatus(t_ClassLoader *self, PyObject *args)
    {
      ::java::lang::String a0((jobject) NULL);
      jboolean a1;

      if (!parseArgs(args, "sZ", &a0, &a1))
      {
        OBJ_CALL(self->object.setPackageAssertionStatus(a0, a1));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "setPackageAssertionStatus", args);
      return NULL;
    }

    static int t_ClassLoader_set__defaultAssertionStatus(t_ClassLoader *self, PyObject *arg, void *data)
    {
      {
        jboolean value;
        if (!parseArg(arg, "Z", &value))
        {
          INT_CALL(self->object.setDefaultAssertionStatus(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "defaultAssertionStatus", arg);
      return -1;
    }

    static PyObject *t_ClassLoader_get__parent(t_ClassLoader *self, void *data)
    {
      ClassLoader value((jobject) NULL);
      OBJ_CALL(value = self->object.getParent());
      return t_ClassLoader::wrap_Object(value);
    }

    static PyObject *t_ClassLoader_get__systemClassLoader(t_ClassLoader *self, void *data)
    {
      ClassLoader value((jobject) NULL);
      OBJ_CALL(value = self->object.getSystemClassLoader());
      return t_ClassLoader::wrap_Object(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/String.h"
#include "java/lang/Throwable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *IllegalArgumentException::class$ = NULL;
    jmethodID *IllegalArgumentException::mids$ = NULL;
    bool IllegalArgumentException::live$ = false;

    jclass IllegalArgumentException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/IllegalArgumentException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_471cfbdb800444a7] = env->getMethodID(cls, "<init>", "(Ljava/lang/Throwable;)V");
        mids$[mid_init$_2e9d196dc293ffe6] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/Throwable;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    IllegalArgumentException::IllegalArgumentException() : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    IllegalArgumentException::IllegalArgumentException(const ::java::lang::String & a0) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    IllegalArgumentException::IllegalArgumentException(const ::java::lang::Throwable & a0) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_471cfbdb800444a7, a0.this$)) {}

    IllegalArgumentException::IllegalArgumentException(const ::java::lang::String & a0, const ::java::lang::Throwable & a1) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_2e9d196dc293ffe6, a0.this$, a1.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_IllegalArgumentException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_IllegalArgumentException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_IllegalArgumentException_init_(t_IllegalArgumentException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_IllegalArgumentException__methods_[] = {
      DECLARE_METHOD(t_IllegalArgumentException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_IllegalArgumentException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(IllegalArgumentException)[] = {
      { Py_tp_methods, t_IllegalArgumentException__methods_ },
      { Py_tp_init, (void *) t_IllegalArgumentException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(IllegalArgumentException)[] = {
      &PY_TYPE_DEF(::java::lang::RuntimeException),
      NULL
    };

    DEFINE_TYPE(IllegalArgumentException, t_IllegalArgumentException, IllegalArgumentException);

    void t_IllegalArgumentException::install(PyObject *module)
    {
      installType(&PY_TYPE(IllegalArgumentException), &PY_TYPE_DEF(IllegalArgumentException), module, "IllegalArgumentException", 0);
    }

    void t_IllegalArgumentException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(IllegalArgumentException), "class_", make_descriptor(IllegalArgumentException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(IllegalArgumentException), "wrapfn_", make_descriptor(t_IllegalArgumentException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(IllegalArgumentException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_IllegalArgumentException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, IllegalArgumentException::initializeClass, 1)))
        return NULL;
      return t_IllegalArgumentException::wrap_Object(IllegalArgumentException(((t_IllegalArgumentException *) arg)->object.this$));
    }
    static PyObject *t_IllegalArgumentException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, IllegalArgumentException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_IllegalArgumentException_init_(t_IllegalArgumentException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          IllegalArgumentException object((jobject) NULL);

          INT_CALL(object = IllegalArgumentException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          IllegalArgumentException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = IllegalArgumentException(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::Throwable a0((jobject) NULL);
          IllegalArgumentException object((jobject) NULL);

          if (!parseArgs(args, "k", ::java::lang::Throwable::initializeClass, &a0))
          {
            INT_CALL(object = IllegalArgumentException(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::Throwable a1((jobject) NULL);
          IllegalArgumentException object((jobject) NULL);

          if (!parseArgs(args, "sk", ::java::lang::Throwable::initializeClass, &a0, &a1))
          {
            INT_CALL(object = IllegalArgumentException(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/SortedSet.h"
#include "java/util/SortedSet.h"
#include "java/util/Comparator.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/Spliterator.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *SortedSet::class$ = NULL;
    jmethodID *SortedSet::mids$ = NULL;
    bool SortedSet::live$ = false;

    jclass SortedSet::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/SortedSet");

        mids$ = new jmethodID[max_mid];
        mids$[mid_comparator_beb0414e0ec1de00] = env->getMethodID(cls, "comparator", "()Ljava/util/Comparator;");
        mids$[mid_first_d6bcd06f3102c4d9] = env->getMethodID(cls, "first", "()Ljava/lang/Object;");
        mids$[mid_headSet_53f2bf24b94c5740] = env->getMethodID(cls, "headSet", "(Ljava/lang/Object;)Ljava/util/SortedSet;");
        mids$[mid_last_d6bcd06f3102c4d9] = env->getMethodID(cls, "last", "()Ljava/lang/Object;");
        mids$[mid_spliterator_7a761c107a8e14bd] = env->getMethodID(cls, "spliterator", "()Ljava/util/Spliterator;");
        mids$[mid_subSet_02b9298b38245e1d] = env->getMethodID(cls, "subSet", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/util/SortedSet;");
        mids$[mid_tailSet_53f2bf24b94c5740] = env->getMethodID(cls, "tailSet", "(Ljava/lang/Object;)Ljava/util/SortedSet;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    ::java::util::Comparator SortedSet::comparator() const
    {
      return ::java::util::Comparator(env->callObjectMethod(this$, mids$[mid_comparator_beb0414e0ec1de00]));
    }

    ::java::lang::Object SortedSet::first() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_first_d6bcd06f3102c4d9]));
    }

    SortedSet SortedSet::headSet(const ::java::lang::Object & a0) const
    {
      return SortedSet(env->callObjectMethod(this$, mids$[mid_headSet_53f2bf24b94c5740], a0.this$));
    }

    ::java::lang::Object SortedSet::last() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_last_d6bcd06f3102c4d9]));
    }

    ::java::util::Spliterator SortedSet::spliterator() const
    {
      return ::java::util::Spliterator(env->callObjectMethod(this$, mids$[mid_spliterator_7a761c107a8e14bd]));
    }

    SortedSet SortedSet::subSet(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return SortedSet(env->callObjectMethod(this$, mids$[mid_subSet_02b9298b38245e1d], a0.this$, a1.this$));
    }

    SortedSet SortedSet::tailSet(const ::java::lang::Object & a0) const
    {
      return SortedSet(env->callObjectMethod(this$, mids$[mid_tailSet_53f2bf24b94c5740], a0.this$));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_SortedSet_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_SortedSet_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_SortedSet_of_(t_SortedSet *self, PyObject *args);
    static PyObject *t_SortedSet_comparator(t_SortedSet *self);
    static PyObject *t_SortedSet_first(t_SortedSet *self);
    static PyObject *t_SortedSet_headSet(t_SortedSet *self, PyObject *arg);
    static PyObject *t_SortedSet_last(t_SortedSet *self);
    static PyObject *t_SortedSet_spliterator(t_SortedSet *self, PyObject *args);
    static PyObject *t_SortedSet_subSet(t_SortedSet *self, PyObject *args);
    static PyObject *t_SortedSet_tailSet(t_SortedSet *self, PyObject *arg);
    static PyObject *t_SortedSet_get__parameters_(t_SortedSet *self, void *data);
    static PyGetSetDef t_SortedSet__fields_[] = {
      DECLARE_GET_FIELD(t_SortedSet, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_SortedSet__methods_[] = {
      DECLARE_METHOD(t_SortedSet, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_SortedSet, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_SortedSet, of_, METH_VARARGS),
      DECLARE_METHOD(t_SortedSet, comparator, METH_NOARGS),
      DECLARE_METHOD(t_SortedSet, first, METH_NOARGS),
      DECLARE_METHOD(t_SortedSet, headSet, METH_O),
      DECLARE_METHOD(t_SortedSet, last, METH_NOARGS),
      DECLARE_METHOD(t_SortedSet, spliterator, METH_VARARGS),
      DECLARE_METHOD(t_SortedSet, subSet, METH_VARARGS),
      DECLARE_METHOD(t_SortedSet, tailSet, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(SortedSet)[] = {
      { Py_tp_methods, t_SortedSet__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_SortedSet__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(SortedSet)[] = {
      &PY_TYPE_DEF(::java::util::Set),
      NULL
    };

    DEFINE_TYPE(SortedSet, t_SortedSet, SortedSet);
    PyObject *t_SortedSet::wrap_Object(const SortedSet& object, PyTypeObject *p0)
    {
      PyObject *obj = t_SortedSet::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_SortedSet *self = (t_SortedSet *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_SortedSet::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_SortedSet::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_SortedSet *self = (t_SortedSet *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_SortedSet::install(PyObject *module)
    {
      installType(&PY_TYPE(SortedSet), &PY_TYPE_DEF(SortedSet), module, "SortedSet", 0);
    }

    void t_SortedSet::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(SortedSet), "class_", make_descriptor(SortedSet::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SortedSet), "wrapfn_", make_descriptor(t_SortedSet::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SortedSet), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_SortedSet_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, SortedSet::initializeClass, 1)))
        return NULL;
      return t_SortedSet::wrap_Object(SortedSet(((t_SortedSet *) arg)->object.this$));
    }
    static PyObject *t_SortedSet_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, SortedSet::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_SortedSet_of_(t_SortedSet *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_SortedSet_comparator(t_SortedSet *self)
    {
      ::java::util::Comparator result((jobject) NULL);
      OBJ_CALL(result = self->object.comparator());
      return ::java::util::t_Comparator::wrap_Object(result);
    }

    static PyObject *t_SortedSet_first(t_SortedSet *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.first());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_SortedSet_headSet(t_SortedSet *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      SortedSet result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.headSet(a0));
        return t_SortedSet::wrap_Object(result, self->parameters[0]);
      }

      PyErr_SetArgsError((PyObject *) self, "headSet", arg);
      return NULL;
    }

    static PyObject *t_SortedSet_last(t_SortedSet *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.last());
      return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_SortedSet_spliterator(t_SortedSet *self, PyObject *args)
    {
      ::java::util::Spliterator result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.spliterator());
        return ::java::util::t_Spliterator::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(SortedSet), (PyObject *) self, "spliterator", args, 2);
    }

    static PyObject *t_SortedSet_subSet(t_SortedSet *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      SortedSet result((jobject) NULL);

      if (!parseArgs(args, "OO", self->parameters[0], self->parameters[0], &a0, &a1))
      {
        OBJ_CALL(result = self->object.subSet(a0, a1));
        return t_SortedSet::wrap_Object(result, self->parameters[0]);
      }

      PyErr_SetArgsError((PyObject *) self, "subSet", args);
      return NULL;
    }

    static PyObject *t_SortedSet_tailSet(t_SortedSet *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      SortedSet result((jobject) NULL);

      if (!parseArg(arg, "O", self->parameters[0], &a0))
      {
        OBJ_CALL(result = self->object.tailSet(a0));
        return t_SortedSet::wrap_Object(result, self->parameters[0]);
      }

      PyErr_SetArgsError((PyObject *) self, "tailSet", arg);
      return NULL;
    }
    static PyObject *t_SortedSet_get__parameters_(t_SortedSet *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/BiConsumer.h"
#include "java/util/function/BiConsumer.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *BiConsumer::class$ = NULL;
      jmethodID *BiConsumer::mids$ = NULL;
      bool BiConsumer::live$ = false;

      jclass BiConsumer::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/BiConsumer");

          mids$ = new jmethodID[max_mid];
          mids$[mid_accept_912183be9c37d462] = env->getMethodID(cls, "accept", "(Ljava/lang/Object;Ljava/lang/Object;)V");
          mids$[mid_andThen_6e7a9dc69845a245] = env->getMethodID(cls, "andThen", "(Ljava/util/function/BiConsumer;)Ljava/util/function/BiConsumer;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      void BiConsumer::accept(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
      {
        env->callVoidMethod(this$, mids$[mid_accept_912183be9c37d462], a0.this$, a1.this$);
      }

      BiConsumer BiConsumer::andThen(const BiConsumer & a0) const
      {
        return BiConsumer(env->callObjectMethod(this$, mids$[mid_andThen_6e7a9dc69845a245], a0.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_BiConsumer_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BiConsumer_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_BiConsumer_of_(t_BiConsumer *self, PyObject *args);
      static PyObject *t_BiConsumer_accept(t_BiConsumer *self, PyObject *args);
      static PyObject *t_BiConsumer_andThen(t_BiConsumer *self, PyObject *arg);
      static PyObject *t_BiConsumer_get__parameters_(t_BiConsumer *self, void *data);
      static PyGetSetDef t_BiConsumer__fields_[] = {
        DECLARE_GET_FIELD(t_BiConsumer, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_BiConsumer__methods_[] = {
        DECLARE_METHOD(t_BiConsumer, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_BiConsumer, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_BiConsumer, of_, METH_VARARGS),
        DECLARE_METHOD(t_BiConsumer, accept, METH_VARARGS),
        DECLARE_METHOD(t_BiConsumer, andThen, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(BiConsumer)[] = {
        { Py_tp_methods, t_BiConsumer__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_BiConsumer__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(BiConsumer)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(BiConsumer, t_BiConsumer, BiConsumer);
      PyObject *t_BiConsumer::wrap_Object(const BiConsumer& object, PyTypeObject *p0, PyTypeObject *p1)
      {
        PyObject *obj = t_BiConsumer::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_BiConsumer *self = (t_BiConsumer *) obj;
          self->parameters[0] = p0;
          self->parameters[1] = p1;
        }
        return obj;
      }

      PyObject *t_BiConsumer::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
      {
        PyObject *obj = t_BiConsumer::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_BiConsumer *self = (t_BiConsumer *) obj;
          self->parameters[0] = p0;
          self->parameters[1] = p1;
        }
        return obj;
      }

      void t_BiConsumer::install(PyObject *module)
      {
        installType(&PY_TYPE(BiConsumer), &PY_TYPE_DEF(BiConsumer), module, "BiConsumer", 0);
      }

      void t_BiConsumer::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(BiConsumer), "class_", make_descriptor(BiConsumer::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(BiConsumer), "wrapfn_", make_descriptor(t_BiConsumer::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(BiConsumer), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_BiConsumer_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, BiConsumer::initializeClass, 1)))
          return NULL;
        return t_BiConsumer::wrap_Object(BiConsumer(((t_BiConsumer *) arg)->object.this$));
      }
      static PyObject *t_BiConsumer_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, BiConsumer::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_BiConsumer_of_(t_BiConsumer *self, PyObject *args)
      {
        if (!parseArg(args, "T", 2, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_BiConsumer_accept(t_BiConsumer *self, PyObject *args)
      {
        ::java::lang::Object a0((jobject) NULL);
        ::java::lang::Object a1((jobject) NULL);

        if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
        {
          OBJ_CALL(self->object.accept(a0, a1));
          Py_RETURN_NONE;
        }

        PyErr_SetArgsError((PyObject *) self, "accept", args);
        return NULL;
      }

      static PyObject *t_BiConsumer_andThen(t_BiConsumer *self, PyObject *arg)
      {
        BiConsumer a0((jobject) NULL);
        PyTypeObject **p0;
        BiConsumer result((jobject) NULL);

        if (!parseArg(arg, "K", BiConsumer::initializeClass, &a0, &p0, t_BiConsumer::parameters_))
        {
          OBJ_CALL(result = self->object.andThen(a0));
          return t_BiConsumer::wrap_Object(result, self->parameters[0], self->parameters[1]);
        }

        PyErr_SetArgsError((PyObject *) self, "andThen", arg);
        return NULL;
      }
      static PyObject *t_BiConsumer_get__parameters_(t_BiConsumer *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Hashtable.h"
#include "java/util/Map.h"
#include "java/util/Collection.h"
#include "java/util/Map$Entry.h"
#include "java/lang/Cloneable.h"
#include "java/util/function/BiConsumer.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/function/Function.h"
#include "java/util/function/BiFunction.h"
#include "java/lang/String.h"
#include "java/util/Enumeration.h"
#include "java/util/Set.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Hashtable::class$ = NULL;
    jmethodID *Hashtable::mids$ = NULL;
    bool Hashtable::live$ = false;

    jclass Hashtable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Hashtable");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_040c4cd0390c5aff] = env->getMethodID(cls, "<init>", "(I)V");
        mids$[mid_init$_408bd889ee3beae5] = env->getMethodID(cls, "<init>", "(Ljava/util/Map;)V");
        mids$[mid_init$_da161bce5801b190] = env->getMethodID(cls, "<init>", "(IF)V");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_clone_d6bcd06f3102c4d9] = env->getMethodID(cls, "clone", "()Ljava/lang/Object;");
        mids$[mid_compute_a077e9e27d3c234f] = env->getMethodID(cls, "compute", "(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;");
        mids$[mid_computeIfAbsent_d6f5a32db425833f] = env->getMethodID(cls, "computeIfAbsent", "(Ljava/lang/Object;Ljava/util/function/Function;)Ljava/lang/Object;");
        mids$[mid_computeIfPresent_a077e9e27d3c234f] = env->getMethodID(cls, "computeIfPresent", "(Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;");
        mids$[mid_contains_8b72f2dcdde6fd1d] = env->getMethodID(cls, "contains", "(Ljava/lang/Object;)Z");
        mids$[mid_containsKey_8b72f2dcdde6fd1d] = env->getMethodID(cls, "containsKey", "(Ljava/lang/Object;)Z");
        mids$[mid_containsValue_8b72f2dcdde6fd1d] = env->getMethodID(cls, "containsValue", "(Ljava/lang/Object;)Z");
        mids$[mid_elements_f270cc1d2d4072a8] = env->getMethodID(cls, "elements", "()Ljava/util/Enumeration;");
        mids$[mid_entrySet_7dcf4034c6d1a92a] = env->getMethodID(cls, "entrySet", "()Ljava/util/Set;");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_forEach_94704ed6ccc48468] = env->getMethodID(cls, "forEach", "(Ljava/util/function/BiConsumer;)V");
        mids$[mid_get_e5ae0f8c04795fa9] = env->getMethodID(cls, "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_getOrDefault_128a89bbc17a8b69] = env->getMethodID(cls, "getOrDefault", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
        mids$[mid_keySet_7dcf4034c6d1a92a] = env->getMethodID(cls, "keySet", "()Ljava/util/Set;");
        mids$[mid_keys_f270cc1d2d4072a8] = env->getMethodID(cls, "keys", "()Ljava/util/Enumeration;");
        mids$[mid_merge_74daa8a3464479e0] = env->getMethodID(cls, "merge", "(Ljava/lang/Object;Ljava/lang/Object;Ljava/util/function/BiFunction;)Ljava/lang/Object;");
        mids$[mid_put_128a89bbc17a8b69] = env->getMethodID(cls, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_putAll_408bd889ee3beae5] = env->getMethodID(cls, "putAll", "(Ljava/util/Map;)V");
        mids$[mid_putIfAbsent_128a89bbc17a8b69] = env->getMethodID(cls, "putIfAbsent", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_remove_e5ae0f8c04795fa9] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_remove_b06c7be184b2a9ad] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;Ljava/lang/Object;)Z");
        mids$[mid_replace_128a89bbc17a8b69] = env->getMethodID(cls, "replace", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_replace_fe62c765dba52df0] = env->getMethodID(cls, "replace", "(Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Z");
        mids$[mid_replaceAll_22221e328874bd4f] = env->getMethodID(cls, "replaceAll", "(Ljava/util/function/BiFunction;)V");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
        mids$[mid_values_d4dfbf7a26ff41df] = env->getMethodID(cls, "values", "()Ljava/util/Collection;");
        mids$[mid_rehash_f2cc1bce94666404] = env->getMethodID(cls, "rehash", "()V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Hashtable::Hashtable() : ::java::util::Dictionary(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    Hashtable::Hashtable(jint a0) : ::java::util::Dictionary(env->newObject(initializeClass, &mids$, mid_init$_040c4cd0390c5aff, a0)) {}

    Hashtable::Hashtable(const ::java::util::Map & a0) : ::java::util::Dictionary(env->newObject(initializeClass, &mids$, mid_init$_408bd889ee3beae5, a0.this$)) {}

    Hashtable::Hashtable(jint a0, jfloat a1) : ::java::util::Dictionary(env->newObject(initializeClass, &mids$, mid_init$_da161bce5801b190, a0, a1)) {}

    void Hashtable::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    ::java::lang::Object Hashtable::clone() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_clone_d6bcd06f3102c4d9]));
    }

    ::java::lang::Object Hashtable::compute(const ::java::lang::Object & a0, const ::java::util::function::BiFunction & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_compute_a077e9e27d3c234f], a0.this$, a1.this$));
    }

    ::java::lang::Object Hashtable::computeIfAbsent(const ::java::lang::Object & a0, const ::java::util::function::Function & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_computeIfAbsent_d6f5a32db425833f], a0.this$, a1.this$));
    }

    ::java::lang::Object Hashtable::computeIfPresent(const ::java::lang::Object & a0, const ::java::util::function::BiFunction & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_computeIfPresent_a077e9e27d3c234f], a0.this$, a1.this$));
    }

    jboolean Hashtable::contains(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_contains_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Hashtable::containsKey(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_containsKey_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean Hashtable::containsValue(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_containsValue_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::util::Enumeration Hashtable::elements() const
    {
      return ::java::util::Enumeration(env->callObjectMethod(this$, mids$[mid_elements_f270cc1d2d4072a8]));
    }

    ::java::util::Set Hashtable::entrySet() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_entrySet_7dcf4034c6d1a92a]));
    }

    jboolean Hashtable::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    void Hashtable::forEach(const ::java::util::function::BiConsumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEach_94704ed6ccc48468], a0.this$);
    }

    ::java::lang::Object Hashtable::get(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_e5ae0f8c04795fa9], a0.this$));
    }

    ::java::lang::Object Hashtable::getOrDefault(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_getOrDefault_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    jint Hashtable::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean Hashtable::isEmpty() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
    }

    ::java::util::Set Hashtable::keySet() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_keySet_7dcf4034c6d1a92a]));
    }

    ::java::util::Enumeration Hashtable::keys() const
    {
      return ::java::util::Enumeration(env->callObjectMethod(this$, mids$[mid_keys_f270cc1d2d4072a8]));
    }

    ::java::lang::Object Hashtable::merge(const ::java::lang::Object & a0, const ::java::lang::Object & a1, const ::java::util::function::BiFunction & a2) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_merge_74daa8a3464479e0], a0.this$, a1.this$, a2.this$));
    }

    ::java::lang::Object Hashtable::put(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_put_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    void Hashtable::putAll(const ::java::util::Map & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_putAll_408bd889ee3beae5], a0.this$);
    }

    ::java::lang::Object Hashtable::putIfAbsent(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_putIfAbsent_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    ::java::lang::Object Hashtable::remove(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_e5ae0f8c04795fa9], a0.this$));
    }

    jboolean Hashtable::remove(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_remove_b06c7be184b2a9ad], a0.this$, a1.this$);
    }

    ::java::lang::Object Hashtable::replace(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_replace_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    jboolean Hashtable::replace(const ::java::lang::Object & a0, const ::java::lang::Object & a1, const ::java::lang::Object & a2) const
    {
      return env->callBooleanMethod(this$, mids$[mid_replace_fe62c765dba52df0], a0.this$, a1.this$, a2.this$);
    }

    void Hashtable::replaceAll(const ::java::util::function::BiFunction & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_replaceAll_22221e328874bd4f], a0.this$);
    }

    jint Hashtable::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }

    ::java::lang::String Hashtable::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }

    ::java::util::Collection Hashtable::values() const
    {
      return ::java::util::Collection(env->callObjectMethod(this$, mids$[mid_values_d4dfbf7a26ff41df]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Hashtable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Hashtable_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Hashtable_of_(t_Hashtable *self, PyObject *args);
    static int t_Hashtable_init_(t_Hashtable *self, PyObject *args, PyObject *kwds);
    static PyObject *t_Hashtable_clear(t_Hashtable *self);
    static PyObject *t_Hashtable_clone(t_Hashtable *self);
    static PyObject *t_Hashtable_compute(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_computeIfAbsent(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_computeIfPresent(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_contains(t_Hashtable *self, PyObject *arg);
    static PyObject *t_Hashtable_containsKey(t_Hashtable *self, PyObject *arg);
    static PyObject *t_Hashtable_containsValue(t_Hashtable *self, PyObject *arg);
    static PyObject *t_Hashtable_elements(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_entrySet(t_Hashtable *self);
    static PyObject *t_Hashtable_equals(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_forEach(t_Hashtable *self, PyObject *arg);
    static PyObject *t_Hashtable_get(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_getOrDefault(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_hashCode(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_isEmpty(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_keySet(t_Hashtable *self);
    static PyObject *t_Hashtable_keys(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_merge(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_put(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_putAll(t_Hashtable *self, PyObject *arg);
    static PyObject *t_Hashtable_putIfAbsent(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_remove(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_replace(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_replaceAll(t_Hashtable *self, PyObject *arg);
    static PyObject *t_Hashtable_size(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_toString(t_Hashtable *self, PyObject *args);
    static PyObject *t_Hashtable_values(t_Hashtable *self);
    static PyObject *t_Hashtable_get__empty(t_Hashtable *self, void *data);
    static PyObject *t_Hashtable_get__parameters_(t_Hashtable *self, void *data);
    static PyGetSetDef t_Hashtable__fields_[] = {
      DECLARE_GET_FIELD(t_Hashtable, empty),
      DECLARE_GET_FIELD(t_Hashtable, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Hashtable__methods_[] = {
      DECLARE_METHOD(t_Hashtable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Hashtable, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Hashtable, of_, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, clear, METH_NOARGS),
      DECLARE_METHOD(t_Hashtable, clone, METH_NOARGS),
      DECLARE_METHOD(t_Hashtable, compute, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, computeIfAbsent, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, computeIfPresent, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, contains, METH_O),
      DECLARE_METHOD(t_Hashtable, containsKey, METH_O),
      DECLARE_METHOD(t_Hashtable, containsValue, METH_O),
      DECLARE_METHOD(t_Hashtable, elements, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, entrySet, METH_NOARGS),
      DECLARE_METHOD(t_Hashtable, equals, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, forEach, METH_O),
      DECLARE_METHOD(t_Hashtable, get, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, getOrDefault, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, isEmpty, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, keySet, METH_NOARGS),
      DECLARE_METHOD(t_Hashtable, keys, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, merge, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, put, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, putAll, METH_O),
      DECLARE_METHOD(t_Hashtable, putIfAbsent, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, remove, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, replace, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, replaceAll, METH_O),
      DECLARE_METHOD(t_Hashtable, size, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, toString, METH_VARARGS),
      DECLARE_METHOD(t_Hashtable, values, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Hashtable)[] = {
      { Py_tp_methods, t_Hashtable__methods_ },
      { Py_tp_init, (void *) t_Hashtable_init_ },
      { Py_tp_getset, t_Hashtable__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Hashtable)[] = {
      &PY_TYPE_DEF(::java::util::Dictionary),
      NULL
    };

    DEFINE_TYPE(Hashtable, t_Hashtable, Hashtable);
    PyObject *t_Hashtable::wrap_Object(const Hashtable& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_Hashtable::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Hashtable *self = (t_Hashtable *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    PyObject *t_Hashtable::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_Hashtable::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Hashtable *self = (t_Hashtable *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    void t_Hashtable::install(PyObject *module)
    {
      installType(&PY_TYPE(Hashtable), &PY_TYPE_DEF(Hashtable), module, "Hashtable", 0);
    }

    void t_Hashtable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Hashtable), "class_", make_descriptor(Hashtable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Hashtable), "wrapfn_", make_descriptor(t_Hashtable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Hashtable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Hashtable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Hashtable::initializeClass, 1)))
        return NULL;
      return t_Hashtable::wrap_Object(Hashtable(((t_Hashtable *) arg)->object.this$));
    }
    static PyObject *t_Hashtable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Hashtable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Hashtable_of_(t_Hashtable *self, PyObject *args)
    {
      if (!parseArg(args, "T", 2, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static int t_Hashtable_init_(t_Hashtable *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          Hashtable object((jobject) NULL);

          INT_CALL(object = Hashtable());
          self->object = object;
          break;
        }
       case 1:
        {
          jint a0;
          Hashtable object((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            INT_CALL(object = Hashtable(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::util::Map a0((jobject) NULL);
          PyTypeObject **p0;
          Hashtable object((jobject) NULL);

          if (!parseArgs(args, "K", ::java::util::Map::initializeClass, &a0, &p0, ::java::util::t_Map::parameters_))
          {
            INT_CALL(object = Hashtable(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          jint a0;
          jfloat a1;
          Hashtable object((jobject) NULL);

          if (!parseArgs(args, "IF", &a0, &a1))
          {
            INT_CALL(object = Hashtable(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_Hashtable_clear(t_Hashtable *self)
    {
      OBJ_CALL(self->object.clear());
      Py_RETURN_NONE;
    }

    static PyObject *t_Hashtable_clone(t_Hashtable *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.clone());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_Hashtable_compute(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::function::BiFunction a1((jobject) NULL);
      PyTypeObject **p1;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OK", self->parameters[0], ::java::util::function::BiFunction::initializeClass, &a0, &a1, &p1, ::java::util::function::t_BiFunction::parameters_))
      {
        OBJ_CALL(result = self->object.compute(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "compute", args);
      return NULL;
    }

    static PyObject *t_Hashtable_computeIfAbsent(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::function::Function a1((jobject) NULL);
      PyTypeObject **p1;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OK", self->parameters[0], ::java::util::function::Function::initializeClass, &a0, &a1, &p1, ::java::util::function::t_Function::parameters_))
      {
        OBJ_CALL(result = self->object.computeIfAbsent(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "computeIfAbsent", args);
      return NULL;
    }

    static PyObject *t_Hashtable_computeIfPresent(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::util::function::BiFunction a1((jobject) NULL);
      PyTypeObject **p1;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OK", self->parameters[0], ::java::util::function::BiFunction::initializeClass, &a0, &a1, &p1, ::java::util::function::t_BiFunction::parameters_))
      {
        OBJ_CALL(result = self->object.computeIfPresent(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "computeIfPresent", args);
      return NULL;
    }

    static PyObject *t_Hashtable_contains(t_Hashtable *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.contains(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "contains", arg);
      return NULL;
    }

    static PyObject *t_Hashtable_containsKey(t_Hashtable *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.containsKey(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "containsKey", arg);
      return NULL;
    }

    static PyObject *t_Hashtable_containsValue(t_Hashtable *self, PyObject *arg)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "o", &a0))
      {
        OBJ_CALL(result = self->object.containsValue(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "containsValue", arg);
      return NULL;
    }

    static PyObject *t_Hashtable_elements(t_Hashtable *self, PyObject *args)
    {
      ::java::util::Enumeration result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.elements());
        return ::java::util::t_Enumeration::wrap_Object(result, self->parameters[1]);
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "elements", args, 2);
    }

    static PyObject *t_Hashtable_entrySet(t_Hashtable *self)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = self->object.entrySet());
      return ::java::util::t_Set::wrap_Object(result);
    }

    static PyObject *t_Hashtable_equals(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_Hashtable_forEach(t_Hashtable *self, PyObject *arg)
    {
      ::java::util::function::BiConsumer a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", ::java::util::function::BiConsumer::initializeClass, &a0, &p0, ::java::util::function::t_BiConsumer::parameters_))
      {
        OBJ_CALL(self->object.forEach(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "forEach", arg);
      return NULL;
    }

    static PyObject *t_Hashtable_get(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "get", args, 2);
    }

    static PyObject *t_Hashtable_getOrDefault(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "oO", self->parameters[1], &a0, &a1))
      {
        OBJ_CALL(result = self->object.getOrDefault(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "getOrDefault", args);
      return NULL;
    }

    static PyObject *t_Hashtable_hashCode(t_Hashtable *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_Hashtable_isEmpty(t_Hashtable *self, PyObject *args)
    {
      jboolean result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.isEmpty());
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "isEmpty", args, 2);
    }

    static PyObject *t_Hashtable_keySet(t_Hashtable *self)
    {
      ::java::util::Set result((jobject) NULL);
      OBJ_CALL(result = self->object.keySet());
      return ::java::util::t_Set::wrap_Object(result, self->parameters[0]);
    }

    static PyObject *t_Hashtable_keys(t_Hashtable *self, PyObject *args)
    {
      ::java::util::Enumeration result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.keys());
        return ::java::util::t_Enumeration::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "keys", args, 2);
    }

    static PyObject *t_Hashtable_merge(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::util::function::BiFunction a2((jobject) NULL);
      PyTypeObject **p2;
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OOK", self->parameters[0], self->parameters[1], ::java::util::function::BiFunction::initializeClass, &a0, &a1, &a2, &p2, ::java::util::function::t_BiFunction::parameters_))
      {
        OBJ_CALL(result = self->object.merge(a0, a1, a2));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "merge", args);
      return NULL;
    }

    static PyObject *t_Hashtable_put(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
      {
        OBJ_CALL(result = self->object.put(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "put", args, 2);
    }

    static PyObject *t_Hashtable_putAll(t_Hashtable *self, PyObject *arg)
    {
      ::java::util::Map a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", ::java::util::Map::initializeClass, &a0, &p0, ::java::util::t_Map::parameters_))
      {
        OBJ_CALL(self->object.putAll(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "putAll", arg);
      return NULL;
    }

    static PyObject *t_Hashtable_putIfAbsent(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
      {
        OBJ_CALL(result = self->object.putIfAbsent(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      PyErr_SetArgsError((PyObject *) self, "putIfAbsent", args);
      return NULL;
    }

    static PyObject *t_Hashtable_remove(t_Hashtable *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object result((jobject) NULL);

          if (!parseArgs(args, "o", &a0))
          {
            OBJ_CALL(result = self->object.remove(a0));
            return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
          }
        }
        break;
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object a1((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "oo", &a0, &a1))
          {
            OBJ_CALL(result = self->object.remove(a0, a1));
            Py_RETURN_BOOL(result);
          }
        }
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_Hashtable_replace(t_Hashtable *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object a1((jobject) NULL);
          ::java::lang::Object result((jobject) NULL);

          if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
          {
            OBJ_CALL(result = self->object.replace(a0, a1));
            return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          ::java::lang::Object a0((jobject) NULL);
          ::java::lang::Object a1((jobject) NULL);
          ::java::lang::Object a2((jobject) NULL);
          jboolean result;

          if (!parseArgs(args, "OOO", self->parameters[0], self->parameters[1], self->parameters[1], &a0, &a1, &a2))
          {
            OBJ_CALL(result = self->object.replace(a0, a1, a2));
            Py_RETURN_BOOL(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "replace", args);
      return NULL;
    }

    static PyObject *t_Hashtable_replaceAll(t_Hashtable *self, PyObject *arg)
    {
      ::java::util::function::BiFunction a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArg(arg, "K", ::java::util::function::BiFunction::initializeClass, &a0, &p0, ::java::util::function::t_BiFunction::parameters_))
      {
        OBJ_CALL(self->object.replaceAll(a0));
        Py_RETURN_NONE;
      }

      PyErr_SetArgsError((PyObject *) self, "replaceAll", arg);
      return NULL;
    }

    static PyObject *t_Hashtable_size(t_Hashtable *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.size());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "size", args, 2);
    }

    static PyObject *t_Hashtable_toString(t_Hashtable *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(Hashtable), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_Hashtable_values(t_Hashtable *self)
    {
      ::java::util::Collection result((jobject) NULL);
      OBJ_CALL(result = self->object.values());
      return ::java::util::t_Collection::wrap_Object(result, self->parameters[1]);
    }
    static PyObject *t_Hashtable_get__parameters_(t_Hashtable *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_Hashtable_get__empty(t_Hashtable *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isEmpty());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/File.h"
#include "java/io/FilenameFilter.h"
#include "java/lang/Comparable.h"
#include "java/lang/Class.h"
#include "java/io/FileFilter.h"
#include "java/lang/String.h"
#include "java/io/File.h"
#include "java/io/IOException.h"
#include "java/nio/file/Path.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *File::class$ = NULL;
    jmethodID *File::mids$ = NULL;
    bool File::live$ = false;
    ::java::lang::String *File::pathSeparator = NULL;
    jchar File::pathSeparatorChar = (jchar) 0;
    ::java::lang::String *File::separator = NULL;
    jchar File::separatorChar = (jchar) 0;

    jclass File::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/File");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_c80751a79d34c011] = env->getMethodID(cls, "<init>", "(Ljava/io/File;Ljava/lang/String;)V");
        mids$[mid_init$_15b72f6a44ff93f2] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;)V");
        mids$[mid_canExecute_8454bd5aa23fd11e] = env->getMethodID(cls, "canExecute", "()Z");
        mids$[mid_canRead_8454bd5aa23fd11e] = env->getMethodID(cls, "canRead", "()Z");
        mids$[mid_canWrite_8454bd5aa23fd11e] = env->getMethodID(cls, "canWrite", "()Z");
        mids$[mid_compareTo_7fa24e00a87a309a] = env->getMethodID(cls, "compareTo", "(Ljava/io/File;)I");
        mids$[mid_createNewFile_8454bd5aa23fd11e] = env->getMethodID(cls, "createNewFile", "()Z");
        mids$[mid_createTempFile_050e83e999bec806] = env->getStaticMethodID(cls, "createTempFile", "(Ljava/lang/String;Ljava/lang/String;)Ljava/io/File;");
        mids$[mid_createTempFile_0ea07473b2efdaea] = env->getStaticMethodID(cls, "createTempFile", "(Ljava/lang/String;Ljava/lang/String;Ljava/io/File;)Ljava/io/File;");
        mids$[mid_delete_8454bd5aa23fd11e] = env->getMethodID(cls, "delete", "()Z");
        mids$[mid_deleteOnExit_f2cc1bce94666404] = env->getMethodID(cls, "deleteOnExit", "()V");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_exists_8454bd5aa23fd11e] = env->getMethodID(cls, "exists", "()Z");
        mids$[mid_getAbsoluteFile_117a3aa19a964e9c] = env->getMethodID(cls, "getAbsoluteFile", "()Ljava/io/File;");
        mids$[mid_getAbsolutePath_db9b55ba01e03e4b] = env->getMethodID(cls, "getAbsolutePath", "()Ljava/lang/String;");
        mids$[mid_getCanonicalFile_117a3aa19a964e9c] = env->getMethodID(cls, "getCanonicalFile", "()Ljava/io/File;");
        mids$[mid_getCanonicalPath_db9b55ba01e03e4b] = env->getMethodID(cls, "getCanonicalPath", "()Ljava/lang/String;");
        mids$[mid_getFreeSpace_2e5ae9edcb9b072f] = env->getMethodID(cls, "getFreeSpace", "()J");
        mids$[mid_getName_db9b55ba01e03e4b] = env->getMethodID(cls, "getName", "()Ljava/lang/String;");
        mids$[mid_getParent_db9b55ba01e03e4b] = env->getMethodID(cls, "getParent", "()Ljava/lang/String;");
        mids$[mid_getParentFile_117a3aa19a964e9c] = env->getMethodID(cls, "getParentFile", "()Ljava/io/File;");
        mids$[mid_getPath_db9b55ba01e03e4b] = env->getMethodID(cls, "getPath", "()Ljava/lang/String;");
        mids$[mid_getTotalSpace_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTotalSpace", "()J");
        mids$[mid_getUsableSpace_2e5ae9edcb9b072f] = env->getMethodID(cls, "getUsableSpace", "()J");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_isAbsolute_8454bd5aa23fd11e] = env->getMethodID(cls, "isAbsolute", "()Z");
        mids$[mid_isDirectory_8454bd5aa23fd11e] = env->getMethodID(cls, "isDirectory", "()Z");
        mids$[mid_isFile_8454bd5aa23fd11e] = env->getMethodID(cls, "isFile", "()Z");
        mids$[mid_isHidden_8454bd5aa23fd11e] = env->getMethodID(cls, "isHidden", "()Z");
        mids$[mid_lastModified_2e5ae9edcb9b072f] = env->getMethodID(cls, "lastModified", "()J");
        mids$[mid_length_2e5ae9edcb9b072f] = env->getMethodID(cls, "length", "()J");
        mids$[mid_list_9865da0b5ee490bc] = env->getMethodID(cls, "list", "()[Ljava/lang/String;");
        mids$[mid_list_7318d5c9adef2efb] = env->getMethodID(cls, "list", "(Ljava/io/FilenameFilter;)[Ljava/lang/String;");
        mids$[mid_listFiles_11270cac0013cb3a] = env->getMethodID(cls, "listFiles", "()[Ljava/io/File;");
        mids$[mid_listFiles_3dee32e39f6b8cf0] = env->getMethodID(cls, "listFiles", "(Ljava/io/FileFilter;)[Ljava/io/File;");
        mids$[mid_listFiles_c5e7dda898e53d2f] = env->getMethodID(cls, "listFiles", "(Ljava/io/FilenameFilter;)[Ljava/io/File;");
        mids$[mid_listRoots_11270cac0013cb3a] = env->getStaticMethodID(cls, "listRoots", "()[Ljava/io/File;");
        mids$[mid_mkdir_8454bd5aa23fd11e] = env->getMethodID(cls, "mkdir", "()Z");
        mids$[mid_mkdirs_8454bd5aa23fd11e] = env->getMethodID(cls, "mkdirs", "()Z");
        mids$[mid_renameTo_a51ee127954badc4] = env->getMethodID(cls, "renameTo", "(Ljava/io/File;)Z");
        mids$[mid_setExecutable_e84cf59305ee1535] = env->getMethodID(cls, "setExecutable", "(Z)Z");
        mids$[mid_setExecutable_266e12b9cc3795ac] = env->getMethodID(cls, "setExecutable", "(ZZ)Z");
        mids$[mid_setLastModified_129dd81483fb5856] = env->getMethodID(cls, "setLastModified", "(J)Z");
        mids$[mid_setReadOnly_8454bd5aa23fd11e] = env->getMethodID(cls, "setReadOnly", "()Z");
        mids$[mid_setReadable_e84cf59305ee1535] = env->getMethodID(cls, "setReadable", "(Z)Z");
        mids$[mid_setReadable_266e12b9cc3795ac] = env->getMethodID(cls, "setReadable", "(ZZ)Z");
        mids$[mid_setWritable_e84cf59305ee1535] = env->getMethodID(cls, "setWritable", "(Z)Z");
        mids$[mid_setWritable_266e12b9cc3795ac] = env->getMethodID(cls, "setWritable", "(ZZ)Z");
        mids$[mid_toPath_7f94726bf5834528] = env->getMethodID(cls, "toPath", "()Ljava/nio/file/Path;");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        pathSeparator = new ::java::lang::String(env->getStaticObjectField(cls, "pathSeparator", "Ljava/lang/String;"));
        pathSeparatorChar = env->getStaticCharField(cls, "pathSeparatorChar");
        separator = new ::java::lang::String(env->getStaticObjectField(cls, "separator", "Ljava/lang/String;"));
        separatorChar = env->getStaticCharField(cls, "separatorChar");
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    File::File(const ::java::lang::String & a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    File::File(const File & a0, const ::java::lang::String & a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_c80751a79d34c011, a0.this$, a1.this$)) {}

    File::File(const ::java::lang::String & a0, const ::java::lang::String & a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_15b72f6a44ff93f2, a0.this$, a1.this$)) {}

    jboolean File::canExecute() const
    {
      return env->callBooleanMethod(this$, mids$[mid_canExecute_8454bd5aa23fd11e]);
    }

    jboolean File::canRead() const
    {
      return env->callBooleanMethod(this$, mids$[mid_canRead_8454bd5aa23fd11e]);
    }

    jboolean File::canWrite() const
    {
      return env->callBooleanMethod(this$, mids$[mid_canWrite_8454bd5aa23fd11e]);
    }

    jint File::compareTo(const File & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_compareTo_7fa24e00a87a309a], a0.this$);
    }

    jboolean File::createNewFile() const
    {
      return env->callBooleanMethod(this$, mids$[mid_createNewFile_8454bd5aa23fd11e]);
    }

    File File::createTempFile(const ::java::lang::String & a0, const ::java::lang::String & a1)
    {
      jclass cls = env->getClass(initializeClass);
      return File(env->callStaticObjectMethod(cls, mids$[mid_createTempFile_050e83e999bec806], a0.this$, a1.this$));
    }

    File File::createTempFile(const ::java::lang::String & a0, const ::java::lang::String & a1, const File & a2)
    {
      jclass cls = env->getClass(initializeClass);
      return File(env->callStaticObjectMethod(cls, mids$[mid_createTempFile_0ea07473b2efdaea], a0.this$, a1.this$, a2.this$));
    }

    jboolean File::delete$() const
    {
      return env->callBooleanMethod(this$, mids$[mid_delete_8454bd5aa23fd11e]);
    }

    void File::deleteOnExit() const
    {
      env->callVoidMethod(this$, mids$[mid_deleteOnExit_f2cc1bce94666404]);
    }

    jboolean File::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean File::exists() const
    {
      return env->callBooleanMethod(this$, mids$[mid_exists_8454bd5aa23fd11e]);
    }

    File File::getAbsoluteFile() const
    {
      return File(env->callObjectMethod(this$, mids$[mid_getAbsoluteFile_117a3aa19a964e9c]));
    }

    ::java::lang::String File::getAbsolutePath() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getAbsolutePath_db9b55ba01e03e4b]));
    }

    File File::getCanonicalFile() const
    {
      return File(env->callObjectMethod(this$, mids$[mid_getCanonicalFile_117a3aa19a964e9c]));
    }

    ::java::lang::String File::getCanonicalPath() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getCanonicalPath_db9b55ba01e03e4b]));
    }

    jlong File::getFreeSpace() const
    {
      return env->callLongMethod(this$, mids$[mid_getFreeSpace_2e5ae9edcb9b072f]);
    }

    ::java::lang::String File::getName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getName_db9b55ba01e03e4b]));
    }

    ::java::lang::String File::getParent() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getParent_db9b55ba01e03e4b]));
    }

    File File::getParentFile() const
    {
      return File(env->callObjectMethod(this$, mids$[mid_getParentFile_117a3aa19a964e9c]));
    }

    ::java::lang::String File::getPath() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getPath_db9b55ba01e03e4b]));
    }

    jlong File::getTotalSpace() const
    {
      return env->callLongMethod(this$, mids$[mid_getTotalSpace_2e5ae9edcb9b072f]);
    }

    jlong File::getUsableSpace() const
    {
      return env->callLongMethod(this$, mids$[mid_getUsableSpace_2e5ae9edcb9b072f]);
    }

    jint File::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean File::isAbsolute() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isAbsolute_8454bd5aa23fd11e]);
    }

    jboolean File::isDirectory() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isDirectory_8454bd5aa23fd11e]);
    }

    jboolean File::isFile() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isFile_8454bd5aa23fd11e]);
    }

    jboolean File::isHidden() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isHidden_8454bd5aa23fd11e]);
    }

    jlong File::lastModified() const
    {
      return env->callLongMethod(this$, mids$[mid_lastModified_2e5ae9edcb9b072f]);
    }

    jlong File::length() const
    {
      return env->callLongMethod(this$, mids$[mid_length_2e5ae9edcb9b072f]);
    }

    JArray< ::java::lang::String > File::list() const
    {
      return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_list_9865da0b5ee490bc]));
    }

    JArray< ::java::lang::String > File::list(const ::java::io::FilenameFilter & a0) const
    {
      return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_list_7318d5c9adef2efb], a0.this$));
    }

    JArray< File > File::listFiles() const
    {
      return JArray< File >(env->callObjectMethod(this$, mids$[mid_listFiles_11270cac0013cb3a]));
    }

    JArray< File > File::listFiles(const ::java::io::FileFilter & a0) const
    {
      return JArray< File >(env->callObjectMethod(this$, mids$[mid_listFiles_3dee32e39f6b8cf0], a0.this$));
    }

    JArray< File > File::listFiles(const ::java::io::FilenameFilter & a0) const
    {
      return JArray< File >(env->callObjectMethod(this$, mids$[mid_listFiles_c5e7dda898e53d2f], a0.this$));
    }

    JArray< File > File::listRoots()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< File >(env->callStaticObjectMethod(cls, mids$[mid_listRoots_11270cac0013cb3a]));
    }

    jboolean File::mkdir() const
    {
      return env->callBooleanMethod(this$, mids$[mid_mkdir_8454bd5aa23fd11e]);
    }

    jboolean File::mkdirs() const
    {
      return env->callBooleanMethod(this$, mids$[mid_mkdirs_8454bd5aa23fd11e]);
    }

    jboolean File::renameTo(const File & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_renameTo_a51ee127954badc4], a0.this$);
    }

    jboolean File::setExecutable(jboolean a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_setExecutable_e84cf59305ee1535], a0);
    }

    jboolean File::setExecutable(jboolean a0, jboolean a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_setExecutable_266e12b9cc3795ac], a0, a1);
    }

    jboolean File::setLastModified(jlong a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_setLastModified_129dd81483fb5856], a0);
    }

    jboolean File::setReadOnly() const
    {
      return env->callBooleanMethod(this$, mids$[mid_setReadOnly_8454bd5aa23fd11e]);
    }

    jboolean File::setReadable(jboolean a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_setReadable_e84cf59305ee1535], a0);
    }

    jboolean File::setReadable(jboolean a0, jboolean a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_setReadable_266e12b9cc3795ac], a0, a1);
    }

    jboolean File::setWritable(jboolean a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_setWritable_e84cf59305ee1535], a0);
    }

    jboolean File::setWritable(jboolean a0, jboolean a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_setWritable_266e12b9cc3795ac], a0, a1);
    }

    ::java::nio::file::Path File::toPath() const
    {
      return ::java::nio::file::Path(env->callObjectMethod(this$, mids$[mid_toPath_7f94726bf5834528]));
    }

    ::java::lang::String File::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_File_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_File_instance_(PyTypeObject *type, PyObject *arg);
    static int t_File_init_(t_File *self, PyObject *args, PyObject *kwds);
    static PyObject *t_File_canExecute(t_File *self);
    static PyObject *t_File_canRead(t_File *self);
    static PyObject *t_File_canWrite(t_File *self);
    static PyObject *t_File_compareTo(t_File *self, PyObject *arg);
    static PyObject *t_File_createNewFile(t_File *self);
    static PyObject *t_File_createTempFile(PyTypeObject *type, PyObject *args);
    static PyObject *t_File_delete(t_File *self);
    static PyObject *t_File_deleteOnExit(t_File *self);
    static PyObject *t_File_equals(t_File *self, PyObject *args);
    static PyObject *t_File_exists(t_File *self);
    static PyObject *t_File_getAbsoluteFile(t_File *self);
    static PyObject *t_File_getAbsolutePath(t_File *self);
    static PyObject *t_File_getCanonicalFile(t_File *self);
    static PyObject *t_File_getCanonicalPath(t_File *self);
    static PyObject *t_File_getFreeSpace(t_File *self);
    static PyObject *t_File_getName(t_File *self);
    static PyObject *t_File_getParent(t_File *self);
    static PyObject *t_File_getParentFile(t_File *self);
    static PyObject *t_File_getPath(t_File *self);
    static PyObject *t_File_getTotalSpace(t_File *self);
    static PyObject *t_File_getUsableSpace(t_File *self);
    static PyObject *t_File_hashCode(t_File *self, PyObject *args);
    static PyObject *t_File_isAbsolute(t_File *self);
    static PyObject *t_File_isDirectory(t_File *self);
    static PyObject *t_File_isFile(t_File *self);
    static PyObject *t_File_isHidden(t_File *self);
    static PyObject *t_File_lastModified(t_File *self);
    static PyObject *t_File_length(t_File *self);
    static PyObject *t_File_list(t_File *self, PyObject *args);
    static PyObject *t_File_listFiles(t_File *self, PyObject *args);
    static PyObject *t_File_listRoots(PyTypeObject *type);
    static PyObject *t_File_mkdir(t_File *self);
    static PyObject *t_File_mkdirs(t_File *self);
    static PyObject *t_File_renameTo(t_File *self, PyObject *arg);
    static PyObject *t_File_setExecutable(t_File *self, PyObject *args);
    static PyObject *t_File_setLastModified(t_File *self, PyObject *arg);
    static PyObject *t_File_setReadOnly(t_File *self);
    static PyObject *t_File_setReadable(t_File *self, PyObject *args);
    static PyObject *t_File_setWritable(t_File *self, PyObject *args);
    static PyObject *t_File_toPath(t_File *self);
    static PyObject *t_File_toString(t_File *self, PyObject *args);
    static PyObject *t_File_get__absolute(t_File *self, void *data);
    static PyObject *t_File_get__absoluteFile(t_File *self, void *data);
    static PyObject *t_File_get__absolutePath(t_File *self, void *data);
    static PyObject *t_File_get__canonicalFile(t_File *self, void *data);
    static PyObject *t_File_get__canonicalPath(t_File *self, void *data);
    static PyObject *t_File_get__directory(t_File *self, void *data);
    static int t_File_set__executable(t_File *self, PyObject *arg, void *data);
    static PyObject *t_File_get__file(t_File *self, void *data);
    static PyObject *t_File_get__freeSpace(t_File *self, void *data);
    static PyObject *t_File_get__hidden(t_File *self, void *data);
    static PyObject *t_File_get__name(t_File *self, void *data);
    static PyObject *t_File_get__parent(t_File *self, void *data);
    static PyObject *t_File_get__parentFile(t_File *self, void *data);
    static PyObject *t_File_get__path(t_File *self, void *data);
    static int t_File_set__readable(t_File *self, PyObject *arg, void *data);
    static PyObject *t_File_get__totalSpace(t_File *self, void *data);
    static PyObject *t_File_get__usableSpace(t_File *self, void *data);
    static int t_File_set__writable(t_File *self, PyObject *arg, void *data);
    static PyGetSetDef t_File__fields_[] = {
      DECLARE_GET_FIELD(t_File, absolute),
      DECLARE_GET_FIELD(t_File, absoluteFile),
      DECLARE_GET_FIELD(t_File, absolutePath),
      DECLARE_GET_FIELD(t_File, canonicalFile),
      DECLARE_GET_FIELD(t_File, canonicalPath),
      DECLARE_GET_FIELD(t_File, directory),
      DECLARE_SET_FIELD(t_File, executable),
      DECLARE_GET_FIELD(t_File, file),
      DECLARE_GET_FIELD(t_File, freeSpace),
      DECLARE_GET_FIELD(t_File, hidden),
      DECLARE_GET_FIELD(t_File, name),
      DECLARE_GET_FIELD(t_File, parent),
      DECLARE_GET_FIELD(t_File, parentFile),
      DECLARE_GET_FIELD(t_File, path),
      DECLARE_SET_FIELD(t_File, readable),
      DECLARE_GET_FIELD(t_File, totalSpace),
      DECLARE_GET_FIELD(t_File, usableSpace),
      DECLARE_SET_FIELD(t_File, writable),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_File__methods_[] = {
      DECLARE_METHOD(t_File, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_File, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_File, canExecute, METH_NOARGS),
      DECLARE_METHOD(t_File, canRead, METH_NOARGS),
      DECLARE_METHOD(t_File, canWrite, METH_NOARGS),
      DECLARE_METHOD(t_File, compareTo, METH_O),
      DECLARE_METHOD(t_File, createNewFile, METH_NOARGS),
      DECLARE_METHOD(t_File, createTempFile, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_File, delete, METH_NOARGS),
      DECLARE_METHOD(t_File, deleteOnExit, METH_NOARGS),
      DECLARE_METHOD(t_File, equals, METH_VARARGS),
      DECLARE_METHOD(t_File, exists, METH_NOARGS),
      DECLARE_METHOD(t_File, getAbsoluteFile, METH_NOARGS),
      DECLARE_METHOD(t_File, getAbsolutePath, METH_NOARGS),
      DECLARE_METHOD(t_File, getCanonicalFile, METH_NOARGS),
      DECLARE_METHOD(t_File, getCanonicalPath, METH_NOARGS),
      DECLARE_METHOD(t_File, getFreeSpace, METH_NOARGS),
      DECLARE_METHOD(t_File, getName, METH_NOARGS),
      DECLARE_METHOD(t_File, getParent, METH_NOARGS),
      DECLARE_METHOD(t_File, getParentFile, METH_NOARGS),
      DECLARE_METHOD(t_File, getPath, METH_NOARGS),
      DECLARE_METHOD(t_File, getTotalSpace, METH_NOARGS),
      DECLARE_METHOD(t_File, getUsableSpace, METH_NOARGS),
      DECLARE_METHOD(t_File, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_File, isAbsolute, METH_NOARGS),
      DECLARE_METHOD(t_File, isDirectory, METH_NOARGS),
      DECLARE_METHOD(t_File, isFile, METH_NOARGS),
      DECLARE_METHOD(t_File, isHidden, METH_NOARGS),
      DECLARE_METHOD(t_File, lastModified, METH_NOARGS),
      DECLARE_METHOD(t_File, length, METH_NOARGS),
      DECLARE_METHOD(t_File, list, METH_VARARGS),
      DECLARE_METHOD(t_File, listFiles, METH_VARARGS),
      DECLARE_METHOD(t_File, listRoots, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_File, mkdir, METH_NOARGS),
      DECLARE_METHOD(t_File, mkdirs, METH_NOARGS),
      DECLARE_METHOD(t_File, renameTo, METH_O),
      DECLARE_METHOD(t_File, setExecutable, METH_VARARGS),
      DECLARE_METHOD(t_File, setLastModified, METH_O),
      DECLARE_METHOD(t_File, setReadOnly, METH_NOARGS),
      DECLARE_METHOD(t_File, setReadable, METH_VARARGS),
      DECLARE_METHOD(t_File, setWritable, METH_VARARGS),
      DECLARE_METHOD(t_File, toPath, METH_NOARGS),
      DECLARE_METHOD(t_File, toString, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(File)[] = {
      { Py_tp_methods, t_File__methods_ },
      { Py_tp_init, (void *) t_File_init_ },
      { Py_tp_getset, t_File__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(File)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(File, t_File, File);

    void t_File::install(PyObject *module)
    {
      installType(&PY_TYPE(File), &PY_TYPE_DEF(File), module, "File", 0);
    }

    void t_File::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(File), "class_", make_descriptor(File::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(File), "wrapfn_", make_descriptor(t_File::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(File), "boxfn_", make_descriptor(boxObject));
      env->getClass(File::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(File), "pathSeparator", make_descriptor(j2p(*File::pathSeparator)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(File), "pathSeparatorChar", make_descriptor(File::pathSeparatorChar));
      PyObject_SetAttrString((PyObject *) PY_TYPE(File), "separator", make_descriptor(j2p(*File::separator)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(File), "separatorChar", make_descriptor(File::separatorChar));
    }

    static PyObject *t_File_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, File::initializeClass, 1)))
        return NULL;
      return t_File::wrap_Object(File(((t_File *) arg)->object.this$));
    }
    static PyObject *t_File_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, File::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_File_init_(t_File *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          File object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = File(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          File a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          File object((jobject) NULL);

          if (!parseArgs(args, "ks", File::initializeClass, &a0, &a1))
          {
            INT_CALL(object = File(a0, a1));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          File object((jobject) NULL);

          if (!parseArgs(args, "ss", &a0, &a1))
          {
            INT_CALL(object = File(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_File_canExecute(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.canExecute());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_canRead(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.canRead());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_canWrite(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.canWrite());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_compareTo(t_File *self, PyObject *arg)
    {
      File a0((jobject) NULL);
      jint result;

      if (!parseArg(arg, "k", File::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.compareTo(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "compareTo", arg);
      return NULL;
    }

    static PyObject *t_File_createNewFile(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.createNewFile());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_createTempFile(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          File result((jobject) NULL);

          if (!parseArgs(args, "ss", &a0, &a1))
          {
            OBJ_CALL(result = ::java::io::File::createTempFile(a0, a1));
            return t_File::wrap_Object(result);
          }
        }
        break;
       case 3:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::lang::String a1((jobject) NULL);
          File a2((jobject) NULL);
          File result((jobject) NULL);

          if (!parseArgs(args, "ssk", File::initializeClass, &a0, &a1, &a2))
          {
            OBJ_CALL(result = ::java::io::File::createTempFile(a0, a1, a2));
            return t_File::wrap_Object(result);
          }
        }
      }

      PyErr_SetArgsError(type, "createTempFile", args);
      return NULL;
    }

    static PyObject *t_File_delete(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.delete$());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_deleteOnExit(t_File *self)
    {
      OBJ_CALL(self->object.deleteOnExit());
      Py_RETURN_NONE;
    }

    static PyObject *t_File_equals(t_File *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(File), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_File_exists(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.exists());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_getAbsoluteFile(t_File *self)
    {
      File result((jobject) NULL);
      OBJ_CALL(result = self->object.getAbsoluteFile());
      return t_File::wrap_Object(result);
    }

    static PyObject *t_File_getAbsolutePath(t_File *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getAbsolutePath());
      return j2p(result);
    }

    static PyObject *t_File_getCanonicalFile(t_File *self)
    {
      File result((jobject) NULL);
      OBJ_CALL(result = self->object.getCanonicalFile());
      return t_File::wrap_Object(result);
    }

    static PyObject *t_File_getCanonicalPath(t_File *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getCanonicalPath());
      return j2p(result);
    }

    static PyObject *t_File_getFreeSpace(t_File *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.getFreeSpace());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_File_getName(t_File *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getName());
      return j2p(result);
    }

    static PyObject *t_File_getParent(t_File *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getParent());
      return j2p(result);
    }

    static PyObject *t_File_getParentFile(t_File *self)
    {
      File result((jobject) NULL);
      OBJ_CALL(result = self->object.getParentFile());
      return t_File::wrap_Object(result);
    }

    static PyObject *t_File_getPath(t_File *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getPath());
      return j2p(result);
    }

    static PyObject *t_File_getTotalSpace(t_File *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.getTotalSpace());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_File_getUsableSpace(t_File *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.getUsableSpace());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_File_hashCode(t_File *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(File), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_File_isAbsolute(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isAbsolute());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_isDirectory(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isDirectory());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_isFile(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isFile());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_isHidden(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.isHidden());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_lastModified(t_File *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.lastModified());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_File_length(t_File *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.length());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_File_list(t_File *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          JArray< ::java::lang::String > result((jobject) NULL);
          OBJ_CALL(result = self->object.list());
          return JArray<jstring>(result.this$).wrap();
        }
        break;
       case 1:
        {
          ::java::io::FilenameFilter a0((jobject) NULL);
          JArray< ::java::lang::String > result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::FilenameFilter::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.list(a0));
            return JArray<jstring>(result.this$).wrap();
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "list", args);
      return NULL;
    }

    static PyObject *t_File_listFiles(t_File *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          JArray< File > result((jobject) NULL);
          OBJ_CALL(result = self->object.listFiles());
          return JArray<jobject>(result.this$).wrap(t_File::wrap_jobject);
        }
        break;
       case 1:
        {
          ::java::io::FileFilter a0((jobject) NULL);
          JArray< File > result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::FileFilter::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.listFiles(a0));
            return JArray<jobject>(result.this$).wrap(t_File::wrap_jobject);
          }
        }
        {
          ::java::io::FilenameFilter a0((jobject) NULL);
          JArray< File > result((jobject) NULL);

          if (!parseArgs(args, "k", ::java::io::FilenameFilter::initializeClass, &a0))
          {
            OBJ_CALL(result = self->object.listFiles(a0));
            return JArray<jobject>(result.this$).wrap(t_File::wrap_jobject);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "listFiles", args);
      return NULL;
    }

    static PyObject *t_File_listRoots(PyTypeObject *type)
    {
      JArray< File > result((jobject) NULL);
      OBJ_CALL(result = ::java::io::File::listRoots());
      return JArray<jobject>(result.this$).wrap(t_File::wrap_jobject);
    }

    static PyObject *t_File_mkdir(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.mkdir());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_mkdirs(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.mkdirs());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_renameTo(t_File *self, PyObject *arg)
    {
      File a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "k", File::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.renameTo(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "renameTo", arg);
      return NULL;
    }

    static PyObject *t_File_setExecutable(t_File *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jboolean a0;
          jboolean result;

          if (!parseArgs(args, "Z", &a0))
          {
            OBJ_CALL(result = self->object.setExecutable(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jboolean a0;
          jboolean a1;
          jboolean result;

          if (!parseArgs(args, "ZZ", &a0, &a1))
          {
            OBJ_CALL(result = self->object.setExecutable(a0, a1));
            Py_RETURN_BOOL(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "setExecutable", args);
      return NULL;
    }

    static PyObject *t_File_setLastModified(t_File *self, PyObject *arg)
    {
      jlong a0;
      jboolean result;

      if (!parseArg(arg, "J", &a0))
      {
        OBJ_CALL(result = self->object.setLastModified(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "setLastModified", arg);
      return NULL;
    }

    static PyObject *t_File_setReadOnly(t_File *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.setReadOnly());
      Py_RETURN_BOOL(result);
    }

    static PyObject *t_File_setReadable(t_File *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jboolean a0;
          jboolean result;

          if (!parseArgs(args, "Z", &a0))
          {
            OBJ_CALL(result = self->object.setReadable(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jboolean a0;
          jboolean a1;
          jboolean result;

          if (!parseArgs(args, "ZZ", &a0, &a1))
          {
            OBJ_CALL(result = self->object.setReadable(a0, a1));
            Py_RETURN_BOOL(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "setReadable", args);
      return NULL;
    }

    static PyObject *t_File_setWritable(t_File *self, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          jboolean a0;
          jboolean result;

          if (!parseArgs(args, "Z", &a0))
          {
            OBJ_CALL(result = self->object.setWritable(a0));
            Py_RETURN_BOOL(result);
          }
        }
        break;
       case 2:
        {
          jboolean a0;
          jboolean a1;
          jboolean result;

          if (!parseArgs(args, "ZZ", &a0, &a1))
          {
            OBJ_CALL(result = self->object.setWritable(a0, a1));
            Py_RETURN_BOOL(result);
          }
        }
      }

      PyErr_SetArgsError((PyObject *) self, "setWritable", args);
      return NULL;
    }

    static PyObject *t_File_toPath(t_File *self)
    {
      ::java::nio::file::Path result((jobject) NULL);
      OBJ_CALL(result = self->object.toPath());
      return ::java::nio::file::t_Path::wrap_Object(result);
    }

    static PyObject *t_File_toString(t_File *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(File), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_File_get__absolute(t_File *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isAbsolute());
      Py_RETURN_BOOL(value);
    }

    static PyObject *t_File_get__absoluteFile(t_File *self, void *data)
    {
      File value((jobject) NULL);
      OBJ_CALL(value = self->object.getAbsoluteFile());
      return t_File::wrap_Object(value);
    }

    static PyObject *t_File_get__absolutePath(t_File *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getAbsolutePath());
      return j2p(value);
    }

    static PyObject *t_File_get__canonicalFile(t_File *self, void *data)
    {
      File value((jobject) NULL);
      OBJ_CALL(value = self->object.getCanonicalFile());
      return t_File::wrap_Object(value);
    }

    static PyObject *t_File_get__canonicalPath(t_File *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getCanonicalPath());
      return j2p(value);
    }

    static PyObject *t_File_get__directory(t_File *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isDirectory());
      Py_RETURN_BOOL(value);
    }

    static int t_File_set__executable(t_File *self, PyObject *arg, void *data)
    {
      {
        jboolean value;
        if (!parseArg(arg, "Z", &value))
        {
          INT_CALL(self->object.setExecutable(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "executable", arg);
      return -1;
    }

    static PyObject *t_File_get__file(t_File *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isFile());
      Py_RETURN_BOOL(value);
    }

    static PyObject *t_File_get__freeSpace(t_File *self, void *data)
    {
      jlong value;
      OBJ_CALL(value = self->object.getFreeSpace());
      return PyLong_FromLongLong((PY_LONG_LONG) value);
    }

    static PyObject *t_File_get__hidden(t_File *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isHidden());
      Py_RETURN_BOOL(value);
    }

    static PyObject *t_File_get__name(t_File *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getName());
      return j2p(value);
    }

    static PyObject *t_File_get__parent(t_File *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getParent());
      return j2p(value);
    }

    static PyObject *t_File_get__parentFile(t_File *self, void *data)
    {
      File value((jobject) NULL);
      OBJ_CALL(value = self->object.getParentFile());
      return t_File::wrap_Object(value);
    }

    static PyObject *t_File_get__path(t_File *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getPath());
      return j2p(value);
    }

    static int t_File_set__readable(t_File *self, PyObject *arg, void *data)
    {
      {
        jboolean value;
        if (!parseArg(arg, "Z", &value))
        {
          INT_CALL(self->object.setReadable(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "readable", arg);
      return -1;
    }

    static PyObject *t_File_get__totalSpace(t_File *self, void *data)
    {
      jlong value;
      OBJ_CALL(value = self->object.getTotalSpace());
      return PyLong_FromLongLong((PY_LONG_LONG) value);
    }

    static PyObject *t_File_get__usableSpace(t_File *self, void *data)
    {
      jlong value;
      OBJ_CALL(value = self->object.getUsableSpace());
      return PyLong_FromLongLong((PY_LONG_LONG) value);
    }

    static int t_File_set__writable(t_File *self, PyObject *arg, void *data)
    {
      {
        jboolean value;
        if (!parseArg(arg, "Z", &value))
        {
          INT_CALL(self->object.setWritable(value));
          return 0;
        }
      }
      PyErr_SetArgsError((PyObject *) self, "writable", arg);
      return -1;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/UnsupportedEncodingException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *UnsupportedEncodingException::class$ = NULL;
    jmethodID *UnsupportedEncodingException::mids$ = NULL;
    bool UnsupportedEncodingException::live$ = false;

    jclass UnsupportedEncodingException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/UnsupportedEncodingException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    UnsupportedEncodingException::UnsupportedEncodingException() : ::java::io::IOException(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    UnsupportedEncodingException::UnsupportedEncodingException(const ::java::lang::String & a0) : ::java::io::IOException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_UnsupportedEncodingException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_UnsupportedEncodingException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_UnsupportedEncodingException_init_(t_UnsupportedEncodingException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_UnsupportedEncodingException__methods_[] = {
      DECLARE_METHOD(t_UnsupportedEncodingException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_UnsupportedEncodingException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(UnsupportedEncodingException)[] = {
      { Py_tp_methods, t_UnsupportedEncodingException__methods_ },
      { Py_tp_init, (void *) t_UnsupportedEncodingException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(UnsupportedEncodingException)[] = {
      &PY_TYPE_DEF(::java::io::IOException),
      NULL
    };

    DEFINE_TYPE(UnsupportedEncodingException, t_UnsupportedEncodingException, UnsupportedEncodingException);

    void t_UnsupportedEncodingException::install(PyObject *module)
    {
      installType(&PY_TYPE(UnsupportedEncodingException), &PY_TYPE_DEF(UnsupportedEncodingException), module, "UnsupportedEncodingException", 0);
    }

    void t_UnsupportedEncodingException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(UnsupportedEncodingException), "class_", make_descriptor(UnsupportedEncodingException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(UnsupportedEncodingException), "wrapfn_", make_descriptor(t_UnsupportedEncodingException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(UnsupportedEncodingException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_UnsupportedEncodingException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, UnsupportedEncodingException::initializeClass, 1)))
        return NULL;
      return t_UnsupportedEncodingException::wrap_Object(UnsupportedEncodingException(((t_UnsupportedEncodingException *) arg)->object.this$));
    }
    static PyObject *t_UnsupportedEncodingException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, UnsupportedEncodingException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_UnsupportedEncodingException_init_(t_UnsupportedEncodingException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          UnsupportedEncodingException object((jobject) NULL);

          INT_CALL(object = UnsupportedEncodingException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          UnsupportedEncodingException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = UnsupportedEncodingException(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/CopyOption.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *CopyOption::class$ = NULL;
      jmethodID *CopyOption::mids$ = NULL;
      bool CopyOption::live$ = false;

      jclass CopyOption::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/CopyOption");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_CopyOption_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_CopyOption_instance_(PyTypeObject *type, PyObject *arg);

      static PyMethodDef t_CopyOption__methods_[] = {
        DECLARE_METHOD(t_CopyOption, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_CopyOption, instance_, METH_O | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(CopyOption)[] = {
        { Py_tp_methods, t_CopyOption__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(CopyOption)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(CopyOption, t_CopyOption, CopyOption);

      void t_CopyOption::install(PyObject *module)
      {
        installType(&PY_TYPE(CopyOption), &PY_TYPE_DEF(CopyOption), module, "CopyOption", 0);
      }

      void t_CopyOption::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(CopyOption), "class_", make_descriptor(CopyOption::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(CopyOption), "wrapfn_", make_descriptor(t_CopyOption::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(CopyOption), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_CopyOption_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, CopyOption::initializeClass, 1)))
          return NULL;
        return t_CopyOption::wrap_Object(CopyOption(((t_CopyOption *) arg)->object.this$));
      }
      static PyObject *t_CopyOption_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, CopyOption::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/CloneNotSupportedException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *CloneNotSupportedException::class$ = NULL;
    jmethodID *CloneNotSupportedException::mids$ = NULL;
    bool CloneNotSupportedException::live$ = false;

    jclass CloneNotSupportedException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/CloneNotSupportedException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    CloneNotSupportedException::CloneNotSupportedException() : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    CloneNotSupportedException::CloneNotSupportedException(const ::java::lang::String & a0) : ::java::lang::Exception(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_CloneNotSupportedException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_CloneNotSupportedException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_CloneNotSupportedException_init_(t_CloneNotSupportedException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_CloneNotSupportedException__methods_[] = {
      DECLARE_METHOD(t_CloneNotSupportedException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_CloneNotSupportedException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(CloneNotSupportedException)[] = {
      { Py_tp_methods, t_CloneNotSupportedException__methods_ },
      { Py_tp_init, (void *) t_CloneNotSupportedException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(CloneNotSupportedException)[] = {
      &PY_TYPE_DEF(::java::lang::Exception),
      NULL
    };

    DEFINE_TYPE(CloneNotSupportedException, t_CloneNotSupportedException, CloneNotSupportedException);

    void t_CloneNotSupportedException::install(PyObject *module)
    {
      installType(&PY_TYPE(CloneNotSupportedException), &PY_TYPE_DEF(CloneNotSupportedException), module, "CloneNotSupportedException", 0);
    }

    void t_CloneNotSupportedException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(CloneNotSupportedException), "class_", make_descriptor(CloneNotSupportedException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(CloneNotSupportedException), "wrapfn_", make_descriptor(t_CloneNotSupportedException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(CloneNotSupportedException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_CloneNotSupportedException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, CloneNotSupportedException::initializeClass, 1)))
        return NULL;
      return t_CloneNotSupportedException::wrap_Object(CloneNotSupportedException(((t_CloneNotSupportedException *) arg)->object.this$));
    }
    static PyObject *t_CloneNotSupportedException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, CloneNotSupportedException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_CloneNotSupportedException_init_(t_CloneNotSupportedException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          CloneNotSupportedException object((jobject) NULL);

          INT_CALL(object = CloneNotSupportedException());
          self->object = object;
          break;
        }
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          CloneNotSupportedException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = CloneNotSupportedException(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/IntStream.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *IntStream::class$ = NULL;
        jmethodID *IntStream::mids$ = NULL;
        bool IntStream::live$ = false;
        jint IntStream::EOF = (jint) 0;
        ::java::lang::String *IntStream::UNKNOWN_SOURCE_NAME = NULL;

        jclass IntStream::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/IntStream");

            mids$ = new jmethodID[max_mid];
            mids$[mid_LA_1e143afe1894d213] = env->getMethodID(cls, "LA", "(I)I");
            mids$[mid_consume_f2cc1bce94666404] = env->getMethodID(cls, "consume", "()V");
            mids$[mid_getSourceName_db9b55ba01e03e4b] = env->getMethodID(cls, "getSourceName", "()Ljava/lang/String;");
            mids$[mid_index_9972fcc56b44e79d] = env->getMethodID(cls, "index", "()I");
            mids$[mid_mark_9972fcc56b44e79d] = env->getMethodID(cls, "mark", "()I");
            mids$[mid_release_040c4cd0390c5aff] = env->getMethodID(cls, "release", "(I)V");
            mids$[mid_seek_040c4cd0390c5aff] = env->getMethodID(cls, "seek", "(I)V");
            mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");

            class$ = new ::java::lang::Class(cls);
            cls = (jclass) class$->this$;

            EOF = env->getStaticIntField(cls, "EOF");
            UNKNOWN_SOURCE_NAME = new ::java::lang::String(env->getStaticObjectField(cls, "UNKNOWN_SOURCE_NAME", "Ljava/lang/String;"));
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        jint IntStream::LA(jint a0) const
        {
          return env->callIntMethod(this$, mids$[mid_LA_1e143afe1894d213], a0);
        }

        void IntStream::consume() const
        {
          env->callVoidMethod(this$, mids$[mid_consume_f2cc1bce94666404]);
        }

        ::java::lang::String IntStream::getSourceName() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSourceName_db9b55ba01e03e4b]));
        }

        jint IntStream::index() const
        {
          return env->callIntMethod(this$, mids$[mid_index_9972fcc56b44e79d]);
        }

        jint IntStream::mark() const
        {
          return env->callIntMethod(this$, mids$[mid_mark_9972fcc56b44e79d]);
        }

        void IntStream::release(jint a0) const
        {
          env->callVoidMethod(this$, mids$[mid_release_040c4cd0390c5aff], a0);
        }

        void IntStream::seek(jint a0) const
        {
          env->callVoidMethod(this$, mids$[mid_seek_040c4cd0390c5aff], a0);
        }

        jint IntStream::size() const
        {
          return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_IntStream_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_IntStream_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_IntStream_LA(t_IntStream *self, PyObject *arg);
        static PyObject *t_IntStream_consume(t_IntStream *self);
        static PyObject *t_IntStream_getSourceName(t_IntStream *self);
        static PyObject *t_IntStream_index(t_IntStream *self);
        static PyObject *t_IntStream_mark(t_IntStream *self);
        static PyObject *t_IntStream_release(t_IntStream *self, PyObject *arg);
        static PyObject *t_IntStream_seek(t_IntStream *self, PyObject *arg);
        static PyObject *t_IntStream_size(t_IntStream *self);
        static PyObject *t_IntStream_get__sourceName(t_IntStream *self, void *data);
        static PyGetSetDef t_IntStream__fields_[] = {
          DECLARE_GET_FIELD(t_IntStream, sourceName),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_IntStream__methods_[] = {
          DECLARE_METHOD(t_IntStream, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_IntStream, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_IntStream, LA, METH_O),
          DECLARE_METHOD(t_IntStream, consume, METH_NOARGS),
          DECLARE_METHOD(t_IntStream, getSourceName, METH_NOARGS),
          DECLARE_METHOD(t_IntStream, index, METH_NOARGS),
          DECLARE_METHOD(t_IntStream, mark, METH_NOARGS),
          DECLARE_METHOD(t_IntStream, release, METH_O),
          DECLARE_METHOD(t_IntStream, seek, METH_O),
          DECLARE_METHOD(t_IntStream, size, METH_NOARGS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(IntStream)[] = {
          { Py_tp_methods, t_IntStream__methods_ },
          { Py_tp_init, (void *) abstract_init },
          { Py_tp_getset, t_IntStream__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(IntStream)[] = {
          &PY_TYPE_DEF(::java::lang::Object),
          NULL
        };

        DEFINE_TYPE(IntStream, t_IntStream, IntStream);

        void t_IntStream::install(PyObject *module)
        {
          installType(&PY_TYPE(IntStream), &PY_TYPE_DEF(IntStream), module, "IntStream", 0);
        }

        void t_IntStream::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(IntStream), "class_", make_descriptor(IntStream::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(IntStream), "wrapfn_", make_descriptor(t_IntStream::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(IntStream), "boxfn_", make_descriptor(boxObject));
          env->getClass(IntStream::initializeClass);
          PyObject_SetAttrString((PyObject *) PY_TYPE(IntStream), "EOF", make_descriptor(IntStream::EOF));
          PyObject_SetAttrString((PyObject *) PY_TYPE(IntStream), "UNKNOWN_SOURCE_NAME", make_descriptor(j2p(*IntStream::UNKNOWN_SOURCE_NAME)));
        }

        static PyObject *t_IntStream_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, IntStream::initializeClass, 1)))
            return NULL;
          return t_IntStream::wrap_Object(IntStream(((t_IntStream *) arg)->object.this$));
        }
        static PyObject *t_IntStream_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, IntStream::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_IntStream_LA(t_IntStream *self, PyObject *arg)
        {
          jint a0;
          jint result;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.LA(a0));
            return PyLong_FromLong((long) result);
          }

          PyErr_SetArgsError((PyObject *) self, "LA", arg);
          return NULL;
        }

        static PyObject *t_IntStream_consume(t_IntStream *self)
        {
          OBJ_CALL(self->object.consume());
          Py_RETURN_NONE;
        }

        static PyObject *t_IntStream_getSourceName(t_IntStream *self)
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getSourceName());
          return j2p(result);
        }

        static PyObject *t_IntStream_index(t_IntStream *self)
        {
          jint result;
          OBJ_CALL(result = self->object.index());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_IntStream_mark(t_IntStream *self)
        {
          jint result;
          OBJ_CALL(result = self->object.mark());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_IntStream_release(t_IntStream *self, PyObject *arg)
        {
          jint a0;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(self->object.release(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "release", arg);
          return NULL;
        }

        static PyObject *t_IntStream_seek(t_IntStream *self, PyObject *arg)
        {
          jint a0;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(self->object.seek(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "seek", arg);
          return NULL;
        }

        static PyObject *t_IntStream_size(t_IntStream *self)
        {
          jint result;
          OBJ_CALL(result = self->object.size());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_IntStream_get__sourceName(t_IntStream *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object.getSourceName());
          return j2p(value);
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Locale$LanguageRange.h"
#include "java/util/Map.h"
#include "java/util/Locale$LanguageRange.h"
#include "java/lang/Class.h"
#include "java/lang/String.h"
#include "java/util/List.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Locale$LanguageRange::class$ = NULL;
    jmethodID *Locale$LanguageRange::mids$ = NULL;
    bool Locale$LanguageRange::live$ = false;
    jdouble Locale$LanguageRange::MAX_WEIGHT = (jdouble) 0;
    jdouble Locale$LanguageRange::MIN_WEIGHT = (jdouble) 0;

    jclass Locale$LanguageRange::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Locale$LanguageRange");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_b5c6442be7f92276] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;D)V");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_getRange_db9b55ba01e03e4b] = env->getMethodID(cls, "getRange", "()Ljava/lang/String;");
        mids$[mid_getWeight_8c74b787998ce4bc] = env->getMethodID(cls, "getWeight", "()D");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_mapEquivalents_3f443c4919deca39] = env->getStaticMethodID(cls, "mapEquivalents", "(Ljava/util/List;Ljava/util/Map;)Ljava/util/List;");
        mids$[mid_parse_25278b4b3ab80e37] = env->getStaticMethodID(cls, "parse", "(Ljava/lang/String;)Ljava/util/List;");
        mids$[mid_parse_b72e0e84c1cdc97c] = env->getStaticMethodID(cls, "parse", "(Ljava/lang/String;Ljava/util/Map;)Ljava/util/List;");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        MAX_WEIGHT = env->getStaticDoubleField(cls, "MAX_WEIGHT");
        MIN_WEIGHT = env->getStaticDoubleField(cls, "MIN_WEIGHT");
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Locale$LanguageRange::Locale$LanguageRange(const ::java::lang::String & a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    Locale$LanguageRange::Locale$LanguageRange(const ::java::lang::String & a0, jdouble a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_b5c6442be7f92276, a0.this$, a1)) {}

    jboolean Locale$LanguageRange::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::lang::String Locale$LanguageRange::getRange() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getRange_db9b55ba01e03e4b]));
    }

    jdouble Locale$LanguageRange::getWeight() const
    {
      return env->callDoubleMethod(this$, mids$[mid_getWeight_8c74b787998ce4bc]);
    }

    jint Locale$LanguageRange::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    ::java::util::List Locale$LanguageRange::mapEquivalents(const ::java::util::List & a0, const ::java::util::Map & a1)
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::util::List(env->callStaticObjectMethod(cls, mids$[mid_mapEquivalents_3f443c4919deca39], a0.this$, a1.this$));
    }

    ::java::util::List Locale$LanguageRange::parse(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::util::List(env->callStaticObjectMethod(cls, mids$[mid_parse_25278b4b3ab80e37], a0.this$));
    }

    ::java::util::List Locale$LanguageRange::parse(const ::java::lang::String & a0, const ::java::util::Map & a1)
    {
      jclass cls = env->getClass(initializeClass);
      return ::java::util::List(env->callStaticObjectMethod(cls, mids$[mid_parse_b72e0e84c1cdc97c], a0.this$, a1.this$));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Locale$LanguageRange_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Locale$LanguageRange_instance_(PyTypeObject *type, PyObject *arg);
    static int t_Locale$LanguageRange_init_(t_Locale$LanguageRange *self, PyObject *args, PyObject *kwds);
    static PyObject *t_Locale$LanguageRange_equals(t_Locale$LanguageRange *self, PyObject *args);
    static PyObject *t_Locale$LanguageRange_getRange(t_Locale$LanguageRange *self);
    static PyObject *t_Locale$LanguageRange_getWeight(t_Locale$LanguageRange *self);
    static PyObject *t_Locale$LanguageRange_hashCode(t_Locale$LanguageRange *self, PyObject *args);
    static PyObject *t_Locale$LanguageRange_mapEquivalents(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale$LanguageRange_parse(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale$LanguageRange_get__range(t_Locale$LanguageRange *self, void *data);
    static PyObject *t_Locale$LanguageRange_get__weight(t_Locale$LanguageRange *self, void *data);
    static PyGetSetDef t_Locale$LanguageRange__fields_[] = {
      DECLARE_GET_FIELD(t_Locale$LanguageRange, range),
      DECLARE_GET_FIELD(t_Locale$LanguageRange, weight),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Locale$LanguageRange__methods_[] = {
      DECLARE_METHOD(t_Locale$LanguageRange, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Locale$LanguageRange, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Locale$LanguageRange, equals, METH_VARARGS),
      DECLARE_METHOD(t_Locale$LanguageRange, getRange, METH_NOARGS),
      DECLARE_METHOD(t_Locale$LanguageRange, getWeight, METH_NOARGS),
      DECLARE_METHOD(t_Locale$LanguageRange, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_Locale$LanguageRange, mapEquivalents, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale$LanguageRange, parse, METH_VARARGS | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Locale$LanguageRange)[] = {
      { Py_tp_methods, t_Locale$LanguageRange__methods_ },
      { Py_tp_init, (void *) t_Locale$LanguageRange_init_ },
      { Py_tp_getset, t_Locale$LanguageRange__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Locale$LanguageRange)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(Locale$LanguageRange, t_Locale$LanguageRange, Locale$LanguageRange);

    void t_Locale$LanguageRange::install(PyObject *module)
    {
      installType(&PY_TYPE(Locale$LanguageRange), &PY_TYPE_DEF(Locale$LanguageRange), module, "Locale$LanguageRange", 0);
    }

    void t_Locale$LanguageRange::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$LanguageRange), "class_", make_descriptor(Locale$LanguageRange::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$LanguageRange), "wrapfn_", make_descriptor(t_Locale$LanguageRange::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$LanguageRange), "boxfn_", make_descriptor(boxObject));
      env->getClass(Locale$LanguageRange::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$LanguageRange), "MAX_WEIGHT", make_descriptor(Locale$LanguageRange::MAX_WEIGHT));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$LanguageRange), "MIN_WEIGHT", make_descriptor(Locale$LanguageRange::MIN_WEIGHT));
    }

    static PyObject *t_Locale$LanguageRange_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Locale$LanguageRange::initializeClass, 1)))
        return NULL;
      return t_Locale$LanguageRange::wrap_Object(Locale$LanguageRange(((t_Locale$LanguageRange *) arg)->object.this$));
    }
    static PyObject *t_Locale$LanguageRange_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Locale$LanguageRange::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_Locale$LanguageRange_init_(t_Locale$LanguageRange *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          Locale$LanguageRange object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = Locale$LanguageRange(a0));
            self->object = object;
            break;
          }
        }
        goto err;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          jdouble a1;
          Locale$LanguageRange object((jobject) NULL);

          if (!parseArgs(args, "sD", &a0, &a1))
          {
            INT_CALL(object = Locale$LanguageRange(a0, a1));
            self->object = object;
            break;
          }
        }
       default:
       err:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_Locale$LanguageRange_equals(t_Locale$LanguageRange *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Locale$LanguageRange), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_Locale$LanguageRange_getRange(t_Locale$LanguageRange *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getRange());
      return j2p(result);
    }

    static PyObject *t_Locale$LanguageRange_getWeight(t_Locale$LanguageRange *self)
    {
      jdouble result;
      OBJ_CALL(result = self->object.getWeight());
      return PyFloat_FromDouble((double) result);
    }

    static PyObject *t_Locale$LanguageRange_hashCode(t_Locale$LanguageRange *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(Locale$LanguageRange), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_Locale$LanguageRange_mapEquivalents(PyTypeObject *type, PyObject *args)
    {
      ::java::util::List a0((jobject) NULL);
      PyTypeObject **p0;
      ::java::util::Map a1((jobject) NULL);
      PyTypeObject **p1;
      ::java::util::List result((jobject) NULL);

      if (!parseArgs(args, "KK", ::java::util::List::initializeClass, ::java::util::Map::initializeClass, &a0, &p0, ::java::util::t_List::parameters_, &a1, &p1, ::java::util::t_Map::parameters_))
      {
        OBJ_CALL(result = ::java::util::Locale$LanguageRange::mapEquivalents(a0, a1));
        return ::java::util::t_List::wrap_Object(result, ::java::util::PY_TYPE(Locale$LanguageRange));
      }

      PyErr_SetArgsError(type, "mapEquivalents", args);
      return NULL;
    }

    static PyObject *t_Locale$LanguageRange_parse(PyTypeObject *type, PyObject *args)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::util::List result((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            OBJ_CALL(result = ::java::util::Locale$LanguageRange::parse(a0));
            return ::java::util::t_List::wrap_Object(result, ::java::util::PY_TYPE(Locale$LanguageRange));
          }
        }
        break;
       case 2:
        {
          ::java::lang::String a0((jobject) NULL);
          ::java::util::Map a1((jobject) NULL);
          PyTypeObject **p1;
          ::java::util::List result((jobject) NULL);

          if (!parseArgs(args, "sK", ::java::util::Map::initializeClass, &a0, &a1, &p1, ::java::util::t_Map::parameters_))
          {
            OBJ_CALL(result = ::java::util::Locale$LanguageRange::parse(a0, a1));
            return ::java::util::t_List::wrap_Object(result, ::java::util::PY_TYPE(Locale$LanguageRange));
          }
        }
      }

      PyErr_SetArgsError(type, "parse", args);
      return NULL;
    }

    static PyObject *t_Locale$LanguageRange_get__range(t_Locale$LanguageRange *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getRange());
      return j2p(value);
    }

    static PyObject *t_Locale$LanguageRange_get__weight(t_Locale$LanguageRange *self, void *data)
    {
      jdouble value;
      OBJ_CALL(value = self->object.getWeight());
      return PyFloat_FromDouble((double) value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/FilenameFilter.h"
#include "java/io/File.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *FilenameFilter::class$ = NULL;
    jmethodID *FilenameFilter::mids$ = NULL;
    bool FilenameFilter::live$ = false;

    jclass FilenameFilter::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/FilenameFilter");

        mids$ = new jmethodID[max_mid];
        mids$[mid_accept_b78c7e4168f53822] = env->getMethodID(cls, "accept", "(Ljava/io/File;Ljava/lang/String;)Z");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jboolean FilenameFilter::accept(const ::java::io::File & a0, const ::java::lang::String & a1) const
    {
      return env->callBooleanMethod(this$, mids$[mid_accept_b78c7e4168f53822], a0.this$, a1.this$);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_FilenameFilter_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_FilenameFilter_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_FilenameFilter_accept(t_FilenameFilter *self, PyObject *args);

    static PyMethodDef t_FilenameFilter__methods_[] = {
      DECLARE_METHOD(t_FilenameFilter, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_FilenameFilter, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_FilenameFilter, accept, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(FilenameFilter)[] = {
      { Py_tp_methods, t_FilenameFilter__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(FilenameFilter)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(FilenameFilter, t_FilenameFilter, FilenameFilter);

    void t_FilenameFilter::install(PyObject *module)
    {
      installType(&PY_TYPE(FilenameFilter), &PY_TYPE_DEF(FilenameFilter), module, "FilenameFilter", 0);
    }

    void t_FilenameFilter::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(FilenameFilter), "class_", make_descriptor(FilenameFilter::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FilenameFilter), "wrapfn_", make_descriptor(t_FilenameFilter::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FilenameFilter), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_FilenameFilter_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, FilenameFilter::initializeClass, 1)))
        return NULL;
      return t_FilenameFilter::wrap_Object(FilenameFilter(((t_FilenameFilter *) arg)->object.this$));
    }
    static PyObject *t_FilenameFilter_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, FilenameFilter::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_FilenameFilter_accept(t_FilenameFilter *self, PyObject *args)
    {
      ::java::io::File a0((jobject) NULL);
      ::java::lang::String a1((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "ks", ::java::io::File::initializeClass, &a0, &a1))
      {
        OBJ_CALL(result = self->object.accept(a0, a1));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "accept", args);
      return NULL;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/MissingResourceException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *MissingResourceException::class$ = NULL;
    jmethodID *MissingResourceException::mids$ = NULL;
    bool MissingResourceException::live$ = false;

    jclass MissingResourceException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/MissingResourceException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f05031826564616f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V");
        mids$[mid_getClassName_db9b55ba01e03e4b] = env->getMethodID(cls, "getClassName", "()Ljava/lang/String;");
        mids$[mid_getKey_db9b55ba01e03e4b] = env->getMethodID(cls, "getKey", "()Ljava/lang/String;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    MissingResourceException::MissingResourceException(const ::java::lang::String & a0, const ::java::lang::String & a1, const ::java::lang::String & a2) : ::java::lang::RuntimeException(env->newObject(initializeClass, &mids$, mid_init$_f05031826564616f, a0.this$, a1.this$, a2.this$)) {}

    ::java::lang::String MissingResourceException::getClassName() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getClassName_db9b55ba01e03e4b]));
    }

    ::java::lang::String MissingResourceException::getKey() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getKey_db9b55ba01e03e4b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_MissingResourceException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_MissingResourceException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_MissingResourceException_init_(t_MissingResourceException *self, PyObject *args, PyObject *kwds);
    static PyObject *t_MissingResourceException_getClassName(t_MissingResourceException *self);
    static PyObject *t_MissingResourceException_getKey(t_MissingResourceException *self);
    static PyObject *t_MissingResourceException_get__className(t_MissingResourceException *self, void *data);
    static PyObject *t_MissingResourceException_get__key(t_MissingResourceException *self, void *data);
    static PyGetSetDef t_MissingResourceException__fields_[] = {
      DECLARE_GET_FIELD(t_MissingResourceException, className),
      DECLARE_GET_FIELD(t_MissingResourceException, key),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_MissingResourceException__methods_[] = {
      DECLARE_METHOD(t_MissingResourceException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_MissingResourceException, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_MissingResourceException, getClassName, METH_NOARGS),
      DECLARE_METHOD(t_MissingResourceException, getKey, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(MissingResourceException)[] = {
      { Py_tp_methods, t_MissingResourceException__methods_ },
      { Py_tp_init, (void *) t_MissingResourceException_init_ },
      { Py_tp_getset, t_MissingResourceException__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(MissingResourceException)[] = {
      &PY_TYPE_DEF(::java::lang::RuntimeException),
      NULL
    };

    DEFINE_TYPE(MissingResourceException, t_MissingResourceException, MissingResourceException);

    void t_MissingResourceException::install(PyObject *module)
    {
      installType(&PY_TYPE(MissingResourceException), &PY_TYPE_DEF(MissingResourceException), module, "MissingResourceException", 0);
    }

    void t_MissingResourceException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(MissingResourceException), "class_", make_descriptor(MissingResourceException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(MissingResourceException), "wrapfn_", make_descriptor(t_MissingResourceException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(MissingResourceException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_MissingResourceException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, MissingResourceException::initializeClass, 1)))
        return NULL;
      return t_MissingResourceException::wrap_Object(MissingResourceException(((t_MissingResourceException *) arg)->object.this$));
    }
    static PyObject *t_MissingResourceException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, MissingResourceException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_MissingResourceException_init_(t_MissingResourceException *self, PyObject *args, PyObject *kwds)
    {
      ::java::lang::String a0((jobject) NULL);
      ::java::lang::String a1((jobject) NULL);
      ::java::lang::String a2((jobject) NULL);
      MissingResourceException object((jobject) NULL);

      if (!parseArgs(args, "sss", &a0, &a1, &a2))
      {
        INT_CALL(object = MissingResourceException(a0, a1, a2));
        self->object = object;
      }
      else
      {
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_MissingResourceException_getClassName(t_MissingResourceException *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getClassName());
      return j2p(result);
    }

    static PyObject *t_MissingResourceException_getKey(t_MissingResourceException *self)
    {
      ::java::lang::String result((jobject) NULL);
      OBJ_CALL(result = self->object.getKey());
      return j2p(result);
    }

    static PyObject *t_MissingResourceException_get__className(t_MissingResourceException *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getClassName());
      return j2p(value);
    }

    static PyObject *t_MissingResourceException_get__key(t_MissingResourceException *self, void *data)
    {
      ::java::lang::String value((jobject) NULL);
      OBJ_CALL(value = self->object.getKey());
      return j2p(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ATN.h"
#include "java/util/Map.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/atn/LexerAction.h"
#include "org/antlr/v4/runtime/atn/TokensStartState.h"
#include "org/antlr/v4/runtime/atn/DecisionState.h"
#include "org/antlr/v4/runtime/atn/ATNType.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/RuleStartState.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/atn/ATNState.h"
#include "org/antlr/v4/runtime/atn/RuleStopState.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ATN::class$ = NULL;
          jmethodID *ATN::mids$ = NULL;
          jfieldID *ATN::fids$ = NULL;
          bool ATN::live$ = false;
          jint ATN::INVALID_ALT_NUMBER = (jint) 0;

          jclass ATN::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ATN");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_b3a9e71462722e83] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNType;I)V");
              mids$[mid_addState_1dedc26b173e2f62] = env->getMethodID(cls, "addState", "(Lorg/antlr/v4/runtime/atn/ATNState;)V");
              mids$[mid_defineDecisionState_bf5684c49a8a40c8] = env->getMethodID(cls, "defineDecisionState", "(Lorg/antlr/v4/runtime/atn/DecisionState;)I");
              mids$[mid_getDecisionState_9e50f53ab7952185] = env->getMethodID(cls, "getDecisionState", "(I)Lorg/antlr/v4/runtime/atn/DecisionState;");
              mids$[mid_getNumberOfDecisions_9972fcc56b44e79d] = env->getMethodID(cls, "getNumberOfDecisions", "()I");
              mids$[mid_removeState_1dedc26b173e2f62] = env->getMethodID(cls, "removeState", "(Lorg/antlr/v4/runtime/atn/ATNState;)V");

              fids$ = new jfieldID[max_fid];
              fids$[fid_decisionToState] = env->getFieldID(cls, "decisionToState", "Ljava/util/List;");
              fids$[fid_grammarType] = env->getFieldID(cls, "grammarType", "Lorg/antlr/v4/runtime/atn/ATNType;");
              fids$[fid_lexerActions] = env->getFieldID(cls, "lexerActions", "[Lorg/antlr/v4/runtime/atn/LexerAction;");
              fids$[fid_maxTokenType] = env->getFieldID(cls, "maxTokenType", "I");
              fids$[fid_modeNameToStartState] = env->getFieldID(cls, "modeNameToStartState", "Ljava/util/Map;");
              fids$[fid_modeToStartState] = env->getFieldID(cls, "modeToStartState", "Ljava/util/List;");
              fids$[fid_ruleToStartState] = env->getFieldID(cls, "ruleToStartState", "[Lorg/antlr/v4/runtime/atn/RuleStartState;");
              fids$[fid_ruleToStopState] = env->getFieldID(cls, "ruleToStopState", "[Lorg/antlr/v4/runtime/atn/RuleStopState;");
              fids$[fid_ruleToTokenType] = env->getFieldID(cls, "ruleToTokenType", "[I");
              fids$[fid_states] = env->getFieldID(cls, "states", "Ljava/util/List;");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              INVALID_ALT_NUMBER = env->getStaticIntField(cls, "INVALID_ALT_NUMBER");
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ATN::ATN(const ::org::antlr::v4::runtime::atn::ATNType & a0, jint a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_b3a9e71462722e83, a0.this$, a1)) {}

          void ATN::addState(const ::org::antlr::v4::runtime::atn::ATNState & a0) const
          {
            env->callVoidMethod(this$, mids$[mid_addState_1dedc26b173e2f62], a0.this$);
          }

          jint ATN::defineDecisionState(const ::org::antlr::v4::runtime::atn::DecisionState & a0) const
          {
            return env->callIntMethod(this$, mids$[mid_defineDecisionState_bf5684c49a8a40c8], a0.this$);
          }

          ::org::antlr::v4::runtime::atn::DecisionState ATN::getDecisionState(jint a0) const
          {
            return ::org::antlr::v4::runtime::atn::DecisionState(env->callObjectMethod(this$, mids$[mid_getDecisionState_9e50f53ab7952185], a0));
          }

          jint ATN::getNumberOfDecisions() const
          {
            return env->callIntMethod(this$, mids$[mid_getNumberOfDecisions_9972fcc56b44e79d]);
          }

          void ATN::removeState(const ::org::antlr::v4::runtime::atn::ATNState & a0) const
          {
            env->callVoidMethod(this$, mids$[mid_removeState_1dedc26b173e2f62], a0.this$);
          }

          ::java::util::List ATN::_get_decisionToState() const
          {
            return ::java::util::List(env->getObjectField(this$, fids$[fid_decisionToState]));
          }

          ::org::antlr::v4::runtime::atn::ATNType ATN::_get_grammarType() const
          {
            return ::org::antlr::v4::runtime::atn::ATNType(env->getObjectField(this$, fids$[fid_grammarType]));
          }

          JArray< ::org::antlr::v4::runtime::atn::LexerAction > ATN::_get_lexerActions() const
          {
            return JArray< ::org::antlr::v4::runtime::atn::LexerAction >(env->getObjectField(this$, fids$[fid_lexerActions]));
          }

          void ATN::_set_lexerActions(const JArray< ::org::antlr::v4::runtime::atn::LexerAction > & a0) const
          {
            env->setObjectField(this$, fids$[fid_lexerActions], a0.this$);
          }

          jint ATN::_get_maxTokenType() const
          {
            return env->getIntField(this$, fids$[fid_maxTokenType]);
          }

          ::java::util::Map ATN::_get_modeNameToStartState() const
          {
            return ::java::util::Map(env->getObjectField(this$, fids$[fid_modeNameToStartState]));
          }

          ::java::util::List ATN::_get_modeToStartState() const
          {
            return ::java::util::List(env->getObjectField(this$, fids$[fid_modeToStartState]));
          }

          JArray< ::org::antlr::v4::runtime::atn::RuleStartState > ATN::_get_ruleToStartState() const
          {
            return JArray< ::org::antlr::v4::runtime::atn::RuleStartState >(env->getObjectField(this$, fids$[fid_ruleToStartState]));
          }

          void ATN::_set_ruleToStartState(const JArray< ::org::antlr::v4::runtime::atn::RuleStartState > & a0) const
          {
            env->setObjectField(this$, fids$[fid_ruleToStartState], a0.this$);
          }

          JArray< ::org::antlr::v4::runtime::atn::RuleStopState > ATN::_get_ruleToStopState() const
          {
            return JArray< ::org::antlr::v4::runtime::atn::RuleStopState >(env->getObjectField(this$, fids$[fid_ruleToStopState]));
          }

          void ATN::_set_ruleToStopState(const JArray< ::org::antlr::v4::runtime::atn::RuleStopState > & a0) const
          {
            env->setObjectField(this$, fids$[fid_ruleToStopState], a0.this$);
          }

          JArray< jint > ATN::_get_ruleToTokenType() const
          {
            return JArray< jint >(env->getObjectField(this$, fids$[fid_ruleToTokenType]));
          }

          void ATN::_set_ruleToTokenType(const JArray< jint > & a0) const
          {
            env->setObjectField(this$, fids$[fid_ruleToTokenType], a0.this$);
          }

          ::java::util::List ATN::_get_states() const
          {
            return ::java::util::List(env->getObjectField(this$, fids$[fid_states]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ATN_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATN_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ATN_init_(t_ATN *self, PyObject *args, PyObject *kwds);
          static PyObject *t_ATN_addState(t_ATN *self, PyObject *arg);
          static PyObject *t_ATN_defineDecisionState(t_ATN *self, PyObject *arg);
          static PyObject *t_ATN_getDecisionState(t_ATN *self, PyObject *arg);
          static PyObject *t_ATN_getNumberOfDecisions(t_ATN *self);
          static PyObject *t_ATN_removeState(t_ATN *self, PyObject *arg);
          static PyObject *t_ATN_get__decisionToState(t_ATN *self, void *data);
          static PyObject *t_ATN_get__grammarType(t_ATN *self, void *data);
          static PyObject *t_ATN_get__lexerActions(t_ATN *self, void *data);
          static int t_ATN_set__lexerActions(t_ATN *self, PyObject *arg, void *data);
          static PyObject *t_ATN_get__maxTokenType(t_ATN *self, void *data);
          static PyObject *t_ATN_get__modeNameToStartState(t_ATN *self, void *data);
          static PyObject *t_ATN_get__modeToStartState(t_ATN *self, void *data);
          static PyObject *t_ATN_get__ruleToStartState(t_ATN *self, void *data);
          static int t_ATN_set__ruleToStartState(t_ATN *self, PyObject *arg, void *data);
          static PyObject *t_ATN_get__ruleToStopState(t_ATN *self, void *data);
          static int t_ATN_set__ruleToStopState(t_ATN *self, PyObject *arg, void *data);
          static PyObject *t_ATN_get__ruleToTokenType(t_ATN *self, void *data);
          static int t_ATN_set__ruleToTokenType(t_ATN *self, PyObject *arg, void *data);
          static PyObject *t_ATN_get__states(t_ATN *self, void *data);

          static PyObject *t_ATN_get__numberOfDecisions(t_ATN *self, void *data);
          static PyGetSetDef t_ATN__fields_[] = {
            DECLARE_GET_FIELD(t_ATN, decisionToState),
            DECLARE_GET_FIELD(t_ATN, grammarType),
            DECLARE_GETSET_FIELD(t_ATN, lexerActions),
            DECLARE_GET_FIELD(t_ATN, maxTokenType),
            DECLARE_GET_FIELD(t_ATN, modeNameToStartState),
            DECLARE_GET_FIELD(t_ATN, modeToStartState),
            DECLARE_GETSET_FIELD(t_ATN, ruleToStartState),
            DECLARE_GETSET_FIELD(t_ATN, ruleToStopState),
            DECLARE_GETSET_FIELD(t_ATN, ruleToTokenType),
            DECLARE_GET_FIELD(t_ATN, states),
            DECLARE_GET_FIELD(t_ATN, numberOfDecisions),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ATN__methods_[] = {
            DECLARE_METHOD(t_ATN, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATN, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATN, addState, METH_O),
            DECLARE_METHOD(t_ATN, defineDecisionState, METH_O),
            DECLARE_METHOD(t_ATN, getDecisionState, METH_O),
            DECLARE_METHOD(t_ATN, getNumberOfDecisions, METH_NOARGS),
            DECLARE_METHOD(t_ATN, removeState, METH_O),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ATN)[] = {
            { Py_tp_methods, t_ATN__methods_ },
            { Py_tp_init, (void *) t_ATN_init_ },
            { Py_tp_getset, t_ATN__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ATN)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(ATN, t_ATN, ATN);

          void t_ATN::install(PyObject *module)
          {
            installType(&PY_TYPE(ATN), &PY_TYPE_DEF(ATN), module, "ATN", 0);
          }

          void t_ATN::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATN), "class_", make_descriptor(ATN::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATN), "wrapfn_", make_descriptor(t_ATN::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATN), "boxfn_", make_descriptor(boxObject));
            env->getClass(ATN::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATN), "INVALID_ALT_NUMBER", make_descriptor(ATN::INVALID_ALT_NUMBER));
          }

          static PyObject *t_ATN_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ATN::initializeClass, 1)))
              return NULL;
            return t_ATN::wrap_Object(ATN(((t_ATN *) arg)->object.this$));
          }
          static PyObject *t_ATN_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ATN::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ATN_init_(t_ATN *self, PyObject *args, PyObject *kwds)
          {
            ::org::antlr::v4::runtime::atn::ATNType a0((jobject) NULL);
            PyTypeObject **p0;
            jint a1;
            ATN object((jobject) NULL);

            if (!parseArgs(args, "KI", ::org::antlr::v4::runtime::atn::ATNType::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::atn::t_ATNType::parameters_, &a1))
            {
              INT_CALL(object = ATN(a0, a1));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_ATN_addState(t_ATN *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNState a0((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNState::initializeClass, &a0))
            {
              OBJ_CALL(self->object.addState(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "addState", arg);
            return NULL;
          }

          static PyObject *t_ATN_defineDecisionState(t_ATN *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::DecisionState a0((jobject) NULL);
            jint result;

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::DecisionState::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.defineDecisionState(a0));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError((PyObject *) self, "defineDecisionState", arg);
            return NULL;
          }

          static PyObject *t_ATN_getDecisionState(t_ATN *self, PyObject *arg)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::DecisionState result((jobject) NULL);

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(result = self->object.getDecisionState(a0));
              return ::org::antlr::v4::runtime::atn::t_DecisionState::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "getDecisionState", arg);
            return NULL;
          }

          static PyObject *t_ATN_getNumberOfDecisions(t_ATN *self)
          {
            jint result;
            OBJ_CALL(result = self->object.getNumberOfDecisions());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_ATN_removeState(t_ATN *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNState a0((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNState::initializeClass, &a0))
            {
              OBJ_CALL(self->object.removeState(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "removeState", arg);
            return NULL;
          }

          static PyObject *t_ATN_get__decisionToState(t_ATN *self, void *data)
          {
            ::java::util::List value((jobject) NULL);
            OBJ_CALL(value = self->object._get_decisionToState());
            return ::java::util::t_List::wrap_Object(value);
          }

          static PyObject *t_ATN_get__grammarType(t_ATN *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATNType value((jobject) NULL);
            OBJ_CALL(value = self->object._get_grammarType());
            return ::org::antlr::v4::runtime::atn::t_ATNType::wrap_Object(value);
          }

          static PyObject *t_ATN_get__lexerActions(t_ATN *self, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::LexerAction > value((jobject) NULL);
            OBJ_CALL(value = self->object._get_lexerActions());
            return JArray<jobject>(value.this$).wrap(::org::antlr::v4::runtime::atn::t_LexerAction::wrap_jobject);
          }
          static int t_ATN_set__lexerActions(t_ATN *self, PyObject *arg, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::LexerAction > value((jobject) NULL);
            if (!parseArg(arg, "[k", ::org::antlr::v4::runtime::atn::LexerAction::initializeClass, &value))
            {
              INT_CALL(self->object._set_lexerActions(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "lexerActions", arg);
            return -1;
          }

          static PyObject *t_ATN_get__maxTokenType(t_ATN *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_maxTokenType());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_ATN_get__modeNameToStartState(t_ATN *self, void *data)
          {
            ::java::util::Map value((jobject) NULL);
            OBJ_CALL(value = self->object._get_modeNameToStartState());
            return ::java::util::t_Map::wrap_Object(value);
          }

          static PyObject *t_ATN_get__modeToStartState(t_ATN *self, void *data)
          {
            ::java::util::List value((jobject) NULL);
            OBJ_CALL(value = self->object._get_modeToStartState());
            return ::java::util::t_List::wrap_Object(value);
          }

          static PyObject *t_ATN_get__ruleToStartState(t_ATN *self, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::RuleStartState > value((jobject) NULL);
            OBJ_CALL(value = self->object._get_ruleToStartState());
            return JArray<jobject>(value.this$).wrap(::org::antlr::v4::runtime::atn::t_RuleStartState::wrap_jobject);
          }
          static int t_ATN_set__ruleToStartState(t_ATN *self, PyObject *arg, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::RuleStartState > value((jobject) NULL);
            if (!parseArg(arg, "[k", ::org::antlr::v4::runtime::atn::RuleStartState::initializeClass, &value))
            {
              INT_CALL(self->object._set_ruleToStartState(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "ruleToStartState", arg);
            return -1;
          }

          static PyObject *t_ATN_get__ruleToStopState(t_ATN *self, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::RuleStopState > value((jobject) NULL);
            OBJ_CALL(value = self->object._get_ruleToStopState());
            return JArray<jobject>(value.this$).wrap(::org::antlr::v4::runtime::atn::t_RuleStopState::wrap_jobject);
          }
          static int t_ATN_set__ruleToStopState(t_ATN *self, PyObject *arg, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::RuleStopState > value((jobject) NULL);
            if (!parseArg(arg, "[k", ::org::antlr::v4::runtime::atn::RuleStopState::initializeClass, &value))
            {
              INT_CALL(self->object._set_ruleToStopState(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "ruleToStopState", arg);
            return -1;
          }

          static PyObject *t_ATN_get__ruleToTokenType(t_ATN *self, void *data)
          {
            JArray< jint > value((jobject) NULL);
            OBJ_CALL(value = self->object._get_ruleToTokenType());
            return value.wrap();
          }
          static int t_ATN_set__ruleToTokenType(t_ATN *self, PyObject *arg, void *data)
          {
            JArray< jint > value((jobject) NULL);
            if (!parseArg(arg, "[I", &value))
            {
              INT_CALL(self->object._set_ruleToTokenType(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "ruleToTokenType", arg);
            return -1;
          }

          static PyObject *t_ATN_get__states(t_ATN *self, void *data)
          {
            ::java::util::List value((jobject) NULL);
            OBJ_CALL(value = self->object._get_states());
            return ::java::util::t_List::wrap_Object(value);
          }

          static PyObject *t_ATN_get__numberOfDecisions(t_ATN *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getNumberOfDecisions());
            return PyLong_FromLong((long) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ATNConfig.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/atn/PredictionContext.h"
#include "org/antlr/v4/runtime/atn/SemanticContext.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/Recognizer.h"
#include "org/antlr/v4/runtime/atn/ATNConfig.h"
#include "org/antlr/v4/runtime/atn/ATNState.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ATNConfig::class$ = NULL;
          jmethodID *ATNConfig::mids$ = NULL;
          jfieldID *ATNConfig::fids$ = NULL;
          bool ATNConfig::live$ = false;

          jclass ATNConfig::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ATNConfig");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_88c42b6aaadcf97d] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNState;)V");
              mids$[mid_init$_101e224c4cb5ae50] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/SemanticContext;)V");
              mids$[mid_init$_e21fca0385a1d053] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/PredictionContext;)V");
              mids$[mid_init$_45d6f0f374153826] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/SemanticContext;)V");
              mids$[mid_init$_cbe24c640a7ffbdb] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNState;ILorg/antlr/v4/runtime/atn/PredictionContext;)V");
              mids$[mid_init$_16ac7c637c0f9be5] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNConfig;Lorg/antlr/v4/runtime/atn/ATNState;Lorg/antlr/v4/runtime/atn/PredictionContext;Lorg/antlr/v4/runtime/atn/SemanticContext;)V");
              mids$[mid_init$_3cbfae3aae13bc3c] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNState;ILorg/antlr/v4/runtime/atn/PredictionContext;Lorg/antlr/v4/runtime/atn/SemanticContext;)V");
              mids$[mid_equals_ee797c2c9eeb87eb] = env->getMethodID(cls, "equals", "(Lorg/antlr/v4/runtime/atn/ATNConfig;)Z");
              mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
              mids$[mid_getOuterContextDepth_9972fcc56b44e79d] = env->getMethodID(cls, "getOuterContextDepth", "()I");
              mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
              mids$[mid_isPrecedenceFilterSuppressed_8454bd5aa23fd11e] = env->getMethodID(cls, "isPrecedenceFilterSuppressed", "()Z");
              mids$[mid_setPrecedenceFilterSuppressed_9d72768e8fdce2b7] = env->getMethodID(cls, "setPrecedenceFilterSuppressed", "(Z)V");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
              mids$[mid_toString_3dd3e2f31052e7db] = env->getMethodID(cls, "toString", "(Lorg/antlr/v4/runtime/Recognizer;Z)Ljava/lang/String;");

              fids$ = new jfieldID[max_fid];
              fids$[fid_alt] = env->getFieldID(cls, "alt", "I");
              fids$[fid_context] = env->getFieldID(cls, "context", "Lorg/antlr/v4/runtime/atn/PredictionContext;");
              fids$[fid_reachesIntoOuterContext] = env->getFieldID(cls, "reachesIntoOuterContext", "I");
              fids$[fid_semanticContext] = env->getFieldID(cls, "semanticContext", "Lorg/antlr/v4/runtime/atn/SemanticContext;");
              fids$[fid_state] = env->getFieldID(cls, "state", "Lorg/antlr/v4/runtime/atn/ATNState;");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ATNConfig::ATNConfig(const ATNConfig & a0, const ::org::antlr::v4::runtime::atn::ATNState & a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_88c42b6aaadcf97d, a0.this$, a1.this$)) {}

          ATNConfig::ATNConfig(const ATNConfig & a0, const ::org::antlr::v4::runtime::atn::SemanticContext & a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_101e224c4cb5ae50, a0.this$, a1.this$)) {}

          ATNConfig::ATNConfig(const ATNConfig & a0, const ::org::antlr::v4::runtime::atn::ATNState & a1, const ::org::antlr::v4::runtime::atn::PredictionContext & a2) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_e21fca0385a1d053, a0.this$, a1.this$, a2.this$)) {}

          ATNConfig::ATNConfig(const ATNConfig & a0, const ::org::antlr::v4::runtime::atn::ATNState & a1, const ::org::antlr::v4::runtime::atn::SemanticContext & a2) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_45d6f0f374153826, a0.this$, a1.this$, a2.this$)) {}

          ATNConfig::ATNConfig(const ::org::antlr::v4::runtime::atn::ATNState & a0, jint a1, const ::org::antlr::v4::runtime::atn::PredictionContext & a2) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_cbe24c640a7ffbdb, a0.this$, a1, a2.this$)) {}

          ATNConfig::ATNConfig(const ATNConfig & a0, const ::org::antlr::v4::runtime::atn::ATNState & a1, const ::org::antlr::v4::runtime::atn::PredictionContext & a2, const ::org::antlr::v4::runtime::atn::SemanticContext & a3) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_16ac7c637c0f9be5, a0.this$, a1.this$, a2.this$, a3.this$)) {}

          ATNConfig::ATNConfig(const ::org::antlr::v4::runtime::atn::ATNState & a0, jint a1, const ::org::antlr::v4::runtime::atn::PredictionContext & a2, const ::org::antlr::v4::runtime::atn::SemanticContext & a3) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_3cbfae3aae13bc3c, a0.this$, a1, a2.this$, a3.this$)) {}

          jboolean ATNConfig::equals(const ATNConfig & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_ee797c2c9eeb87eb], a0.this$);
          }

          jboolean ATNConfig::equals(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
          }

          jint ATNConfig::getOuterContextDepth() const
          {
            return env->callIntMethod(this$, mids$[mid_getOuterContextDepth_9972fcc56b44e79d]);
          }

          jint ATNConfig::hashCode() const
          {
            return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
          }

          jboolean ATNConfig::isPrecedenceFilterSuppressed() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isPrecedenceFilterSuppressed_8454bd5aa23fd11e]);
          }

          void ATNConfig::setPrecedenceFilterSuppressed(jboolean a0) const
          {
            env->callVoidMethod(this$, mids$[mid_setPrecedenceFilterSuppressed_9d72768e8fdce2b7], a0);
          }

          ::java::lang::String ATNConfig::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }

          ::java::lang::String ATNConfig::toString(const ::org::antlr::v4::runtime::Recognizer & a0, jboolean a1) const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_3dd3e2f31052e7db], a0.this$, a1));
          }

          jint ATNConfig::_get_alt() const
          {
            return env->getIntField(this$, fids$[fid_alt]);
          }

          ::org::antlr::v4::runtime::atn::PredictionContext ATNConfig::_get_context() const
          {
            return ::org::antlr::v4::runtime::atn::PredictionContext(env->getObjectField(this$, fids$[fid_context]));
          }

          void ATNConfig::_set_context(const ::org::antlr::v4::runtime::atn::PredictionContext & a0) const
          {
            env->setObjectField(this$, fids$[fid_context], a0.this$);
          }

          jint ATNConfig::_get_reachesIntoOuterContext() const
          {
            return env->getIntField(this$, fids$[fid_reachesIntoOuterContext]);
          }

          void ATNConfig::_set_reachesIntoOuterContext(jint a0) const
          {
            env->setIntField(this$, fids$[fid_reachesIntoOuterContext], a0);
          }

          ::org::antlr::v4::runtime::atn::SemanticContext ATNConfig::_get_semanticContext() const
          {
            return ::org::antlr::v4::runtime::atn::SemanticContext(env->getObjectField(this$, fids$[fid_semanticContext]));
          }

          ::org::antlr::v4::runtime::atn::ATNState ATNConfig::_get_state() const
          {
            return ::org::antlr::v4::runtime::atn::ATNState(env->getObjectField(this$, fids$[fid_state]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ATNConfig_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNConfig_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ATNConfig_init_(t_ATNConfig *self, PyObject *args, PyObject *kwds);
          static PyObject *t_ATNConfig_equals(t_ATNConfig *self, PyObject *args);
          static PyObject *t_ATNConfig_getOuterContextDepth(t_ATNConfig *self);
          static PyObject *t_ATNConfig_hashCode(t_ATNConfig *self, PyObject *args);
          static PyObject *t_ATNConfig_isPrecedenceFilterSuppressed(t_ATNConfig *self);
          static PyObject *t_ATNConfig_setPrecedenceFilterSuppressed(t_ATNConfig *self, PyObject *arg);
          static PyObject *t_ATNConfig_toString(t_ATNConfig *self, PyObject *args);
          static PyObject *t_ATNConfig_get__alt(t_ATNConfig *self, void *data);
          static PyObject *t_ATNConfig_get__context(t_ATNConfig *self, void *data);
          static int t_ATNConfig_set__context(t_ATNConfig *self, PyObject *arg, void *data);
          static PyObject *t_ATNConfig_get__reachesIntoOuterContext(t_ATNConfig *self, void *data);
          static int t_ATNConfig_set__reachesIntoOuterContext(t_ATNConfig *self, PyObject *arg, void *data);
          static PyObject *t_ATNConfig_get__semanticContext(t_ATNConfig *self, void *data);
          static PyObject *t_ATNConfig_get__state(t_ATNConfig *self, void *data);

          static PyObject *t_ATNConfig_get__outerContextDepth(t_ATNConfig *self, void *data);
          static PyObject *t_ATNConfig_get__precedenceFilterSuppressed(t_ATNConfig *self, void *data);
          static int t_ATNConfig_set__precedenceFilterSuppressed(t_ATNConfig *self, PyObject *arg, void *data);
          static PyGetSetDef t_ATNConfig__fields_[] = {
            DECLARE_GET_FIELD(t_ATNConfig, alt),
            DECLARE_GETSET_FIELD(t_ATNConfig, context),
            DECLARE_GETSET_FIELD(t_ATNConfig, reachesIntoOuterContext),
            DECLARE_GET_FIELD(t_ATNConfig, semanticContext),
            DECLARE_GET_FIELD(t_ATNConfig, state),
            DECLARE_GET_FIELD(t_ATNConfig, outerContextDepth),
            DECLARE_GETSET_FIELD(t_ATNConfig, precedenceFilterSuppressed),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ATNConfig__methods_[] = {
            DECLARE_METHOD(t_ATNConfig, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNConfig, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNConfig, equals, METH_VARARGS),
            DECLARE_METHOD(t_ATNConfig, getOuterContextDepth, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfig, hashCode, METH_VARARGS),
            DECLARE_METHOD(t_ATNConfig, isPrecedenceFilterSuppressed, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfig, setPrecedenceFilterSuppressed, METH_O),
            DECLARE_METHOD(t_ATNConfig, toString, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ATNConfig)[] = {
            { Py_tp_methods, t_ATNConfig__methods_ },
            { Py_tp_init, (void *) t_ATNConfig_init_ },
            { Py_tp_getset, t_ATNConfig__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ATNConfig)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(ATNConfig, t_ATNConfig, ATNConfig);

          void t_ATNConfig::install(PyObject *module)
          {
            installType(&PY_TYPE(ATNConfig), &PY_TYPE_DEF(ATNConfig), module, "ATNConfig", 0);
          }

          void t_ATNConfig::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfig), "class_", make_descriptor(ATNConfig::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfig), "wrapfn_", make_descriptor(t_ATNConfig::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfig), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_ATNConfig_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ATNConfig::initializeClass, 1)))
              return NULL;
            return t_ATNConfig::wrap_Object(ATNConfig(((t_ATNConfig *) arg)->object.this$));
          }
          static PyObject *t_ATNConfig_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ATNConfig::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ATNConfig_init_(t_ATNConfig *self, PyObject *args, PyObject *kwds)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 2:
              {
                ATNConfig a0((jobject) NULL);
                ::org::antlr::v4::runtime::atn::ATNState a1((jobject) NULL);
                ATNConfig object((jobject) NULL);

                if (!parseArgs(args, "kk", ATNConfig::initializeClass, ::org::antlr::v4::runtime::atn::ATNState::initializeClass, &a0, &a1))
                {
                  INT_CALL(object = ATNConfig(a0, a1));
                  self->object = object;
                  break;
                }
              }
              {
                ATNConfig a0((jobject) NULL);
                ::org::antlr::v4::runtime::atn::SemanticContext a1((jobject) NULL);
                ATNConfig object((jobject) NULL);

                if (!parseArgs(args, "kk", ATNConfig::initializeClass, ::org::antlr::v4::runtime::atn::SemanticContext::initializeClass, &a0, &a1))
                {
                  INT_CALL(object = ATNConfig(a0, a1));
                  self->object = object;
                  break;
                }
              }
              goto err;
             case 3:
              {
                ATNConfig a0((jobject) NULL);
                ::org::antlr::v4::runtime::atn::ATNState a1((jobject) NULL);
                ::org::antlr::v4::runtime::atn::PredictionContext a2((jobject) NULL);
                ATNConfig object((jobject) NULL);

                if (!parseArgs(args, "kkk", ATNConfig::initializeClass, ::org::antlr::v4::runtime::atn::ATNState::initializeClass, ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, &a0, &a1, &a2))
                {
                  INT_CALL(object = ATNConfig(a0, a1, a2));
                  self->object = object;
                  break;
                }
              }
              {
                ATNConfig a0((jobject) NULL);
                ::org::antlr::v4::runtime::atn::ATNState a1((jobject) NULL);
                ::org::antlr::v4::runtime::atn::SemanticContext a2((jobject) NULL);
                ATNConfig object((jobject) NULL);

                if (!parseArgs(args, "kkk", ATNConfig::initializeClass, ::org::antlr::v4::runtime::atn::ATNState::initializeClass, ::org::antlr::v4::runtime::atn::SemanticContext::initializeClass, &a0, &a1, &a2))
                {
                  INT_CALL(object = ATNConfig(a0, a1, a2));
                  self->object = object;
                  break;
                }
              }
              {
                ::org::antlr::v4::runtime::atn::ATNState a0((jobject) NULL);
                jint a1;
                ::org::antlr::v4::runtime::atn::PredictionContext a2((jobject) NULL);
                ATNConfig object((jobject) NULL);

                if (!parseArgs(args, "kIk", ::org::antlr::v4::runtime::atn::ATNState::initializeClass, ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, &a0, &a1, &a2))
                {
                  INT_CALL(object = ATNConfig(a0, a1, a2));
                  self->object = object;
                  break;
                }
              }
              goto err;
             case 4:
              {
                ATNConfig a0((jobject) NULL);
                ::org::antlr::v4::runtime::atn::ATNState a1((jobject) NULL);
                ::org::antlr::v4::runtime::atn::PredictionContext a2((jobject) NULL);
                ::org::antlr::v4::runtime::atn::SemanticContext a3((jobject) NULL);
                ATNConfig object((jobject) NULL);

                if (!parseArgs(args, "kkkk", ATNConfig::initializeClass, ::org::antlr::v4::runtime::atn::ATNState::initializeClass, ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, ::org::antlr::v4::runtime::atn::SemanticContext::initializeClass, &a0, &a1, &a2, &a3))
                {
                  INT_CALL(object = ATNConfig(a0, a1, a2, a3));
                  self->object = object;
                  break;
                }
              }
              {
                ::org::antlr::v4::runtime::atn::ATNState a0((jobject) NULL);
                jint a1;
                ::org::antlr::v4::runtime::atn::PredictionContext a2((jobject) NULL);
                ::org::antlr::v4::runtime::atn::SemanticContext a3((jobject) NULL);
                ATNConfig object((jobject) NULL);

                if (!parseArgs(args, "kIkk", ::org::antlr::v4::runtime::atn::ATNState::initializeClass, ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, ::org::antlr::v4::runtime::atn::SemanticContext::initializeClass, &a0, &a1, &a2, &a3))
                {
                  INT_CALL(object = ATNConfig(a0, a1, a2, a3));
                  self->object = object;
                  break;
                }
              }
             default:
             err:
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_ATNConfig_equals(t_ATNConfig *self, PyObject *args)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 1:
              {
                ATNConfig a0((jobject) NULL);
                jboolean result;

                if (!parseArgs(args, "k", ATNConfig::initializeClass, &a0))
                {
                  OBJ_CALL(result = self->object.equals(a0));
                  Py_RETURN_BOOL(result);
                }
              }
              {
                ::java::lang::Object a0((jobject) NULL);
                jboolean result;

                if (!parseArgs(args, "o", &a0))
                {
                  OBJ_CALL(result = self->object.equals(a0));
                  Py_RETURN_BOOL(result);
                }
              }
            }

            return callSuper(PY_TYPE(ATNConfig), (PyObject *) self, "equals", args, 2);
          }

          static PyObject *t_ATNConfig_getOuterContextDepth(t_ATNConfig *self)
          {
            jint result;
            OBJ_CALL(result = self->object.getOuterContextDepth());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_ATNConfig_hashCode(t_ATNConfig *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.hashCode());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(ATNConfig), (PyObject *) self, "hashCode", args, 2);
          }

          static PyObject *t_ATNConfig_isPrecedenceFilterSuppressed(t_ATNConfig *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.isPrecedenceFilterSuppressed());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_ATNConfig_setPrecedenceFilterSuppressed(t_ATNConfig *self, PyObject *arg)
          {
            jboolean a0;

            if (!parseArg(arg, "Z", &a0))
            {
              OBJ_CALL(self->object.setPrecedenceFilterSuppressed(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "setPrecedenceFilterSuppressed", arg);
            return NULL;
          }

          static PyObject *t_ATNConfig_toString(t_ATNConfig *self, PyObject *args)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 0:
              {
                ::java::lang::String result((jobject) NULL);
                OBJ_CALL(result = self->object.toString());
                return j2p(result);
              }
              break;
             case 2:
              {
                ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
                PyTypeObject **p0;
                jboolean a1;
                ::java::lang::String result((jobject) NULL);

                if (!parseArgs(args, "KZ", ::org::antlr::v4::runtime::Recognizer::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a1))
                {
                  OBJ_CALL(result = self->object.toString(a0, a1));
                  return j2p(result);
                }
              }
            }

            return callSuper(PY_TYPE(ATNConfig), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_ATNConfig_get__alt(t_ATNConfig *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_alt());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_ATNConfig_get__context(t_ATNConfig *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::PredictionContext value((jobject) NULL);
            OBJ_CALL(value = self->object._get_context());
            return ::org::antlr::v4::runtime::atn::t_PredictionContext::wrap_Object(value);
          }
          static int t_ATNConfig_set__context(t_ATNConfig *self, PyObject *arg, void *data)
          {
            ::org::antlr::v4::runtime::atn::PredictionContext value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, &value))
            {
              INT_CALL(self->object._set_context(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "context", arg);
            return -1;
          }

          static PyObject *t_ATNConfig_get__reachesIntoOuterContext(t_ATNConfig *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_reachesIntoOuterContext());
            return PyLong_FromLong((long) value);
          }
          static int t_ATNConfig_set__reachesIntoOuterContext(t_ATNConfig *self, PyObject *arg, void *data)
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object._set_reachesIntoOuterContext(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "reachesIntoOuterContext", arg);
            return -1;
          }

          static PyObject *t_ATNConfig_get__semanticContext(t_ATNConfig *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::SemanticContext value((jobject) NULL);
            OBJ_CALL(value = self->object._get_semanticContext());
            return ::org::antlr::v4::runtime::atn::t_SemanticContext::wrap_Object(value);
          }

          static PyObject *t_ATNConfig_get__state(t_ATNConfig *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATNState value((jobject) NULL);
            OBJ_CALL(value = self->object._get_state());
            return ::org::antlr::v4::runtime::atn::t_ATNState::wrap_Object(value);
          }

          static PyObject *t_ATNConfig_get__outerContextDepth(t_ATNConfig *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getOuterContextDepth());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_ATNConfig_get__precedenceFilterSuppressed(t_ATNConfig *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isPrecedenceFilterSuppressed());
            Py_RETURN_BOOL(value);
          }
          static int t_ATNConfig_set__precedenceFilterSuppressed(t_ATNConfig *self, PyObject *arg, void *data)
          {
            {
              jboolean value;
              if (!parseArg(arg, "Z", &value))
              {
                INT_CALL(self->object.setPrecedenceFilterSuppressed(value));
                return 0;
              }
            }
            PyErr_SetArgsError((PyObject *) self, "precedenceFilterSuppressed", arg);
            return -1;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Locale$FilteringMode.h"
#include "java/lang/String.h"
#include "java/util/Locale$FilteringMode.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Locale$FilteringMode::class$ = NULL;
    jmethodID *Locale$FilteringMode::mids$ = NULL;
    bool Locale$FilteringMode::live$ = false;
    Locale$FilteringMode *Locale$FilteringMode::AUTOSELECT_FILTERING = NULL;
    Locale$FilteringMode *Locale$FilteringMode::EXTENDED_FILTERING = NULL;
    Locale$FilteringMode *Locale$FilteringMode::IGNORE_EXTENDED_RANGES = NULL;
    Locale$FilteringMode *Locale$FilteringMode::MAP_EXTENDED_RANGES = NULL;
    Locale$FilteringMode *Locale$FilteringMode::REJECT_EXTENDED_RANGES = NULL;

    jclass Locale$FilteringMode::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Locale$FilteringMode");

        mids$ = new jmethodID[max_mid];
        mids$[mid_valueOf_c4216e3f11d8af3f] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Ljava/util/Locale$FilteringMode;");
        mids$[mid_values_e69d47411c63095b] = env->getStaticMethodID(cls, "values", "()[Ljava/util/Locale$FilteringMode;");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        AUTOSELECT_FILTERING = new Locale$FilteringMode(env->getStaticObjectField(cls, "AUTOSELECT_FILTERING", "Ljava/util/Locale$FilteringMode;"));
        EXTENDED_FILTERING = new Locale$FilteringMode(env->getStaticObjectField(cls, "EXTENDED_FILTERING", "Ljava/util/Locale$FilteringMode;"));
        IGNORE_EXTENDED_RANGES = new Locale$FilteringMode(env->getStaticObjectField(cls, "IGNORE_EXTENDED_RANGES", "Ljava/util/Locale$FilteringMode;"));
        MAP_EXTENDED_RANGES = new Locale$FilteringMode(env->getStaticObjectField(cls, "MAP_EXTENDED_RANGES", "Ljava/util/Locale$FilteringMode;"));
        REJECT_EXTENDED_RANGES = new Locale$FilteringMode(env->getStaticObjectField(cls, "REJECT_EXTENDED_RANGES", "Ljava/util/Locale$FilteringMode;"));
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Locale$FilteringMode Locale$FilteringMode::valueOf(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Locale$FilteringMode(env->callStaticObjectMethod(cls, mids$[mid_valueOf_c4216e3f11d8af3f], a0.this$));
    }

    JArray< Locale$FilteringMode > Locale$FilteringMode::values()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< Locale$FilteringMode >(env->callStaticObjectMethod(cls, mids$[mid_values_e69d47411c63095b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Locale$FilteringMode_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Locale$FilteringMode_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Locale$FilteringMode_of_(t_Locale$FilteringMode *self, PyObject *args);
    static PyObject *t_Locale$FilteringMode_valueOf(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale$FilteringMode_values(PyTypeObject *type);
    static PyObject *t_Locale$FilteringMode_get__parameters_(t_Locale$FilteringMode *self, void *data);
    static PyGetSetDef t_Locale$FilteringMode__fields_[] = {
      DECLARE_GET_FIELD(t_Locale$FilteringMode, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Locale$FilteringMode__methods_[] = {
      DECLARE_METHOD(t_Locale$FilteringMode, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Locale$FilteringMode, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Locale$FilteringMode, of_, METH_VARARGS),
      DECLARE_METHOD(t_Locale$FilteringMode, valueOf, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale$FilteringMode, values, METH_NOARGS | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Locale$FilteringMode)[] = {
      { Py_tp_methods, t_Locale$FilteringMode__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Locale$FilteringMode__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Locale$FilteringMode)[] = {
      &PY_TYPE_DEF(::java::lang::Enum),
      NULL
    };

    DEFINE_TYPE(Locale$FilteringMode, t_Locale$FilteringMode, Locale$FilteringMode);
    PyObject *t_Locale$FilteringMode::wrap_Object(const Locale$FilteringMode& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Locale$FilteringMode::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Locale$FilteringMode *self = (t_Locale$FilteringMode *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Locale$FilteringMode::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Locale$FilteringMode::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Locale$FilteringMode *self = (t_Locale$FilteringMode *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Locale$FilteringMode::install(PyObject *module)
    {
      installType(&PY_TYPE(Locale$FilteringMode), &PY_TYPE_DEF(Locale$FilteringMode), module, "Locale$FilteringMode", 0);
    }

    void t_Locale$FilteringMode::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$FilteringMode), "class_", make_descriptor(Locale$FilteringMode::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$FilteringMode), "wrapfn_", make_descriptor(t_Locale$FilteringMode::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$FilteringMode), "boxfn_", make_descriptor(boxObject));
      env->getClass(Locale$FilteringMode::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$FilteringMode), "AUTOSELECT_FILTERING", make_descriptor(t_Locale$FilteringMode::wrap_Object(*Locale$FilteringMode::AUTOSELECT_FILTERING)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$FilteringMode), "EXTENDED_FILTERING", make_descriptor(t_Locale$FilteringMode::wrap_Object(*Locale$FilteringMode::EXTENDED_FILTERING)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$FilteringMode), "IGNORE_EXTENDED_RANGES", make_descriptor(t_Locale$FilteringMode::wrap_Object(*Locale$FilteringMode::IGNORE_EXTENDED_RANGES)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$FilteringMode), "MAP_EXTENDED_RANGES", make_descriptor(t_Locale$FilteringMode::wrap_Object(*Locale$FilteringMode::MAP_EXTENDED_RANGES)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$FilteringMode), "REJECT_EXTENDED_RANGES", make_descriptor(t_Locale$FilteringMode::wrap_Object(*Locale$FilteringMode::REJECT_EXTENDED_RANGES)));
    }

    static PyObject *t_Locale$FilteringMode_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Locale$FilteringMode::initializeClass, 1)))
        return NULL;
      return t_Locale$FilteringMode::wrap_Object(Locale$FilteringMode(((t_Locale$FilteringMode *) arg)->object.this$));
    }
    static PyObject *t_Locale$FilteringMode_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Locale$FilteringMode::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Locale$FilteringMode_of_(t_Locale$FilteringMode *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Locale$FilteringMode_valueOf(PyTypeObject *type, PyObject *args)
    {
      ::java::lang::String a0((jobject) NULL);
      Locale$FilteringMode result((jobject) NULL);

      if (!parseArgs(args, "s", &a0))
      {
        OBJ_CALL(result = ::java::util::Locale$FilteringMode::valueOf(a0));
        return t_Locale$FilteringMode::wrap_Object(result);
      }

      return callSuper(type, "valueOf", args, 2);
    }

    static PyObject *t_Locale$FilteringMode_values(PyTypeObject *type)
    {
      JArray< Locale$FilteringMode > result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Locale$FilteringMode::values());
      return JArray<jobject>(result.this$).wrap(t_Locale$FilteringMode::wrap_jobject);
    }
    static PyObject *t_Locale$FilteringMode_get__parameters_(t_Locale$FilteringMode *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/TokenFactory.h"
#include "org/antlr/v4/runtime/Token.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *TokenFactory::class$ = NULL;
        jmethodID *TokenFactory::mids$ = NULL;
        bool TokenFactory::live$ = false;

        jclass TokenFactory::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/TokenFactory");

            mids$ = new jmethodID[max_mid];
            mids$[mid_create_780b2fffd616e9e0] = env->getMethodID(cls, "create", "(ILjava/lang/String;)Lorg/antlr/v4/runtime/Token;");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        ::org::antlr::v4::runtime::Token TokenFactory::create(jint a0, const ::java::lang::String & a1) const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_create_780b2fffd616e9e0], a0, a1.this$));
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_TokenFactory_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_TokenFactory_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_TokenFactory_of_(t_TokenFactory *self, PyObject *args);
        static PyObject *t_TokenFactory_create(t_TokenFactory *self, PyObject *args);
        static PyObject *t_TokenFactory_get__parameters_(t_TokenFactory *self, void *data);
        static PyGetSetDef t_TokenFactory__fields_[] = {
          DECLARE_GET_FIELD(t_TokenFactory, parameters_),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_TokenFactory__methods_[] = {
          DECLARE_METHOD(t_TokenFactory, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_TokenFactory, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_TokenFactory, of_, METH_VARARGS),
          DECLARE_METHOD(t_TokenFactory, create, METH_VARARGS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(TokenFactory)[] = {
          { Py_tp_methods, t_TokenFactory__methods_ },
          { Py_tp_init, (void *) abstract_init },
          { Py_tp_getset, t_TokenFactory__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(TokenFactory)[] = {
          &PY_TYPE_DEF(::java::lang::Object),
          NULL
        };

        DEFINE_TYPE(TokenFactory, t_TokenFactory, TokenFactory);
        PyObject *t_TokenFactory::wrap_Object(const TokenFactory& object, PyTypeObject *p0)
        {
          PyObject *obj = t_TokenFactory::wrap_Object(object);
          if (obj != NULL && obj != Py_None)
          {
            t_TokenFactory *self = (t_TokenFactory *) obj;
            self->parameters[0] = p0;
          }
          return obj;
        }

        PyObject *t_TokenFactory::wrap_jobject(const jobject& object, PyTypeObject *p0)
        {
          PyObject *obj = t_TokenFactory::wrap_jobject(object);
          if (obj != NULL && obj != Py_None)
          {
            t_TokenFactory *self = (t_TokenFactory *) obj;
            self->parameters[0] = p0;
          }
          return obj;
        }

        void t_TokenFactory::install(PyObject *module)
        {
          installType(&PY_TYPE(TokenFactory), &PY_TYPE_DEF(TokenFactory), module, "TokenFactory", 0);
        }

        void t_TokenFactory::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(TokenFactory), "class_", make_descriptor(TokenFactory::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(TokenFactory), "wrapfn_", make_descriptor(t_TokenFactory::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(TokenFactory), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_TokenFactory_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, TokenFactory::initializeClass, 1)))
            return NULL;
          return t_TokenFactory::wrap_Object(TokenFactory(((t_TokenFactory *) arg)->object.this$));
        }
        static PyObject *t_TokenFactory_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, TokenFactory::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_TokenFactory_of_(t_TokenFactory *self, PyObject *args)
        {
          if (!parseArg(args, "T", 1, &(self->parameters)))
            Py_RETURN_SELF;
          return PyErr_SetArgsError((PyObject *) self, "of_", args);
        }

        static PyObject *t_TokenFactory_create(t_TokenFactory *self, PyObject *args)
        {
          jint a0;
          ::java::lang::String a1((jobject) NULL);
          ::org::antlr::v4::runtime::Token result((jobject) NULL);

          if (!parseArgs(args, "Is", &a0, &a1))
          {
            OBJ_CALL(result = self->object.create(a0, a1));
            return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
          }

          PyErr_SetArgsError((PyObject *) self, "create", args);
          return NULL;
        }
        static PyObject *t_TokenFactory_get__parameters_(t_TokenFactory *self, void *data)
        {
          return typeParameters(self->parameters, sizeof(self->parameters));
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/LongConsumer.h"
#include "java/util/function/LongConsumer.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *LongConsumer::class$ = NULL;
      jmethodID *LongConsumer::mids$ = NULL;
      bool LongConsumer::live$ = false;

      jclass LongConsumer::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/LongConsumer");

          mids$ = new jmethodID[max_mid];
          mids$[mid_accept_9c778c9bce6694df] = env->getMethodID(cls, "accept", "(J)V");
          mids$[mid_andThen_d98eb39aab723c90] = env->getMethodID(cls, "andThen", "(Ljava/util/function/LongConsumer;)Ljava/util/function/LongConsumer;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      void LongConsumer::accept(jlong a0) const
      {
        env->callVoidMethod(this$, mids$[mid_accept_9c778c9bce6694df], a0);
      }

      LongConsumer LongConsumer::andThen(const LongConsumer & a0) const
      {
        return LongConsumer(env->callObjectMethod(this$, mids$[mid_andThen_d98eb39aab723c90], a0.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_LongConsumer_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_LongConsumer_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_LongConsumer_accept(t_LongConsumer *self, PyObject *arg);
      static PyObject *t_LongConsumer_andThen(t_LongConsumer *self, PyObject *arg);

      static PyMethodDef t_LongConsumer__methods_[] = {
        DECLARE_METHOD(t_LongConsumer, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_LongConsumer, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_LongConsumer, accept, METH_O),
        DECLARE_METHOD(t_LongConsumer, andThen, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(LongConsumer)[] = {
        { Py_tp_methods, t_LongConsumer__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(LongConsumer)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(LongConsumer, t_LongConsumer, LongConsumer);

      void t_LongConsumer::install(PyObject *module)
      {
        installType(&PY_TYPE(LongConsumer), &PY_TYPE_DEF(LongConsumer), module, "LongConsumer", 0);
      }

      void t_LongConsumer::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(LongConsumer), "class_", make_descriptor(LongConsumer::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(LongConsumer), "wrapfn_", make_descriptor(t_LongConsumer::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(LongConsumer), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_LongConsumer_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, LongConsumer::initializeClass, 1)))
          return NULL;
        return t_LongConsumer::wrap_Object(LongConsumer(((t_LongConsumer *) arg)->object.this$));
      }
      static PyObject *t_LongConsumer_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, LongConsumer::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_LongConsumer_accept(t_LongConsumer *self, PyObject *arg)
      {
        jlong a0;

        if (!parseArg(arg, "J", &a0))
        {
          OBJ_CALL(self->object.accept(a0));
          Py_RETURN_NONE;
        }

        PyErr_SetArgsError((PyObject *) self, "accept", arg);
        return NULL;
      }

      static PyObject *t_LongConsumer_andThen(t_LongConsumer *self, PyObject *arg)
      {
        LongConsumer a0((jobject) NULL);
        LongConsumer result((jobject) NULL);

        if (!parseArg(arg, "k", LongConsumer::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.andThen(a0));
          return t_LongConsumer::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "andThen", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Spliterator$OfPrimitive.h"
#include "java/util/Spliterator$OfPrimitive.h"
#include "java/lang/Object.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Spliterator$OfPrimitive::class$ = NULL;
    jmethodID *Spliterator$OfPrimitive::mids$ = NULL;
    bool Spliterator$OfPrimitive::live$ = false;

    jclass Spliterator$OfPrimitive::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Spliterator$OfPrimitive");

        mids$ = new jmethodID[max_mid];
        mids$[mid_forEachRemaining_d20f626183f72f7d] = env->getMethodID(cls, "forEachRemaining", "(Ljava/lang/Object;)V");
        mids$[mid_tryAdvance_8b72f2dcdde6fd1d] = env->getMethodID(cls, "tryAdvance", "(Ljava/lang/Object;)Z");
        mids$[mid_trySplit_628cfe9eaf607b7d] = env->getMethodID(cls, "trySplit", "()Ljava/util/Spliterator$OfPrimitive;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void Spliterator$OfPrimitive::forEachRemaining(const ::java::lang::Object & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEachRemaining_d20f626183f72f7d], a0.this$);
    }

    jboolean Spliterator$OfPrimitive::tryAdvance(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_tryAdvance_8b72f2dcdde6fd1d], a0.this$);
    }

    Spliterator$OfPrimitive Spliterator$OfPrimitive::trySplit() const
    {
      return Spliterator$OfPrimitive(env->callObjectMethod(this$, mids$[mid_trySplit_628cfe9eaf607b7d]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Spliterator$OfPrimitive_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator$OfPrimitive_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Spliterator$OfPrimitive_of_(t_Spliterator$OfPrimitive *self, PyObject *args);
    static PyObject *t_Spliterator$OfPrimitive_forEachRemaining(t_Spliterator$OfPrimitive *self, PyObject *args);
    static PyObject *t_Spliterator$OfPrimitive_tryAdvance(t_Spliterator$OfPrimitive *self, PyObject *args);
    static PyObject *t_Spliterator$OfPrimitive_trySplit(t_Spliterator$OfPrimitive *self, PyObject *args);
    static PyObject *t_Spliterator$OfPrimitive_get__parameters_(t_Spliterator$OfPrimitive *self, void *data);
    static PyGetSetDef t_Spliterator$OfPrimitive__fields_[] = {
      DECLARE_GET_FIELD(t_Spliterator$OfPrimitive, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Spliterator$OfPrimitive__methods_[] = {
      DECLARE_METHOD(t_Spliterator$OfPrimitive, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator$OfPrimitive, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Spliterator$OfPrimitive, of_, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfPrimitive, forEachRemaining, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfPrimitive, tryAdvance, METH_VARARGS),
      DECLARE_METHOD(t_Spliterator$OfPrimitive, trySplit, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Spliterator$OfPrimitive)[] = {
      { Py_tp_methods, t_Spliterator$OfPrimitive__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Spliterator$OfPrimitive__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Spliterator$OfPrimitive)[] = {
      &PY_TYPE_DEF(::java::util::Spliterator),
      NULL
    };

    DEFINE_TYPE(Spliterator$OfPrimitive, t_Spliterator$OfPrimitive, Spliterator$OfPrimitive);
    PyObject *t_Spliterator$OfPrimitive::wrap_Object(const Spliterator$OfPrimitive& object, PyTypeObject *p0, PyTypeObject *p1, PyTypeObject *p2)
    {
      PyObject *obj = t_Spliterator$OfPrimitive::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator$OfPrimitive *self = (t_Spliterator$OfPrimitive *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
        self->parameters[2] = p2;
      }
      return obj;
    }

    PyObject *t_Spliterator$OfPrimitive::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1, PyTypeObject *p2)
    {
      PyObject *obj = t_Spliterator$OfPrimitive::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Spliterator$OfPrimitive *self = (t_Spliterator$OfPrimitive *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
        self->parameters[2] = p2;
      }
      return obj;
    }

    void t_Spliterator$OfPrimitive::install(PyObject *module)
    {
      installType(&PY_TYPE(Spliterator$OfPrimitive), &PY_TYPE_DEF(Spliterator$OfPrimitive), module, "Spliterator$OfPrimitive", 0);
    }

    void t_Spliterator$OfPrimitive::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfPrimitive), "class_", make_descriptor(Spliterator$OfPrimitive::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfPrimitive), "wrapfn_", make_descriptor(t_Spliterator$OfPrimitive::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Spliterator$OfPrimitive), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_Spliterator$OfPrimitive_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Spliterator$OfPrimitive::initializeClass, 1)))
        return NULL;
      return t_Spliterator$OfPrimitive::wrap_Object(Spliterator$OfPrimitive(((t_Spliterator$OfPrimitive *) arg)->object.this$));
    }
    static PyObject *t_Spliterator$OfPrimitive_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Spliterator$OfPrimitive::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Spliterator$OfPrimitive_of_(t_Spliterator$OfPrimitive *self, PyObject *args)
    {
      if (!parseArg(args, "T", 3, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Spliterator$OfPrimitive_forEachRemaining(t_Spliterator$OfPrimitive *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);

      if (!parseArgs(args, "O", self->parameters[1], &a0))
      {
        OBJ_CALL(self->object.forEachRemaining(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(Spliterator$OfPrimitive), (PyObject *) self, "forEachRemaining", args, 2);
    }

    static PyObject *t_Spliterator$OfPrimitive_tryAdvance(t_Spliterator$OfPrimitive *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "O", self->parameters[1], &a0))
      {
        OBJ_CALL(result = self->object.tryAdvance(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(Spliterator$OfPrimitive), (PyObject *) self, "tryAdvance", args, 2);
    }

    static PyObject *t_Spliterator$OfPrimitive_trySplit(t_Spliterator$OfPrimitive *self, PyObject *args)
    {
      Spliterator$OfPrimitive result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.trySplit());
        return self->parameters[2] != NULL ? wrapType(self->parameters[2], result.this$) : t_Spliterator$OfPrimitive::wrap_Object(result);
      }

      return callSuper(PY_TYPE(Spliterator$OfPrimitive), (PyObject *) self, "trySplit", args, 2);
    }
    static PyObject *t_Spliterator$OfPrimitive_get__parameters_(t_Spliterator$OfPrimitive *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/PathMatcher.h"
#include "java/nio/file/Path.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *PathMatcher::class$ = NULL;
      jmethodID *PathMatcher::mids$ = NULL;
      bool PathMatcher::live$ = false;

      jclass PathMatcher::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/PathMatcher");

          mids$ = new jmethodID[max_mid];
          mids$[mid_matches_64eb4236a3fd11dc] = env->getMethodID(cls, "matches", "(Ljava/nio/file/Path;)Z");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jboolean PathMatcher::matches(const ::java::nio::file::Path & a0) const
      {
        return env->callBooleanMethod(this$, mids$[mid_matches_64eb4236a3fd11dc], a0.this$);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_PathMatcher_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_PathMatcher_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_PathMatcher_matches(t_PathMatcher *self, PyObject *arg);

      static PyMethodDef t_PathMatcher__methods_[] = {
        DECLARE_METHOD(t_PathMatcher, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_PathMatcher, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_PathMatcher, matches, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(PathMatcher)[] = {
        { Py_tp_methods, t_PathMatcher__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(PathMatcher)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(PathMatcher, t_PathMatcher, PathMatcher);

      void t_PathMatcher::install(PyObject *module)
      {
        installType(&PY_TYPE(PathMatcher), &PY_TYPE_DEF(PathMatcher), module, "PathMatcher", 0);
      }

      void t_PathMatcher::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(PathMatcher), "class_", make_descriptor(PathMatcher::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(PathMatcher), "wrapfn_", make_descriptor(t_PathMatcher::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(PathMatcher), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_PathMatcher_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, PathMatcher::initializeClass, 1)))
          return NULL;
        return t_PathMatcher::wrap_Object(PathMatcher(((t_PathMatcher *) arg)->object.this$));
      }
      static PyObject *t_PathMatcher_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, PathMatcher::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_PathMatcher_matches(t_PathMatcher *self, PyObject *arg)
      {
        ::java::nio::file::Path a0((jobject) NULL);
        jboolean result;

        if (!parseArg(arg, "k", ::java::nio::file::Path::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.matches(a0));
          Py_RETURN_BOOL(result);
        }

        PyErr_SetArgsError((PyObject *) self, "matches", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/ANTLRErrorStrategy.h"
#include "org/antlr/v4/runtime/Token.h"
#include "org/antlr/v4/runtime/RecognitionException.h"
#include "org/antlr/v4/runtime/Parser.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *ANTLRErrorStrategy::class$ = NULL;
        jmethodID *ANTLRErrorStrategy::mids$ = NULL;
        bool ANTLRErrorStrategy::live$ = false;

        jclass ANTLRErrorStrategy::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/ANTLRErrorStrategy");

            mids$ = new jmethodID[max_mid];
            mids$[mid_inErrorRecoveryMode_83682fc0fd54c55f] = env->getMethodID(cls, "inErrorRecoveryMode", "(Lorg/antlr/v4/runtime/Parser;)Z");
            mids$[mid_recover_9f3a2f793dca973d] = env->getMethodID(cls, "recover", "(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/RecognitionException;)V");
            mids$[mid_recoverInline_46b7e0a8a11026f9] = env->getMethodID(cls, "recoverInline", "(Lorg/antlr/v4/runtime/Parser;)Lorg/antlr/v4/runtime/Token;");
            mids$[mid_reportError_9f3a2f793dca973d] = env->getMethodID(cls, "reportError", "(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/RecognitionException;)V");
            mids$[mid_reportMatch_32103c89317c9cb1] = env->getMethodID(cls, "reportMatch", "(Lorg/antlr/v4/runtime/Parser;)V");
            mids$[mid_reset_32103c89317c9cb1] = env->getMethodID(cls, "reset", "(Lorg/antlr/v4/runtime/Parser;)V");
            mids$[mid_sync_32103c89317c9cb1] = env->getMethodID(cls, "sync", "(Lorg/antlr/v4/runtime/Parser;)V");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        jboolean ANTLRErrorStrategy::inErrorRecoveryMode(const ::org::antlr::v4::runtime::Parser & a0) const
        {
          return env->callBooleanMethod(this$, mids$[mid_inErrorRecoveryMode_83682fc0fd54c55f], a0.this$);
        }

        void ANTLRErrorStrategy::recover(const ::org::antlr::v4::runtime::Parser & a0, const ::org::antlr::v4::runtime::RecognitionException & a1) const
        {
          env->callVoidMethod(this$, mids$[mid_recover_9f3a2f793dca973d], a0.this$, a1.this$);
        }

        ::org::antlr::v4::runtime::Token ANTLRErrorStrategy::recoverInline(const ::org::antlr::v4::runtime::Parser & a0) const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_recoverInline_46b7e0a8a11026f9], a0.this$));
        }

        void ANTLRErrorStrategy::reportError(const ::org::antlr::v4::runtime::Parser & a0, const ::org::antlr::v4::runtime::RecognitionException & a1) const
        {
          env->callVoidMethod(this$, mids$[mid_reportError_9f3a2f793dca973d], a0.this$, a1.this$);
        }

        void ANTLRErrorStrategy::reportMatch(const ::org::antlr::v4::runtime::Parser & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_reportMatch_32103c89317c9cb1], a0.this$);
        }

        void ANTLRErrorStrategy::reset(const ::org::antlr::v4::runtime::Parser & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_reset_32103c89317c9cb1], a0.this$);
        }

        void ANTLRErrorStrategy::sync(const ::org::antlr::v4::runtime::Parser & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_sync_32103c89317c9cb1], a0.this$);
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_ANTLRErrorStrategy_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_ANTLRErrorStrategy_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_ANTLRErrorStrategy_inErrorRecoveryMode(t_ANTLRErrorStrategy *self, PyObject *arg);
        static PyObject *t_ANTLRErrorStrategy_recover(t_ANTLRErrorStrategy *self, PyObject *args);
        static PyObject *t_ANTLRErrorStrategy_recoverInline(t_ANTLRErrorStrategy *self, PyObject *arg);
        static PyObject *t_ANTLRErrorStrategy_reportError(t_ANTLRErrorStrategy *self, PyObject *args);
        static PyObject *t_ANTLRErrorStrategy_reportMatch(t_ANTLRErrorStrategy *self, PyObject *arg);
        static PyObject *t_ANTLRErrorStrategy_reset(t_ANTLRErrorStrategy *self, PyObject *arg);
        static PyObject *t_ANTLRErrorStrategy_sync(t_ANTLRErrorStrategy *self, PyObject *arg);

        static PyMethodDef t_ANTLRErrorStrategy__methods_[] = {
          DECLARE_METHOD(t_ANTLRErrorStrategy, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_ANTLRErrorStrategy, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_ANTLRErrorStrategy, inErrorRecoveryMode, METH_O),
          DECLARE_METHOD(t_ANTLRErrorStrategy, recover, METH_VARARGS),
          DECLARE_METHOD(t_ANTLRErrorStrategy, recoverInline, METH_O),
          DECLARE_METHOD(t_ANTLRErrorStrategy, reportError, METH_VARARGS),
          DECLARE_METHOD(t_ANTLRErrorStrategy, reportMatch, METH_O),
          DECLARE_METHOD(t_ANTLRErrorStrategy, reset, METH_O),
          DECLARE_METHOD(t_ANTLRErrorStrategy, sync, METH_O),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(ANTLRErrorStrategy)[] = {
          { Py_tp_methods, t_ANTLRErrorStrategy__methods_ },
          { Py_tp_init, (void *) abstract_init },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(ANTLRErrorStrategy)[] = {
          &PY_TYPE_DEF(::java::lang::Object),
          NULL
        };

        DEFINE_TYPE(ANTLRErrorStrategy, t_ANTLRErrorStrategy, ANTLRErrorStrategy);

        void t_ANTLRErrorStrategy::install(PyObject *module)
        {
          installType(&PY_TYPE(ANTLRErrorStrategy), &PY_TYPE_DEF(ANTLRErrorStrategy), module, "ANTLRErrorStrategy", 0);
        }

        void t_ANTLRErrorStrategy::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(ANTLRErrorStrategy), "class_", make_descriptor(ANTLRErrorStrategy::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(ANTLRErrorStrategy), "wrapfn_", make_descriptor(t_ANTLRErrorStrategy::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(ANTLRErrorStrategy), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_ANTLRErrorStrategy_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, ANTLRErrorStrategy::initializeClass, 1)))
            return NULL;
          return t_ANTLRErrorStrategy::wrap_Object(ANTLRErrorStrategy(((t_ANTLRErrorStrategy *) arg)->object.this$));
        }
        static PyObject *t_ANTLRErrorStrategy_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, ANTLRErrorStrategy::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_ANTLRErrorStrategy_inErrorRecoveryMode(t_ANTLRErrorStrategy *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
          PyTypeObject **p0;
          jboolean result;

          if (!parseArg(arg, "K", ::org::antlr::v4::runtime::Parser::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_))
          {
            OBJ_CALL(result = self->object.inErrorRecoveryMode(a0));
            Py_RETURN_BOOL(result);
          }

          PyErr_SetArgsError((PyObject *) self, "inErrorRecoveryMode", arg);
          return NULL;
        }

        static PyObject *t_ANTLRErrorStrategy_recover(t_ANTLRErrorStrategy *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
          PyTypeObject **p0;
          ::org::antlr::v4::runtime::RecognitionException a1((jobject) NULL);

          if (!parseArgs(args, "Kk", ::org::antlr::v4::runtime::Parser::initializeClass, ::org::antlr::v4::runtime::RecognitionException::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_, &a1))
          {
            OBJ_CALL(self->object.recover(a0, a1));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "recover", args);
          return NULL;
        }

        static PyObject *t_ANTLRErrorStrategy_recoverInline(t_ANTLRErrorStrategy *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
          PyTypeObject **p0;
          ::org::antlr::v4::runtime::Token result((jobject) NULL);

          if (!parseArg(arg, "K", ::org::antlr::v4::runtime::Parser::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_))
          {
            OBJ_CALL(result = self->object.recoverInline(a0));
            return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
          }

          PyErr_SetArgsError((PyObject *) self, "recoverInline", arg);
          return NULL;
        }

        static PyObject *t_ANTLRErrorStrategy_reportError(t_ANTLRErrorStrategy *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
          PyTypeObject **p0;
          ::org::antlr::v4::runtime::RecognitionException a1((jobject) NULL);

          if (!parseArgs(args, "Kk", ::org::antlr::v4::runtime::Parser::initializeClass, ::org::antlr::v4::runtime::RecognitionException::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_, &a1))
          {
            OBJ_CALL(self->object.reportError(a0, a1));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "reportError", args);
          return NULL;
        }

        static PyObject *t_ANTLRErrorStrategy_reportMatch(t_ANTLRErrorStrategy *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArg(arg, "K", ::org::antlr::v4::runtime::Parser::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_))
          {
            OBJ_CALL(self->object.reportMatch(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "reportMatch", arg);
          return NULL;
        }

        static PyObject *t_ANTLRErrorStrategy_reset(t_ANTLRErrorStrategy *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArg(arg, "K", ::org::antlr::v4::runtime::Parser::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_))
          {
            OBJ_CALL(self->object.reset(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "reset", arg);
          return NULL;
        }

        static PyObject *t_ANTLRErrorStrategy_sync(t_ANTLRErrorStrategy *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArg(arg, "K", ::org::antlr::v4::runtime::Parser::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_))
          {
            OBJ_CALL(self->object.sync(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "sync", arg);
          return NULL;
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/FileVisitResult.h"
#include "java/nio/file/FileVisitResult.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *FileVisitResult::class$ = NULL;
      jmethodID *FileVisitResult::mids$ = NULL;
      bool FileVisitResult::live$ = false;
      FileVisitResult *FileVisitResult::CONTINUE = NULL;
      FileVisitResult *FileVisitResult::SKIP_SIBLINGS = NULL;
      FileVisitResult *FileVisitResult::SKIP_SUBTREE = NULL;
      FileVisitResult *FileVisitResult::TERMINATE = NULL;

      jclass FileVisitResult::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/FileVisitResult");

          mids$ = new jmethodID[max_mid];
          mids$[mid_valueOf_ce26279acada11a3] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Ljava/nio/file/FileVisitResult;");
          mids$[mid_values_d159229b551aa387] = env->getStaticMethodID(cls, "values", "()[Ljava/nio/file/FileVisitResult;");

          class$ = new ::java::lang::Class(cls);
          cls = (jclass) class$->this$;

          CONTINUE = new FileVisitResult(env->getStaticObjectField(cls, "CONTINUE", "Ljava/nio/file/FileVisitResult;"));
          SKIP_SIBLINGS = new FileVisitResult(env->getStaticObjectField(cls, "SKIP_SIBLINGS", "Ljava/nio/file/FileVisitResult;"));
          SKIP_SUBTREE = new FileVisitResult(env->getStaticObjectField(cls, "SKIP_SUBTREE", "Ljava/nio/file/FileVisitResult;"));
          TERMINATE = new FileVisitResult(env->getStaticObjectField(cls, "TERMINATE", "Ljava/nio/file/FileVisitResult;"));
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      FileVisitResult FileVisitResult::valueOf(const ::java::lang::String & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return FileVisitResult(env->callStaticObjectMethod(cls, mids$[mid_valueOf_ce26279acada11a3], a0.this$));
      }

      JArray< FileVisitResult > FileVisitResult::values()
      {
        jclass cls = env->getClass(initializeClass);
        return JArray< FileVisitResult >(env->callStaticObjectMethod(cls, mids$[mid_values_d159229b551aa387]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_FileVisitResult_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileVisitResult_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_FileVisitResult_of_(t_FileVisitResult *self, PyObject *args);
      static PyObject *t_FileVisitResult_valueOf(PyTypeObject *type, PyObject *args);
      static PyObject *t_FileVisitResult_values(PyTypeObject *type);
      static PyObject *t_FileVisitResult_get__parameters_(t_FileVisitResult *self, void *data);
      static PyGetSetDef t_FileVisitResult__fields_[] = {
        DECLARE_GET_FIELD(t_FileVisitResult, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_FileVisitResult__methods_[] = {
        DECLARE_METHOD(t_FileVisitResult, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileVisitResult, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_FileVisitResult, of_, METH_VARARGS),
        DECLARE_METHOD(t_FileVisitResult, valueOf, METH_VARARGS | METH_CLASS),
        DECLARE_METHOD(t_FileVisitResult, values, METH_NOARGS | METH_CLASS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(FileVisitResult)[] = {
        { Py_tp_methods, t_FileVisitResult__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_FileVisitResult__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(FileVisitResult)[] = {
        &PY_TYPE_DEF(::java::lang::Enum),
        NULL
      };

      DEFINE_TYPE(FileVisitResult, t_FileVisitResult, FileVisitResult);
      PyObject *t_FileVisitResult::wrap_Object(const FileVisitResult& object, PyTypeObject *p0)
      {
        PyObject *obj = t_FileVisitResult::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_FileVisitResult *self = (t_FileVisitResult *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_FileVisitResult::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_FileVisitResult::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_FileVisitResult *self = (t_FileVisitResult *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_FileVisitResult::install(PyObject *module)
      {
        installType(&PY_TYPE(FileVisitResult), &PY_TYPE_DEF(FileVisitResult), module, "FileVisitResult", 0);
      }

      void t_FileVisitResult::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitResult), "class_", make_descriptor(FileVisitResult::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitResult), "wrapfn_", make_descriptor(t_FileVisitResult::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitResult), "boxfn_", make_descriptor(boxObject));
        env->getClass(FileVisitResult::initializeClass);
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitResult), "CONTINUE", make_descriptor(t_FileVisitResult::wrap_Object(*FileVisitResult::CONTINUE)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitResult), "SKIP_SIBLINGS", make_descriptor(t_FileVisitResult::wrap_Object(*FileVisitResult::SKIP_SIBLINGS)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitResult), "SKIP_SUBTREE", make_descriptor(t_FileVisitResult::wrap_Object(*FileVisitResult::SKIP_SUBTREE)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(FileVisitResult), "TERMINATE", make_descriptor(t_FileVisitResult::wrap_Object(*FileVisitResult::TERMINATE)));
      }

      static PyObject *t_FileVisitResult_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, FileVisitResult::initializeClass, 1)))
          return NULL;
        return t_FileVisitResult::wrap_Object(FileVisitResult(((t_FileVisitResult *) arg)->object.this$));
      }
      static PyObject *t_FileVisitResult_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, FileVisitResult::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_FileVisitResult_of_(t_FileVisitResult *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_FileVisitResult_valueOf(PyTypeObject *type, PyObject *args)
      {
        ::java::lang::String a0((jobject) NULL);
        FileVisitResult result((jobject) NULL);

        if (!parseArgs(args, "s", &a0))
        {
          OBJ_CALL(result = ::java::nio::file::FileVisitResult::valueOf(a0));
          return t_FileVisitResult::wrap_Object(result);
        }

        return callSuper(type, "valueOf", args, 2);
      }

      static PyObject *t_FileVisitResult_values(PyTypeObject *type)
      {
        JArray< FileVisitResult > result((jobject) NULL);
        OBJ_CALL(result = ::java::nio::file::FileVisitResult::values());
        return JArray<jobject>(result.this$).wrap(t_FileVisitResult::wrap_jobject);
      }
      static PyObject *t_FileVisitResult_get__parameters_(t_FileVisitResult *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/nio/file/WatchEvent.h"
#include "java/nio/file/WatchEvent$Kind.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace nio {
    namespace file {

      ::java::lang::Class *WatchEvent::class$ = NULL;
      jmethodID *WatchEvent::mids$ = NULL;
      bool WatchEvent::live$ = false;

      jclass WatchEvent::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/nio/file/WatchEvent");

          mids$ = new jmethodID[max_mid];
          mids$[mid_context_d6bcd06f3102c4d9] = env->getMethodID(cls, "context", "()Ljava/lang/Object;");
          mids$[mid_count_9972fcc56b44e79d] = env->getMethodID(cls, "count", "()I");
          mids$[mid_kind_0fa2c070f5131065] = env->getMethodID(cls, "kind", "()Ljava/nio/file/WatchEvent$Kind;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      ::java::lang::Object WatchEvent::context() const
      {
        return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_context_d6bcd06f3102c4d9]));
      }

      jint WatchEvent::count() const
      {
        return env->callIntMethod(this$, mids$[mid_count_9972fcc56b44e79d]);
      }

      ::java::nio::file::WatchEvent$Kind WatchEvent::kind() const
      {
        return ::java::nio::file::WatchEvent$Kind(env->callObjectMethod(this$, mids$[mid_kind_0fa2c070f5131065]));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"
#include "java/nio/file/WatchEvent$Modifier.h"

namespace java {
  namespace nio {
    namespace file {
      static PyObject *t_WatchEvent_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchEvent_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_WatchEvent_of_(t_WatchEvent *self, PyObject *args);
      static PyObject *t_WatchEvent_context(t_WatchEvent *self);
      static PyObject *t_WatchEvent_count(t_WatchEvent *self);
      static PyObject *t_WatchEvent_kind(t_WatchEvent *self);
      static PyObject *t_WatchEvent_get__parameters_(t_WatchEvent *self, void *data);
      static PyGetSetDef t_WatchEvent__fields_[] = {
        DECLARE_GET_FIELD(t_WatchEvent, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_WatchEvent__methods_[] = {
        DECLARE_METHOD(t_WatchEvent, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchEvent, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_WatchEvent, of_, METH_VARARGS),
        DECLARE_METHOD(t_WatchEvent, context, METH_NOARGS),
        DECLARE_METHOD(t_WatchEvent, count, METH_NOARGS),
        DECLARE_METHOD(t_WatchEvent, kind, METH_NOARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(WatchEvent)[] = {
        { Py_tp_methods, t_WatchEvent__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_WatchEvent__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(WatchEvent)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(WatchEvent, t_WatchEvent, WatchEvent);
      PyObject *t_WatchEvent::wrap_Object(const WatchEvent& object, PyTypeObject *p0)
      {
        PyObject *obj = t_WatchEvent::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_WatchEvent *self = (t_WatchEvent *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_WatchEvent::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_WatchEvent::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_WatchEvent *self = (t_WatchEvent *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_WatchEvent::install(PyObject *module)
      {
        installType(&PY_TYPE(WatchEvent), &PY_TYPE_DEF(WatchEvent), module, "WatchEvent", 0);
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent), "Modifier", make_descriptor(&PY_TYPE_DEF(WatchEvent$Modifier)));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent), "Kind", make_descriptor(&PY_TYPE_DEF(WatchEvent$Kind)));
      }

      void t_WatchEvent::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent), "class_", make_descriptor(WatchEvent::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent), "wrapfn_", make_descriptor(t_WatchEvent::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(WatchEvent), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_WatchEvent_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, WatchEvent::initializeClass, 1)))
          return NULL;
        return t_WatchEvent::wrap_Object(WatchEvent(((t_WatchEvent *) arg)->object.this$));
      }
      static PyObject *t_WatchEvent_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, WatchEvent::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_WatchEvent_of_(t_WatchEvent *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_WatchEvent_context(t_WatchEvent *self)
      {
        ::java::lang::Object result((jobject) NULL);
        OBJ_CALL(result = self->object.context());
        return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      static PyObject *t_WatchEvent_count(t_WatchEvent *self)
      {
        jint result;
        OBJ_CALL(result = self->object.count());
        return PyLong_FromLong((long) result);
      }

      static PyObject *t_WatchEvent_kind(t_WatchEvent *self)
      {
        ::java::nio::file::WatchEvent$Kind result((jobject) NULL);
        OBJ_CALL(result = self->object.kind());
        return ::java::nio::file::t_WatchEvent$Kind::wrap_Object(result, self->parameters[0]);
      }
      static PyObject *t_WatchEvent_get__parameters_(t_WatchEvent *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/PredictionContextCache.h"
#include "org/antlr/v4/runtime/atn/PredictionContext.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *PredictionContextCache::class$ = NULL;
          jmethodID *PredictionContextCache::mids$ = NULL;
          bool PredictionContextCache::live$ = false;

          jclass PredictionContextCache::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/PredictionContextCache");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
              mids$[mid_add_48ada528ddd16ee5] = env->getMethodID(cls, "add", "(Lorg/antlr/v4/runtime/atn/PredictionContext;)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_get_48ada528ddd16ee5] = env->getMethodID(cls, "get", "(Lorg/antlr/v4/runtime/atn/PredictionContext;)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          PredictionContextCache::PredictionContextCache() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          ::org::antlr::v4::runtime::atn::PredictionContext PredictionContextCache::add(const ::org::antlr::v4::runtime::atn::PredictionContext & a0) const
          {
            return ::org::antlr::v4::runtime::atn::PredictionContext(env->callObjectMethod(this$, mids$[mid_add_48ada528ddd16ee5], a0.this$));
          }

          ::org::antlr::v4::runtime::atn::PredictionContext PredictionContextCache::get(const ::org::antlr::v4::runtime::atn::PredictionContext & a0) const
          {
            return ::org::antlr::v4::runtime::atn::PredictionContext(env->callObjectMethod(this$, mids$[mid_get_48ada528ddd16ee5], a0.this$));
          }

          jint PredictionContextCache::size() const
          {
            return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_PredictionContextCache_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionContextCache_instance_(PyTypeObject *type, PyObject *arg);
          static int t_PredictionContextCache_init_(t_PredictionContextCache *self, PyObject *args, PyObject *kwds);
          static PyObject *t_PredictionContextCache_add(t_PredictionContextCache *self, PyObject *arg);
          static PyObject *t_PredictionContextCache_get(t_PredictionContextCache *self, PyObject *arg);
          static PyObject *t_PredictionContextCache_size(t_PredictionContextCache *self);

          static PyMethodDef t_PredictionContextCache__methods_[] = {
            DECLARE_METHOD(t_PredictionContextCache, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionContextCache, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionContextCache, add, METH_O),
            DECLARE_METHOD(t_PredictionContextCache, get, METH_O),
            DECLARE_METHOD(t_PredictionContextCache, size, METH_NOARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(PredictionContextCache)[] = {
            { Py_tp_methods, t_PredictionContextCache__methods_ },
            { Py_tp_init, (void *) t_PredictionContextCache_init_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(PredictionContextCache)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(PredictionContextCache, t_PredictionContextCache, PredictionContextCache);

          void t_PredictionContextCache::install(PyObject *module)
          {
            installType(&PY_TYPE(PredictionContextCache), &PY_TYPE_DEF(PredictionContextCache), module, "PredictionContextCache", 0);
          }

          void t_PredictionContextCache::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionContextCache), "class_", make_descriptor(PredictionContextCache::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionContextCache), "wrapfn_", make_descriptor(t_PredictionContextCache::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionContextCache), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_PredictionContextCache_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, PredictionContextCache::initializeClass, 1)))
              return NULL;
            return t_PredictionContextCache::wrap_Object(PredictionContextCache(((t_PredictionContextCache *) arg)->object.this$));
          }
          static PyObject *t_PredictionContextCache_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, PredictionContextCache::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_PredictionContextCache_init_(t_PredictionContextCache *self, PyObject *args, PyObject *kwds)
          {
            PredictionContextCache object((jobject) NULL);

            INT_CALL(object = PredictionContextCache());
            self->object = object;

            return 0;
          }

          static PyObject *t_PredictionContextCache_add(t_PredictionContextCache *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::PredictionContext a0((jobject) NULL);
            ::org::antlr::v4::runtime::atn::PredictionContext result((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.add(a0));
              return ::org::antlr::v4::runtime::atn::t_PredictionContext::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "add", arg);
            return NULL;
          }

          static PyObject *t_PredictionContextCache_get(t_PredictionContextCache *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::PredictionContext a0((jobject) NULL);
            ::org::antlr::v4::runtime::atn::PredictionContext result((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.get(a0));
              return ::org::antlr::v4::runtime::atn::t_PredictionContext::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "get", arg);
            return NULL;
          }

          static PyObject *t_PredictionContextCache_size(t_PredictionContextCache *self)
          {
            jint result;
            OBJ_CALL(result = self->object.size());
            return PyLong_FromLong((long) result);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/ToIntFunction.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *ToIntFunction::class$ = NULL;
      jmethodID *ToIntFunction::mids$ = NULL;
      bool ToIntFunction::live$ = false;

      jclass ToIntFunction::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/ToIntFunction");

          mids$ = new jmethodID[max_mid];
          mids$[mid_applyAsInt_5a4805a36cf611e7] = env->getMethodID(cls, "applyAsInt", "(Ljava/lang/Object;)I");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jint ToIntFunction::applyAsInt(const ::java::lang::Object & a0) const
      {
        return env->callIntMethod(this$, mids$[mid_applyAsInt_5a4805a36cf611e7], a0.this$);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_ToIntFunction_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ToIntFunction_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ToIntFunction_of_(t_ToIntFunction *self, PyObject *args);
      static PyObject *t_ToIntFunction_applyAsInt(t_ToIntFunction *self, PyObject *arg);
      static PyObject *t_ToIntFunction_get__parameters_(t_ToIntFunction *self, void *data);
      static PyGetSetDef t_ToIntFunction__fields_[] = {
        DECLARE_GET_FIELD(t_ToIntFunction, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_ToIntFunction__methods_[] = {
        DECLARE_METHOD(t_ToIntFunction, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ToIntFunction, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ToIntFunction, of_, METH_VARARGS),
        DECLARE_METHOD(t_ToIntFunction, applyAsInt, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(ToIntFunction)[] = {
        { Py_tp_methods, t_ToIntFunction__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_ToIntFunction__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(ToIntFunction)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(ToIntFunction, t_ToIntFunction, ToIntFunction);
      PyObject *t_ToIntFunction::wrap_Object(const ToIntFunction& object, PyTypeObject *p0)
      {
        PyObject *obj = t_ToIntFunction::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_ToIntFunction *self = (t_ToIntFunction *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_ToIntFunction::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_ToIntFunction::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_ToIntFunction *self = (t_ToIntFunction *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_ToIntFunction::install(PyObject *module)
      {
        installType(&PY_TYPE(ToIntFunction), &PY_TYPE_DEF(ToIntFunction), module, "ToIntFunction", 0);
      }

      void t_ToIntFunction::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(ToIntFunction), "class_", make_descriptor(ToIntFunction::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ToIntFunction), "wrapfn_", make_descriptor(t_ToIntFunction::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ToIntFunction), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_ToIntFunction_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, ToIntFunction::initializeClass, 1)))
          return NULL;
        return t_ToIntFunction::wrap_Object(ToIntFunction(((t_ToIntFunction *) arg)->object.this$));
      }
      static PyObject *t_ToIntFunction_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, ToIntFunction::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_ToIntFunction_of_(t_ToIntFunction *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_ToIntFunction_applyAsInt(t_ToIntFunction *self, PyObject *arg)
      {
        ::java::lang::Object a0((jobject) NULL);
        jint result;

        if (!parseArg(arg, "O", self->parameters[0], &a0))
        {
          OBJ_CALL(result = self->object.applyAsInt(a0));
          return PyLong_FromLong((long) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsInt", arg);
        return NULL;
      }
      static PyObject *t_ToIntFunction_get__parameters_(t_ToIntFunction *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/ToLongFunction.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *ToLongFunction::class$ = NULL;
      jmethodID *ToLongFunction::mids$ = NULL;
      bool ToLongFunction::live$ = false;

      jclass ToLongFunction::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/ToLongFunction");

          mids$ = new jmethodID[max_mid];
          mids$[mid_applyAsLong_c602cc71de3e942a] = env->getMethodID(cls, "applyAsLong", "(Ljava/lang/Object;)J");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jlong ToLongFunction::applyAsLong(const ::java::lang::Object & a0) const
      {
        return env->callLongMethod(this$, mids$[mid_applyAsLong_c602cc71de3e942a], a0.this$);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_ToLongFunction_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ToLongFunction_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ToLongFunction_of_(t_ToLongFunction *self, PyObject *args);
      static PyObject *t_ToLongFunction_applyAsLong(t_ToLongFunction *self, PyObject *arg);
      static PyObject *t_ToLongFunction_get__parameters_(t_ToLongFunction *self, void *data);
      static PyGetSetDef t_ToLongFunction__fields_[] = {
        DECLARE_GET_FIELD(t_ToLongFunction, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_ToLongFunction__methods_[] = {
        DECLARE_METHOD(t_ToLongFunction, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ToLongFunction, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ToLongFunction, of_, METH_VARARGS),
        DECLARE_METHOD(t_ToLongFunction, applyAsLong, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(ToLongFunction)[] = {
        { Py_tp_methods, t_ToLongFunction__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_ToLongFunction__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(ToLongFunction)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(ToLongFunction, t_ToLongFunction, ToLongFunction);
      PyObject *t_ToLongFunction::wrap_Object(const ToLongFunction& object, PyTypeObject *p0)
      {
        PyObject *obj = t_ToLongFunction::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_ToLongFunction *self = (t_ToLongFunction *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_ToLongFunction::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_ToLongFunction::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_ToLongFunction *self = (t_ToLongFunction *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_ToLongFunction::install(PyObject *module)
      {
        installType(&PY_TYPE(ToLongFunction), &PY_TYPE_DEF(ToLongFunction), module, "ToLongFunction", 0);
      }

      void t_ToLongFunction::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(ToLongFunction), "class_", make_descriptor(ToLongFunction::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ToLongFunction), "wrapfn_", make_descriptor(t_ToLongFunction::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ToLongFunction), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_ToLongFunction_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, ToLongFunction::initializeClass, 1)))
          return NULL;
        return t_ToLongFunction::wrap_Object(ToLongFunction(((t_ToLongFunction *) arg)->object.this$));
      }
      static PyObject *t_ToLongFunction_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, ToLongFunction::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_ToLongFunction_of_(t_ToLongFunction *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_ToLongFunction_applyAsLong(t_ToLongFunction *self, PyObject *arg)
      {
        ::java::lang::Object a0((jobject) NULL);
        jlong result;

        if (!parseArg(arg, "O", self->parameters[0], &a0))
        {
          OBJ_CALL(result = self->object.applyAsLong(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsLong", arg);
        return NULL;
      }
      static PyObject *t_ToLongFunction_get__parameters_(t_ToLongFunction *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/Locale$Category.h"
#include "java/util/Locale$Category.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *Locale$Category::class$ = NULL;
    jmethodID *Locale$Category::mids$ = NULL;
    bool Locale$Category::live$ = false;
    Locale$Category *Locale$Category::DISPLAY = NULL;
    Locale$Category *Locale$Category::FORMAT = NULL;

    jclass Locale$Category::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/Locale$Category");

        mids$ = new jmethodID[max_mid];
        mids$[mid_valueOf_56a8580458a04523] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Ljava/util/Locale$Category;");
        mids$[mid_values_0ec9e91674ad041b] = env->getStaticMethodID(cls, "values", "()[Ljava/util/Locale$Category;");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        DISPLAY = new Locale$Category(env->getStaticObjectField(cls, "DISPLAY", "Ljava/util/Locale$Category;"));
        FORMAT = new Locale$Category(env->getStaticObjectField(cls, "FORMAT", "Ljava/util/Locale$Category;"));
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    Locale$Category Locale$Category::valueOf(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return Locale$Category(env->callStaticObjectMethod(cls, mids$[mid_valueOf_56a8580458a04523], a0.this$));
    }

    JArray< Locale$Category > Locale$Category::values()
    {
      jclass cls = env->getClass(initializeClass);
      return JArray< Locale$Category >(env->callStaticObjectMethod(cls, mids$[mid_values_0ec9e91674ad041b]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_Locale$Category_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Locale$Category_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_Locale$Category_of_(t_Locale$Category *self, PyObject *args);
    static PyObject *t_Locale$Category_valueOf(PyTypeObject *type, PyObject *args);
    static PyObject *t_Locale$Category_values(PyTypeObject *type);
    static PyObject *t_Locale$Category_get__parameters_(t_Locale$Category *self, void *data);
    static PyGetSetDef t_Locale$Category__fields_[] = {
      DECLARE_GET_FIELD(t_Locale$Category, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_Locale$Category__methods_[] = {
      DECLARE_METHOD(t_Locale$Category, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Locale$Category, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_Locale$Category, of_, METH_VARARGS),
      DECLARE_METHOD(t_Locale$Category, valueOf, METH_VARARGS | METH_CLASS),
      DECLARE_METHOD(t_Locale$Category, values, METH_NOARGS | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(Locale$Category)[] = {
      { Py_tp_methods, t_Locale$Category__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { Py_tp_getset, t_Locale$Category__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(Locale$Category)[] = {
      &PY_TYPE_DEF(::java::lang::Enum),
      NULL
    };

    DEFINE_TYPE(Locale$Category, t_Locale$Category, Locale$Category);
    PyObject *t_Locale$Category::wrap_Object(const Locale$Category& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Locale$Category::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Locale$Category *self = (t_Locale$Category *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    PyObject *t_Locale$Category::wrap_jobject(const jobject& object, PyTypeObject *p0)
    {
      PyObject *obj = t_Locale$Category::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_Locale$Category *self = (t_Locale$Category *) obj;
        self->parameters[0] = p0;
      }
      return obj;
    }

    void t_Locale$Category::install(PyObject *module)
    {
      installType(&PY_TYPE(Locale$Category), &PY_TYPE_DEF(Locale$Category), module, "Locale$Category", 0);
    }

    void t_Locale$Category::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$Category), "class_", make_descriptor(Locale$Category::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$Category), "wrapfn_", make_descriptor(t_Locale$Category::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$Category), "boxfn_", make_descriptor(boxObject));
      env->getClass(Locale$Category::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$Category), "DISPLAY", make_descriptor(t_Locale$Category::wrap_Object(*Locale$Category::DISPLAY)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(Locale$Category), "FORMAT", make_descriptor(t_Locale$Category::wrap_Object(*Locale$Category::FORMAT)));
    }

    static PyObject *t_Locale$Category_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, Locale$Category::initializeClass, 1)))
        return NULL;
      return t_Locale$Category::wrap_Object(Locale$Category(((t_Locale$Category *) arg)->object.this$));
    }
    static PyObject *t_Locale$Category_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, Locale$Category::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_Locale$Category_of_(t_Locale$Category *self, PyObject *args)
    {
      if (!parseArg(args, "T", 1, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static PyObject *t_Locale$Category_valueOf(PyTypeObject *type, PyObject *args)
    {
      ::java::lang::String a0((jobject) NULL);
      Locale$Category result((jobject) NULL);

      if (!parseArgs(args, "s", &a0))
      {
        OBJ_CALL(result = ::java::util::Locale$Category::valueOf(a0));
        return t_Locale$Category::wrap_Object(result);
      }

      return callSuper(type, "valueOf", args, 2);
    }

    static PyObject *t_Locale$Category_values(PyTypeObject *type)
    {
      JArray< Locale$Category > result((jobject) NULL);
      OBJ_CALL(result = ::java::util::Locale$Category::values());
      return JArray<jobject>(result.this$).wrap(t_Locale$Category::wrap_jobject);
    }
    static PyObject *t_Locale$Category_get__parameters_(t_Locale$Category *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/AbstractPredicateTransition.h"
#include "org/antlr/v4/runtime/atn/ATNState.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *AbstractPredicateTransition::class$ = NULL;
          jmethodID *AbstractPredicateTransition::mids$ = NULL;
          bool AbstractPredicateTransition::live$ = false;

          jclass AbstractPredicateTransition::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/AbstractPredicateTransition");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_1dedc26b173e2f62] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNState;)V");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          AbstractPredicateTransition::AbstractPredicateTransition(const ::org::antlr::v4::runtime::atn::ATNState & a0) : ::org::antlr::v4::runtime::atn::Transition(env->newObject(initializeClass, &mids$, mid_init$_1dedc26b173e2f62, a0.this$)) {}
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_AbstractPredicateTransition_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_AbstractPredicateTransition_instance_(PyTypeObject *type, PyObject *arg);
          static int t_AbstractPredicateTransition_init_(t_AbstractPredicateTransition *self, PyObject *args, PyObject *kwds);

          static PyMethodDef t_AbstractPredicateTransition__methods_[] = {
            DECLARE_METHOD(t_AbstractPredicateTransition, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_AbstractPredicateTransition, instance_, METH_O | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(AbstractPredicateTransition)[] = {
            { Py_tp_methods, t_AbstractPredicateTransition__methods_ },
            { Py_tp_init, (void *) t_AbstractPredicateTransition_init_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(AbstractPredicateTransition)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::Transition),
            NULL
          };

          DEFINE_TYPE(AbstractPredicateTransition, t_AbstractPredicateTransition, AbstractPredicateTransition);

          void t_AbstractPredicateTransition::install(PyObject *module)
          {
            installType(&PY_TYPE(AbstractPredicateTransition), &PY_TYPE_DEF(AbstractPredicateTransition), module, "AbstractPredicateTransition", 0);
          }

          void t_AbstractPredicateTransition::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractPredicateTransition), "class_", make_descriptor(AbstractPredicateTransition::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractPredicateTransition), "wrapfn_", make_descriptor(t_AbstractPredicateTransition::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(AbstractPredicateTransition), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_AbstractPredicateTransition_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, AbstractPredicateTransition::initializeClass, 1)))
              return NULL;
            return t_AbstractPredicateTransition::wrap_Object(AbstractPredicateTransition(((t_AbstractPredicateTransition *) arg)->object.this$));
          }
          static PyObject *t_AbstractPredicateTransition_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, AbstractPredicateTransition::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_AbstractPredicateTransition_init_(t_AbstractPredicateTransition *self, PyObject *args, PyObject *kwds)
          {
            ::org::antlr::v4::runtime::atn::ATNState a0((jobject) NULL);
            AbstractPredicateTransition object((jobject) NULL);

            if (!parseArgs(args, "k", ::org::antlr::v4::runtime::atn::ATNState::initializeClass, &a0))
            {
              INT_CALL(object = AbstractPredicateTransition(a0));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/PredictionContext.h"
#include "org/antlr/v4/runtime/atn/PredictionContextCache.h"
#include "java/util/Map.h"
#include "org/antlr/v4/runtime/atn/ArrayPredictionContext.h"
#include "org/antlr/v4/runtime/atn/ATN.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/atn/EmptyPredictionContext.h"
#include "org/antlr/v4/runtime/RuleContext.h"
#include "org/antlr/v4/runtime/atn/PredictionContext.h"
#include "java/util/IdentityHashMap.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/Recognizer.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/atn/SingletonPredictionContext.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *PredictionContext::class$ = NULL;
          jmethodID *PredictionContext::mids$ = NULL;
          jfieldID *PredictionContext::fids$ = NULL;
          bool PredictionContext::live$ = false;
          ::org::antlr::v4::runtime::atn::EmptyPredictionContext *PredictionContext::EMPTY = NULL;
          jint PredictionContext::EMPTY_RETURN_STATE = (jint) 0;
          jint PredictionContext::globalNodeCount = (jint) 0;

          jclass PredictionContext::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/PredictionContext");

              mids$ = new jmethodID[max_mid];
              mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
              mids$[mid_fromRuleContext_8effd03653511c53] = env->getStaticMethodID(cls, "fromRuleContext", "(Lorg/antlr/v4/runtime/atn/ATN;Lorg/antlr/v4/runtime/RuleContext;)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_getAllContextNodes_d8863b2c6752b9d6] = env->getStaticMethodID(cls, "getAllContextNodes", "(Lorg/antlr/v4/runtime/atn/PredictionContext;)Ljava/util/List;");
              mids$[mid_getAllContextNodes__dd22c0a67c49f8a2] = env->getStaticMethodID(cls, "getAllContextNodes_", "(Lorg/antlr/v4/runtime/atn/PredictionContext;Ljava/util/List;Ljava/util/Map;)V");
              mids$[mid_getCachedContext_559d0b88717bc07c] = env->getStaticMethodID(cls, "getCachedContext", "(Lorg/antlr/v4/runtime/atn/PredictionContext;Lorg/antlr/v4/runtime/atn/PredictionContextCache;Ljava/util/IdentityHashMap;)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_getParent_de7c941e2462c7c5] = env->getMethodID(cls, "getParent", "(I)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_getReturnState_1e143afe1894d213] = env->getMethodID(cls, "getReturnState", "(I)I");
              mids$[mid_hasEmptyPath_8454bd5aa23fd11e] = env->getMethodID(cls, "hasEmptyPath", "()Z");
              mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
              mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
              mids$[mid_mergeRoot_7f539e19aedf9919] = env->getStaticMethodID(cls, "mergeRoot", "(Lorg/antlr/v4/runtime/atn/SingletonPredictionContext;Lorg/antlr/v4/runtime/atn/SingletonPredictionContext;Z)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
              mids$[mid_toDOTString_cd07dd248e0ebbe1] = env->getStaticMethodID(cls, "toDOTString", "(Lorg/antlr/v4/runtime/atn/PredictionContext;)Ljava/lang/String;");
              mids$[mid_toString_d149253c7f4e18bb] = env->getMethodID(cls, "toString", "(Lorg/antlr/v4/runtime/Recognizer;)Ljava/lang/String;");
              mids$[mid_toStrings_60c8dc50b443e2cd] = env->getMethodID(cls, "toStrings", "(Lorg/antlr/v4/runtime/Recognizer;I)[Ljava/lang/String;");
              mids$[mid_toStrings_cda991109ecf05d6] = env->getMethodID(cls, "toStrings", "(Lorg/antlr/v4/runtime/Recognizer;Lorg/antlr/v4/runtime/atn/PredictionContext;I)[Ljava/lang/String;");
              mids$[mid_combineCommonParents_9d688856c0590cda] = env->getStaticMethodID(cls, "combineCommonParents", "([Lorg/antlr/v4/runtime/atn/PredictionContext;)V");
              mids$[mid_calculateEmptyHashCode_9972fcc56b44e79d] = env->getStaticMethodID(cls, "calculateEmptyHashCode", "()I");
              mids$[mid_calculateHashCode_f26b21972a428417] = env->getStaticMethodID(cls, "calculateHashCode", "(Lorg/antlr/v4/runtime/atn/PredictionContext;I)I");
              mids$[mid_calculateHashCode_0fab10242a699534] = env->getStaticMethodID(cls, "calculateHashCode", "([Lorg/antlr/v4/runtime/atn/PredictionContext;[I)I");

              fids$ = new jfieldID[max_fid];
              fids$[fid_cachedHashCode] = env->getFieldID(cls, "cachedHashCode", "I");
              fids$[fid_id] = env->getFieldID(cls, "id", "I");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              EMPTY = new ::org::antlr::v4::runtime::atn::EmptyPredictionContext(env->getStaticObjectField(cls, "EMPTY", "Lorg/antlr/v4/runtime/atn/EmptyPredictionContext;"));
              EMPTY_RETURN_STATE = env->getStaticIntField(cls, "EMPTY_RETURN_STATE");
              globalNodeCount = env->getStaticIntField(cls, "globalNodeCount");
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          jboolean PredictionContext::equals(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
          }

          PredictionContext PredictionContext::fromRuleContext(const ::org::antlr::v4::runtime::atn::ATN & a0, const ::org::antlr::v4::runtime::RuleContext & a1)
          {
            jclass cls = env->getClass(initializeClass);
            return PredictionContext(env->callStaticObjectMethod(cls, mids$[mid_fromRuleContext_8effd03653511c53], a0.this$, a1.this$));
          }

          ::java::util::List PredictionContext::getAllContextNodes(const PredictionContext & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return ::java::util::List(env->callStaticObjectMethod(cls, mids$[mid_getAllContextNodes_d8863b2c6752b9d6], a0.this$));
          }

          void PredictionContext::getAllContextNodes_(const PredictionContext & a0, const ::java::util::List & a1, const ::java::util::Map & a2)
          {
            jclass cls = env->getClass(initializeClass);
            env->callStaticVoidMethod(cls, mids$[mid_getAllContextNodes__dd22c0a67c49f8a2], a0.this$, a1.this$, a2.this$);
          }

          PredictionContext PredictionContext::getCachedContext(const PredictionContext & a0, const ::org::antlr::v4::runtime::atn::PredictionContextCache & a1, const ::java::util::IdentityHashMap & a2)
          {
            jclass cls = env->getClass(initializeClass);
            return PredictionContext(env->callStaticObjectMethod(cls, mids$[mid_getCachedContext_559d0b88717bc07c], a0.this$, a1.this$, a2.this$));
          }

          PredictionContext PredictionContext::getParent(jint a0) const
          {
            return PredictionContext(env->callObjectMethod(this$, mids$[mid_getParent_de7c941e2462c7c5], a0));
          }

          jint PredictionContext::getReturnState(jint a0) const
          {
            return env->callIntMethod(this$, mids$[mid_getReturnState_1e143afe1894d213], a0);
          }

          jboolean PredictionContext::hasEmptyPath() const
          {
            return env->callBooleanMethod(this$, mids$[mid_hasEmptyPath_8454bd5aa23fd11e]);
          }

          jint PredictionContext::hashCode() const
          {
            return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
          }

          jboolean PredictionContext::isEmpty() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
          }

          PredictionContext PredictionContext::mergeRoot(const ::org::antlr::v4::runtime::atn::SingletonPredictionContext & a0, const ::org::antlr::v4::runtime::atn::SingletonPredictionContext & a1, jboolean a2)
          {
            jclass cls = env->getClass(initializeClass);
            return PredictionContext(env->callStaticObjectMethod(cls, mids$[mid_mergeRoot_7f539e19aedf9919], a0.this$, a1.this$, a2));
          }

          jint PredictionContext::size() const
          {
            return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
          }

          ::java::lang::String PredictionContext::toDOTString(const PredictionContext & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return ::java::lang::String(env->callStaticObjectMethod(cls, mids$[mid_toDOTString_cd07dd248e0ebbe1], a0.this$));
          }

          ::java::lang::String PredictionContext::toString(const ::org::antlr::v4::runtime::Recognizer & a0) const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_d149253c7f4e18bb], a0.this$));
          }

          JArray< ::java::lang::String > PredictionContext::toStrings(const ::org::antlr::v4::runtime::Recognizer & a0, jint a1) const
          {
            return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_toStrings_60c8dc50b443e2cd], a0.this$, a1));
          }

          JArray< ::java::lang::String > PredictionContext::toStrings(const ::org::antlr::v4::runtime::Recognizer & a0, const PredictionContext & a1, jint a2) const
          {
            return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_toStrings_cda991109ecf05d6], a0.this$, a1.this$, a2));
          }

          jint PredictionContext::_get_cachedHashCode() const
          {
            return env->getIntField(this$, fids$[fid_cachedHashCode]);
          }

          jint PredictionContext::_get_id() const
          {
            return env->getIntField(this$, fids$[fid_id]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_PredictionContext_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionContext_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionContext_equals(t_PredictionContext *self, PyObject *args);
          static PyObject *t_PredictionContext_fromRuleContext(PyTypeObject *type, PyObject *args);
          static PyObject *t_PredictionContext_getAllContextNodes(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionContext_getAllContextNodes_(PyTypeObject *type, PyObject *args);
          static PyObject *t_PredictionContext_getCachedContext(PyTypeObject *type, PyObject *args);
          static PyObject *t_PredictionContext_getParent(t_PredictionContext *self, PyObject *arg);
          static PyObject *t_PredictionContext_getReturnState(t_PredictionContext *self, PyObject *arg);
          static PyObject *t_PredictionContext_hasEmptyPath(t_PredictionContext *self);
          static PyObject *t_PredictionContext_hashCode(t_PredictionContext *self, PyObject *args);
          static PyObject *t_PredictionContext_isEmpty(t_PredictionContext *self);
          static PyObject *t_PredictionContext_mergeRoot(PyTypeObject *type, PyObject *args);
          static PyObject *t_PredictionContext_size(t_PredictionContext *self);
          static PyObject *t_PredictionContext_toDOTString(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionContext_toString(t_PredictionContext *self, PyObject *args);
          static PyObject *t_PredictionContext_toStrings(t_PredictionContext *self, PyObject *args);
          static PyObject *t_PredictionContext_get__cachedHashCode(t_PredictionContext *self, void *data);
          static PyObject *t_PredictionContext_get__id(t_PredictionContext *self, void *data);

          static PyObject *t_PredictionContext_get__empty(t_PredictionContext *self, void *data);
          static PyGetSetDef t_PredictionContext__fields_[] = {
            DECLARE_GET_FIELD(t_PredictionContext, cachedHashCode),
            DECLARE_GET_FIELD(t_PredictionContext, id),
            DECLARE_GET_FIELD(t_PredictionContext, empty),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_PredictionContext__methods_[] = {
            DECLARE_METHOD(t_PredictionContext, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionContext, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionContext, equals, METH_VARARGS),
            DECLARE_METHOD(t_PredictionContext, fromRuleContext, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_PredictionContext, getAllContextNodes, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionContext, getAllContextNodes_, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_PredictionContext, getCachedContext, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_PredictionContext, getParent, METH_O),
            DECLARE_METHOD(t_PredictionContext, getReturnState, METH_O),
            DECLARE_METHOD(t_PredictionContext, hasEmptyPath, METH_NOARGS),
            DECLARE_METHOD(t_PredictionContext, hashCode, METH_VARARGS),
            DECLARE_METHOD(t_PredictionContext, isEmpty, METH_NOARGS),
            DECLARE_METHOD(t_PredictionContext, mergeRoot, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_PredictionContext, size, METH_NOARGS),
            DECLARE_METHOD(t_PredictionContext, toDOTString, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionContext, toString, METH_VARARGS),
            DECLARE_METHOD(t_PredictionContext, toStrings, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(PredictionContext)[] = {
            { Py_tp_methods, t_PredictionContext__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_PredictionContext__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(PredictionContext)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(PredictionContext, t_PredictionContext, PredictionContext);

          void t_PredictionContext::install(PyObject *module)
          {
            installType(&PY_TYPE(PredictionContext), &PY_TYPE_DEF(PredictionContext), module, "PredictionContext", 0);
          }

          void t_PredictionContext::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionContext), "class_", make_descriptor(PredictionContext::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionContext), "wrapfn_", make_descriptor(t_PredictionContext::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionContext), "boxfn_", make_descriptor(boxObject));
            env->getClass(PredictionContext::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionContext), "EMPTY", make_descriptor(::org::antlr::v4::runtime::atn::t_EmptyPredictionContext::wrap_Object(*PredictionContext::EMPTY)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionContext), "EMPTY_RETURN_STATE", make_descriptor(PredictionContext::EMPTY_RETURN_STATE));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionContext), "globalNodeCount", make_descriptor(PredictionContext::globalNodeCount));
          }

          static PyObject *t_PredictionContext_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, PredictionContext::initializeClass, 1)))
              return NULL;
            return t_PredictionContext::wrap_Object(PredictionContext(((t_PredictionContext *) arg)->object.this$));
          }
          static PyObject *t_PredictionContext_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, PredictionContext::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_PredictionContext_equals(t_PredictionContext *self, PyObject *args)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "o", &a0))
            {
              OBJ_CALL(result = self->object.equals(a0));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(PredictionContext), (PyObject *) self, "equals", args, 2);
          }

          static PyObject *t_PredictionContext_fromRuleContext(PyTypeObject *type, PyObject *args)
          {
            ::org::antlr::v4::runtime::atn::ATN a0((jobject) NULL);
            ::org::antlr::v4::runtime::RuleContext a1((jobject) NULL);
            PredictionContext result((jobject) NULL);

            if (!parseArgs(args, "kk", ::org::antlr::v4::runtime::atn::ATN::initializeClass, ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0, &a1))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionContext::fromRuleContext(a0, a1));
              return t_PredictionContext::wrap_Object(result);
            }

            PyErr_SetArgsError(type, "fromRuleContext", args);
            return NULL;
          }

          static PyObject *t_PredictionContext_getAllContextNodes(PyTypeObject *type, PyObject *arg)
          {
            PredictionContext a0((jobject) NULL);
            ::java::util::List result((jobject) NULL);

            if (!parseArg(arg, "k", PredictionContext::initializeClass, &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionContext::getAllContextNodes(a0));
              return ::java::util::t_List::wrap_Object(result, ::org::antlr::v4::runtime::atn::PY_TYPE(PredictionContext));
            }

            PyErr_SetArgsError(type, "getAllContextNodes", arg);
            return NULL;
          }

          static PyObject *t_PredictionContext_getAllContextNodes_(PyTypeObject *type, PyObject *args)
          {
            PredictionContext a0((jobject) NULL);
            ::java::util::List a1((jobject) NULL);
            PyTypeObject **p1;
            ::java::util::Map a2((jobject) NULL);
            PyTypeObject **p2;

            if (!parseArgs(args, "kKK", PredictionContext::initializeClass, ::java::util::List::initializeClass, ::java::util::Map::initializeClass, &a0, &a1, &p1, ::java::util::t_List::parameters_, &a2, &p2, ::java::util::t_Map::parameters_))
            {
              OBJ_CALL(::org::antlr::v4::runtime::atn::PredictionContext::getAllContextNodes_(a0, a1, a2));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError(type, "getAllContextNodes_", args);
            return NULL;
          }

          static PyObject *t_PredictionContext_getCachedContext(PyTypeObject *type, PyObject *args)
          {
            PredictionContext a0((jobject) NULL);
            ::org::antlr::v4::runtime::atn::PredictionContextCache a1((jobject) NULL);
            ::java::util::IdentityHashMap a2((jobject) NULL);
            PyTypeObject **p2;
            PredictionContext result((jobject) NULL);

            if (!parseArgs(args, "kkK", PredictionContext::initializeClass, ::org::antlr::v4::runtime::atn::PredictionContextCache::initializeClass, ::java::util::IdentityHashMap::initializeClass, &a0, &a1, &a2, &p2, ::java::util::t_IdentityHashMap::parameters_))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionContext::getCachedContext(a0, a1, a2));
              return t_PredictionContext::wrap_Object(result);
            }

            PyErr_SetArgsError(type, "getCachedContext", args);
            return NULL;
          }

          static PyObject *t_PredictionContext_getParent(t_PredictionContext *self, PyObject *arg)
          {
            jint a0;
            PredictionContext result((jobject) NULL);

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(result = self->object.getParent(a0));
              return t_PredictionContext::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "getParent", arg);
            return NULL;
          }

          static PyObject *t_PredictionContext_getReturnState(t_PredictionContext *self, PyObject *arg)
          {
            jint a0;
            jint result;

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(result = self->object.getReturnState(a0));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError((PyObject *) self, "getReturnState", arg);
            return NULL;
          }

          static PyObject *t_PredictionContext_hasEmptyPath(t_PredictionContext *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.hasEmptyPath());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_PredictionContext_hashCode(t_PredictionContext *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.hashCode());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(PredictionContext), (PyObject *) self, "hashCode", args, 2);
          }

          static PyObject *t_PredictionContext_isEmpty(t_PredictionContext *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.isEmpty());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_PredictionContext_mergeRoot(PyTypeObject *type, PyObject *args)
          {
            ::org::antlr::v4::runtime::atn::SingletonPredictionContext a0((jobject) NULL);
            ::org::antlr::v4::runtime::atn::SingletonPredictionContext a1((jobject) NULL);
            jboolean a2;
            PredictionContext result((jobject) NULL);

            if (!parseArgs(args, "kkZ", ::org::antlr::v4::runtime::atn::SingletonPredictionContext::initializeClass, ::org::antlr::v4::runtime::atn::SingletonPredictionContext::initializeClass, &a0, &a1, &a2))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionContext::mergeRoot(a0, a1, a2));
              return t_PredictionContext::wrap_Object(result);
            }

            PyErr_SetArgsError(type, "mergeRoot", args);
            return NULL;
          }

          static PyObject *t_PredictionContext_size(t_PredictionContext *self)
          {
            jint result;
            OBJ_CALL(result = self->object.size());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_PredictionContext_toDOTString(PyTypeObject *type, PyObject *arg)
          {
            PredictionContext a0((jobject) NULL);
            ::java::lang::String result((jobject) NULL);

            if (!parseArg(arg, "k", PredictionContext::initializeClass, &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionContext::toDOTString(a0));
              return j2p(result);
            }

            PyErr_SetArgsError(type, "toDOTString", arg);
            return NULL;
          }

          static PyObject *t_PredictionContext_toString(t_PredictionContext *self, PyObject *args)
          {
            ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
            PyTypeObject **p0;
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, "K", ::org::antlr::v4::runtime::Recognizer::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_))
            {
              OBJ_CALL(result = self->object.toString(a0));
              return j2p(result);
            }

            return callSuper(PY_TYPE(PredictionContext), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_PredictionContext_toStrings(t_PredictionContext *self, PyObject *args)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 2:
              {
                ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
                PyTypeObject **p0;
                jint a1;
                JArray< ::java::lang::String > result((jobject) NULL);

                if (!parseArgs(args, "KI", ::org::antlr::v4::runtime::Recognizer::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a1))
                {
                  OBJ_CALL(result = self->object.toStrings(a0, a1));
                  return JArray<jstring>(result.this$).wrap();
                }
              }
              break;
             case 3:
              {
                ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
                PyTypeObject **p0;
                PredictionContext a1((jobject) NULL);
                jint a2;
                JArray< ::java::lang::String > result((jobject) NULL);

                if (!parseArgs(args, "KkI", ::org::antlr::v4::runtime::Recognizer::initializeClass, PredictionContext::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a1, &a2))
                {
                  OBJ_CALL(result = self->object.toStrings(a0, a1, a2));
                  return JArray<jstring>(result.this$).wrap();
                }
              }
            }

            PyErr_SetArgsError((PyObject *) self, "toStrings", args);
            return NULL;
          }

          static PyObject *t_PredictionContext_get__cachedHashCode(t_PredictionContext *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_cachedHashCode());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_PredictionContext_get__id(t_PredictionContext *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_id());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_PredictionContext_get__empty(t_PredictionContext *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isEmpty());
            Py_RETURN_BOOL(value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "org/antlr/v4/runtime/TokenSource.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/RuleContext.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/Token.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *TokenStream::class$ = NULL;
        jmethodID *TokenStream::mids$ = NULL;
        bool TokenStream::live$ = false;

        jclass TokenStream::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/TokenStream");

            mids$ = new jmethodID[max_mid];
            mids$[mid_LT_42cc671c2f94ca07] = env->getMethodID(cls, "LT", "(I)Lorg/antlr/v4/runtime/Token;");
            mids$[mid_get_42cc671c2f94ca07] = env->getMethodID(cls, "get", "(I)Lorg/antlr/v4/runtime/Token;");
            mids$[mid_getText_db9b55ba01e03e4b] = env->getMethodID(cls, "getText", "()Ljava/lang/String;");
            mids$[mid_getText_44a6dd219a8d7d73] = env->getMethodID(cls, "getText", "(Lorg/antlr/v4/runtime/RuleContext;)Ljava/lang/String;");
            mids$[mid_getText_061dfb3ec6cb6194] = env->getMethodID(cls, "getText", "(Lorg/antlr/v4/runtime/Token;Lorg/antlr/v4/runtime/Token;)Ljava/lang/String;");
            mids$[mid_getTokenSource_d01019507f363a98] = env->getMethodID(cls, "getTokenSource", "()Lorg/antlr/v4/runtime/TokenSource;");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        ::org::antlr::v4::runtime::Token TokenStream::LT(jint a0) const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_LT_42cc671c2f94ca07], a0));
        }

        ::org::antlr::v4::runtime::Token TokenStream::get(jint a0) const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_get_42cc671c2f94ca07], a0));
        }

        ::java::lang::String TokenStream::getText() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getText_db9b55ba01e03e4b]));
        }

        ::java::lang::String TokenStream::getText(const ::org::antlr::v4::runtime::RuleContext & a0) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getText_44a6dd219a8d7d73], a0.this$));
        }

        ::java::lang::String TokenStream::getText(const ::org::antlr::v4::runtime::Token & a0, const ::org::antlr::v4::runtime::Token & a1) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getText_061dfb3ec6cb6194], a0.this$, a1.this$));
        }

        ::org::antlr::v4::runtime::TokenSource TokenStream::getTokenSource() const
        {
          return ::org::antlr::v4::runtime::TokenSource(env->callObjectMethod(this$, mids$[mid_getTokenSource_d01019507f363a98]));
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_TokenStream_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_TokenStream_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_TokenStream_LT(t_TokenStream *self, PyObject *arg);
        static PyObject *t_TokenStream_get(t_TokenStream *self, PyObject *arg);
        static PyObject *t_TokenStream_getText(t_TokenStream *self, PyObject *args);
        static PyObject *t_TokenStream_getTokenSource(t_TokenStream *self);
        static PyObject *t_TokenStream_get__text(t_TokenStream *self, void *data);
        static PyObject *t_TokenStream_get__tokenSource(t_TokenStream *self, void *data);
        static PyGetSetDef t_TokenStream__fields_[] = {
          DECLARE_GET_FIELD(t_TokenStream, text),
          DECLARE_GET_FIELD(t_TokenStream, tokenSource),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_TokenStream__methods_[] = {
          DECLARE_METHOD(t_TokenStream, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_TokenStream, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_TokenStream, LT, METH_O),
          DECLARE_METHOD(t_TokenStream, get, METH_O),
          DECLARE_METHOD(t_TokenStream, getText, METH_VARARGS),
          DECLARE_METHOD(t_TokenStream, getTokenSource, METH_NOARGS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(TokenStream)[] = {
          { Py_tp_methods, t_TokenStream__methods_ },
          { Py_tp_init, (void *) abstract_init },
          { Py_tp_getset, t_TokenStream__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(TokenStream)[] = {
          &PY_TYPE_DEF(::org::antlr::v4::runtime::IntStream),
          NULL
        };

        DEFINE_TYPE(TokenStream, t_TokenStream, TokenStream);

        void t_TokenStream::install(PyObject *module)
        {
          installType(&PY_TYPE(TokenStream), &PY_TYPE_DEF(TokenStream), module, "TokenStream", 0);
        }

        void t_TokenStream::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(TokenStream), "class_", make_descriptor(TokenStream::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(TokenStream), "wrapfn_", make_descriptor(t_TokenStream::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(TokenStream), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_TokenStream_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, TokenStream::initializeClass, 1)))
            return NULL;
          return t_TokenStream::wrap_Object(TokenStream(((t_TokenStream *) arg)->object.this$));
        }
        static PyObject *t_TokenStream_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, TokenStream::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_TokenStream_LT(t_TokenStream *self, PyObject *arg)
        {
          jint a0;
          ::org::antlr::v4::runtime::Token result((jobject) NULL);

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.LT(a0));
            return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
          }

          PyErr_SetArgsError((PyObject *) self, "LT", arg);
          return NULL;
        }

        static PyObject *t_TokenStream_get(t_TokenStream *self, PyObject *arg)
        {
          jint a0;
          ::org::antlr::v4::runtime::Token result((jobject) NULL);

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.get(a0));
            return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
          }

          PyErr_SetArgsError((PyObject *) self, "get", arg);
          return NULL;
        }

        static PyObject *t_TokenStream_getText(t_TokenStream *self, PyObject *args)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 0:
            {
              ::java::lang::String result((jobject) NULL);
              OBJ_CALL(result = self->object.getText());
              return j2p(result);
            }
            break;
           case 1:
            {
              ::org::antlr::v4::runtime::RuleContext a0((jobject) NULL);
              ::java::lang::String result((jobject) NULL);

              if (!parseArgs(args, "k", ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0))
              {
                OBJ_CALL(result = self->object.getText(a0));
                return j2p(result);
              }
            }
            break;
           case 2:
            {
              ::org::antlr::v4::runtime::Token a0((jobject) NULL);
              ::org::antlr::v4::runtime::Token a1((jobject) NULL);
              ::java::lang::String result((jobject) NULL);

              if (!parseArgs(args, "kk", ::org::antlr::v4::runtime::Token::initializeClass, ::org::antlr::v4::runtime::Token::initializeClass, &a0, &a1))
              {
                OBJ_CALL(result = self->object.getText(a0, a1));
                return j2p(result);
              }
            }
          }

          PyErr_SetArgsError((PyObject *) self, "getText", args);
          return NULL;
        }

        static PyObject *t_TokenStream_getTokenSource(t_TokenStream *self)
        {
          ::org::antlr::v4::runtime::TokenSource result((jobject) NULL);
          OBJ_CALL(result = self->object.getTokenSource());
          return ::org::antlr::v4::runtime::t_TokenSource::wrap_Object(result);
        }

        static PyObject *t_TokenStream_get__text(t_TokenStream *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object.getText());
          return j2p(value);
        }

        static PyObject *t_TokenStream_get__tokenSource(t_TokenStream *self, void *data)
        {
          ::org::antlr::v4::runtime::TokenSource value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenSource());
          return ::org::antlr::v4::runtime::t_TokenSource::wrap_Object(value);
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/ANTLRErrorListener.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/RecognitionException.h"
#include "org/antlr/v4/runtime/Recognizer.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/Parser.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *ANTLRErrorListener::class$ = NULL;
        jmethodID *ANTLRErrorListener::mids$ = NULL;
        bool ANTLRErrorListener::live$ = false;

        jclass ANTLRErrorListener::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/ANTLRErrorListener");

            mids$ = new jmethodID[max_mid];
            mids$[mid_syntaxError_f859b92346f7e3b6] = env->getMethodID(cls, "syntaxError", "(Lorg/antlr/v4/runtime/Recognizer;Ljava/lang/Object;IILjava/lang/String;Lorg/antlr/v4/runtime/RecognitionException;)V");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        void ANTLRErrorListener::syntaxError(const ::org::antlr::v4::runtime::Recognizer & a0, const ::java::lang::Object & a1, jint a2, jint a3, const ::java::lang::String & a4, const ::org::antlr::v4::runtime::RecognitionException & a5) const
        {
          env->callVoidMethod(this$, mids$[mid_syntaxError_f859b92346f7e3b6], a0.this$, a1.this$, a2, a3, a4.this$, a5.this$);
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_ANTLRErrorListener_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_ANTLRErrorListener_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_ANTLRErrorListener_syntaxError(t_ANTLRErrorListener *self, PyObject *args);

        static PyMethodDef t_ANTLRErrorListener__methods_[] = {
          DECLARE_METHOD(t_ANTLRErrorListener, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_ANTLRErrorListener, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_ANTLRErrorListener, syntaxError, METH_VARARGS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(ANTLRErrorListener)[] = {
          { Py_tp_methods, t_ANTLRErrorListener__methods_ },
          { Py_tp_init, (void *) abstract_init },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(ANTLRErrorListener)[] = {
          &PY_TYPE_DEF(::java::lang::Object),
          NULL
        };

        DEFINE_TYPE(ANTLRErrorListener, t_ANTLRErrorListener, ANTLRErrorListener);

        void t_ANTLRErrorListener::install(PyObject *module)
        {
          installType(&PY_TYPE(ANTLRErrorListener), &PY_TYPE_DEF(ANTLRErrorListener), module, "ANTLRErrorListener", 0);
        }

        void t_ANTLRErrorListener::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(ANTLRErrorListener), "class_", make_descriptor(ANTLRErrorListener::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(ANTLRErrorListener), "wrapfn_", make_descriptor(t_ANTLRErrorListener::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(ANTLRErrorListener), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_ANTLRErrorListener_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, ANTLRErrorListener::initializeClass, 1)))
            return NULL;
          return t_ANTLRErrorListener::wrap_Object(ANTLRErrorListener(((t_ANTLRErrorListener *) arg)->object.this$));
        }
        static PyObject *t_ANTLRErrorListener_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, ANTLRErrorListener::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_ANTLRErrorListener_syntaxError(t_ANTLRErrorListener *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
          PyTypeObject **p0;
          ::java::lang::Object a1((jobject) NULL);
          jint a2;
          jint a3;
          ::java::lang::String a4((jobject) NULL);
          ::org::antlr::v4::runtime::RecognitionException a5((jobject) NULL);

          if (!parseArgs(args, "KoIIsk", ::org::antlr::v4::runtime::Recognizer::initializeClass, ::org::antlr::v4::runtime::RecognitionException::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a1, &a2, &a3, &a4, &a5))
          {
            OBJ_CALL(self->object.syntaxError(a0, a1, a2, a3, a4, a5));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "syntaxError", args);
          return NULL;
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/Transition.h"
#include "java/util/Map.h"
#include "java/lang/Class.h"
#include "java/lang/Integer.h"
#include "java/lang/String.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/atn/ATNState.h"
#include "org/antlr/v4/runtime/atn/Transition.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *Transition::class$ = NULL;
          jmethodID *Transition::mids$ = NULL;
          jfieldID *Transition::fids$ = NULL;
          bool Transition::live$ = false;
          jint Transition::ACTION = (jint) 0;
          jint Transition::ATOM = (jint) 0;
          jint Transition::EPSILON = (jint) 0;
          jint Transition::NOT_SET = (jint) 0;
          jint Transition::PRECEDENCE = (jint) 0;
          jint Transition::PREDICATE = (jint) 0;
          jint Transition::RANGE = (jint) 0;
          jint Transition::RULE = (jint) 0;
          jint Transition::SET = (jint) 0;
          jint Transition::WILDCARD = (jint) 0;
          ::java::util::List *Transition::serializationNames = NULL;
          ::java::util::Map *Transition::serializationTypes = NULL;

          jclass Transition::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/Transition");

              mids$ = new jmethodID[max_mid];
              mids$[mid_getSerializationType_9972fcc56b44e79d] = env->getMethodID(cls, "getSerializationType", "()I");
              mids$[mid_isEpsilon_8454bd5aa23fd11e] = env->getMethodID(cls, "isEpsilon", "()Z");
              mids$[mid_matches_478e39400b58360d] = env->getMethodID(cls, "matches", "(III)Z");

              fids$ = new jfieldID[max_fid];
              fids$[fid_target] = env->getFieldID(cls, "target", "Lorg/antlr/v4/runtime/atn/ATNState;");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              ACTION = env->getStaticIntField(cls, "ACTION");
              ATOM = env->getStaticIntField(cls, "ATOM");
              EPSILON = env->getStaticIntField(cls, "EPSILON");
              NOT_SET = env->getStaticIntField(cls, "NOT_SET");
              PRECEDENCE = env->getStaticIntField(cls, "PRECEDENCE");
              PREDICATE = env->getStaticIntField(cls, "PREDICATE");
              RANGE = env->getStaticIntField(cls, "RANGE");
              RULE = env->getStaticIntField(cls, "RULE");
              SET = env->getStaticIntField(cls, "SET");
              WILDCARD = env->getStaticIntField(cls, "WILDCARD");
              serializationNames = new ::java::util::List(env->getStaticObjectField(cls, "serializationNames", "Ljava/util/List;"));
              serializationTypes = new ::java::util::Map(env->getStaticObjectField(cls, "serializationTypes", "Ljava/util/Map;"));
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          jint Transition::getSerializationType() const
          {
            return env->callIntMethod(this$, mids$[mid_getSerializationType_9972fcc56b44e79d]);
          }

          jboolean Transition::isEpsilon() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isEpsilon_8454bd5aa23fd11e]);
          }

          jboolean Transition::matches(jint a0, jint a1, jint a2) const
          {
            return env->callBooleanMethod(this$, mids$[mid_matches_478e39400b58360d], a0, a1, a2);
          }

          ::org::antlr::v4::runtime::atn::ATNState Transition::_get_target() const
          {
            return ::org::antlr::v4::runtime::atn::ATNState(env->getObjectField(this$, fids$[fid_target]));
          }

          void Transition::_set_target(const ::org::antlr::v4::runtime::atn::ATNState & a0) const
          {
            env->setObjectField(this$, fids$[fid_target], a0.this$);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_Transition_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_Transition_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_Transition_getSerializationType(t_Transition *self);
          static PyObject *t_Transition_isEpsilon(t_Transition *self);
          static PyObject *t_Transition_matches(t_Transition *self, PyObject *args);
          static PyObject *t_Transition_get__target(t_Transition *self, void *data);
          static int t_Transition_set__target(t_Transition *self, PyObject *arg, void *data);

          static PyObject *t_Transition_get__epsilon(t_Transition *self, void *data);
          static PyObject *t_Transition_get__serializationType(t_Transition *self, void *data);
          static PyGetSetDef t_Transition__fields_[] = {
            DECLARE_GETSET_FIELD(t_Transition, target),
            DECLARE_GET_FIELD(t_Transition, epsilon),
            DECLARE_GET_FIELD(t_Transition, serializationType),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_Transition__methods_[] = {
            DECLARE_METHOD(t_Transition, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_Transition, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_Transition, getSerializationType, METH_NOARGS),
            DECLARE_METHOD(t_Transition, isEpsilon, METH_NOARGS),
            DECLARE_METHOD(t_Transition, matches, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(Transition)[] = {
            { Py_tp_methods, t_Transition__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_Transition__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(Transition)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(Transition, t_Transition, Transition);

          void t_Transition::install(PyObject *module)
          {
            installType(&PY_TYPE(Transition), &PY_TYPE_DEF(Transition), module, "Transition", 0);
          }

          void t_Transition::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "class_", make_descriptor(Transition::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "wrapfn_", make_descriptor(t_Transition::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "boxfn_", make_descriptor(boxObject));
            env->getClass(Transition::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "ACTION", make_descriptor(Transition::ACTION));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "ATOM", make_descriptor(Transition::ATOM));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "EPSILON", make_descriptor(Transition::EPSILON));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "NOT_SET", make_descriptor(Transition::NOT_SET));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "PRECEDENCE", make_descriptor(Transition::PRECEDENCE));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "PREDICATE", make_descriptor(Transition::PREDICATE));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "RANGE", make_descriptor(Transition::RANGE));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "RULE", make_descriptor(Transition::RULE));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "SET", make_descriptor(Transition::SET));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "WILDCARD", make_descriptor(Transition::WILDCARD));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "serializationNames", make_descriptor(::java::util::t_List::wrap_Object(*Transition::serializationNames)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Transition), "serializationTypes", make_descriptor(::java::util::t_Map::wrap_Object(*Transition::serializationTypes)));
          }

          static PyObject *t_Transition_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, Transition::initializeClass, 1)))
              return NULL;
            return t_Transition::wrap_Object(Transition(((t_Transition *) arg)->object.this$));
          }
          static PyObject *t_Transition_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, Transition::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_Transition_getSerializationType(t_Transition *self)
          {
            jint result;
            OBJ_CALL(result = self->object.getSerializationType());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_Transition_isEpsilon(t_Transition *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.isEpsilon());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_Transition_matches(t_Transition *self, PyObject *args)
          {
            jint a0;
            jint a1;
            jint a2;
            jboolean result;

            if (!parseArgs(args, "III", &a0, &a1, &a2))
            {
              OBJ_CALL(result = self->object.matches(a0, a1, a2));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "matches", args);
            return NULL;
          }

          static PyObject *t_Transition_get__target(t_Transition *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATNState value((jobject) NULL);
            OBJ_CALL(value = self->object._get_target());
            return ::org::antlr::v4::runtime::atn::t_ATNState::wrap_Object(value);
          }
          static int t_Transition_set__target(t_Transition *self, PyObject *arg, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATNState value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNState::initializeClass, &value))
            {
              INT_CALL(self->object._set_target(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "target", arg);
            return -1;
          }

          static PyObject *t_Transition_get__epsilon(t_Transition *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isEpsilon());
            Py_RETURN_BOOL(value);
          }

          static PyObject *t_Transition_get__serializationType(t_Transition *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getSerializationType());
            return PyLong_FromLong((long) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/CharStream.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *CharStream::class$ = NULL;
        jmethodID *CharStream::mids$ = NULL;
        bool CharStream::live$ = false;

        jclass CharStream::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/CharStream");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_CharStream_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_CharStream_instance_(PyTypeObject *type, PyObject *arg);

        static PyMethodDef t_CharStream__methods_[] = {
          DECLARE_METHOD(t_CharStream, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_CharStream, instance_, METH_O | METH_CLASS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(CharStream)[] = {
          { Py_tp_methods, t_CharStream__methods_ },
          { Py_tp_init, (void *) abstract_init },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(CharStream)[] = {
          &PY_TYPE_DEF(::org::antlr::v4::runtime::IntStream),
          NULL
        };

        DEFINE_TYPE(CharStream, t_CharStream, CharStream);

        void t_CharStream::install(PyObject *module)
        {
          installType(&PY_TYPE(CharStream), &PY_TYPE_DEF(CharStream), module, "CharStream", 0);
        }

        void t_CharStream::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(CharStream), "class_", make_descriptor(CharStream::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(CharStream), "wrapfn_", make_descriptor(t_CharStream::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(CharStream), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_CharStream_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, CharStream::initializeClass, 1)))
            return NULL;
          return t_CharStream::wrap_Object(CharStream(((t_CharStream *) arg)->object.this$));
        }
        static PyObject *t_CharStream_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, CharStream::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/TokenSource.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/TokenFactory.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/Token.h"
#include "org/antlr/v4/runtime/CharStream.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *TokenSource::class$ = NULL;
        jmethodID *TokenSource::mids$ = NULL;
        bool TokenSource::live$ = false;

        jclass TokenSource::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/TokenSource");

            mids$ = new jmethodID[max_mid];
            mids$[mid_getCharPositionInLine_9972fcc56b44e79d] = env->getMethodID(cls, "getCharPositionInLine", "()I");
            mids$[mid_getInputStream_f3effd93aa48b2fd] = env->getMethodID(cls, "getInputStream", "()Lorg/antlr/v4/runtime/CharStream;");
            mids$[mid_getLine_9972fcc56b44e79d] = env->getMethodID(cls, "getLine", "()I");
            mids$[mid_getSourceName_db9b55ba01e03e4b] = env->getMethodID(cls, "getSourceName", "()Ljava/lang/String;");
            mids$[mid_getTokenFactory_9bf94c5de004cd3c] = env->getMethodID(cls, "getTokenFactory", "()Lorg/antlr/v4/runtime/TokenFactory;");
            mids$[mid_nextToken_ed548981de5895c4] = env->getMethodID(cls, "nextToken", "()Lorg/antlr/v4/runtime/Token;");
            mids$[mid_setTokenFactory_a25e147938e67e01] = env->getMethodID(cls, "setTokenFactory", "(Lorg/antlr/v4/runtime/TokenFactory;)V");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        jint TokenSource::getCharPositionInLine() const
        {
          return env->callIntMethod(this$, mids$[mid_getCharPositionInLine_9972fcc56b44e79d]);
        }

        ::org::antlr::v4::runtime::CharStream TokenSource::getInputStream() const
        {
          return ::org::antlr::v4::runtime::CharStream(env->callObjectMethod(this$, mids$[mid_getInputStream_f3effd93aa48b2fd]));
        }

        jint TokenSource::getLine() const
        {
          return env->callIntMethod(this$, mids$[mid_getLine_9972fcc56b44e79d]);
        }

        ::java::lang::String TokenSource::getSourceName() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSourceName_db9b55ba01e03e4b]));
        }

        ::org::antlr::v4::runtime::TokenFactory TokenSource::getTokenFactory() const
        {
          return ::org::antlr::v4::runtime::TokenFactory(env->callObjectMethod(this$, mids$[mid_getTokenFactory_9bf94c5de004cd3c]));
        }

        ::org::antlr::v4::runtime::Token TokenSource::nextToken() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_nextToken_ed548981de5895c4]));
        }

        void TokenSource::setTokenFactory(const ::org::antlr::v4::runtime::TokenFactory & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setTokenFactory_a25e147938e67e01], a0.this$);
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_TokenSource_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_TokenSource_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_TokenSource_getCharPositionInLine(t_TokenSource *self);
        static PyObject *t_TokenSource_getInputStream(t_TokenSource *self);
        static PyObject *t_TokenSource_getLine(t_TokenSource *self);
        static PyObject *t_TokenSource_getSourceName(t_TokenSource *self);
        static PyObject *t_TokenSource_getTokenFactory(t_TokenSource *self);
        static PyObject *t_TokenSource_nextToken(t_TokenSource *self);
        static PyObject *t_TokenSource_setTokenFactory(t_TokenSource *self, PyObject *arg);
        static PyObject *t_TokenSource_get__charPositionInLine(t_TokenSource *self, void *data);
        static PyObject *t_TokenSource_get__inputStream(t_TokenSource *self, void *data);
        static PyObject *t_TokenSource_get__line(t_TokenSource *self, void *data);
        static PyObject *t_TokenSource_get__sourceName(t_TokenSource *self, void *data);
        static PyObject *t_TokenSource_get__tokenFactory(t_TokenSource *self, void *data);
        static int t_TokenSource_set__tokenFactory(t_TokenSource *self, PyObject *arg, void *data);
        static PyGetSetDef t_TokenSource__fields_[] = {
          DECLARE_GET_FIELD(t_TokenSource, charPositionInLine),
          DECLARE_GET_FIELD(t_TokenSource, inputStream),
          DECLARE_GET_FIELD(t_TokenSource, line),
          DECLARE_GET_FIELD(t_TokenSource, sourceName),
          DECLARE_GETSET_FIELD(t_TokenSource, tokenFactory),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_TokenSource__methods_[] = {
          DECLARE_METHOD(t_TokenSource, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_TokenSource, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_TokenSource, getCharPositionInLine, METH_NOARGS),
          DECLARE_METHOD(t_TokenSource, getInputStream, METH_NOARGS),
          DECLARE_METHOD(t_TokenSource, getLine, METH_NOARGS),
          DECLARE_METHOD(t_TokenSource, getSourceName, METH_NOARGS),
          DECLARE_METHOD(t_TokenSource, getTokenFactory, METH_NOARGS),
          DECLARE_METHOD(t_TokenSource, nextToken, METH_NOARGS),
          DECLARE_METHOD(t_TokenSource, setTokenFactory, METH_O),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(TokenSource)[] = {
          { Py_tp_methods, t_TokenSource__methods_ },
          { Py_tp_init, (void *) abstract_init },
          { Py_tp_getset, t_TokenSource__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(TokenSource)[] = {
          &PY_TYPE_DEF(::java::lang::Object),
          NULL
        };

        DEFINE_TYPE(TokenSource, t_TokenSource, TokenSource);

        void t_TokenSource::install(PyObject *module)
        {
          installType(&PY_TYPE(TokenSource), &PY_TYPE_DEF(TokenSource), module, "TokenSource", 0);
        }

        void t_TokenSource::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(TokenSource), "class_", make_descriptor(TokenSource::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(TokenSource), "wrapfn_", make_descriptor(t_TokenSource::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(TokenSource), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_TokenSource_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, TokenSource::initializeClass, 1)))
            return NULL;
          return t_TokenSource::wrap_Object(TokenSource(((t_TokenSource *) arg)->object.this$));
        }
        static PyObject *t_TokenSource_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, TokenSource::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_TokenSource_getCharPositionInLine(t_TokenSource *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getCharPositionInLine());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_TokenSource_getInputStream(t_TokenSource *self)
        {
          ::org::antlr::v4::runtime::CharStream result((jobject) NULL);
          OBJ_CALL(result = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_CharStream::wrap_Object(result);
        }

        static PyObject *t_TokenSource_getLine(t_TokenSource *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getLine());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_TokenSource_getSourceName(t_TokenSource *self)
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getSourceName());
          return j2p(result);
        }

        static PyObject *t_TokenSource_getTokenFactory(t_TokenSource *self)
        {
          ::org::antlr::v4::runtime::TokenFactory result((jobject) NULL);
          OBJ_CALL(result = self->object.getTokenFactory());
          return ::org::antlr::v4::runtime::t_TokenFactory::wrap_Object(result);
        }

        static PyObject *t_TokenSource_nextToken(t_TokenSource *self)
        {
          ::org::antlr::v4::runtime::Token result((jobject) NULL);
          OBJ_CALL(result = self->object.nextToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
        }

        static PyObject *t_TokenSource_setTokenFactory(t_TokenSource *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::TokenFactory a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArg(arg, "K", ::org::antlr::v4::runtime::TokenFactory::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_TokenFactory::parameters_))
          {
            OBJ_CALL(self->object.setTokenFactory(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setTokenFactory", arg);
          return NULL;
        }

        static PyObject *t_TokenSource_get__charPositionInLine(t_TokenSource *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getCharPositionInLine());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_TokenSource_get__inputStream(t_TokenSource *self, void *data)
        {
          ::org::antlr::v4::runtime::CharStream value((jobject) NULL);
          OBJ_CALL(value = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_CharStream::wrap_Object(value);
        }

        static PyObject *t_TokenSource_get__line(t_TokenSource *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getLine());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_TokenSource_get__sourceName(t_TokenSource *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object.getSourceName());
          return j2p(value);
        }

        static PyObject *t_TokenSource_get__tokenFactory(t_TokenSource *self, void *data)
        {
          ::org::antlr::v4::runtime::TokenFactory value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenFactory());
          return ::org::antlr::v4::runtime::t_TokenFactory::wrap_Object(value);
        }
        static int t_TokenSource_set__tokenFactory(t_TokenSource *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::TokenFactory value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::TokenFactory::initializeClass, &value))
            {
              INT_CALL(self->object.setTokenFactory(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "tokenFactory", arg);
          return -1;
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/RandomAccess.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *RandomAccess::class$ = NULL;
    jmethodID *RandomAccess::mids$ = NULL;
    bool RandomAccess::live$ = false;

    jclass RandomAccess::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/RandomAccess");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_RandomAccess_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_RandomAccess_instance_(PyTypeObject *type, PyObject *arg);

    static PyMethodDef t_RandomAccess__methods_[] = {
      DECLARE_METHOD(t_RandomAccess, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_RandomAccess, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(RandomAccess)[] = {
      { Py_tp_methods, t_RandomAccess__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(RandomAccess)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(RandomAccess, t_RandomAccess, RandomAccess);

    void t_RandomAccess::install(PyObject *module)
    {
      installType(&PY_TYPE(RandomAccess), &PY_TYPE_DEF(RandomAccess), module, "RandomAccess", 0);
    }

    void t_RandomAccess::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(RandomAccess), "class_", make_descriptor(RandomAccess::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(RandomAccess), "wrapfn_", make_descriptor(t_RandomAccess::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(RandomAccess), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_RandomAccess_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, RandomAccess::initializeClass, 1)))
        return NULL;
      return t_RandomAccess::wrap_Object(RandomAccess(((t_RandomAccess *) arg)->object.this$));
    }
    static PyObject *t_RandomAccess_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, RandomAccess::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/PredictionMode.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet.h"
#include "java/util/Map.h"
#include "java/util/Collection.h"
#include "org/antlr/v4/runtime/atn/PredictionMode.h"
#include "java/lang/Class.h"
#include "java/util/BitSet.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/ATNState.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *PredictionMode::class$ = NULL;
          jmethodID *PredictionMode::mids$ = NULL;
          bool PredictionMode::live$ = false;
          PredictionMode *PredictionMode::LL = NULL;
          PredictionMode *PredictionMode::LL_EXACT_AMBIG_DETECTION = NULL;
          PredictionMode *PredictionMode::SLL = NULL;

          jclass PredictionMode::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/PredictionMode");

              mids$ = new jmethodID[max_mid];
              mids$[mid_allConfigsInRuleStopStates_93c39a9023479e43] = env->getStaticMethodID(cls, "allConfigsInRuleStopStates", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Z");
              mids$[mid_allSubsetsConflict_15d9cc2398c22637] = env->getStaticMethodID(cls, "allSubsetsConflict", "(Ljava/util/Collection;)Z");
              mids$[mid_allSubsetsEqual_15d9cc2398c22637] = env->getStaticMethodID(cls, "allSubsetsEqual", "(Ljava/util/Collection;)Z");
              mids$[mid_getAlts_d58e25cdab3539e8] = env->getStaticMethodID(cls, "getAlts", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Ljava/util/BitSet;");
              mids$[mid_getAlts_81dcb69cb4e9e682] = env->getStaticMethodID(cls, "getAlts", "(Ljava/util/Collection;)Ljava/util/BitSet;");
              mids$[mid_getConflictingAltSubsets_f8ece6dc90eddfcd] = env->getStaticMethodID(cls, "getConflictingAltSubsets", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Ljava/util/Collection;");
              mids$[mid_getSingleViableAlt_d7a09af4629d2a96] = env->getStaticMethodID(cls, "getSingleViableAlt", "(Ljava/util/Collection;)I");
              mids$[mid_getStateToAltMap_574b2632dcf8c562] = env->getStaticMethodID(cls, "getStateToAltMap", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Ljava/util/Map;");
              mids$[mid_getUniqueAlt_d7a09af4629d2a96] = env->getStaticMethodID(cls, "getUniqueAlt", "(Ljava/util/Collection;)I");
              mids$[mid_hasConfigInRuleStopState_93c39a9023479e43] = env->getStaticMethodID(cls, "hasConfigInRuleStopState", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Z");
              mids$[mid_hasConflictingAltSet_15d9cc2398c22637] = env->getStaticMethodID(cls, "hasConflictingAltSet", "(Ljava/util/Collection;)Z");
              mids$[mid_hasNonConflictingAltSet_15d9cc2398c22637] = env->getStaticMethodID(cls, "hasNonConflictingAltSet", "(Ljava/util/Collection;)Z");
              mids$[mid_hasSLLConflictTerminatingPrediction_f5eb9200db4de401] = env->getStaticMethodID(cls, "hasSLLConflictTerminatingPrediction", "(Lorg/antlr/v4/runtime/atn/PredictionMode;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Z");
              mids$[mid_hasStateAssociatedWithOneAlt_93c39a9023479e43] = env->getStaticMethodID(cls, "hasStateAssociatedWithOneAlt", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Z");
              mids$[mid_resolvesToJustOneViableAlt_d7a09af4629d2a96] = env->getStaticMethodID(cls, "resolvesToJustOneViableAlt", "(Ljava/util/Collection;)I");
              mids$[mid_valueOf_afc48f6781c5532f] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lorg/antlr/v4/runtime/atn/PredictionMode;");
              mids$[mid_values_dd3bf809ee367b16] = env->getStaticMethodID(cls, "values", "()[Lorg/antlr/v4/runtime/atn/PredictionMode;");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              LL = new PredictionMode(env->getStaticObjectField(cls, "LL", "Lorg/antlr/v4/runtime/atn/PredictionMode;"));
              LL_EXACT_AMBIG_DETECTION = new PredictionMode(env->getStaticObjectField(cls, "LL_EXACT_AMBIG_DETECTION", "Lorg/antlr/v4/runtime/atn/PredictionMode;"));
              SLL = new PredictionMode(env->getStaticObjectField(cls, "SLL", "Lorg/antlr/v4/runtime/atn/PredictionMode;"));
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          jboolean PredictionMode::allConfigsInRuleStopStates(const ::org::antlr::v4::runtime::atn::ATNConfigSet & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticBooleanMethod(cls, mids$[mid_allConfigsInRuleStopStates_93c39a9023479e43], a0.this$);
          }

          jboolean PredictionMode::allSubsetsConflict(const ::java::util::Collection & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticBooleanMethod(cls, mids$[mid_allSubsetsConflict_15d9cc2398c22637], a0.this$);
          }

          jboolean PredictionMode::allSubsetsEqual(const ::java::util::Collection & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticBooleanMethod(cls, mids$[mid_allSubsetsEqual_15d9cc2398c22637], a0.this$);
          }

          ::java::util::BitSet PredictionMode::getAlts(const ::org::antlr::v4::runtime::atn::ATNConfigSet & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return ::java::util::BitSet(env->callStaticObjectMethod(cls, mids$[mid_getAlts_d58e25cdab3539e8], a0.this$));
          }

          ::java::util::BitSet PredictionMode::getAlts(const ::java::util::Collection & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return ::java::util::BitSet(env->callStaticObjectMethod(cls, mids$[mid_getAlts_81dcb69cb4e9e682], a0.this$));
          }

          ::java::util::Collection PredictionMode::getConflictingAltSubsets(const ::org::antlr::v4::runtime::atn::ATNConfigSet & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return ::java::util::Collection(env->callStaticObjectMethod(cls, mids$[mid_getConflictingAltSubsets_f8ece6dc90eddfcd], a0.this$));
          }

          jint PredictionMode::getSingleViableAlt(const ::java::util::Collection & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticIntMethod(cls, mids$[mid_getSingleViableAlt_d7a09af4629d2a96], a0.this$);
          }

          ::java::util::Map PredictionMode::getStateToAltMap(const ::org::antlr::v4::runtime::atn::ATNConfigSet & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return ::java::util::Map(env->callStaticObjectMethod(cls, mids$[mid_getStateToAltMap_574b2632dcf8c562], a0.this$));
          }

          jint PredictionMode::getUniqueAlt(const ::java::util::Collection & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticIntMethod(cls, mids$[mid_getUniqueAlt_d7a09af4629d2a96], a0.this$);
          }

          jboolean PredictionMode::hasConfigInRuleStopState(const ::org::antlr::v4::runtime::atn::ATNConfigSet & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticBooleanMethod(cls, mids$[mid_hasConfigInRuleStopState_93c39a9023479e43], a0.this$);
          }

          jboolean PredictionMode::hasConflictingAltSet(const ::java::util::Collection & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticBooleanMethod(cls, mids$[mid_hasConflictingAltSet_15d9cc2398c22637], a0.this$);
          }

          jboolean PredictionMode::hasNonConflictingAltSet(const ::java::util::Collection & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticBooleanMethod(cls, mids$[mid_hasNonConflictingAltSet_15d9cc2398c22637], a0.this$);
          }

          jboolean PredictionMode::hasSLLConflictTerminatingPrediction(const PredictionMode & a0, const ::org::antlr::v4::runtime::atn::ATNConfigSet & a1)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticBooleanMethod(cls, mids$[mid_hasSLLConflictTerminatingPrediction_f5eb9200db4de401], a0.this$, a1.this$);
          }

          jboolean PredictionMode::hasStateAssociatedWithOneAlt(const ::org::antlr::v4::runtime::atn::ATNConfigSet & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticBooleanMethod(cls, mids$[mid_hasStateAssociatedWithOneAlt_93c39a9023479e43], a0.this$);
          }

          jint PredictionMode::resolvesToJustOneViableAlt(const ::java::util::Collection & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return env->callStaticIntMethod(cls, mids$[mid_resolvesToJustOneViableAlt_d7a09af4629d2a96], a0.this$);
          }

          PredictionMode PredictionMode::valueOf(const ::java::lang::String & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return PredictionMode(env->callStaticObjectMethod(cls, mids$[mid_valueOf_afc48f6781c5532f], a0.this$));
          }

          JArray< PredictionMode > PredictionMode::values()
          {
            jclass cls = env->getClass(initializeClass);
            return JArray< PredictionMode >(env->callStaticObjectMethod(cls, mids$[mid_values_dd3bf809ee367b16]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_PredictionMode_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_of_(t_PredictionMode *self, PyObject *args);
          static PyObject *t_PredictionMode_allConfigsInRuleStopStates(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_allSubsetsConflict(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_allSubsetsEqual(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_getAlts(PyTypeObject *type, PyObject *args);
          static PyObject *t_PredictionMode_getConflictingAltSubsets(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_getSingleViableAlt(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_getStateToAltMap(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_getUniqueAlt(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_hasConfigInRuleStopState(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_hasConflictingAltSet(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_hasNonConflictingAltSet(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_hasSLLConflictTerminatingPrediction(PyTypeObject *type, PyObject *args);
          static PyObject *t_PredictionMode_hasStateAssociatedWithOneAlt(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_resolvesToJustOneViableAlt(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredictionMode_valueOf(PyTypeObject *type, PyObject *args);
          static PyObject *t_PredictionMode_values(PyTypeObject *type);
          static PyObject *t_PredictionMode_get__parameters_(t_PredictionMode *self, void *data);
          static PyGetSetDef t_PredictionMode__fields_[] = {
            DECLARE_GET_FIELD(t_PredictionMode, parameters_),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_PredictionMode__methods_[] = {
            DECLARE_METHOD(t_PredictionMode, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, of_, METH_VARARGS),
            DECLARE_METHOD(t_PredictionMode, allConfigsInRuleStopStates, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, allSubsetsConflict, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, allSubsetsEqual, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, getAlts, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, getConflictingAltSubsets, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, getSingleViableAlt, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, getStateToAltMap, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, getUniqueAlt, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, hasConfigInRuleStopState, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, hasConflictingAltSet, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, hasNonConflictingAltSet, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, hasSLLConflictTerminatingPrediction, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, hasStateAssociatedWithOneAlt, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, resolvesToJustOneViableAlt, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, valueOf, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_PredictionMode, values, METH_NOARGS | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(PredictionMode)[] = {
            { Py_tp_methods, t_PredictionMode__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_PredictionMode__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(PredictionMode)[] = {
            &PY_TYPE_DEF(::java::lang::Enum),
            NULL
          };

          DEFINE_TYPE(PredictionMode, t_PredictionMode, PredictionMode);
          PyObject *t_PredictionMode::wrap_Object(const PredictionMode& object, PyTypeObject *p0)
          {
            PyObject *obj = t_PredictionMode::wrap_Object(object);
            if (obj != NULL && obj != Py_None)
            {
              t_PredictionMode *self = (t_PredictionMode *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          PyObject *t_PredictionMode::wrap_jobject(const jobject& object, PyTypeObject *p0)
          {
            PyObject *obj = t_PredictionMode::wrap_jobject(object);
            if (obj != NULL && obj != Py_None)
            {
              t_PredictionMode *self = (t_PredictionMode *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          void t_PredictionMode::install(PyObject *module)
          {
            installType(&PY_TYPE(PredictionMode), &PY_TYPE_DEF(PredictionMode), module, "PredictionMode", 0);
          }

          void t_PredictionMode::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionMode), "class_", make_descriptor(PredictionMode::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionMode), "wrapfn_", make_descriptor(t_PredictionMode::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionMode), "boxfn_", make_descriptor(boxObject));
            env->getClass(PredictionMode::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionMode), "LL", make_descriptor(t_PredictionMode::wrap_Object(*PredictionMode::LL)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionMode), "LL_EXACT_AMBIG_DETECTION", make_descriptor(t_PredictionMode::wrap_Object(*PredictionMode::LL_EXACT_AMBIG_DETECTION)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredictionMode), "SLL", make_descriptor(t_PredictionMode::wrap_Object(*PredictionMode::SLL)));
          }

          static PyObject *t_PredictionMode_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, PredictionMode::initializeClass, 1)))
              return NULL;
            return t_PredictionMode::wrap_Object(PredictionMode(((t_PredictionMode *) arg)->object.this$));
          }
          static PyObject *t_PredictionMode_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, PredictionMode::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_PredictionMode_of_(t_PredictionMode *self, PyObject *args)
          {
            if (!parseArg(args, "T", 1, &(self->parameters)))
              Py_RETURN_SELF;
            return PyErr_SetArgsError((PyObject *) self, "of_", args);
          }

          static PyObject *t_PredictionMode_allConfigsInRuleStopStates(PyTypeObject *type, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNConfigSet a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::allConfigsInRuleStopStates(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError(type, "allConfigsInRuleStopStates", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_allSubsetsConflict(PyTypeObject *type, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::allSubsetsConflict(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError(type, "allSubsetsConflict", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_allSubsetsEqual(PyTypeObject *type, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::allSubsetsEqual(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError(type, "allSubsetsEqual", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_getAlts(PyTypeObject *type, PyObject *args)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 1:
              {
                ::org::antlr::v4::runtime::atn::ATNConfigSet a0((jobject) NULL);
                ::java::util::BitSet result((jobject) NULL);

                if (!parseArgs(args, "k", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, &a0))
                {
                  OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::getAlts(a0));
                  return ::java::util::t_BitSet::wrap_Object(result);
                }
              }
              {
                ::java::util::Collection a0((jobject) NULL);
                PyTypeObject **p0;
                ::java::util::BitSet result((jobject) NULL);

                if (!parseArgs(args, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
                {
                  OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::getAlts(a0));
                  return ::java::util::t_BitSet::wrap_Object(result);
                }
              }
            }

            PyErr_SetArgsError(type, "getAlts", args);
            return NULL;
          }

          static PyObject *t_PredictionMode_getConflictingAltSubsets(PyTypeObject *type, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNConfigSet a0((jobject) NULL);
            ::java::util::Collection result((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::getConflictingAltSubsets(a0));
              return ::java::util::t_Collection::wrap_Object(result, ::java::util::PY_TYPE(BitSet));
            }

            PyErr_SetArgsError(type, "getConflictingAltSubsets", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_getSingleViableAlt(PyTypeObject *type, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jint result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::getSingleViableAlt(a0));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError(type, "getSingleViableAlt", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_getStateToAltMap(PyTypeObject *type, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNConfigSet a0((jobject) NULL);
            ::java::util::Map result((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::getStateToAltMap(a0));
              return ::java::util::t_Map::wrap_Object(result, ::org::antlr::v4::runtime::atn::PY_TYPE(ATNState), ::java::util::PY_TYPE(BitSet));
            }

            PyErr_SetArgsError(type, "getStateToAltMap", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_getUniqueAlt(PyTypeObject *type, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jint result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::getUniqueAlt(a0));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError(type, "getUniqueAlt", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_hasConfigInRuleStopState(PyTypeObject *type, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNConfigSet a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::hasConfigInRuleStopState(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError(type, "hasConfigInRuleStopState", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_hasConflictingAltSet(PyTypeObject *type, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::hasConflictingAltSet(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError(type, "hasConflictingAltSet", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_hasNonConflictingAltSet(PyTypeObject *type, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::hasNonConflictingAltSet(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError(type, "hasNonConflictingAltSet", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_hasSLLConflictTerminatingPrediction(PyTypeObject *type, PyObject *args)
          {
            PredictionMode a0((jobject) NULL);
            PyTypeObject **p0;
            ::org::antlr::v4::runtime::atn::ATNConfigSet a1((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "Kk", PredictionMode::initializeClass, ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, &a0, &p0, t_PredictionMode::parameters_, &a1))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::hasSLLConflictTerminatingPrediction(a0, a1));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError(type, "hasSLLConflictTerminatingPrediction", args);
            return NULL;
          }

          static PyObject *t_PredictionMode_hasStateAssociatedWithOneAlt(PyTypeObject *type, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNConfigSet a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::hasStateAssociatedWithOneAlt(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError(type, "hasStateAssociatedWithOneAlt", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_resolvesToJustOneViableAlt(PyTypeObject *type, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jint result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::resolvesToJustOneViableAlt(a0));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError(type, "resolvesToJustOneViableAlt", arg);
            return NULL;
          }

          static PyObject *t_PredictionMode_valueOf(PyTypeObject *type, PyObject *args)
          {
            ::java::lang::String a0((jobject) NULL);
            PredictionMode result((jobject) NULL);

            if (!parseArgs(args, "s", &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::valueOf(a0));
              return t_PredictionMode::wrap_Object(result);
            }

            return callSuper(type, "valueOf", args, 2);
          }

          static PyObject *t_PredictionMode_values(PyTypeObject *type)
          {
            JArray< PredictionMode > result((jobject) NULL);
            OBJ_CALL(result = ::org::antlr::v4::runtime::atn::PredictionMode::values());
            return JArray<jobject>(result.this$).wrap(t_PredictionMode::wrap_jobject);
          }
          static PyObject *t_PredictionMode_get__parameters_(t_PredictionMode *self, void *data)
          {
            return typeParameters(self->parameters, sizeof(self->parameters));
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/ScheduledFuture.h"
#include "java/util/concurrent/Future.h"
#include "java/lang/Object.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *ScheduledFuture::class$ = NULL;
      jmethodID *ScheduledFuture::mids$ = NULL;
      bool ScheduledFuture::live$ = false;

      jclass ScheduledFuture::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/ScheduledFuture");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_ScheduledFuture_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ScheduledFuture_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ScheduledFuture_of_(t_ScheduledFuture *self, PyObject *args);
      static PyObject *t_ScheduledFuture_get__parameters_(t_ScheduledFuture *self, void *data);
      static PyGetSetDef t_ScheduledFuture__fields_[] = {
        DECLARE_GET_FIELD(t_ScheduledFuture, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_ScheduledFuture__methods_[] = {
        DECLARE_METHOD(t_ScheduledFuture, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ScheduledFuture, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ScheduledFuture, of_, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(ScheduledFuture)[] = {
        { Py_tp_methods, t_ScheduledFuture__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_ScheduledFuture__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(ScheduledFuture)[] = {
        &PY_TYPE_DEF(::java::util::concurrent::Delayed),
        NULL
      };

      DEFINE_TYPE(ScheduledFuture, t_ScheduledFuture, ScheduledFuture);
      PyObject *t_ScheduledFuture::wrap_Object(const ScheduledFuture& object, PyTypeObject *p0)
      {
        PyObject *obj = t_ScheduledFuture::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_ScheduledFuture *self = (t_ScheduledFuture *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_ScheduledFuture::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_ScheduledFuture::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_ScheduledFuture *self = (t_ScheduledFuture *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_ScheduledFuture::install(PyObject *module)
      {
        installType(&PY_TYPE(ScheduledFuture), &PY_TYPE_DEF(ScheduledFuture), module, "ScheduledFuture", 0);
      }

      void t_ScheduledFuture::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(ScheduledFuture), "class_", make_descriptor(ScheduledFuture::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ScheduledFuture), "wrapfn_", make_descriptor(t_ScheduledFuture::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ScheduledFuture), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_ScheduledFuture_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, ScheduledFuture::initializeClass, 1)))
          return NULL;
        return t_ScheduledFuture::wrap_Object(ScheduledFuture(((t_ScheduledFuture *) arg)->object.this$));
      }
      static PyObject *t_ScheduledFuture_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, ScheduledFuture::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_ScheduledFuture_of_(t_ScheduledFuture *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }
      static PyObject *t_ScheduledFuture_get__parameters_(t_ScheduledFuture *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/FileDescriptor.h"
#include "java/io/SyncFailedException.h"
#include "java/io/FileDescriptor.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *FileDescriptor::class$ = NULL;
    jmethodID *FileDescriptor::mids$ = NULL;
    bool FileDescriptor::live$ = false;
    FileDescriptor *FileDescriptor::err = NULL;
    FileDescriptor *FileDescriptor::in = NULL;
    FileDescriptor *FileDescriptor::out = NULL;

    jclass FileDescriptor::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/FileDescriptor");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_sync_f2cc1bce94666404] = env->getMethodID(cls, "sync", "()V");
        mids$[mid_valid_8454bd5aa23fd11e] = env->getMethodID(cls, "valid", "()Z");

        class$ = new ::java::lang::Class(cls);
        cls = (jclass) class$->this$;

        err = new FileDescriptor(env->getStaticObjectField(cls, "err", "Ljava/io/FileDescriptor;"));
        in = new FileDescriptor(env->getStaticObjectField(cls, "in", "Ljava/io/FileDescriptor;"));
        out = new FileDescriptor(env->getStaticObjectField(cls, "out", "Ljava/io/FileDescriptor;"));
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    FileDescriptor::FileDescriptor() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    void FileDescriptor::sync() const
    {
      env->callVoidMethod(this$, mids$[mid_sync_f2cc1bce94666404]);
    }

    jboolean FileDescriptor::valid() const
    {
      return env->callBooleanMethod(this$, mids$[mid_valid_8454bd5aa23fd11e]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_FileDescriptor_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_FileDescriptor_instance_(PyTypeObject *type, PyObject *arg);
    static int t_FileDescriptor_init_(t_FileDescriptor *self, PyObject *args, PyObject *kwds);
    static PyObject *t_FileDescriptor_sync(t_FileDescriptor *self);
    static PyObject *t_FileDescriptor_valid(t_FileDescriptor *self);

    static PyMethodDef t_FileDescriptor__methods_[] = {
      DECLARE_METHOD(t_FileDescriptor, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_FileDescriptor, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_FileDescriptor, sync, METH_NOARGS),
      DECLARE_METHOD(t_FileDescriptor, valid, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(FileDescriptor)[] = {
      { Py_tp_methods, t_FileDescriptor__methods_ },
      { Py_tp_init, (void *) t_FileDescriptor_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(FileDescriptor)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(FileDescriptor, t_FileDescriptor, FileDescriptor);

    void t_FileDescriptor::install(PyObject *module)
    {
      installType(&PY_TYPE(FileDescriptor), &PY_TYPE_DEF(FileDescriptor), module, "FileDescriptor", 0);
    }

    void t_FileDescriptor::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(FileDescriptor), "class_", make_descriptor(FileDescriptor::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FileDescriptor), "wrapfn_", make_descriptor(t_FileDescriptor::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FileDescriptor), "boxfn_", make_descriptor(boxObject));
      env->getClass(FileDescriptor::initializeClass);
      PyObject_SetAttrString((PyObject *) PY_TYPE(FileDescriptor), "err", make_descriptor(t_FileDescriptor::wrap_Object(*FileDescriptor::err)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FileDescriptor), "in", make_descriptor(t_FileDescriptor::wrap_Object(*FileDescriptor::in)));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FileDescriptor), "out", make_descriptor(t_FileDescriptor::wrap_Object(*FileDescriptor::out)));
    }

    static PyObject *t_FileDescriptor_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, FileDescriptor::initializeClass, 1)))
        return NULL;
      return t_FileDescriptor::wrap_Object(FileDescriptor(((t_FileDescriptor *) arg)->object.this$));
    }
    static PyObject *t_FileDescriptor_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, FileDescriptor::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_FileDescriptor_init_(t_FileDescriptor *self, PyObject *args, PyObject *kwds)
    {
      FileDescriptor object((jobject) NULL);

      INT_CALL(object = FileDescriptor());
      self->object = object;

      return 0;
    }

    static PyObject *t_FileDescriptor_sync(t_FileDescriptor *self)
    {
      OBJ_CALL(self->object.sync());
      Py_RETURN_NONE;
    }

    static PyObject *t_FileDescriptor_valid(t_FileDescriptor *self)
    {
      jboolean result;
      OBJ_CALL(result = self->object.valid());
      Py_RETURN_BOOL(result);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ParseInfo.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/atn/DecisionInfo.h"
#include "java/lang/Integer.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/atn/ProfilingATNSimulator.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ParseInfo::class$ = NULL;
          jmethodID *ParseInfo::mids$ = NULL;
          bool ParseInfo::live$ = false;

          jclass ParseInfo::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ParseInfo");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_11e1f3e69ddda4bd] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ProfilingATNSimulator;)V");
              mids$[mid_getDFASize_9972fcc56b44e79d] = env->getMethodID(cls, "getDFASize", "()I");
              mids$[mid_getDFASize_1e143afe1894d213] = env->getMethodID(cls, "getDFASize", "(I)I");
              mids$[mid_getDecisionInfo_7d2aa8394c2bb88e] = env->getMethodID(cls, "getDecisionInfo", "()[Lorg/antlr/v4/runtime/atn/DecisionInfo;");
              mids$[mid_getLLDecisions_49ec78390f08338a] = env->getMethodID(cls, "getLLDecisions", "()Ljava/util/List;");
              mids$[mid_getTotalATNLookaheadOps_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTotalATNLookaheadOps", "()J");
              mids$[mid_getTotalLLATNLookaheadOps_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTotalLLATNLookaheadOps", "()J");
              mids$[mid_getTotalLLLookaheadOps_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTotalLLLookaheadOps", "()J");
              mids$[mid_getTotalSLLATNLookaheadOps_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTotalSLLATNLookaheadOps", "()J");
              mids$[mid_getTotalSLLLookaheadOps_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTotalSLLLookaheadOps", "()J");
              mids$[mid_getTotalTimeInPrediction_2e5ae9edcb9b072f] = env->getMethodID(cls, "getTotalTimeInPrediction", "()J");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ParseInfo::ParseInfo(const ::org::antlr::v4::runtime::atn::ProfilingATNSimulator & a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_11e1f3e69ddda4bd, a0.this$)) {}

          jint ParseInfo::getDFASize() const
          {
            return env->callIntMethod(this$, mids$[mid_getDFASize_9972fcc56b44e79d]);
          }

          jint ParseInfo::getDFASize(jint a0) const
          {
            return env->callIntMethod(this$, mids$[mid_getDFASize_1e143afe1894d213], a0);
          }

          JArray< ::org::antlr::v4::runtime::atn::DecisionInfo > ParseInfo::getDecisionInfo() const
          {
            return JArray< ::org::antlr::v4::runtime::atn::DecisionInfo >(env->callObjectMethod(this$, mids$[mid_getDecisionInfo_7d2aa8394c2bb88e]));
          }

          ::java::util::List ParseInfo::getLLDecisions() const
          {
            return ::java::util::List(env->callObjectMethod(this$, mids$[mid_getLLDecisions_49ec78390f08338a]));
          }

          jlong ParseInfo::getTotalATNLookaheadOps() const
          {
            return env->callLongMethod(this$, mids$[mid_getTotalATNLookaheadOps_2e5ae9edcb9b072f]);
          }

          jlong ParseInfo::getTotalLLATNLookaheadOps() const
          {
            return env->callLongMethod(this$, mids$[mid_getTotalLLATNLookaheadOps_2e5ae9edcb9b072f]);
          }

          jlong ParseInfo::getTotalLLLookaheadOps() const
          {
            return env->callLongMethod(this$, mids$[mid_getTotalLLLookaheadOps_2e5ae9edcb9b072f]);
          }

          jlong ParseInfo::getTotalSLLATNLookaheadOps() const
          {
            return env->callLongMethod(this$, mids$[mid_getTotalSLLATNLookaheadOps_2e5ae9edcb9b072f]);
          }

          jlong ParseInfo::getTotalSLLLookaheadOps() const
          {
            return env->callLongMethod(this$, mids$[mid_getTotalSLLLookaheadOps_2e5ae9edcb9b072f]);
          }

          jlong ParseInfo::getTotalTimeInPrediction() const
          {
            return env->callLongMethod(this$, mids$[mid_getTotalTimeInPrediction_2e5ae9edcb9b072f]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ParseInfo_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ParseInfo_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ParseInfo_init_(t_ParseInfo *self, PyObject *args, PyObject *kwds);
          static PyObject *t_ParseInfo_getDFASize(t_ParseInfo *self, PyObject *args);
          static PyObject *t_ParseInfo_getDecisionInfo(t_ParseInfo *self);
          static PyObject *t_ParseInfo_getLLDecisions(t_ParseInfo *self);
          static PyObject *t_ParseInfo_getTotalATNLookaheadOps(t_ParseInfo *self);
          static PyObject *t_ParseInfo_getTotalLLATNLookaheadOps(t_ParseInfo *self);
          static PyObject *t_ParseInfo_getTotalLLLookaheadOps(t_ParseInfo *self);
          static PyObject *t_ParseInfo_getTotalSLLATNLookaheadOps(t_ParseInfo *self);
          static PyObject *t_ParseInfo_getTotalSLLLookaheadOps(t_ParseInfo *self);
          static PyObject *t_ParseInfo_getTotalTimeInPrediction(t_ParseInfo *self);
          static PyObject *t_ParseInfo_get__dFASize(t_ParseInfo *self, void *data);
          static PyObject *t_ParseInfo_get__decisionInfo(t_ParseInfo *self, void *data);
          static PyObject *t_ParseInfo_get__lLDecisions(t_ParseInfo *self, void *data);
          static PyObject *t_ParseInfo_get__totalATNLookaheadOps(t_ParseInfo *self, void *data);
          static PyObject *t_ParseInfo_get__totalLLATNLookaheadOps(t_ParseInfo *self, void *data);
          static PyObject *t_ParseInfo_get__totalLLLookaheadOps(t_ParseInfo *self, void *data);
          static PyObject *t_ParseInfo_get__totalSLLATNLookaheadOps(t_ParseInfo *self, void *data);
          static PyObject *t_ParseInfo_get__totalSLLLookaheadOps(t_ParseInfo *self, void *data);
          static PyObject *t_ParseInfo_get__totalTimeInPrediction(t_ParseInfo *self, void *data);
          static PyGetSetDef t_ParseInfo__fields_[] = {
            DECLARE_GET_FIELD(t_ParseInfo, dFASize),
            DECLARE_GET_FIELD(t_ParseInfo, decisionInfo),
            DECLARE_GET_FIELD(t_ParseInfo, lLDecisions),
            DECLARE_GET_FIELD(t_ParseInfo, totalATNLookaheadOps),
            DECLARE_GET_FIELD(t_ParseInfo, totalLLATNLookaheadOps),
            DECLARE_GET_FIELD(t_ParseInfo, totalLLLookaheadOps),
            DECLARE_GET_FIELD(t_ParseInfo, totalSLLATNLookaheadOps),
            DECLARE_GET_FIELD(t_ParseInfo, totalSLLLookaheadOps),
            DECLARE_GET_FIELD(t_ParseInfo, totalTimeInPrediction),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ParseInfo__methods_[] = {
            DECLARE_METHOD(t_ParseInfo, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ParseInfo, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ParseInfo, getDFASize, METH_VARARGS),
            DECLARE_METHOD(t_ParseInfo, getDecisionInfo, METH_NOARGS),
            DECLARE_METHOD(t_ParseInfo, getLLDecisions, METH_NOARGS),
            DECLARE_METHOD(t_ParseInfo, getTotalATNLookaheadOps, METH_NOARGS),
            DECLARE_METHOD(t_ParseInfo, getTotalLLATNLookaheadOps, METH_NOARGS),
            DECLARE_METHOD(t_ParseInfo, getTotalLLLookaheadOps, METH_NOARGS),
            DECLARE_METHOD(t_ParseInfo, getTotalSLLATNLookaheadOps, METH_NOARGS),
            DECLARE_METHOD(t_ParseInfo, getTotalSLLLookaheadOps, METH_NOARGS),
            DECLARE_METHOD(t_ParseInfo, getTotalTimeInPrediction, METH_NOARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ParseInfo)[] = {
            { Py_tp_methods, t_ParseInfo__methods_ },
            { Py_tp_init, (void *) t_ParseInfo_init_ },
            { Py_tp_getset, t_ParseInfo__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ParseInfo)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(ParseInfo, t_ParseInfo, ParseInfo);

          void t_ParseInfo::install(PyObject *module)
          {
            installType(&PY_TYPE(ParseInfo), &PY_TYPE_DEF(ParseInfo), module, "ParseInfo", 0);
          }

          void t_ParseInfo::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParseInfo), "class_", make_descriptor(ParseInfo::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParseInfo), "wrapfn_", make_descriptor(t_ParseInfo::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ParseInfo), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_ParseInfo_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ParseInfo::initializeClass, 1)))
              return NULL;
            return t_ParseInfo::wrap_Object(ParseInfo(((t_ParseInfo *) arg)->object.this$));
          }
          static PyObject *t_ParseInfo_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ParseInfo::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ParseInfo_init_(t_ParseInfo *self, PyObject *args, PyObject *kwds)
          {
            ::org::antlr::v4::runtime::atn::ProfilingATNSimulator a0((jobject) NULL);
            ParseInfo object((jobject) NULL);

            if (!parseArgs(args, "k", ::org::antlr::v4::runtime::atn::ProfilingATNSimulator::initializeClass, &a0))
            {
              INT_CALL(object = ParseInfo(a0));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_ParseInfo_getDFASize(t_ParseInfo *self, PyObject *args)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 0:
              {
                jint result;
                OBJ_CALL(result = self->object.getDFASize());
                return PyLong_FromLong((long) result);
              }
              break;
             case 1:
              {
                jint a0;
                jint result;

                if (!parseArgs(args, "I", &a0))
                {
                  OBJ_CALL(result = self->object.getDFASize(a0));
                  return PyLong_FromLong((long) result);
                }
              }
            }

            PyErr_SetArgsError((PyObject *) self, "getDFASize", args);
            return NULL;
          }

          static PyObject *t_ParseInfo_getDecisionInfo(t_ParseInfo *self)
          {
            JArray< ::org::antlr::v4::runtime::atn::DecisionInfo > result((jobject) NULL);
            OBJ_CALL(result = self->object.getDecisionInfo());
            return JArray<jobject>(result.this$).wrap(::org::antlr::v4::runtime::atn::t_DecisionInfo::wrap_jobject);
          }

          static PyObject *t_ParseInfo_getLLDecisions(t_ParseInfo *self)
          {
            ::java::util::List result((jobject) NULL);
            OBJ_CALL(result = self->object.getLLDecisions());
            return ::java::util::t_List::wrap_Object(result, ::java::lang::PY_TYPE(Integer));
          }

          static PyObject *t_ParseInfo_getTotalATNLookaheadOps(t_ParseInfo *self)
          {
            jlong result;
            OBJ_CALL(result = self->object.getTotalATNLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) result);
          }

          static PyObject *t_ParseInfo_getTotalLLATNLookaheadOps(t_ParseInfo *self)
          {
            jlong result;
            OBJ_CALL(result = self->object.getTotalLLATNLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) result);
          }

          static PyObject *t_ParseInfo_getTotalLLLookaheadOps(t_ParseInfo *self)
          {
            jlong result;
            OBJ_CALL(result = self->object.getTotalLLLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) result);
          }

          static PyObject *t_ParseInfo_getTotalSLLATNLookaheadOps(t_ParseInfo *self)
          {
            jlong result;
            OBJ_CALL(result = self->object.getTotalSLLATNLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) result);
          }

          static PyObject *t_ParseInfo_getTotalSLLLookaheadOps(t_ParseInfo *self)
          {
            jlong result;
            OBJ_CALL(result = self->object.getTotalSLLLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) result);
          }

          static PyObject *t_ParseInfo_getTotalTimeInPrediction(t_ParseInfo *self)
          {
            jlong result;
            OBJ_CALL(result = self->object.getTotalTimeInPrediction());
            return PyLong_FromLongLong((PY_LONG_LONG) result);
          }

          static PyObject *t_ParseInfo_get__dFASize(t_ParseInfo *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getDFASize());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_ParseInfo_get__decisionInfo(t_ParseInfo *self, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::DecisionInfo > value((jobject) NULL);
            OBJ_CALL(value = self->object.getDecisionInfo());
            return JArray<jobject>(value.this$).wrap(::org::antlr::v4::runtime::atn::t_DecisionInfo::wrap_jobject);
          }

          static PyObject *t_ParseInfo_get__lLDecisions(t_ParseInfo *self, void *data)
          {
            ::java::util::List value((jobject) NULL);
            OBJ_CALL(value = self->object.getLLDecisions());
            return ::java::util::t_List::wrap_Object(value);
          }

          static PyObject *t_ParseInfo_get__totalATNLookaheadOps(t_ParseInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object.getTotalATNLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }

          static PyObject *t_ParseInfo_get__totalLLATNLookaheadOps(t_ParseInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object.getTotalLLATNLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }

          static PyObject *t_ParseInfo_get__totalLLLookaheadOps(t_ParseInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object.getTotalLLLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }

          static PyObject *t_ParseInfo_get__totalSLLATNLookaheadOps(t_ParseInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object.getTotalSLLATNLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }

          static PyObject *t_ParseInfo_get__totalSLLLookaheadOps(t_ParseInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object.getTotalSLLLookaheadOps());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }

          static PyObject *t_ParseInfo_get__totalTimeInPrediction(t_ParseInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object.getTotalTimeInPrediction());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/ToDoubleFunction.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *ToDoubleFunction::class$ = NULL;
      jmethodID *ToDoubleFunction::mids$ = NULL;
      bool ToDoubleFunction::live$ = false;

      jclass ToDoubleFunction::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/ToDoubleFunction");

          mids$ = new jmethodID[max_mid];
          mids$[mid_applyAsDouble_843b86a1c273f622] = env->getMethodID(cls, "applyAsDouble", "(Ljava/lang/Object;)D");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jdouble ToDoubleFunction::applyAsDouble(const ::java::lang::Object & a0) const
      {
        return env->callDoubleMethod(this$, mids$[mid_applyAsDouble_843b86a1c273f622], a0.this$);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_ToDoubleFunction_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ToDoubleFunction_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_ToDoubleFunction_of_(t_ToDoubleFunction *self, PyObject *args);
      static PyObject *t_ToDoubleFunction_applyAsDouble(t_ToDoubleFunction *self, PyObject *arg);
      static PyObject *t_ToDoubleFunction_get__parameters_(t_ToDoubleFunction *self, void *data);
      static PyGetSetDef t_ToDoubleFunction__fields_[] = {
        DECLARE_GET_FIELD(t_ToDoubleFunction, parameters_),
        { NULL, NULL, NULL, NULL, NULL }
      };

      static PyMethodDef t_ToDoubleFunction__methods_[] = {
        DECLARE_METHOD(t_ToDoubleFunction, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ToDoubleFunction, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_ToDoubleFunction, of_, METH_VARARGS),
        DECLARE_METHOD(t_ToDoubleFunction, applyAsDouble, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(ToDoubleFunction)[] = {
        { Py_tp_methods, t_ToDoubleFunction__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { Py_tp_getset, t_ToDoubleFunction__fields_ },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(ToDoubleFunction)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(ToDoubleFunction, t_ToDoubleFunction, ToDoubleFunction);
      PyObject *t_ToDoubleFunction::wrap_Object(const ToDoubleFunction& object, PyTypeObject *p0)
      {
        PyObject *obj = t_ToDoubleFunction::wrap_Object(object);
        if (obj != NULL && obj != Py_None)
        {
          t_ToDoubleFunction *self = (t_ToDoubleFunction *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      PyObject *t_ToDoubleFunction::wrap_jobject(const jobject& object, PyTypeObject *p0)
      {
        PyObject *obj = t_ToDoubleFunction::wrap_jobject(object);
        if (obj != NULL && obj != Py_None)
        {
          t_ToDoubleFunction *self = (t_ToDoubleFunction *) obj;
          self->parameters[0] = p0;
        }
        return obj;
      }

      void t_ToDoubleFunction::install(PyObject *module)
      {
        installType(&PY_TYPE(ToDoubleFunction), &PY_TYPE_DEF(ToDoubleFunction), module, "ToDoubleFunction", 0);
      }

      void t_ToDoubleFunction::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(ToDoubleFunction), "class_", make_descriptor(ToDoubleFunction::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ToDoubleFunction), "wrapfn_", make_descriptor(t_ToDoubleFunction::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(ToDoubleFunction), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_ToDoubleFunction_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, ToDoubleFunction::initializeClass, 1)))
          return NULL;
        return t_ToDoubleFunction::wrap_Object(ToDoubleFunction(((t_ToDoubleFunction *) arg)->object.this$));
      }
      static PyObject *t_ToDoubleFunction_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, ToDoubleFunction::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_ToDoubleFunction_of_(t_ToDoubleFunction *self, PyObject *args)
      {
        if (!parseArg(args, "T", 1, &(self->parameters)))
          Py_RETURN_SELF;
        return PyErr_SetArgsError((PyObject *) self, "of_", args);
      }

      static PyObject *t_ToDoubleFunction_applyAsDouble(t_ToDoubleFunction *self, PyObject *arg)
      {
        ::java::lang::Object a0((jobject) NULL);
        jdouble result;

        if (!parseArg(arg, "O", self->parameters[0], &a0))
        {
          OBJ_CALL(result = self->object.applyAsDouble(a0));
          return PyFloat_FromDouble((double) result);
        }

        PyErr_SetArgsError((PyObject *) self, "applyAsDouble", arg);
        return NULL;
      }
      static PyObject *t_ToDoubleFunction_get__parameters_(t_ToDoubleFunction *self, void *data)
      {
        return typeParameters(self->parameters, sizeof(self->parameters));
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/regex/Matcher.h"
#include "java/util/regex/Matcher.h"
#include "java/util/regex/MatchResult.h"
#include "java/lang/Class.h"
#include "java/util/regex/Pattern.h"
#include "java/lang/String.h"
#include "java/lang/CharSequence.h"
#include "java/lang/StringBuffer.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace regex {

      ::java::lang::Class *Matcher::class$ = NULL;
      jmethodID *Matcher::mids$ = NULL;
      bool Matcher::live$ = false;

      jclass Matcher::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/regex/Matcher");

          mids$ = new jmethodID[max_mid];
          mids$[mid_appendReplacement_4a6a8eee68ae3f14] = env->getMethodID(cls, "appendReplacement", "(Ljava/lang/StringBuffer;Ljava/lang/String;)Ljava/util/regex/Matcher;");
          mids$[mid_appendTail_9e0b91680059c0b9] = env->getMethodID(cls, "appendTail", "(Ljava/lang/StringBuffer;)Ljava/lang/StringBuffer;");
          mids$[mid_end_9972fcc56b44e79d] = env->getMethodID(cls, "end", "()I");
          mids$[mid_end_a5a7d1128e9e2bb7] = env->getMethodID(cls, "end", "(Ljava/lang/String;)I");
          mids$[mid_end_1e143afe1894d213] = env->getMethodID(cls, "end", "(I)I");
          mids$[mid_find_8454bd5aa23fd11e] = env->getMethodID(cls, "find", "()Z");
          mids$[mid_find_a1d30e1ee40c89a2] = env->getMethodID(cls, "find", "(I)Z");
          mids$[mid_group_db9b55ba01e03e4b] = env->getMethodID(cls, "group", "()Ljava/lang/String;");
          mids$[mid_group_9bfa75c9f141b67f] = env->getMethodID(cls, "group", "(Ljava/lang/String;)Ljava/lang/String;");
          mids$[mid_group_d7593acad64ef635] = env->getMethodID(cls, "group", "(I)Ljava/lang/String;");
          mids$[mid_groupCount_9972fcc56b44e79d] = env->getMethodID(cls, "groupCount", "()I");
          mids$[mid_hasAnchoringBounds_8454bd5aa23fd11e] = env->getMethodID(cls, "hasAnchoringBounds", "()Z");
          mids$[mid_hasTransparentBounds_8454bd5aa23fd11e] = env->getMethodID(cls, "hasTransparentBounds", "()Z");
          mids$[mid_hitEnd_8454bd5aa23fd11e] = env->getMethodID(cls, "hitEnd", "()Z");
          mids$[mid_lookingAt_8454bd5aa23fd11e] = env->getMethodID(cls, "lookingAt", "()Z");
          mids$[mid_matches_8454bd5aa23fd11e] = env->getMethodID(cls, "matches", "()Z");
          mids$[mid_pattern_8b5e65d345ff91eb] = env->getMethodID(cls, "pattern", "()Ljava/util/regex/Pattern;");
          mids$[mid_quoteReplacement_9bfa75c9f141b67f] = env->getStaticMethodID(cls, "quoteReplacement", "(Ljava/lang/String;)Ljava/lang/String;");
          mids$[mid_region_e5696c255f1f4bab] = env->getMethodID(cls, "region", "(II)Ljava/util/regex/Matcher;");
          mids$[mid_regionEnd_9972fcc56b44e79d] = env->getMethodID(cls, "regionEnd", "()I");
          mids$[mid_regionStart_9972fcc56b44e79d] = env->getMethodID(cls, "regionStart", "()I");
          mids$[mid_replaceAll_9bfa75c9f141b67f] = env->getMethodID(cls, "replaceAll", "(Ljava/lang/String;)Ljava/lang/String;");
          mids$[mid_replaceFirst_9bfa75c9f141b67f] = env->getMethodID(cls, "replaceFirst", "(Ljava/lang/String;)Ljava/lang/String;");
          mids$[mid_requireEnd_8454bd5aa23fd11e] = env->getMethodID(cls, "requireEnd", "()Z");
          mids$[mid_reset_6799eb40a862b2af] = env->getMethodID(cls, "reset", "()Ljava/util/regex/Matcher;");
          mids$[mid_reset_bf97a5101a89a457] = env->getMethodID(cls, "reset", "(Ljava/lang/CharSequence;)Ljava/util/regex/Matcher;");
          mids$[mid_start_9972fcc56b44e79d] = env->getMethodID(cls, "start", "()I");
          mids$[mid_start_a5a7d1128e9e2bb7] = env->getMethodID(cls, "start", "(Ljava/lang/String;)I");
          mids$[mid_start_1e143afe1894d213] = env->getMethodID(cls, "start", "(I)I");
          mids$[mid_toMatchResult_ffa6e5ff23a41621] = env->getMethodID(cls, "toMatchResult", "()Ljava/util/regex/MatchResult;");
          mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
          mids$[mid_useAnchoringBounds_d16614ca53fd6060] = env->getMethodID(cls, "useAnchoringBounds", "(Z)Ljava/util/regex/Matcher;");
          mids$[mid_usePattern_1e9850baaeefa70f] = env->getMethodID(cls, "usePattern", "(Ljava/util/regex/Pattern;)Ljava/util/regex/Matcher;");
          mids$[mid_useTransparentBounds_d16614ca53fd6060] = env->getMethodID(cls, "useTransparentBounds", "(Z)Ljava/util/regex/Matcher;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      Matcher Matcher::appendReplacement(const ::java::lang::StringBuffer & a0, const ::java::lang::String & a1) const
      {
        return Matcher(env->callObjectMethod(this$, mids$[mid_appendReplacement_4a6a8eee68ae3f14], a0.this$, a1.this$));
      }

      ::java::lang::StringBuffer Matcher::appendTail(const ::java::lang::StringBuffer & a0) const
      {
        return ::java::lang::StringBuffer(env->callObjectMethod(this$, mids$[mid_appendTail_9e0b91680059c0b9], a0.this$));
      }

      jint Matcher::end() const
      {
        return env->callIntMethod(this$, mids$[mid_end_9972fcc56b44e79d]);
      }

      jint Matcher::end(const ::java::lang::String & a0) const
      {
        return env->callIntMethod(this$, mids$[mid_end_a5a7d1128e9e2bb7], a0.this$);
      }

      jint Matcher::end(jint a0) const
      {
        return env->callIntMethod(this$, mids$[mid_end_1e143afe1894d213], a0);
      }

      jboolean Matcher::find() const
      {
        return env->callBooleanMethod(this$, mids$[mid_find_8454bd5aa23fd11e]);
      }

      jboolean Matcher::find(jint a0) const
      {
        return env->callBooleanMethod(this$, mids$[mid_find_a1d30e1ee40c89a2], a0);
      }

      ::java::lang::String Matcher::group() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_group_db9b55ba01e03e4b]));
      }

      ::java::lang::String Matcher::group(const ::java::lang::String & a0) const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_group_9bfa75c9f141b67f], a0.this$));
      }

      ::java::lang::String Matcher::group(jint a0) const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_group_d7593acad64ef635], a0));
      }

      jint Matcher::groupCount() const
      {
        return env->callIntMethod(this$, mids$[mid_groupCount_9972fcc56b44e79d]);
      }

      jboolean Matcher::hasAnchoringBounds() const
      {
        return env->callBooleanMethod(this$, mids$[mid_hasAnchoringBounds_8454bd5aa23fd11e]);
      }

      jboolean Matcher::hasTransparentBounds() const
      {
        return env->callBooleanMethod(this$, mids$[mid_hasTransparentBounds_8454bd5aa23fd11e]);
      }

      jboolean Matcher::hitEnd() const
      {
        return env->callBooleanMethod(this$, mids$[mid_hitEnd_8454bd5aa23fd11e]);
      }

      jboolean Matcher::lookingAt() const
      {
        return env->callBooleanMethod(this$, mids$[mid_lookingAt_8454bd5aa23fd11e]);
      }

      jboolean Matcher::matches() const
      {
        return env->callBooleanMethod(this$, mids$[mid_matches_8454bd5aa23fd11e]);
      }

      ::java::util::regex::Pattern Matcher::pattern() const
      {
        return ::java::util::regex::Pattern(env->callObjectMethod(this$, mids$[mid_pattern_8b5e65d345ff91eb]));
      }

      ::java::lang::String Matcher::quoteReplacement(const ::java::lang::String & a0)
      {
        jclass cls = env->getClass(initializeClass);
        return ::java::lang::String(env->callStaticObjectMethod(cls, mids$[mid_quoteReplacement_9bfa75c9f141b67f], a0.this$));
      }

      Matcher Matcher::region(jint a0, jint a1) const
      {
        return Matcher(env->callObjectMethod(this$, mids$[mid_region_e5696c255f1f4bab], a0, a1));
      }

      jint Matcher::regionEnd() const
      {
        return env->callIntMethod(this$, mids$[mid_regionEnd_9972fcc56b44e79d]);
      }

      jint Matcher::regionStart() const
      {
        return env->callIntMethod(this$, mids$[mid_regionStart_9972fcc56b44e79d]);
      }

      ::java::lang::String Matcher::replaceAll(const ::java::lang::String & a0) const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_replaceAll_9bfa75c9f141b67f], a0.this$));
      }

      ::java::lang::String Matcher::replaceFirst(const ::java::lang::String & a0) const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_replaceFirst_9bfa75c9f141b67f], a0.this$));
      }

      jboolean Matcher::requireEnd() const
      {
        return env->callBooleanMethod(this$, mids$[mid_requireEnd_8454bd5aa23fd11e]);
      }

      Matcher Matcher::reset() const
      {
        return Matcher(env->callObjectMethod(this$, mids$[mid_reset_6799eb40a862b2af]));
      }

      Matcher Matcher::reset(const ::java::lang::CharSequence & a0) const
      {
        return Matcher(env->callObjectMethod(this$, mids$[mid_reset_bf97a5101a89a457], a0.this$));
      }

      jint Matcher::start() const
      {
        return env->callIntMethod(this$, mids$[mid_start_9972fcc56b44e79d]);
      }

      jint Matcher::start(const ::java::lang::String & a0) const
      {
        return env->callIntMethod(this$, mids$[mid_start_a5a7d1128e9e2bb7], a0.this$);
      }

      jint Matcher::start(jint a0) const
      {
        return env->callIntMethod(this$, mids$[mid_start_1e143afe1894d213], a0);
      }

      ::java::util::regex::MatchResult Matcher::toMatchResult() const
      {
        return ::java::util::regex::MatchResult(env->callObjectMethod(this$, mids$[mid_toMatchResult_ffa6e5ff23a41621]));
      }

      ::java::lang::String Matcher::toString() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
      }

      Matcher Matcher::useAnchoringBounds(jboolean a0) const
      {
        return Matcher(env->callObjectMethod(this$, mids$[mid_useAnchoringBounds_d16614ca53fd6060], a0));
      }

      Matcher Matcher::usePattern(const ::java::util::regex::Pattern & a0) const
      {
        return Matcher(env->callObjectMethod(this$, mids$[mid_usePattern_1e9850baaeefa70f], a0.this$));
      }

      Matcher Matcher::useTransparentBounds(jboolean a0) const
      {
        return Matcher(env->callObjectMethod(this$, mids$[mid_useTransparentBounds_d16614ca53fd6060], a0));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace regex {
      static PyObject *t_Matcher_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Matcher_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Matcher_appendReplacement(t_Matcher *self, PyObject *args);
      static PyObject *t_Matcher_appendTail(t_Matcher *self, PyObject *arg);
      static PyObject *t_Matcher_end(t_Matcher *self, PyObject *args);
      static PyObject *t_Matcher_find(t_Matcher *self, PyObject *args);
      static PyObject *t_Matcher_group(t_Matcher *self, PyObject *args);
      static PyObject *t_Matcher_groupCount(t_Matcher *self);
      static PyObject *t_Matcher_hasAnchoringBounds(t_Matcher *self);
      static PyObject *t_Matcher_hasTransparentBounds(t_Matcher *self);
      static PyObject *t_Matcher_hitEnd(t_Matcher *self);
      static PyObject *t_Matcher_lookingAt(t_Matcher *self);
      static PyObject *t_Matcher_matches(t_Matcher *self);
      static PyObject *t_Matcher_pattern(t_Matcher *self);
      static PyObject *t_Matcher_quoteReplacement(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Matcher_region(t_Matcher *self, PyObject *args);
      static PyObject *t_Matcher_regionEnd(t_Matcher *self);
      static PyObject *t_Matcher_regionStart(t_Matcher *self);
      static PyObject *t_Matcher_replaceAll(t_Matcher *self, PyObject *arg);
      static PyObject *t_Matcher_replaceFirst(t_Matcher *self, PyObject *arg);
      static PyObject *t_Matcher_requireEnd(t_Matcher *self);
      static PyObject *t_Matcher_reset(t_Matcher *self, PyObject *args);
      static PyObject *t_Matcher_start(t_Matcher *self, PyObject *args);
      static PyObject *t_Matcher_toMatchResult(t_Matcher *self);
      static PyObject *t_Matcher_toString(t_Matcher *self, PyObject *args);
      static PyObject *t_Matcher_useAnchoringBounds(t_Matcher *self, PyObject *arg);
      static PyObject *t_Matcher_usePattern(t_Matcher *self, PyObject *arg);
      static PyObject *t_Matcher_useTransparentBounds(t_Matcher *self, PyObject *arg);

      static PyMethodDef t_Matcher__methods_[] = {
        DECLARE_METHOD(t_Matcher, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Matcher, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Matcher, appendReplacement, METH_VARARGS),
        DECLARE_METHOD(t_Matcher, appendTail, METH_O),
        DECLARE_METHOD(t_Matcher, end, METH_VARARGS),
        DECLARE_METHOD(t_Matcher, find, METH_VARARGS),
        DECLARE_METHOD(t_Matcher, group, METH_VARARGS),
        DECLARE_METHOD(t_Matcher, groupCount, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, hasAnchoringBounds, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, hasTransparentBounds, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, hitEnd, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, lookingAt, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, matches, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, pattern, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, quoteReplacement, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Matcher, region, METH_VARARGS),
        DECLARE_METHOD(t_Matcher, regionEnd, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, regionStart, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, replaceAll, METH_O),
        DECLARE_METHOD(t_Matcher, replaceFirst, METH_O),
        DECLARE_METHOD(t_Matcher, requireEnd, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, reset, METH_VARARGS),
        DECLARE_METHOD(t_Matcher, start, METH_VARARGS),
        DECLARE_METHOD(t_Matcher, toMatchResult, METH_NOARGS),
        DECLARE_METHOD(t_Matcher, toString, METH_VARARGS),
        DECLARE_METHOD(t_Matcher, useAnchoringBounds, METH_O),
        DECLARE_METHOD(t_Matcher, usePattern, METH_O),
        DECLARE_METHOD(t_Matcher, useTransparentBounds, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Matcher)[] = {
        { Py_tp_methods, t_Matcher__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Matcher)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(Matcher, t_Matcher, Matcher);

      void t_Matcher::install(PyObject *module)
      {
        installType(&PY_TYPE(Matcher), &PY_TYPE_DEF(Matcher), module, "Matcher", 0);
      }

      void t_Matcher::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Matcher), "class_", make_descriptor(Matcher::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Matcher), "wrapfn_", make_descriptor(t_Matcher::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Matcher), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Matcher_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Matcher::initializeClass, 1)))
          return NULL;
        return t_Matcher::wrap_Object(Matcher(((t_Matcher *) arg)->object.this$));
      }
      static PyObject *t_Matcher_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Matcher::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Matcher_appendReplacement(t_Matcher *self, PyObject *args)
      {
        ::java::lang::StringBuffer a0((jobject) NULL);
        ::java::lang::String a1((jobject) NULL);
        Matcher result((jobject) NULL);

        if (!parseArgs(args, "ks", ::java::lang::StringBuffer::initializeClass, &a0, &a1))
        {
          OBJ_CALL(result = self->object.appendReplacement(a0, a1));
          return t_Matcher::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "appendReplacement", args);
        return NULL;
      }

      static PyObject *t_Matcher_appendTail(t_Matcher *self, PyObject *arg)
      {
        ::java::lang::StringBuffer a0((jobject) NULL);
        ::java::lang::StringBuffer result((jobject) NULL);

        if (!parseArg(arg, "k", ::java::lang::StringBuffer::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.appendTail(a0));
          return ::java::lang::t_StringBuffer::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "appendTail", arg);
        return NULL;
      }

      static PyObject *t_Matcher_end(t_Matcher *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            jint result;
            OBJ_CALL(result = self->object.end());
            return PyLong_FromLong((long) result);
          }
          break;
         case 1:
          {
            ::java::lang::String a0((jobject) NULL);
            jint result;

            if (!parseArgs(args, "s", &a0))
            {
              OBJ_CALL(result = self->object.end(a0));
              return PyLong_FromLong((long) result);
            }
          }
          {
            jint a0;
            jint result;

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.end(a0));
              return PyLong_FromLong((long) result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "end", args);
        return NULL;
      }

      static PyObject *t_Matcher_find(t_Matcher *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            jboolean result;
            OBJ_CALL(result = self->object.find());
            Py_RETURN_BOOL(result);
          }
          break;
         case 1:
          {
            jint a0;
            jboolean result;

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.find(a0));
              Py_RETURN_BOOL(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "find", args);
        return NULL;
      }

      static PyObject *t_Matcher_group(t_Matcher *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            ::java::lang::String result((jobject) NULL);
            OBJ_CALL(result = self->object.group());
            return j2p(result);
          }
          break;
         case 1:
          {
            ::java::lang::String a0((jobject) NULL);
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, "s", &a0))
            {
              OBJ_CALL(result = self->object.group(a0));
              return j2p(result);
            }
          }
          {
            jint a0;
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.group(a0));
              return j2p(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "group", args);
        return NULL;
      }

      static PyObject *t_Matcher_groupCount(t_Matcher *self)
      {
        jint result;
        OBJ_CALL(result = self->object.groupCount());
        return PyLong_FromLong((long) result);
      }

      static PyObject *t_Matcher_hasAnchoringBounds(t_Matcher *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.hasAnchoringBounds());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_Matcher_hasTransparentBounds(t_Matcher *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.hasTransparentBounds());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_Matcher_hitEnd(t_Matcher *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.hitEnd());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_Matcher_lookingAt(t_Matcher *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.lookingAt());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_Matcher_matches(t_Matcher *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.matches());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_Matcher_pattern(t_Matcher *self)
      {
        ::java::util::regex::Pattern result((jobject) NULL);
        OBJ_CALL(result = self->object.pattern());
        return ::java::util::regex::t_Pattern::wrap_Object(result);
      }

      static PyObject *t_Matcher_quoteReplacement(PyTypeObject *type, PyObject *arg)
      {
        ::java::lang::String a0((jobject) NULL);
        ::java::lang::String result((jobject) NULL);

        if (!parseArg(arg, "s", &a0))
        {
          OBJ_CALL(result = ::java::util::regex::Matcher::quoteReplacement(a0));
          return j2p(result);
        }

        PyErr_SetArgsError(type, "quoteReplacement", arg);
        return NULL;
      }

      static PyObject *t_Matcher_region(t_Matcher *self, PyObject *args)
      {
        jint a0;
        jint a1;
        Matcher result((jobject) NULL);

        if (!parseArgs(args, "II", &a0, &a1))
        {
          OBJ_CALL(result = self->object.region(a0, a1));
          return t_Matcher::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "region", args);
        return NULL;
      }

      static PyObject *t_Matcher_regionEnd(t_Matcher *self)
      {
        jint result;
        OBJ_CALL(result = self->object.regionEnd());
        return PyLong_FromLong((long) result);
      }

      static PyObject *t_Matcher_regionStart(t_Matcher *self)
      {
        jint result;
        OBJ_CALL(result = self->object.regionStart());
        return PyLong_FromLong((long) result);
      }

      static PyObject *t_Matcher_replaceAll(t_Matcher *self, PyObject *arg)
      {
        ::java::lang::String a0((jobject) NULL);
        ::java::lang::String result((jobject) NULL);

        if (!parseArg(arg, "s", &a0))
        {
          OBJ_CALL(result = self->object.replaceAll(a0));
          return j2p(result);
        }

        PyErr_SetArgsError((PyObject *) self, "replaceAll", arg);
        return NULL;
      }

      static PyObject *t_Matcher_replaceFirst(t_Matcher *self, PyObject *arg)
      {
        ::java::lang::String a0((jobject) NULL);
        ::java::lang::String result((jobject) NULL);

        if (!parseArg(arg, "s", &a0))
        {
          OBJ_CALL(result = self->object.replaceFirst(a0));
          return j2p(result);
        }

        PyErr_SetArgsError((PyObject *) self, "replaceFirst", arg);
        return NULL;
      }

      static PyObject *t_Matcher_requireEnd(t_Matcher *self)
      {
        jboolean result;
        OBJ_CALL(result = self->object.requireEnd());
        Py_RETURN_BOOL(result);
      }

      static PyObject *t_Matcher_reset(t_Matcher *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            Matcher result((jobject) NULL);
            OBJ_CALL(result = self->object.reset());
            return t_Matcher::wrap_Object(result);
          }
          break;
         case 1:
          {
            ::java::lang::CharSequence a0((jobject) NULL);
            Matcher result((jobject) NULL);

            if (!parseArgs(args, "O", ::java::lang::PY_TYPE(CharSequence), &a0))
            {
              OBJ_CALL(result = self->object.reset(a0));
              return t_Matcher::wrap_Object(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "reset", args);
        return NULL;
      }

      static PyObject *t_Matcher_start(t_Matcher *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            jint result;
            OBJ_CALL(result = self->object.start());
            return PyLong_FromLong((long) result);
          }
          break;
         case 1:
          {
            ::java::lang::String a0((jobject) NULL);
            jint result;

            if (!parseArgs(args, "s", &a0))
            {
              OBJ_CALL(result = self->object.start(a0));
              return PyLong_FromLong((long) result);
            }
          }
          {
            jint a0;
            jint result;

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.start(a0));
              return PyLong_FromLong((long) result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "start", args);
        return NULL;
      }

      static PyObject *t_Matcher_toMatchResult(t_Matcher *self)
      {
        ::java::util::regex::MatchResult result((jobject) NULL);
        OBJ_CALL(result = self->object.toMatchResult());
        return ::java::util::regex::t_MatchResult::wrap_Object(result);
      }

      static PyObject *t_Matcher_toString(t_Matcher *self, PyObject *args)
      {
        ::java::lang::String result((jobject) NULL);

        if (!parseArgs(args, ""))
        {
          OBJ_CALL(result = self->object.toString());
          return j2p(result);
        }

        return callSuper(PY_TYPE(Matcher), (PyObject *) self, "toString", args, 2);
      }

      static PyObject *t_Matcher_useAnchoringBounds(t_Matcher *self, PyObject *arg)
      {
        jboolean a0;
        Matcher result((jobject) NULL);

        if (!parseArg(arg, "Z", &a0))
        {
          OBJ_CALL(result = self->object.useAnchoringBounds(a0));
          return t_Matcher::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "useAnchoringBounds", arg);
        return NULL;
      }

      static PyObject *t_Matcher_usePattern(t_Matcher *self, PyObject *arg)
      {
        ::java::util::regex::Pattern a0((jobject) NULL);
        Matcher result((jobject) NULL);

        if (!parseArg(arg, "k", ::java::util::regex::Pattern::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.usePattern(a0));
          return t_Matcher::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "usePattern", arg);
        return NULL;
      }

      static PyObject *t_Matcher_useTransparentBounds(t_Matcher *self, PyObject *arg)
      {
        jboolean a0;
        Matcher result((jobject) NULL);

        if (!parseArg(arg, "Z", &a0))
        {
          OBJ_CALL(result = self->object.useTransparentBounds(a0));
          return t_Matcher::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "useTransparentBounds", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/NoViableAltException.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/ParserRuleContext.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "org/antlr/v4/runtime/Parser.h"
#include "org/antlr/v4/runtime/Token.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *NoViableAltException::class$ = NULL;
        jmethodID *NoViableAltException::mids$ = NULL;
        bool NoViableAltException::live$ = false;

        jclass NoViableAltException::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/NoViableAltException");

            mids$ = new jmethodID[max_mid];
            mids$[mid_init$_32103c89317c9cb1] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/Parser;)V");
            mids$[mid_init$_d57f89cb65a7d7e1] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/Parser;Lorg/antlr/v4/runtime/TokenStream;Lorg/antlr/v4/runtime/Token;Lorg/antlr/v4/runtime/Token;Lorg/antlr/v4/runtime/atn/ATNConfigSet;Lorg/antlr/v4/runtime/ParserRuleContext;)V");
            mids$[mid_getDeadEndConfigs_63f4947260fb4a02] = env->getMethodID(cls, "getDeadEndConfigs", "()Lorg/antlr/v4/runtime/atn/ATNConfigSet;");
            mids$[mid_getStartToken_ed548981de5895c4] = env->getMethodID(cls, "getStartToken", "()Lorg/antlr/v4/runtime/Token;");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        NoViableAltException::NoViableAltException(const ::org::antlr::v4::runtime::Parser & a0) : ::org::antlr::v4::runtime::RecognitionException(env->newObject(initializeClass, &mids$, mid_init$_32103c89317c9cb1, a0.this$)) {}

        NoViableAltException::NoViableAltException(const ::org::antlr::v4::runtime::Parser & a0, const ::org::antlr::v4::runtime::TokenStream & a1, const ::org::antlr::v4::runtime::Token & a2, const ::org::antlr::v4::runtime::Token & a3, const ::org::antlr::v4::runtime::atn::ATNConfigSet & a4, const ::org::antlr::v4::runtime::ParserRuleContext & a5) : ::org::antlr::v4::runtime::RecognitionException(env->newObject(initializeClass, &mids$, mid_init$_d57f89cb65a7d7e1, a0.this$, a1.this$, a2.this$, a3.this$, a4.this$, a5.this$)) {}

        ::org::antlr::v4::runtime::atn::ATNConfigSet NoViableAltException::getDeadEndConfigs() const
        {
          return ::org::antlr::v4::runtime::atn::ATNConfigSet(env->callObjectMethod(this$, mids$[mid_getDeadEndConfigs_63f4947260fb4a02]));
        }

        ::org::antlr::v4::runtime::Token NoViableAltException::getStartToken() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_getStartToken_ed548981de5895c4]));
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_NoViableAltException_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_NoViableAltException_instance_(PyTypeObject *type, PyObject *arg);
        static int t_NoViableAltException_init_(t_NoViableAltException *self, PyObject *args, PyObject *kwds);
        static PyObject *t_NoViableAltException_getDeadEndConfigs(t_NoViableAltException *self);
        static PyObject *t_NoViableAltException_getStartToken(t_NoViableAltException *self);
        static PyObject *t_NoViableAltException_get__deadEndConfigs(t_NoViableAltException *self, void *data);
        static PyObject *t_NoViableAltException_get__startToken(t_NoViableAltException *self, void *data);
        static PyGetSetDef t_NoViableAltException__fields_[] = {
          DECLARE_GET_FIELD(t_NoViableAltException, deadEndConfigs),
          DECLARE_GET_FIELD(t_NoViableAltException, startToken),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_NoViableAltException__methods_[] = {
          DECLARE_METHOD(t_NoViableAltException, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_NoViableAltException, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_NoViableAltException, getDeadEndConfigs, METH_NOARGS),
          DECLARE_METHOD(t_NoViableAltException, getStartToken, METH_NOARGS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(NoViableAltException)[] = {
          { Py_tp_methods, t_NoViableAltException__methods_ },
          { Py_tp_init, (void *) t_NoViableAltException_init_ },
          { Py_tp_getset, t_NoViableAltException__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(NoViableAltException)[] = {
          &PY_TYPE_DEF(::org::antlr::v4::runtime::RecognitionException),
          NULL
        };

        DEFINE_TYPE(NoViableAltException, t_NoViableAltException, NoViableAltException);

        void t_NoViableAltException::install(PyObject *module)
        {
          installType(&PY_TYPE(NoViableAltException), &PY_TYPE_DEF(NoViableAltException), module, "NoViableAltException", 0);
        }

        void t_NoViableAltException::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(NoViableAltException), "class_", make_descriptor(NoViableAltException::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(NoViableAltException), "wrapfn_", make_descriptor(t_NoViableAltException::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(NoViableAltException), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_NoViableAltException_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, NoViableAltException::initializeClass, 1)))
            return NULL;
          return t_NoViableAltException::wrap_Object(NoViableAltException(((t_NoViableAltException *) arg)->object.this$));
        }
        static PyObject *t_NoViableAltException_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, NoViableAltException::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static int t_NoViableAltException_init_(t_NoViableAltException *self, PyObject *args, PyObject *kwds)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 1:
            {
              ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
              PyTypeObject **p0;
              NoViableAltException object((jobject) NULL);

              if (!parseArgs(args, "K", ::org::antlr::v4::runtime::Parser::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_))
              {
                INT_CALL(object = NoViableAltException(a0));
                self->object = object;
                break;
              }
            }
            goto err;
           case 6:
            {
              ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
              PyTypeObject **p0;
              ::org::antlr::v4::runtime::TokenStream a1((jobject) NULL);
              ::org::antlr::v4::runtime::Token a2((jobject) NULL);
              ::org::antlr::v4::runtime::Token a3((jobject) NULL);
              ::org::antlr::v4::runtime::atn::ATNConfigSet a4((jobject) NULL);
              ::org::antlr::v4::runtime::ParserRuleContext a5((jobject) NULL);
              NoViableAltException object((jobject) NULL);

              if (!parseArgs(args, "Kkkkkk", ::org::antlr::v4::runtime::Parser::initializeClass, ::org::antlr::v4::runtime::TokenStream::initializeClass, ::org::antlr::v4::runtime::Token::initializeClass, ::org::antlr::v4::runtime::Token::initializeClass, ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_, &a1, &a2, &a3, &a4, &a5))
              {
                INT_CALL(object = NoViableAltException(a0, a1, a2, a3, a4, a5));
                self->object = object;
                break;
              }
            }
           default:
           err:
            PyErr_SetArgsError((PyObject *) self, "__init__", args);
            return -1;
          }

          return 0;
        }

        static PyObject *t_NoViableAltException_getDeadEndConfigs(t_NoViableAltException *self)
        {
          ::org::antlr::v4::runtime::atn::ATNConfigSet result((jobject) NULL);
          OBJ_CALL(result = self->object.getDeadEndConfigs());
          return ::org::antlr::v4::runtime::atn::t_ATNConfigSet::wrap_Object(result);
        }

        static PyObject *t_NoViableAltException_getStartToken(t_NoViableAltException *self)
        {
          ::org::antlr::v4::runtime::Token result((jobject) NULL);
          OBJ_CALL(result = self->object.getStartToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
        }

        static PyObject *t_NoViableAltException_get__deadEndConfigs(t_NoViableAltException *self, void *data)
        {
          ::org::antlr::v4::runtime::atn::ATNConfigSet value((jobject) NULL);
          OBJ_CALL(value = self->object.getDeadEndConfigs());
          return ::org::antlr::v4::runtime::atn::t_ATNConfigSet::wrap_Object(value);
        }

        static PyObject *t_NoViableAltException_get__startToken(t_NoViableAltException *self, void *data)
        {
          ::org::antlr::v4::runtime::Token value((jobject) NULL);
          OBJ_CALL(value = self->object.getStartToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(value);
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/FileFilter.h"
#include "java/io/File.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *FileFilter::class$ = NULL;
    jmethodID *FileFilter::mids$ = NULL;
    bool FileFilter::live$ = false;

    jclass FileFilter::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/FileFilter");

        mids$ = new jmethodID[max_mid];
        mids$[mid_accept_a51ee127954badc4] = env->getMethodID(cls, "accept", "(Ljava/io/File;)Z");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    jboolean FileFilter::accept(const ::java::io::File & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_accept_a51ee127954badc4], a0.this$);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_FileFilter_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_FileFilter_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_FileFilter_accept(t_FileFilter *self, PyObject *arg);

    static PyMethodDef t_FileFilter__methods_[] = {
      DECLARE_METHOD(t_FileFilter, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_FileFilter, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_FileFilter, accept, METH_O),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(FileFilter)[] = {
      { Py_tp_methods, t_FileFilter__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(FileFilter)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(FileFilter, t_FileFilter, FileFilter);

    void t_FileFilter::install(PyObject *module)
    {
      installType(&PY_TYPE(FileFilter), &PY_TYPE_DEF(FileFilter), module, "FileFilter", 0);
    }

    void t_FileFilter::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(FileFilter), "class_", make_descriptor(FileFilter::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FileFilter), "wrapfn_", make_descriptor(t_FileFilter::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(FileFilter), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_FileFilter_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, FileFilter::initializeClass, 1)))
        return NULL;
      return t_FileFilter::wrap_Object(FileFilter(((t_FileFilter *) arg)->object.this$));
    }
    static PyObject *t_FileFilter_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, FileFilter::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_FileFilter_accept(t_FileFilter *self, PyObject *arg)
    {
      ::java::io::File a0((jobject) NULL);
      jboolean result;

      if (!parseArg(arg, "k", ::java::io::File::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.accept(a0));
        Py_RETURN_BOOL(result);
      }

      PyErr_SetArgsError((PyObject *) self, "accept", arg);
      return NULL;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/IntConsumer.h"
#include "java/util/function/IntConsumer.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *IntConsumer::class$ = NULL;
      jmethodID *IntConsumer::mids$ = NULL;
      bool IntConsumer::live$ = false;

      jclass IntConsumer::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/IntConsumer");

          mids$ = new jmethodID[max_mid];
          mids$[mid_accept_040c4cd0390c5aff] = env->getMethodID(cls, "accept", "(I)V");
          mids$[mid_andThen_45f7fa77fe77dd9b] = env->getMethodID(cls, "andThen", "(Ljava/util/function/IntConsumer;)Ljava/util/function/IntConsumer;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      void IntConsumer::accept(jint a0) const
      {
        env->callVoidMethod(this$, mids$[mid_accept_040c4cd0390c5aff], a0);
      }

      IntConsumer IntConsumer::andThen(const IntConsumer & a0) const
      {
        return IntConsumer(env->callObjectMethod(this$, mids$[mid_andThen_45f7fa77fe77dd9b], a0.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_IntConsumer_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntConsumer_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_IntConsumer_accept(t_IntConsumer *self, PyObject *arg);
      static PyObject *t_IntConsumer_andThen(t_IntConsumer *self, PyObject *arg);

      static PyMethodDef t_IntConsumer__methods_[] = {
        DECLARE_METHOD(t_IntConsumer, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntConsumer, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_IntConsumer, accept, METH_O),
        DECLARE_METHOD(t_IntConsumer, andThen, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(IntConsumer)[] = {
        { Py_tp_methods, t_IntConsumer__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(IntConsumer)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(IntConsumer, t_IntConsumer, IntConsumer);

      void t_IntConsumer::install(PyObject *module)
      {
        installType(&PY_TYPE(IntConsumer), &PY_TYPE_DEF(IntConsumer), module, "IntConsumer", 0);
      }

      void t_IntConsumer::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntConsumer), "class_", make_descriptor(IntConsumer::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntConsumer), "wrapfn_", make_descriptor(t_IntConsumer::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(IntConsumer), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_IntConsumer_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, IntConsumer::initializeClass, 1)))
          return NULL;
        return t_IntConsumer::wrap_Object(IntConsumer(((t_IntConsumer *) arg)->object.this$));
      }
      static PyObject *t_IntConsumer_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, IntConsumer::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_IntConsumer_accept(t_IntConsumer *self, PyObject *arg)
      {
        jint a0;

        if (!parseArg(arg, "I", &a0))
        {
          OBJ_CALL(self->object.accept(a0));
          Py_RETURN_NONE;
        }

        PyErr_SetArgsError((PyObject *) self, "accept", arg);
        return NULL;
      }

      static PyObject *t_IntConsumer_andThen(t_IntConsumer *self, PyObject *arg)
      {
        IntConsumer a0((jobject) NULL);
        IntConsumer result((jobject) NULL);

        if (!parseArg(arg, "k", IntConsumer::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.andThen(a0));
          return t_IntConsumer::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "andThen", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/InvalidPropertiesFormatException.h"
#include "java/lang/String.h"
#include "java/lang/Throwable.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *InvalidPropertiesFormatException::class$ = NULL;
    jmethodID *InvalidPropertiesFormatException::mids$ = NULL;
    bool InvalidPropertiesFormatException::live$ = false;

    jclass InvalidPropertiesFormatException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/InvalidPropertiesFormatException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");
        mids$[mid_init$_471cfbdb800444a7] = env->getMethodID(cls, "<init>", "(Ljava/lang/Throwable;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    InvalidPropertiesFormatException::InvalidPropertiesFormatException(const ::java::lang::String & a0) : ::java::io::IOException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}

    InvalidPropertiesFormatException::InvalidPropertiesFormatException(const ::java::lang::Throwable & a0) : ::java::io::IOException(env->newObject(initializeClass, &mids$, mid_init$_471cfbdb800444a7, a0.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_InvalidPropertiesFormatException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_InvalidPropertiesFormatException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_InvalidPropertiesFormatException_init_(t_InvalidPropertiesFormatException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_InvalidPropertiesFormatException__methods_[] = {
      DECLARE_METHOD(t_InvalidPropertiesFormatException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_InvalidPropertiesFormatException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(InvalidPropertiesFormatException)[] = {
      { Py_tp_methods, t_InvalidPropertiesFormatException__methods_ },
      { Py_tp_init, (void *) t_InvalidPropertiesFormatException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(InvalidPropertiesFormatException)[] = {
      &PY_TYPE_DEF(::java::io::IOException),
      NULL
    };

    DEFINE_TYPE(InvalidPropertiesFormatException, t_InvalidPropertiesFormatException, InvalidPropertiesFormatException);

    void t_InvalidPropertiesFormatException::install(PyObject *module)
    {
      installType(&PY_TYPE(InvalidPropertiesFormatException), &PY_TYPE_DEF(InvalidPropertiesFormatException), module, "InvalidPropertiesFormatException", 0);
    }

    void t_InvalidPropertiesFormatException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(InvalidPropertiesFormatException), "class_", make_descriptor(InvalidPropertiesFormatException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(InvalidPropertiesFormatException), "wrapfn_", make_descriptor(t_InvalidPropertiesFormatException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(InvalidPropertiesFormatException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_InvalidPropertiesFormatException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, InvalidPropertiesFormatException::initializeClass, 1)))
        return NULL;
      return t_InvalidPropertiesFormatException::wrap_Object(InvalidPropertiesFormatException(((t_InvalidPropertiesFormatException *) arg)->object.this$));
    }
    static PyObject *t_InvalidPropertiesFormatException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, InvalidPropertiesFormatException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_InvalidPropertiesFormatException_init_(t_InvalidPropertiesFormatException *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 1:
        {
          ::java::lang::String a0((jobject) NULL);
          InvalidPropertiesFormatException object((jobject) NULL);

          if (!parseArgs(args, "s", &a0))
          {
            INT_CALL(object = InvalidPropertiesFormatException(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::lang::Throwable a0((jobject) NULL);
          InvalidPropertiesFormatException object((jobject) NULL);

          if (!parseArgs(args, "k", ::java::lang::Throwable::initializeClass, &a0))
          {
            INT_CALL(object = InvalidPropertiesFormatException(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/Vocabulary.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *Vocabulary::class$ = NULL;
        jmethodID *Vocabulary::mids$ = NULL;
        bool Vocabulary::live$ = false;

        jclass Vocabulary::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/Vocabulary");

            mids$ = new jmethodID[max_mid];
            mids$[mid_getDisplayName_d7593acad64ef635] = env->getMethodID(cls, "getDisplayName", "(I)Ljava/lang/String;");
            mids$[mid_getLiteralName_d7593acad64ef635] = env->getMethodID(cls, "getLiteralName", "(I)Ljava/lang/String;");
            mids$[mid_getSymbolicName_d7593acad64ef635] = env->getMethodID(cls, "getSymbolicName", "(I)Ljava/lang/String;");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        ::java::lang::String Vocabulary::getDisplayName(jint a0) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getDisplayName_d7593acad64ef635], a0));
        }

        ::java::lang::String Vocabulary::getLiteralName(jint a0) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getLiteralName_d7593acad64ef635], a0));
        }

        ::java::lang::String Vocabulary::getSymbolicName(jint a0) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSymbolicName_d7593acad64ef635], a0));
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_Vocabulary_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Vocabulary_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Vocabulary_getDisplayName(t_Vocabulary *self, PyObject *arg);
        static PyObject *t_Vocabulary_getLiteralName(t_Vocabulary *self, PyObject *arg);
        static PyObject *t_Vocabulary_getSymbolicName(t_Vocabulary *self, PyObject *arg);

        static PyMethodDef t_Vocabulary__methods_[] = {
          DECLARE_METHOD(t_Vocabulary, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Vocabulary, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Vocabulary, getDisplayName, METH_O),
          DECLARE_METHOD(t_Vocabulary, getLiteralName, METH_O),
          DECLARE_METHOD(t_Vocabulary, getSymbolicName, METH_O),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(Vocabulary)[] = {
          { Py_tp_methods, t_Vocabulary__methods_ },
          { Py_tp_init, (void *) abstract_init },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(Vocabulary)[] = {
          &PY_TYPE_DEF(::java::lang::Object),
          NULL
        };

        DEFINE_TYPE(Vocabulary, t_Vocabulary, Vocabulary);

        void t_Vocabulary::install(PyObject *module)
        {
          installType(&PY_TYPE(Vocabulary), &PY_TYPE_DEF(Vocabulary), module, "Vocabulary", 0);
        }

        void t_Vocabulary::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(Vocabulary), "class_", make_descriptor(Vocabulary::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Vocabulary), "wrapfn_", make_descriptor(t_Vocabulary::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Vocabulary), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_Vocabulary_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, Vocabulary::initializeClass, 1)))
            return NULL;
          return t_Vocabulary::wrap_Object(Vocabulary(((t_Vocabulary *) arg)->object.this$));
        }
        static PyObject *t_Vocabulary_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, Vocabulary::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_Vocabulary_getDisplayName(t_Vocabulary *self, PyObject *arg)
        {
          jint a0;
          ::java::lang::String result((jobject) NULL);

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.getDisplayName(a0));
            return j2p(result);
          }

          PyErr_SetArgsError((PyObject *) self, "getDisplayName", arg);
          return NULL;
        }

        static PyObject *t_Vocabulary_getLiteralName(t_Vocabulary *self, PyObject *arg)
        {
          jint a0;
          ::java::lang::String result((jobject) NULL);

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.getLiteralName(a0));
            return j2p(result);
          }

          PyErr_SetArgsError((PyObject *) self, "getLiteralName", arg);
          return NULL;
        }

        static PyObject *t_Vocabulary_getSymbolicName(t_Vocabulary *self, PyObject *arg)
        {
          jint a0;
          ::java::lang::String result((jobject) NULL);

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.getSymbolicName(a0));
            return j2p(result);
          }

          PyErr_SetArgsError((PyObject *) self, "getSymbolicName", arg);
          return NULL;
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/PrecedencePredicateTransition.h"
#include "org/antlr/v4/runtime/atn/ATNState.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/SemanticContext$PrecedencePredicate.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *PrecedencePredicateTransition::class$ = NULL;
          jmethodID *PrecedencePredicateTransition::mids$ = NULL;
          jfieldID *PrecedencePredicateTransition::fids$ = NULL;
          bool PrecedencePredicateTransition::live$ = false;

          jclass PrecedencePredicateTransition::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/PrecedencePredicateTransition");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_a2ca760a43599518] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/ATNState;I)V");
              mids$[mid_getPredicate_a4a4d217e5047caf] = env->getMethodID(cls, "getPredicate", "()Lorg/antlr/v4/runtime/atn/SemanticContext$PrecedencePredicate;");
              mids$[mid_getSerializationType_9972fcc56b44e79d] = env->getMethodID(cls, "getSerializationType", "()I");
              mids$[mid_isEpsilon_8454bd5aa23fd11e] = env->getMethodID(cls, "isEpsilon", "()Z");
              mids$[mid_matches_478e39400b58360d] = env->getMethodID(cls, "matches", "(III)Z");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

              fids$ = new jfieldID[max_fid];
              fids$[fid_precedence] = env->getFieldID(cls, "precedence", "I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          PrecedencePredicateTransition::PrecedencePredicateTransition(const ::org::antlr::v4::runtime::atn::ATNState & a0, jint a1) : ::org::antlr::v4::runtime::atn::AbstractPredicateTransition(env->newObject(initializeClass, &mids$, mid_init$_a2ca760a43599518, a0.this$, a1)) {}

          ::org::antlr::v4::runtime::atn::SemanticContext$PrecedencePredicate PrecedencePredicateTransition::getPredicate() const
          {
            return ::org::antlr::v4::runtime::atn::SemanticContext$PrecedencePredicate(env->callObjectMethod(this$, mids$[mid_getPredicate_a4a4d217e5047caf]));
          }

          jint PrecedencePredicateTransition::getSerializationType() const
          {
            return env->callIntMethod(this$, mids$[mid_getSerializationType_9972fcc56b44e79d]);
          }

          jboolean PrecedencePredicateTransition::isEpsilon() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isEpsilon_8454bd5aa23fd11e]);
          }

          jboolean PrecedencePredicateTransition::matches(jint a0, jint a1, jint a2) const
          {
            return env->callBooleanMethod(this$, mids$[mid_matches_478e39400b58360d], a0, a1, a2);
          }

          ::java::lang::String PrecedencePredicateTransition::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }

          jint PrecedencePredicateTransition::_get_precedence() const
          {
            return env->getIntField(this$, fids$[fid_precedence]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_PrecedencePredicateTransition_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PrecedencePredicateTransition_instance_(PyTypeObject *type, PyObject *arg);
          static int t_PrecedencePredicateTransition_init_(t_PrecedencePredicateTransition *self, PyObject *args, PyObject *kwds);
          static PyObject *t_PrecedencePredicateTransition_getPredicate(t_PrecedencePredicateTransition *self);
          static PyObject *t_PrecedencePredicateTransition_getSerializationType(t_PrecedencePredicateTransition *self, PyObject *args);
          static PyObject *t_PrecedencePredicateTransition_isEpsilon(t_PrecedencePredicateTransition *self, PyObject *args);
          static PyObject *t_PrecedencePredicateTransition_matches(t_PrecedencePredicateTransition *self, PyObject *args);
          static PyObject *t_PrecedencePredicateTransition_toString(t_PrecedencePredicateTransition *self, PyObject *args);
          static PyObject *t_PrecedencePredicateTransition_get__precedence(t_PrecedencePredicateTransition *self, void *data);

          static PyObject *t_PrecedencePredicateTransition_get__epsilon(t_PrecedencePredicateTransition *self, void *data);
          static PyObject *t_PrecedencePredicateTransition_get__predicate(t_PrecedencePredicateTransition *self, void *data);
          static PyObject *t_PrecedencePredicateTransition_get__serializationType(t_PrecedencePredicateTransition *self, void *data);
          static PyGetSetDef t_PrecedencePredicateTransition__fields_[] = {
            DECLARE_GET_FIELD(t_PrecedencePredicateTransition, precedence),
            DECLARE_GET_FIELD(t_PrecedencePredicateTransition, epsilon),
            DECLARE_GET_FIELD(t_PrecedencePredicateTransition, predicate),
            DECLARE_GET_FIELD(t_PrecedencePredicateTransition, serializationType),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_PrecedencePredicateTransition__methods_[] = {
            DECLARE_METHOD(t_PrecedencePredicateTransition, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PrecedencePredicateTransition, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PrecedencePredicateTransition, getPredicate, METH_NOARGS),
            DECLARE_METHOD(t_PrecedencePredicateTransition, getSerializationType, METH_VARARGS),
            DECLARE_METHOD(t_PrecedencePredicateTransition, isEpsilon, METH_VARARGS),
            DECLARE_METHOD(t_PrecedencePredicateTransition, matches, METH_VARARGS),
            DECLARE_METHOD(t_PrecedencePredicateTransition, toString, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(PrecedencePredicateTransition)[] = {
            { Py_tp_methods, t_PrecedencePredicateTransition__methods_ },
            { Py_tp_init, (void *) t_PrecedencePredicateTransition_init_ },
            { Py_tp_getset, t_PrecedencePredicateTransition__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(PrecedencePredicateTransition)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::AbstractPredicateTransition),
            NULL
          };

          DEFINE_TYPE(PrecedencePredicateTransition, t_PrecedencePredicateTransition, PrecedencePredicateTransition);

          void t_PrecedencePredicateTransition::install(PyObject *module)
          {
            installType(&PY_TYPE(PrecedencePredicateTransition), &PY_TYPE_DEF(PrecedencePredicateTransition), module, "PrecedencePredicateTransition", 0);
          }

          void t_PrecedencePredicateTransition::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(PrecedencePredicateTransition), "class_", make_descriptor(PrecedencePredicateTransition::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PrecedencePredicateTransition), "wrapfn_", make_descriptor(t_PrecedencePredicateTransition::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PrecedencePredicateTransition), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_PrecedencePredicateTransition_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, PrecedencePredicateTransition::initializeClass, 1)))
              return NULL;
            return t_PrecedencePredicateTransition::wrap_Object(PrecedencePredicateTransition(((t_PrecedencePredicateTransition *) arg)->object.this$));
          }
          static PyObject *t_PrecedencePredicateTransition_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, PrecedencePredicateTransition::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_PrecedencePredicateTransition_init_(t_PrecedencePredicateTransition *self, PyObject *args, PyObject *kwds)
          {
            ::org::antlr::v4::runtime::atn::ATNState a0((jobject) NULL);
            jint a1;
            PrecedencePredicateTransition object((jobject) NULL);

            if (!parseArgs(args, "kI", ::org::antlr::v4::runtime::atn::ATNState::initializeClass, &a0, &a1))
            {
              INT_CALL(object = PrecedencePredicateTransition(a0, a1));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_PrecedencePredicateTransition_getPredicate(t_PrecedencePredicateTransition *self)
          {
            ::org::antlr::v4::runtime::atn::SemanticContext$PrecedencePredicate result((jobject) NULL);
            OBJ_CALL(result = self->object.getPredicate());
            return ::org::antlr::v4::runtime::atn::t_SemanticContext$PrecedencePredicate::wrap_Object(result);
          }

          static PyObject *t_PrecedencePredicateTransition_getSerializationType(t_PrecedencePredicateTransition *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.getSerializationType());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(PrecedencePredicateTransition), (PyObject *) self, "getSerializationType", args, 2);
          }

          static PyObject *t_PrecedencePredicateTransition_isEpsilon(t_PrecedencePredicateTransition *self, PyObject *args)
          {
            jboolean result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.isEpsilon());
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(PrecedencePredicateTransition), (PyObject *) self, "isEpsilon", args, 2);
          }

          static PyObject *t_PrecedencePredicateTransition_matches(t_PrecedencePredicateTransition *self, PyObject *args)
          {
            jint a0;
            jint a1;
            jint a2;
            jboolean result;

            if (!parseArgs(args, "III", &a0, &a1, &a2))
            {
              OBJ_CALL(result = self->object.matches(a0, a1, a2));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(PrecedencePredicateTransition), (PyObject *) self, "matches", args, 2);
          }

          static PyObject *t_PrecedencePredicateTransition_toString(t_PrecedencePredicateTransition *self, PyObject *args)
          {
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.toString());
              return j2p(result);
            }

            return callSuper(PY_TYPE(PrecedencePredicateTransition), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_PrecedencePredicateTransition_get__precedence(t_PrecedencePredicateTransition *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_precedence());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_PrecedencePredicateTransition_get__epsilon(t_PrecedencePredicateTransition *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isEpsilon());
            Py_RETURN_BOOL(value);
          }

          static PyObject *t_PrecedencePredicateTransition_get__predicate(t_PrecedencePredicateTransition *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::SemanticContext$PrecedencePredicate value((jobject) NULL);
            OBJ_CALL(value = self->object.getPredicate());
            return ::org::antlr::v4::runtime::atn::t_SemanticContext$PrecedencePredicate::wrap_Object(value);
          }

          static PyObject *t_PrecedencePredicateTransition_get__serializationType(t_PrecedencePredicateTransition *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getSerializationType());
            return PyLong_FromLong((long) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/UUID.h"
#include "java/lang/Comparable.h"
#include "java/lang/Class.h"
#include "java/lang/String.h"
#include "java/util/UUID.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *UUID::class$ = NULL;
    jmethodID *UUID::mids$ = NULL;
    bool UUID::live$ = false;

    jclass UUID::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/UUID");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_0248b6e53dc27ea3] = env->getMethodID(cls, "<init>", "(JJ)V");
        mids$[mid_clockSequence_9972fcc56b44e79d] = env->getMethodID(cls, "clockSequence", "()I");
        mids$[mid_compareTo_7969dcadf75b6ebc] = env->getMethodID(cls, "compareTo", "(Ljava/util/UUID;)I");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_fromString_125cc66c0fdeb636] = env->getStaticMethodID(cls, "fromString", "(Ljava/lang/String;)Ljava/util/UUID;");
        mids$[mid_getLeastSignificantBits_2e5ae9edcb9b072f] = env->getMethodID(cls, "getLeastSignificantBits", "()J");
        mids$[mid_getMostSignificantBits_2e5ae9edcb9b072f] = env->getMethodID(cls, "getMostSignificantBits", "()J");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_nameUUIDFromBytes_3c41660c5d90db43] = env->getStaticMethodID(cls, "nameUUIDFromBytes", "([B)Ljava/util/UUID;");
        mids$[mid_node_2e5ae9edcb9b072f] = env->getMethodID(cls, "node", "()J");
        mids$[mid_randomUUID_c2ec84b97895b92f] = env->getStaticMethodID(cls, "randomUUID", "()Ljava/util/UUID;");
        mids$[mid_timestamp_2e5ae9edcb9b072f] = env->getMethodID(cls, "timestamp", "()J");
        mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
        mids$[mid_variant_9972fcc56b44e79d] = env->getMethodID(cls, "variant", "()I");
        mids$[mid_version_9972fcc56b44e79d] = env->getMethodID(cls, "version", "()I");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    UUID::UUID(jlong a0, jlong a1) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_0248b6e53dc27ea3, a0, a1)) {}

    jint UUID::clockSequence() const
    {
      return env->callIntMethod(this$, mids$[mid_clockSequence_9972fcc56b44e79d]);
    }

    jint UUID::compareTo(const UUID & a0) const
    {
      return env->callIntMethod(this$, mids$[mid_compareTo_7969dcadf75b6ebc], a0.this$);
    }

    jboolean UUID::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    UUID UUID::fromString(const ::java::lang::String & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return UUID(env->callStaticObjectMethod(cls, mids$[mid_fromString_125cc66c0fdeb636], a0.this$));
    }

    jlong UUID::getLeastSignificantBits() const
    {
      return env->callLongMethod(this$, mids$[mid_getLeastSignificantBits_2e5ae9edcb9b072f]);
    }

    jlong UUID::getMostSignificantBits() const
    {
      return env->callLongMethod(this$, mids$[mid_getMostSignificantBits_2e5ae9edcb9b072f]);
    }

    jint UUID::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    UUID UUID::nameUUIDFromBytes(const JArray< jbyte > & a0)
    {
      jclass cls = env->getClass(initializeClass);
      return UUID(env->callStaticObjectMethod(cls, mids$[mid_nameUUIDFromBytes_3c41660c5d90db43], a0.this$));
    }

    jlong UUID::node() const
    {
      return env->callLongMethod(this$, mids$[mid_node_2e5ae9edcb9b072f]);
    }

    UUID UUID::randomUUID()
    {
      jclass cls = env->getClass(initializeClass);
      return UUID(env->callStaticObjectMethod(cls, mids$[mid_randomUUID_c2ec84b97895b92f]));
    }

    jlong UUID::timestamp() const
    {
      return env->callLongMethod(this$, mids$[mid_timestamp_2e5ae9edcb9b072f]);
    }

    ::java::lang::String UUID::toString() const
    {
      return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
    }

    jint UUID::variant() const
    {
      return env->callIntMethod(this$, mids$[mid_variant_9972fcc56b44e79d]);
    }

    jint UUID::version() const
    {
      return env->callIntMethod(this$, mids$[mid_version_9972fcc56b44e79d]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_UUID_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_UUID_instance_(PyTypeObject *type, PyObject *arg);
    static int t_UUID_init_(t_UUID *self, PyObject *args, PyObject *kwds);
    static PyObject *t_UUID_clockSequence(t_UUID *self);
    static PyObject *t_UUID_compareTo(t_UUID *self, PyObject *arg);
    static PyObject *t_UUID_equals(t_UUID *self, PyObject *args);
    static PyObject *t_UUID_fromString(PyTypeObject *type, PyObject *arg);
    static PyObject *t_UUID_getLeastSignificantBits(t_UUID *self);
    static PyObject *t_UUID_getMostSignificantBits(t_UUID *self);
    static PyObject *t_UUID_hashCode(t_UUID *self, PyObject *args);
    static PyObject *t_UUID_nameUUIDFromBytes(PyTypeObject *type, PyObject *arg);
    static PyObject *t_UUID_node(t_UUID *self);
    static PyObject *t_UUID_randomUUID(PyTypeObject *type);
    static PyObject *t_UUID_timestamp(t_UUID *self);
    static PyObject *t_UUID_toString(t_UUID *self, PyObject *args);
    static PyObject *t_UUID_variant(t_UUID *self);
    static PyObject *t_UUID_version(t_UUID *self);
    static PyObject *t_UUID_get__leastSignificantBits(t_UUID *self, void *data);
    static PyObject *t_UUID_get__mostSignificantBits(t_UUID *self, void *data);
    static PyGetSetDef t_UUID__fields_[] = {
      DECLARE_GET_FIELD(t_UUID, leastSignificantBits),
      DECLARE_GET_FIELD(t_UUID, mostSignificantBits),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_UUID__methods_[] = {
      DECLARE_METHOD(t_UUID, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_UUID, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_UUID, clockSequence, METH_NOARGS),
      DECLARE_METHOD(t_UUID, compareTo, METH_O),
      DECLARE_METHOD(t_UUID, equals, METH_VARARGS),
      DECLARE_METHOD(t_UUID, fromString, METH_O | METH_CLASS),
      DECLARE_METHOD(t_UUID, getLeastSignificantBits, METH_NOARGS),
      DECLARE_METHOD(t_UUID, getMostSignificantBits, METH_NOARGS),
      DECLARE_METHOD(t_UUID, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_UUID, nameUUIDFromBytes, METH_O | METH_CLASS),
      DECLARE_METHOD(t_UUID, node, METH_NOARGS),
      DECLARE_METHOD(t_UUID, randomUUID, METH_NOARGS | METH_CLASS),
      DECLARE_METHOD(t_UUID, timestamp, METH_NOARGS),
      DECLARE_METHOD(t_UUID, toString, METH_VARARGS),
      DECLARE_METHOD(t_UUID, variant, METH_NOARGS),
      DECLARE_METHOD(t_UUID, version, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(UUID)[] = {
      { Py_tp_methods, t_UUID__methods_ },
      { Py_tp_init, (void *) t_UUID_init_ },
      { Py_tp_getset, t_UUID__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(UUID)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(UUID, t_UUID, UUID);

    void t_UUID::install(PyObject *module)
    {
      installType(&PY_TYPE(UUID), &PY_TYPE_DEF(UUID), module, "UUID", 0);
    }

    void t_UUID::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(UUID), "class_", make_descriptor(UUID::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(UUID), "wrapfn_", make_descriptor(t_UUID::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(UUID), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_UUID_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, UUID::initializeClass, 1)))
        return NULL;
      return t_UUID::wrap_Object(UUID(((t_UUID *) arg)->object.this$));
    }
    static PyObject *t_UUID_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, UUID::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_UUID_init_(t_UUID *self, PyObject *args, PyObject *kwds)
    {
      jlong a0;
      jlong a1;
      UUID object((jobject) NULL);

      if (!parseArgs(args, "JJ", &a0, &a1))
      {
        INT_CALL(object = UUID(a0, a1));
        self->object = object;
      }
      else
      {
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_UUID_clockSequence(t_UUID *self)
    {
      jint result;
      OBJ_CALL(result = self->object.clockSequence());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_UUID_compareTo(t_UUID *self, PyObject *arg)
    {
      UUID a0((jobject) NULL);
      jint result;

      if (!parseArg(arg, "k", UUID::initializeClass, &a0))
      {
        OBJ_CALL(result = self->object.compareTo(a0));
        return PyLong_FromLong((long) result);
      }

      PyErr_SetArgsError((PyObject *) self, "compareTo", arg);
      return NULL;
    }

    static PyObject *t_UUID_equals(t_UUID *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(UUID), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_UUID_fromString(PyTypeObject *type, PyObject *arg)
    {
      ::java::lang::String a0((jobject) NULL);
      UUID result((jobject) NULL);

      if (!parseArg(arg, "s", &a0))
      {
        OBJ_CALL(result = ::java::util::UUID::fromString(a0));
        return t_UUID::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "fromString", arg);
      return NULL;
    }

    static PyObject *t_UUID_getLeastSignificantBits(t_UUID *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.getLeastSignificantBits());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_UUID_getMostSignificantBits(t_UUID *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.getMostSignificantBits());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_UUID_hashCode(t_UUID *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(UUID), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_UUID_nameUUIDFromBytes(PyTypeObject *type, PyObject *arg)
    {
      JArray< jbyte > a0((jobject) NULL);
      UUID result((jobject) NULL);

      if (!parseArg(arg, "[B", &a0))
      {
        OBJ_CALL(result = ::java::util::UUID::nameUUIDFromBytes(a0));
        return t_UUID::wrap_Object(result);
      }

      PyErr_SetArgsError(type, "nameUUIDFromBytes", arg);
      return NULL;
    }

    static PyObject *t_UUID_node(t_UUID *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.node());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_UUID_randomUUID(PyTypeObject *type)
    {
      UUID result((jobject) NULL);
      OBJ_CALL(result = ::java::util::UUID::randomUUID());
      return t_UUID::wrap_Object(result);
    }

    static PyObject *t_UUID_timestamp(t_UUID *self)
    {
      jlong result;
      OBJ_CALL(result = self->object.timestamp());
      return PyLong_FromLongLong((PY_LONG_LONG) result);
    }

    static PyObject *t_UUID_toString(t_UUID *self, PyObject *args)
    {
      ::java::lang::String result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.toString());
        return j2p(result);
      }

      return callSuper(PY_TYPE(UUID), (PyObject *) self, "toString", args, 2);
    }

    static PyObject *t_UUID_variant(t_UUID *self)
    {
      jint result;
      OBJ_CALL(result = self->object.variant());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_UUID_version(t_UUID *self)
    {
      jint result;
      OBJ_CALL(result = self->object.version());
      return PyLong_FromLong((long) result);
    }

    static PyObject *t_UUID_get__leastSignificantBits(t_UUID *self, void *data)
    {
      jlong value;
      OBJ_CALL(value = self->object.getLeastSignificantBits());
      return PyLong_FromLongLong((PY_LONG_LONG) value);
    }

    static PyObject *t_UUID_get__mostSignificantBits(t_UUID *self, void *data)
    {
      jlong value;
      OBJ_CALL(value = self->object.getMostSignificantBits());
      return PyLong_FromLongLong((PY_LONG_LONG) value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/function/DoubleConsumer.h"
#include "java/util/function/DoubleConsumer.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace function {

      ::java::lang::Class *DoubleConsumer::class$ = NULL;
      jmethodID *DoubleConsumer::mids$ = NULL;
      bool DoubleConsumer::live$ = false;

      jclass DoubleConsumer::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/function/DoubleConsumer");

          mids$ = new jmethodID[max_mid];
          mids$[mid_accept_3c435f10a3b1e038] = env->getMethodID(cls, "accept", "(D)V");
          mids$[mid_andThen_dfe90dc0cb64c1ba] = env->getMethodID(cls, "andThen", "(Ljava/util/function/DoubleConsumer;)Ljava/util/function/DoubleConsumer;");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      void DoubleConsumer::accept(jdouble a0) const
      {
        env->callVoidMethod(this$, mids$[mid_accept_3c435f10a3b1e038], a0);
      }

      DoubleConsumer DoubleConsumer::andThen(const DoubleConsumer & a0) const
      {
        return DoubleConsumer(env->callObjectMethod(this$, mids$[mid_andThen_dfe90dc0cb64c1ba], a0.this$));
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace function {
      static PyObject *t_DoubleConsumer_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DoubleConsumer_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_DoubleConsumer_accept(t_DoubleConsumer *self, PyObject *arg);
      static PyObject *t_DoubleConsumer_andThen(t_DoubleConsumer *self, PyObject *arg);

      static PyMethodDef t_DoubleConsumer__methods_[] = {
        DECLARE_METHOD(t_DoubleConsumer, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DoubleConsumer, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_DoubleConsumer, accept, METH_O),
        DECLARE_METHOD(t_DoubleConsumer, andThen, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(DoubleConsumer)[] = {
        { Py_tp_methods, t_DoubleConsumer__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(DoubleConsumer)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(DoubleConsumer, t_DoubleConsumer, DoubleConsumer);

      void t_DoubleConsumer::install(PyObject *module)
      {
        installType(&PY_TYPE(DoubleConsumer), &PY_TYPE_DEF(DoubleConsumer), module, "DoubleConsumer", 0);
      }

      void t_DoubleConsumer::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(DoubleConsumer), "class_", make_descriptor(DoubleConsumer::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DoubleConsumer), "wrapfn_", make_descriptor(t_DoubleConsumer::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(DoubleConsumer), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_DoubleConsumer_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, DoubleConsumer::initializeClass, 1)))
          return NULL;
        return t_DoubleConsumer::wrap_Object(DoubleConsumer(((t_DoubleConsumer *) arg)->object.this$));
      }
      static PyObject *t_DoubleConsumer_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, DoubleConsumer::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_DoubleConsumer_accept(t_DoubleConsumer *self, PyObject *arg)
      {
        jdouble a0;

        if (!parseArg(arg, "D", &a0))
        {
          OBJ_CALL(self->object.accept(a0));
          Py_RETURN_NONE;
        }

        PyErr_SetArgsError((PyObject *) self, "accept", arg);
        return NULL;
      }

      static PyObject *t_DoubleConsumer_andThen(t_DoubleConsumer *self, PyObject *arg)
      {
        DoubleConsumer a0((jobject) NULL);
        DoubleConsumer result((jobject) NULL);

        if (!parseArg(arg, "k", DoubleConsumer::initializeClass, &a0))
        {
          OBJ_CALL(result = self->object.andThen(a0));
          return t_DoubleConsumer::wrap_Object(result);
        }

        PyErr_SetArgsError((PyObject *) self, "andThen", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ATNState.h"
#include "org/antlr/v4/runtime/atn/ATN.h"
#include "java/lang/Class.h"
#include "java/lang/String.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/atn/Transition.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ATNState::class$ = NULL;
          jmethodID *ATNState::mids$ = NULL;
          jfieldID *ATNState::fids$ = NULL;
          bool ATNState::live$ = false;
          jint ATNState::BASIC = (jint) 0;
          jint ATNState::BLOCK_END = (jint) 0;
          jint ATNState::BLOCK_START = (jint) 0;
          jint ATNState::INITIAL_NUM_TRANSITIONS = (jint) 0;
          jint ATNState::INVALID_STATE_NUMBER = (jint) 0;
          jint ATNState::INVALID_TYPE = (jint) 0;
          jint ATNState::LOOP_END = (jint) 0;
          jint ATNState::PLUS_BLOCK_START = (jint) 0;
          jint ATNState::PLUS_LOOP_BACK = (jint) 0;
          jint ATNState::RULE_START = (jint) 0;
          jint ATNState::RULE_STOP = (jint) 0;
          jint ATNState::STAR_BLOCK_START = (jint) 0;
          jint ATNState::STAR_LOOP_BACK = (jint) 0;
          jint ATNState::STAR_LOOP_ENTRY = (jint) 0;
          jint ATNState::TOKEN_START = (jint) 0;
          ::java::util::List *ATNState::serializationNames = NULL;

          jclass ATNState::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ATNState");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
              mids$[mid_addTransition_f99acf65941cba1c] = env->getMethodID(cls, "addTransition", "(Lorg/antlr/v4/runtime/atn/Transition;)V");
              mids$[mid_addTransition_7a695a8615359a2d] = env->getMethodID(cls, "addTransition", "(ILorg/antlr/v4/runtime/atn/Transition;)V");
              mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
              mids$[mid_getNumberOfTransitions_9972fcc56b44e79d] = env->getMethodID(cls, "getNumberOfTransitions", "()I");
              mids$[mid_getStateType_9972fcc56b44e79d] = env->getMethodID(cls, "getStateType", "()I");
              mids$[mid_getTransitions_73a62076f6902dad] = env->getMethodID(cls, "getTransitions", "()[Lorg/antlr/v4/runtime/atn/Transition;");
              mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
              mids$[mid_isNonGreedyExitState_8454bd5aa23fd11e] = env->getMethodID(cls, "isNonGreedyExitState", "()Z");
              mids$[mid_onlyHasEpsilonTransitions_8454bd5aa23fd11e] = env->getMethodID(cls, "onlyHasEpsilonTransitions", "()Z");
              mids$[mid_removeTransition_b22c34463faa5dd6] = env->getMethodID(cls, "removeTransition", "(I)Lorg/antlr/v4/runtime/atn/Transition;");
              mids$[mid_setRuleIndex_040c4cd0390c5aff] = env->getMethodID(cls, "setRuleIndex", "(I)V");
              mids$[mid_setTransition_7a695a8615359a2d] = env->getMethodID(cls, "setTransition", "(ILorg/antlr/v4/runtime/atn/Transition;)V");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
              mids$[mid_transition_b22c34463faa5dd6] = env->getMethodID(cls, "transition", "(I)Lorg/antlr/v4/runtime/atn/Transition;");

              fids$ = new jfieldID[max_fid];
              fids$[fid_atn] = env->getFieldID(cls, "atn", "Lorg/antlr/v4/runtime/atn/ATN;");
              fids$[fid_epsilonOnlyTransitions] = env->getFieldID(cls, "epsilonOnlyTransitions", "Z");
              fids$[fid_ruleIndex] = env->getFieldID(cls, "ruleIndex", "I");
              fids$[fid_stateNumber] = env->getFieldID(cls, "stateNumber", "I");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              BASIC = env->getStaticIntField(cls, "BASIC");
              BLOCK_END = env->getStaticIntField(cls, "BLOCK_END");
              BLOCK_START = env->getStaticIntField(cls, "BLOCK_START");
              INITIAL_NUM_TRANSITIONS = env->getStaticIntField(cls, "INITIAL_NUM_TRANSITIONS");
              INVALID_STATE_NUMBER = env->getStaticIntField(cls, "INVALID_STATE_NUMBER");
              INVALID_TYPE = env->getStaticIntField(cls, "INVALID_TYPE");
              LOOP_END = env->getStaticIntField(cls, "LOOP_END");
              PLUS_BLOCK_START = env->getStaticIntField(cls, "PLUS_BLOCK_START");
              PLUS_LOOP_BACK = env->getStaticIntField(cls, "PLUS_LOOP_BACK");
              RULE_START = env->getStaticIntField(cls, "RULE_START");
              RULE_STOP = env->getStaticIntField(cls, "RULE_STOP");
              STAR_BLOCK_START = env->getStaticIntField(cls, "STAR_BLOCK_START");
              STAR_LOOP_BACK = env->getStaticIntField(cls, "STAR_LOOP_BACK");
              STAR_LOOP_ENTRY = env->getStaticIntField(cls, "STAR_LOOP_ENTRY");
              TOKEN_START = env->getStaticIntField(cls, "TOKEN_START");
              serializationNames = new ::java::util::List(env->getStaticObjectField(cls, "serializationNames", "Ljava/util/List;"));
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ATNState::ATNState() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          void ATNState::addTransition(const ::org::antlr::v4::runtime::atn::Transition & a0) const
          {
            env->callVoidMethod(this$, mids$[mid_addTransition_f99acf65941cba1c], a0.this$);
          }

          void ATNState::addTransition(jint a0, const ::org::antlr::v4::runtime::atn::Transition & a1) const
          {
            env->callVoidMethod(this$, mids$[mid_addTransition_7a695a8615359a2d], a0, a1.this$);
          }

          jboolean ATNState::equals(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
          }

          jint ATNState::getNumberOfTransitions() const
          {
            return env->callIntMethod(this$, mids$[mid_getNumberOfTransitions_9972fcc56b44e79d]);
          }

          jint ATNState::getStateType() const
          {
            return env->callIntMethod(this$, mids$[mid_getStateType_9972fcc56b44e79d]);
          }

          JArray< ::org::antlr::v4::runtime::atn::Transition > ATNState::getTransitions() const
          {
            return JArray< ::org::antlr::v4::runtime::atn::Transition >(env->callObjectMethod(this$, mids$[mid_getTransitions_73a62076f6902dad]));
          }

          jint ATNState::hashCode() const
          {
            return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
          }

          jboolean ATNState::isNonGreedyExitState() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isNonGreedyExitState_8454bd5aa23fd11e]);
          }

          jboolean ATNState::onlyHasEpsilonTransitions() const
          {
            return env->callBooleanMethod(this$, mids$[mid_onlyHasEpsilonTransitions_8454bd5aa23fd11e]);
          }

          ::org::antlr::v4::runtime::atn::Transition ATNState::removeTransition(jint a0) const
          {
            return ::org::antlr::v4::runtime::atn::Transition(env->callObjectMethod(this$, mids$[mid_removeTransition_b22c34463faa5dd6], a0));
          }

          void ATNState::setRuleIndex(jint a0) const
          {
            env->callVoidMethod(this$, mids$[mid_setRuleIndex_040c4cd0390c5aff], a0);
          }

          void ATNState::setTransition(jint a0, const ::org::antlr::v4::runtime::atn::Transition & a1) const
          {
            env->callVoidMethod(this$, mids$[mid_setTransition_7a695a8615359a2d], a0, a1.this$);
          }

          ::java::lang::String ATNState::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }

          ::org::antlr::v4::runtime::atn::Transition ATNState::transition(jint a0) const
          {
            return ::org::antlr::v4::runtime::atn::Transition(env->callObjectMethod(this$, mids$[mid_transition_b22c34463faa5dd6], a0));
          }

          ::org::antlr::v4::runtime::atn::ATN ATNState::_get_atn() const
          {
            return ::org::antlr::v4::runtime::atn::ATN(env->getObjectField(this$, fids$[fid_atn]));
          }

          void ATNState::_set_atn(const ::org::antlr::v4::runtime::atn::ATN & a0) const
          {
            env->setObjectField(this$, fids$[fid_atn], a0.this$);
          }

          jboolean ATNState::_get_epsilonOnlyTransitions() const
          {
            return env->getBooleanField(this$, fids$[fid_epsilonOnlyTransitions]);
          }

          void ATNState::_set_epsilonOnlyTransitions(jboolean a0) const
          {
            env->setBooleanField(this$, fids$[fid_epsilonOnlyTransitions], a0);
          }

          jint ATNState::_get_ruleIndex() const
          {
            return env->getIntField(this$, fids$[fid_ruleIndex]);
          }

          void ATNState::_set_ruleIndex(jint a0) const
          {
            env->setIntField(this$, fids$[fid_ruleIndex], a0);
          }

          jint ATNState::_get_stateNumber() const
          {
            return env->getIntField(this$, fids$[fid_stateNumber]);
          }

          void ATNState::_set_stateNumber(jint a0) const
          {
            env->setIntField(this$, fids$[fid_stateNumber], a0);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ATNState_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNState_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ATNState_init_(t_ATNState *self, PyObject *args, PyObject *kwds);
          static PyObject *t_ATNState_addTransition(t_ATNState *self, PyObject *args);
          static PyObject *t_ATNState_equals(t_ATNState *self, PyObject *args);
          static PyObject *t_ATNState_getNumberOfTransitions(t_ATNState *self);
          static PyObject *t_ATNState_getStateType(t_ATNState *self);
          static PyObject *t_ATNState_getTransitions(t_ATNState *self);
          static PyObject *t_ATNState_hashCode(t_ATNState *self, PyObject *args);
          static PyObject *t_ATNState_isNonGreedyExitState(t_ATNState *self);
          static PyObject *t_ATNState_onlyHasEpsilonTransitions(t_ATNState *self);
          static PyObject *t_ATNState_removeTransition(t_ATNState *self, PyObject *arg);
          static PyObject *t_ATNState_setRuleIndex(t_ATNState *self, PyObject *arg);
          static PyObject *t_ATNState_setTransition(t_ATNState *self, PyObject *args);
          static PyObject *t_ATNState_toString(t_ATNState *self, PyObject *args);
          static PyObject *t_ATNState_transition(t_ATNState *self, PyObject *arg);
          static PyObject *t_ATNState_get__atn(t_ATNState *self, void *data);
          static int t_ATNState_set__atn(t_ATNState *self, PyObject *arg, void *data);
          static PyObject *t_ATNState_get__epsilonOnlyTransitions(t_ATNState *self, void *data);
          static int t_ATNState_set__epsilonOnlyTransitions(t_ATNState *self, PyObject *arg, void *data);
          static PyObject *t_ATNState_get__stateNumber(t_ATNState *self, void *data);
          static int t_ATNState_set__stateNumber(t_ATNState *self, PyObject *arg, void *data);

          static PyObject *t_ATNState_get__nonGreedyExitState(t_ATNState *self, void *data);
          static PyObject *t_ATNState_get__numberOfTransitions(t_ATNState *self, void *data);
          static int t_ATNState_set__ruleIndex(t_ATNState *self, PyObject *arg, void *data);
          static PyObject *t_ATNState_get__stateType(t_ATNState *self, void *data);
          static PyObject *t_ATNState_get__transitions(t_ATNState *self, void *data);
          static PyGetSetDef t_ATNState__fields_[] = {
            DECLARE_GETSET_FIELD(t_ATNState, atn),
            DECLARE_GETSET_FIELD(t_ATNState, epsilonOnlyTransitions),
            DECLARE_GETSET_FIELD(t_ATNState, stateNumber),
            DECLARE_GET_FIELD(t_ATNState, nonGreedyExitState),
            DECLARE_GET_FIELD(t_ATNState, numberOfTransitions),
            DECLARE_SET_FIELD(t_ATNState, ruleIndex),
            DECLARE_GET_FIELD(t_ATNState, stateType),
            DECLARE_GET_FIELD(t_ATNState, transitions),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ATNState__methods_[] = {
            DECLARE_METHOD(t_ATNState, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNState, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNState, addTransition, METH_VARARGS),
            DECLARE_METHOD(t_ATNState, equals, METH_VARARGS),
            DECLARE_METHOD(t_ATNState, getNumberOfTransitions, METH_NOARGS),
            DECLARE_METHOD(t_ATNState, getStateType, METH_NOARGS),
            DECLARE_METHOD(t_ATNState, getTransitions, METH_NOARGS),
            DECLARE_METHOD(t_ATNState, hashCode, METH_VARARGS),
            DECLARE_METHOD(t_ATNState, isNonGreedyExitState, METH_NOARGS),
            DECLARE_METHOD(t_ATNState, onlyHasEpsilonTransitions, METH_NOARGS),
            DECLARE_METHOD(t_ATNState, removeTransition, METH_O),
            DECLARE_METHOD(t_ATNState, setRuleIndex, METH_O),
            DECLARE_METHOD(t_ATNState, setTransition, METH_VARARGS),
            DECLARE_METHOD(t_ATNState, toString, METH_VARARGS),
            DECLARE_METHOD(t_ATNState, transition, METH_O),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ATNState)[] = {
            { Py_tp_methods, t_ATNState__methods_ },
            { Py_tp_init, (void *) t_ATNState_init_ },
            { Py_tp_getset, t_ATNState__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ATNState)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(ATNState, t_ATNState, ATNState);

          void t_ATNState::install(PyObject *module)
          {
            installType(&PY_TYPE(ATNState), &PY_TYPE_DEF(ATNState), module, "ATNState", 0);
          }

          void t_ATNState::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "class_", make_descriptor(ATNState::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "wrapfn_", make_descriptor(t_ATNState::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "boxfn_", make_descriptor(boxObject));
            env->getClass(ATNState::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "BASIC", make_descriptor(ATNState::BASIC));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "BLOCK_END", make_descriptor(ATNState::BLOCK_END));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "BLOCK_START", make_descriptor(ATNState::BLOCK_START));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "INITIAL_NUM_TRANSITIONS", make_descriptor(ATNState::INITIAL_NUM_TRANSITIONS));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "INVALID_STATE_NUMBER", make_descriptor(ATNState::INVALID_STATE_NUMBER));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "INVALID_TYPE", make_descriptor(ATNState::INVALID_TYPE));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "LOOP_END", make_descriptor(ATNState::LOOP_END));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "PLUS_BLOCK_START", make_descriptor(ATNState::PLUS_BLOCK_START));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "PLUS_LOOP_BACK", make_descriptor(ATNState::PLUS_LOOP_BACK));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "RULE_START", make_descriptor(ATNState::RULE_START));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "RULE_STOP", make_descriptor(ATNState::RULE_STOP));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "STAR_BLOCK_START", make_descriptor(ATNState::STAR_BLOCK_START));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "STAR_LOOP_BACK", make_descriptor(ATNState::STAR_LOOP_BACK));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "STAR_LOOP_ENTRY", make_descriptor(ATNState::STAR_LOOP_ENTRY));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "TOKEN_START", make_descriptor(ATNState::TOKEN_START));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNState), "serializationNames", make_descriptor(::java::util::t_List::wrap_Object(*ATNState::serializationNames)));
          }

          static PyObject *t_ATNState_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ATNState::initializeClass, 1)))
              return NULL;
            return t_ATNState::wrap_Object(ATNState(((t_ATNState *) arg)->object.this$));
          }
          static PyObject *t_ATNState_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ATNState::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ATNState_init_(t_ATNState *self, PyObject *args, PyObject *kwds)
          {
            ATNState object((jobject) NULL);

            INT_CALL(object = ATNState());
            self->object = object;

            return 0;
          }

          static PyObject *t_ATNState_addTransition(t_ATNState *self, PyObject *args)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 1:
              {
                ::org::antlr::v4::runtime::atn::Transition a0((jobject) NULL);

                if (!parseArgs(args, "k", ::org::antlr::v4::runtime::atn::Transition::initializeClass, &a0))
                {
                  OBJ_CALL(self->object.addTransition(a0));
                  Py_RETURN_NONE;
                }
              }
              break;
             case 2:
              {
                jint a0;
                ::org::antlr::v4::runtime::atn::Transition a1((jobject) NULL);

                if (!parseArgs(args, "Ik", ::org::antlr::v4::runtime::atn::Transition::initializeClass, &a0, &a1))
                {
                  OBJ_CALL(self->object.addTransition(a0, a1));
                  Py_RETURN_NONE;
                }
              }
            }

            PyErr_SetArgsError((PyObject *) self, "addTransition", args);
            return NULL;
          }

          static PyObject *t_ATNState_equals(t_ATNState *self, PyObject *args)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "o", &a0))
            {
              OBJ_CALL(result = self->object.equals(a0));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(ATNState), (PyObject *) self, "equals", args, 2);
          }

          static PyObject *t_ATNState_getNumberOfTransitions(t_ATNState *self)
          {
            jint result;
            OBJ_CALL(result = self->object.getNumberOfTransitions());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_ATNState_getStateType(t_ATNState *self)
          {
            jint result;
            OBJ_CALL(result = self->object.getStateType());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_ATNState_getTransitions(t_ATNState *self)
          {
            JArray< ::org::antlr::v4::runtime::atn::Transition > result((jobject) NULL);
            OBJ_CALL(result = self->object.getTransitions());
            return JArray<jobject>(result.this$).wrap(::org::antlr::v4::runtime::atn::t_Transition::wrap_jobject);
          }

          static PyObject *t_ATNState_hashCode(t_ATNState *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.hashCode());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(ATNState), (PyObject *) self, "hashCode", args, 2);
          }

          static PyObject *t_ATNState_isNonGreedyExitState(t_ATNState *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.isNonGreedyExitState());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_ATNState_onlyHasEpsilonTransitions(t_ATNState *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.onlyHasEpsilonTransitions());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_ATNState_removeTransition(t_ATNState *self, PyObject *arg)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::Transition result((jobject) NULL);

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(result = self->object.removeTransition(a0));
              return ::org::antlr::v4::runtime::atn::t_Transition::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "removeTransition", arg);
            return NULL;
          }

          static PyObject *t_ATNState_setRuleIndex(t_ATNState *self, PyObject *arg)
          {
            jint a0;

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(self->object.setRuleIndex(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "setRuleIndex", arg);
            return NULL;
          }

          static PyObject *t_ATNState_setTransition(t_ATNState *self, PyObject *args)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::Transition a1((jobject) NULL);

            if (!parseArgs(args, "Ik", ::org::antlr::v4::runtime::atn::Transition::initializeClass, &a0, &a1))
            {
              OBJ_CALL(self->object.setTransition(a0, a1));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "setTransition", args);
            return NULL;
          }

          static PyObject *t_ATNState_toString(t_ATNState *self, PyObject *args)
          {
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.toString());
              return j2p(result);
            }

            return callSuper(PY_TYPE(ATNState), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_ATNState_transition(t_ATNState *self, PyObject *arg)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::Transition result((jobject) NULL);

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(result = self->object.transition(a0));
              return ::org::antlr::v4::runtime::atn::t_Transition::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "transition", arg);
            return NULL;
          }

          static PyObject *t_ATNState_get__atn(t_ATNState *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATN value((jobject) NULL);
            OBJ_CALL(value = self->object._get_atn());
            return ::org::antlr::v4::runtime::atn::t_ATN::wrap_Object(value);
          }
          static int t_ATNState_set__atn(t_ATNState *self, PyObject *arg, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATN value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATN::initializeClass, &value))
            {
              INT_CALL(self->object._set_atn(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "atn", arg);
            return -1;
          }

          static PyObject *t_ATNState_get__epsilonOnlyTransitions(t_ATNState *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object._get_epsilonOnlyTransitions());
            Py_RETURN_BOOL(value);
          }
          static int t_ATNState_set__epsilonOnlyTransitions(t_ATNState *self, PyObject *arg, void *data)
          {
            jboolean value;
            if (!parseArg(arg, "Z", &value))
            {
              INT_CALL(self->object._set_epsilonOnlyTransitions(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "epsilonOnlyTransitions", arg);
            return -1;
          }

          static PyObject *t_ATNState_get__stateNumber(t_ATNState *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_stateNumber());
            return PyLong_FromLong((long) value);
          }
          static int t_ATNState_set__stateNumber(t_ATNState *self, PyObject *arg, void *data)
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object._set_stateNumber(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "stateNumber", arg);
            return -1;
          }

          static PyObject *t_ATNState_get__nonGreedyExitState(t_ATNState *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isNonGreedyExitState());
            Py_RETURN_BOOL(value);
          }

          static PyObject *t_ATNState_get__numberOfTransitions(t_ATNState *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getNumberOfTransitions());
            return PyLong_FromLong((long) value);
          }

          static int t_ATNState_set__ruleIndex(t_ATNState *self, PyObject *arg, void *data)
          {
            {
              jint value;
              if (!parseArg(arg, "I", &value))
              {
                INT_CALL(self->object.setRuleIndex(value));
                return 0;
              }
            }
            PyErr_SetArgsError((PyObject *) self, "ruleIndex", arg);
            return -1;
          }

          static PyObject *t_ATNState_get__stateType(t_ATNState *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getStateType());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_ATNState_get__transitions(t_ATNState *self, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::Transition > value((jobject) NULL);
            OBJ_CALL(value = self->object.getTransitions());
            return JArray<jobject>(value.this$).wrap(::org::antlr::v4::runtime::atn::t_Transition::wrap_jobject);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/lang/AutoCloseable.h"
#include "java/lang/Exception.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace lang {

    ::java::lang::Class *AutoCloseable::class$ = NULL;
    jmethodID *AutoCloseable::mids$ = NULL;
    bool AutoCloseable::live$ = false;

    jclass AutoCloseable::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/lang/AutoCloseable");

        mids$ = new jmethodID[max_mid];
        mids$[mid_close_f2cc1bce94666404] = env->getMethodID(cls, "close", "()V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    void AutoCloseable::close() const
    {
      env->callVoidMethod(this$, mids$[mid_close_f2cc1bce94666404]);
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace lang {
    static PyObject *t_AutoCloseable_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_AutoCloseable_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_AutoCloseable_close(t_AutoCloseable *self);

    static PyMethodDef t_AutoCloseable__methods_[] = {
      DECLARE_METHOD(t_AutoCloseable, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_AutoCloseable, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_AutoCloseable, close, METH_NOARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(AutoCloseable)[] = {
      { Py_tp_methods, t_AutoCloseable__methods_ },
      { Py_tp_init, (void *) abstract_init },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(AutoCloseable)[] = {
      &PY_TYPE_DEF(::java::lang::Object),
      NULL
    };

    DEFINE_TYPE(AutoCloseable, t_AutoCloseable, AutoCloseable);

    void t_AutoCloseable::install(PyObject *module)
    {
      installType(&PY_TYPE(AutoCloseable), &PY_TYPE_DEF(AutoCloseable), module, "AutoCloseable", 0);
    }

    void t_AutoCloseable::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(AutoCloseable), "class_", make_descriptor(AutoCloseable::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(AutoCloseable), "wrapfn_", make_descriptor(t_AutoCloseable::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(AutoCloseable), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_AutoCloseable_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, AutoCloseable::initializeClass, 1)))
        return NULL;
      return t_AutoCloseable::wrap_Object(AutoCloseable(((t_AutoCloseable *) arg)->object.this$));
    }
    static PyObject *t_AutoCloseable_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, AutoCloseable::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_AutoCloseable_close(t_AutoCloseable *self)
    {
      OBJ_CALL(self->object.close());
      Py_RETURN_NONE;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet.h"
#include "java/util/Collection.h"
#include "java/util/ArrayList.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet$AbstractConfigHashSet.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/atn/SemanticContext.h"
#include "java/util/BitSet.h"
#include "java/lang/String.h"
#include "java/util/Iterator.h"
#include "java/util/Set.h"
#include "org/antlr/v4/runtime/atn/ATNConfig.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/atn/ATNState.h"
#include "org/antlr/v4/runtime/atn/ATNSimulator.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ATNConfigSet::class$ = NULL;
          jmethodID *ATNConfigSet::mids$ = NULL;
          jfieldID *ATNConfigSet::fids$ = NULL;
          bool ATNConfigSet::live$ = false;

          jclass ATNConfigSet::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ATNConfigSet");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
              mids$[mid_init$_9d72768e8fdce2b7] = env->getMethodID(cls, "<init>", "(Z)V");
              mids$[mid_add_ee797c2c9eeb87eb] = env->getMethodID(cls, "add", "(Lorg/antlr/v4/runtime/atn/ATNConfig;)Z");
              mids$[mid_addAll_15d9cc2398c22637] = env->getMethodID(cls, "addAll", "(Ljava/util/Collection;)Z");
              mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
              mids$[mid_contains_8b72f2dcdde6fd1d] = env->getMethodID(cls, "contains", "(Ljava/lang/Object;)Z");
              mids$[mid_containsAll_15d9cc2398c22637] = env->getMethodID(cls, "containsAll", "(Ljava/util/Collection;)Z");
              mids$[mid_containsFast_ee797c2c9eeb87eb] = env->getMethodID(cls, "containsFast", "(Lorg/antlr/v4/runtime/atn/ATNConfig;)Z");
              mids$[mid_elements_49ec78390f08338a] = env->getMethodID(cls, "elements", "()Ljava/util/List;");
              mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
              mids$[mid_get_524964022147277a] = env->getMethodID(cls, "get", "(I)Lorg/antlr/v4/runtime/atn/ATNConfig;");
              mids$[mid_getAlts_56fb7b391b4328ed] = env->getMethodID(cls, "getAlts", "()Ljava/util/BitSet;");
              mids$[mid_getPredicates_49ec78390f08338a] = env->getMethodID(cls, "getPredicates", "()Ljava/util/List;");
              mids$[mid_getStates_7dcf4034c6d1a92a] = env->getMethodID(cls, "getStates", "()Ljava/util/Set;");
              mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
              mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
              mids$[mid_isReadonly_8454bd5aa23fd11e] = env->getMethodID(cls, "isReadonly", "()Z");
              mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
              mids$[mid_optimizeConfigs_4bd1fd6f8f3ec57e] = env->getMethodID(cls, "optimizeConfigs", "(Lorg/antlr/v4/runtime/atn/ATNSimulator;)V");
              mids$[mid_remove_8b72f2dcdde6fd1d] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Z");
              mids$[mid_removeAll_15d9cc2398c22637] = env->getMethodID(cls, "removeAll", "(Ljava/util/Collection;)Z");
              mids$[mid_retainAll_15d9cc2398c22637] = env->getMethodID(cls, "retainAll", "(Ljava/util/Collection;)Z");
              mids$[mid_setReadonly_9d72768e8fdce2b7] = env->getMethodID(cls, "setReadonly", "(Z)V");
              mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
              mids$[mid_toArray_29d905cced791577] = env->getMethodID(cls, "toArray", "()[Lorg/antlr/v4/runtime/atn/ATNConfig;");
              mids$[mid_toArray_609b05756010dc5d] = env->getMethodID(cls, "toArray", "([Ljava/lang/Object;)[Ljava/lang/Object;");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

              fids$ = new jfieldID[max_fid];
              fids$[fid_configLookup] = env->getFieldID(cls, "configLookup", "Lorg/antlr/v4/runtime/atn/ATNConfigSet$AbstractConfigHashSet;");
              fids$[fid_configs] = env->getFieldID(cls, "configs", "Ljava/util/ArrayList;");
              fids$[fid_dipsIntoOuterContext] = env->getFieldID(cls, "dipsIntoOuterContext", "Z");
              fids$[fid_fullCtx] = env->getFieldID(cls, "fullCtx", "Z");
              fids$[fid_hasSemanticContext] = env->getFieldID(cls, "hasSemanticContext", "Z");
              fids$[fid_uniqueAlt] = env->getFieldID(cls, "uniqueAlt", "I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ATNConfigSet::ATNConfigSet() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          ATNConfigSet::ATNConfigSet(jboolean a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_9d72768e8fdce2b7, a0)) {}

          jboolean ATNConfigSet::add(const ::org::antlr::v4::runtime::atn::ATNConfig & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_add_ee797c2c9eeb87eb], a0.this$);
          }

          jboolean ATNConfigSet::addAll(const ::java::util::Collection & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_addAll_15d9cc2398c22637], a0.this$);
          }

          void ATNConfigSet::clear() const
          {
            env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
          }

          jboolean ATNConfigSet::contains(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_contains_8b72f2dcdde6fd1d], a0.this$);
          }

          jboolean ATNConfigSet::containsAll(const ::java::util::Collection & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_containsAll_15d9cc2398c22637], a0.this$);
          }

          jboolean ATNConfigSet::containsFast(const ::org::antlr::v4::runtime::atn::ATNConfig & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_containsFast_ee797c2c9eeb87eb], a0.this$);
          }

          ::java::util::List ATNConfigSet::elements() const
          {
            return ::java::util::List(env->callObjectMethod(this$, mids$[mid_elements_49ec78390f08338a]));
          }

          jboolean ATNConfigSet::equals(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
          }

          ::org::antlr::v4::runtime::atn::ATNConfig ATNConfigSet::get(jint a0) const
          {
            return ::org::antlr::v4::runtime::atn::ATNConfig(env->callObjectMethod(this$, mids$[mid_get_524964022147277a], a0));
          }

          ::java::util::BitSet ATNConfigSet::getAlts() const
          {
            return ::java::util::BitSet(env->callObjectMethod(this$, mids$[mid_getAlts_56fb7b391b4328ed]));
          }

          ::java::util::List ATNConfigSet::getPredicates() const
          {
            return ::java::util::List(env->callObjectMethod(this$, mids$[mid_getPredicates_49ec78390f08338a]));
          }

          ::java::util::Set ATNConfigSet::getStates() const
          {
            return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_getStates_7dcf4034c6d1a92a]));
          }

          jint ATNConfigSet::hashCode() const
          {
            return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
          }

          jboolean ATNConfigSet::isEmpty() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
          }

          jboolean ATNConfigSet::isReadonly() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isReadonly_8454bd5aa23fd11e]);
          }

          ::java::util::Iterator ATNConfigSet::iterator() const
          {
            return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
          }

          void ATNConfigSet::optimizeConfigs(const ::org::antlr::v4::runtime::atn::ATNSimulator & a0) const
          {
            env->callVoidMethod(this$, mids$[mid_optimizeConfigs_4bd1fd6f8f3ec57e], a0.this$);
          }

          jboolean ATNConfigSet::remove(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_remove_8b72f2dcdde6fd1d], a0.this$);
          }

          jboolean ATNConfigSet::removeAll(const ::java::util::Collection & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_removeAll_15d9cc2398c22637], a0.this$);
          }

          jboolean ATNConfigSet::retainAll(const ::java::util::Collection & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_retainAll_15d9cc2398c22637], a0.this$);
          }

          void ATNConfigSet::setReadonly(jboolean a0) const
          {
            env->callVoidMethod(this$, mids$[mid_setReadonly_9d72768e8fdce2b7], a0);
          }

          jint ATNConfigSet::size() const
          {
            return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
          }

          JArray< ::org::antlr::v4::runtime::atn::ATNConfig > ATNConfigSet::toArray() const
          {
            return JArray< ::org::antlr::v4::runtime::atn::ATNConfig >(env->callObjectMethod(this$, mids$[mid_toArray_29d905cced791577]));
          }

          JArray< ::java::lang::Object > ATNConfigSet::toArray(const JArray< ::java::lang::Object > & a0) const
          {
            return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_609b05756010dc5d], a0.this$));
          }

          ::java::lang::String ATNConfigSet::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }

          ::org::antlr::v4::runtime::atn::ATNConfigSet$AbstractConfigHashSet ATNConfigSet::_get_configLookup() const
          {
            return ::org::antlr::v4::runtime::atn::ATNConfigSet$AbstractConfigHashSet(env->getObjectField(this$, fids$[fid_configLookup]));
          }

          void ATNConfigSet::_set_configLookup(const ::org::antlr::v4::runtime::atn::ATNConfigSet$AbstractConfigHashSet & a0) const
          {
            env->setObjectField(this$, fids$[fid_configLookup], a0.this$);
          }

          ::java::util::ArrayList ATNConfigSet::_get_configs() const
          {
            return ::java::util::ArrayList(env->getObjectField(this$, fids$[fid_configs]));
          }

          jboolean ATNConfigSet::_get_dipsIntoOuterContext() const
          {
            return env->getBooleanField(this$, fids$[fid_dipsIntoOuterContext]);
          }

          void ATNConfigSet::_set_dipsIntoOuterContext(jboolean a0) const
          {
            env->setBooleanField(this$, fids$[fid_dipsIntoOuterContext], a0);
          }

          jboolean ATNConfigSet::_get_fullCtx() const
          {
            return env->getBooleanField(this$, fids$[fid_fullCtx]);
          }

          jboolean ATNConfigSet::_get_hasSemanticContext() const
          {
            return env->getBooleanField(this$, fids$[fid_hasSemanticContext]);
          }

          void ATNConfigSet::_set_hasSemanticContext(jboolean a0) const
          {
            env->setBooleanField(this$, fids$[fid_hasSemanticContext], a0);
          }

          jint ATNConfigSet::_get_uniqueAlt() const
          {
            return env->getIntField(this$, fids$[fid_uniqueAlt]);
          }

          void ATNConfigSet::_set_uniqueAlt(jint a0) const
          {
            env->setIntField(this$, fids$[fid_uniqueAlt], a0);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ATNConfigSet_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNConfigSet_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ATNConfigSet_init_(t_ATNConfigSet *self, PyObject *args, PyObject *kwds);
          static PyObject *t_ATNConfigSet_add(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_addAll(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_clear(t_ATNConfigSet *self);
          static PyObject *t_ATNConfigSet_contains(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_containsAll(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_containsFast(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_elements(t_ATNConfigSet *self);
          static PyObject *t_ATNConfigSet_equals(t_ATNConfigSet *self, PyObject *args);
          static PyObject *t_ATNConfigSet_get(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_getAlts(t_ATNConfigSet *self);
          static PyObject *t_ATNConfigSet_getPredicates(t_ATNConfigSet *self);
          static PyObject *t_ATNConfigSet_getStates(t_ATNConfigSet *self);
          static PyObject *t_ATNConfigSet_hashCode(t_ATNConfigSet *self, PyObject *args);
          static PyObject *t_ATNConfigSet_isEmpty(t_ATNConfigSet *self);
          static PyObject *t_ATNConfigSet_isReadonly(t_ATNConfigSet *self);
          static PyObject *t_ATNConfigSet_iterator(t_ATNConfigSet *self);
          static PyObject *t_ATNConfigSet_optimizeConfigs(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_remove(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_removeAll(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_retainAll(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_setReadonly(t_ATNConfigSet *self, PyObject *arg);
          static PyObject *t_ATNConfigSet_size(t_ATNConfigSet *self);
          static PyObject *t_ATNConfigSet_toArray(t_ATNConfigSet *self, PyObject *args);
          static PyObject *t_ATNConfigSet_toString(t_ATNConfigSet *self, PyObject *args);
          static PyObject *t_ATNConfigSet_get__configLookup(t_ATNConfigSet *self, void *data);
          static int t_ATNConfigSet_set__configLookup(t_ATNConfigSet *self, PyObject *arg, void *data);
          static PyObject *t_ATNConfigSet_get__configs(t_ATNConfigSet *self, void *data);
          static PyObject *t_ATNConfigSet_get__dipsIntoOuterContext(t_ATNConfigSet *self, void *data);
          static int t_ATNConfigSet_set__dipsIntoOuterContext(t_ATNConfigSet *self, PyObject *arg, void *data);
          static PyObject *t_ATNConfigSet_get__fullCtx(t_ATNConfigSet *self, void *data);
          static PyObject *t_ATNConfigSet_get__hasSemanticContext(t_ATNConfigSet *self, void *data);
          static int t_ATNConfigSet_set__hasSemanticContext(t_ATNConfigSet *self, PyObject *arg, void *data);
          static PyObject *t_ATNConfigSet_get__uniqueAlt(t_ATNConfigSet *self, void *data);
          static int t_ATNConfigSet_set__uniqueAlt(t_ATNConfigSet *self, PyObject *arg, void *data);

          static PyObject *t_ATNConfigSet_get__alts(t_ATNConfigSet *self, void *data);
          static PyObject *t_ATNConfigSet_get__empty(t_ATNConfigSet *self, void *data);
          static PyObject *t_ATNConfigSet_get__predicates(t_ATNConfigSet *self, void *data);
          static PyObject *t_ATNConfigSet_get__readonly(t_ATNConfigSet *self, void *data);
          static int t_ATNConfigSet_set__readonly(t_ATNConfigSet *self, PyObject *arg, void *data);
          static PyObject *t_ATNConfigSet_get__states(t_ATNConfigSet *self, void *data);
          static PyGetSetDef t_ATNConfigSet__fields_[] = {
            DECLARE_GETSET_FIELD(t_ATNConfigSet, configLookup),
            DECLARE_GET_FIELD(t_ATNConfigSet, configs),
            DECLARE_GETSET_FIELD(t_ATNConfigSet, dipsIntoOuterContext),
            DECLARE_GET_FIELD(t_ATNConfigSet, fullCtx),
            DECLARE_GETSET_FIELD(t_ATNConfigSet, hasSemanticContext),
            DECLARE_GETSET_FIELD(t_ATNConfigSet, uniqueAlt),
            DECLARE_GET_FIELD(t_ATNConfigSet, alts),
            DECLARE_GET_FIELD(t_ATNConfigSet, empty),
            DECLARE_GET_FIELD(t_ATNConfigSet, predicates),
            DECLARE_GETSET_FIELD(t_ATNConfigSet, readonly),
            DECLARE_GET_FIELD(t_ATNConfigSet, states),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ATNConfigSet__methods_[] = {
            DECLARE_METHOD(t_ATNConfigSet, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNConfigSet, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNConfigSet, add, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, addAll, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, clear, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfigSet, contains, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, containsAll, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, containsFast, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, elements, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfigSet, equals, METH_VARARGS),
            DECLARE_METHOD(t_ATNConfigSet, get, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, getAlts, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfigSet, getPredicates, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfigSet, getStates, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfigSet, hashCode, METH_VARARGS),
            DECLARE_METHOD(t_ATNConfigSet, isEmpty, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfigSet, isReadonly, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfigSet, iterator, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfigSet, optimizeConfigs, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, remove, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, removeAll, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, retainAll, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, setReadonly, METH_O),
            DECLARE_METHOD(t_ATNConfigSet, size, METH_NOARGS),
            DECLARE_METHOD(t_ATNConfigSet, toArray, METH_VARARGS),
            DECLARE_METHOD(t_ATNConfigSet, toString, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ATNConfigSet)[] = {
            { Py_tp_methods, t_ATNConfigSet__methods_ },
            { Py_tp_init, (void *) t_ATNConfigSet_init_ },
            { Py_tp_getset, t_ATNConfigSet__fields_ },
            { Py_tp_iter, (void *) ((PyObject *(*)(t_ATNConfigSet *)) get_iterator< t_ATNConfigSet >) },
            { Py_tp_iternext, (void *) 0 },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ATNConfigSet)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(ATNConfigSet, t_ATNConfigSet, ATNConfigSet);

          void t_ATNConfigSet::install(PyObject *module)
          {
            installType(&PY_TYPE(ATNConfigSet), &PY_TYPE_DEF(ATNConfigSet), module, "ATNConfigSet", 0);
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfigSet), "AbstractConfigHashSet", make_descriptor(&PY_TYPE_DEF(ATNConfigSet$AbstractConfigHashSet)));
          }

          void t_ATNConfigSet::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfigSet), "class_", make_descriptor(ATNConfigSet::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfigSet), "wrapfn_", make_descriptor(t_ATNConfigSet::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfigSet), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_ATNConfigSet_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ATNConfigSet::initializeClass, 1)))
              return NULL;
            return t_ATNConfigSet::wrap_Object(ATNConfigSet(((t_ATNConfigSet *) arg)->object.this$));
          }
          static PyObject *t_ATNConfigSet_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ATNConfigSet::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ATNConfigSet_init_(t_ATNConfigSet *self, PyObject *args, PyObject *kwds)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 0:
              {
                ATNConfigSet object((jobject) NULL);

                INT_CALL(object = ATNConfigSet());
                self->object = object;
                break;
              }
             case 1:
              {
                jboolean a0;
                ATNConfigSet object((jobject) NULL);

                if (!parseArgs(args, "Z", &a0))
                {
                  INT_CALL(object = ATNConfigSet(a0));
                  self->object = object;
                  break;
                }
              }
             default:
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_ATNConfigSet_add(t_ATNConfigSet *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNConfig a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNConfig::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.add(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "add", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_addAll(t_ATNConfigSet *self, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.addAll(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "addAll", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_clear(t_ATNConfigSet *self)
          {
            OBJ_CALL(self->object.clear());
            Py_RETURN_NONE;
          }

          static PyObject *t_ATNConfigSet_contains(t_ATNConfigSet *self, PyObject *arg)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "o", &a0))
            {
              OBJ_CALL(result = self->object.contains(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "contains", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_containsAll(t_ATNConfigSet *self, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.containsAll(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "containsAll", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_containsFast(t_ATNConfigSet *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNConfig a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNConfig::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.containsFast(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "containsFast", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_elements(t_ATNConfigSet *self)
          {
            ::java::util::List result((jobject) NULL);
            OBJ_CALL(result = self->object.elements());
            return ::java::util::t_List::wrap_Object(result, ::org::antlr::v4::runtime::atn::PY_TYPE(ATNConfig));
          }

          static PyObject *t_ATNConfigSet_equals(t_ATNConfigSet *self, PyObject *args)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "o", &a0))
            {
              OBJ_CALL(result = self->object.equals(a0));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(ATNConfigSet), (PyObject *) self, "equals", args, 2);
          }

          static PyObject *t_ATNConfigSet_get(t_ATNConfigSet *self, PyObject *arg)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::ATNConfig result((jobject) NULL);

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(result = self->object.get(a0));
              return ::org::antlr::v4::runtime::atn::t_ATNConfig::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "get", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_getAlts(t_ATNConfigSet *self)
          {
            ::java::util::BitSet result((jobject) NULL);
            OBJ_CALL(result = self->object.getAlts());
            return ::java::util::t_BitSet::wrap_Object(result);
          }

          static PyObject *t_ATNConfigSet_getPredicates(t_ATNConfigSet *self)
          {
            ::java::util::List result((jobject) NULL);
            OBJ_CALL(result = self->object.getPredicates());
            return ::java::util::t_List::wrap_Object(result, ::org::antlr::v4::runtime::atn::PY_TYPE(SemanticContext));
          }

          static PyObject *t_ATNConfigSet_getStates(t_ATNConfigSet *self)
          {
            ::java::util::Set result((jobject) NULL);
            OBJ_CALL(result = self->object.getStates());
            return ::java::util::t_Set::wrap_Object(result, ::org::antlr::v4::runtime::atn::PY_TYPE(ATNState));
          }

          static PyObject *t_ATNConfigSet_hashCode(t_ATNConfigSet *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.hashCode());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(ATNConfigSet), (PyObject *) self, "hashCode", args, 2);
          }

          static PyObject *t_ATNConfigSet_isEmpty(t_ATNConfigSet *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.isEmpty());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_ATNConfigSet_isReadonly(t_ATNConfigSet *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.isReadonly());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_ATNConfigSet_iterator(t_ATNConfigSet *self)
          {
            ::java::util::Iterator result((jobject) NULL);
            OBJ_CALL(result = self->object.iterator());
            return ::java::util::t_Iterator::wrap_Object(result, ::org::antlr::v4::runtime::atn::PY_TYPE(ATNConfig));
          }

          static PyObject *t_ATNConfigSet_optimizeConfigs(t_ATNConfigSet *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::atn::ATNSimulator a0((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNSimulator::initializeClass, &a0))
            {
              OBJ_CALL(self->object.optimizeConfigs(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "optimizeConfigs", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_remove(t_ATNConfigSet *self, PyObject *arg)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "o", &a0))
            {
              OBJ_CALL(result = self->object.remove(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "remove", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_removeAll(t_ATNConfigSet *self, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.removeAll(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "removeAll", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_retainAll(t_ATNConfigSet *self, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.retainAll(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "retainAll", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_setReadonly(t_ATNConfigSet *self, PyObject *arg)
          {
            jboolean a0;

            if (!parseArg(arg, "Z", &a0))
            {
              OBJ_CALL(self->object.setReadonly(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "setReadonly", arg);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_size(t_ATNConfigSet *self)
          {
            jint result;
            OBJ_CALL(result = self->object.size());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_ATNConfigSet_toArray(t_ATNConfigSet *self, PyObject *args)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 0:
              {
                JArray< ::org::antlr::v4::runtime::atn::ATNConfig > result((jobject) NULL);
                OBJ_CALL(result = self->object.toArray());
                return JArray<jobject>(result.this$).wrap(::org::antlr::v4::runtime::atn::t_ATNConfig::wrap_jobject);
              }
              break;
             case 1:
              {
                JArray< ::java::lang::Object > a0((jobject) NULL);
                JArray< ::java::lang::Object > result((jobject) NULL);

                if (!parseArgs(args, "[o", &a0))
                {
                  OBJ_CALL(result = self->object.toArray(a0));
                  return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
                }
              }
            }

            PyErr_SetArgsError((PyObject *) self, "toArray", args);
            return NULL;
          }

          static PyObject *t_ATNConfigSet_toString(t_ATNConfigSet *self, PyObject *args)
          {
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.toString());
              return j2p(result);
            }

            return callSuper(PY_TYPE(ATNConfigSet), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_ATNConfigSet_get__configLookup(t_ATNConfigSet *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATNConfigSet$AbstractConfigHashSet value((jobject) NULL);
            OBJ_CALL(value = self->object._get_configLookup());
            return ::org::antlr::v4::runtime::atn::t_ATNConfigSet$AbstractConfigHashSet::wrap_Object(value);
          }
          static int t_ATNConfigSet_set__configLookup(t_ATNConfigSet *self, PyObject *arg, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATNConfigSet$AbstractConfigHashSet value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::ATNConfigSet$AbstractConfigHashSet::initializeClass, &value))
            {
              INT_CALL(self->object._set_configLookup(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "configLookup", arg);
            return -1;
          }

          static PyObject *t_ATNConfigSet_get__configs(t_ATNConfigSet *self, void *data)
          {
            ::java::util::ArrayList value((jobject) NULL);
            OBJ_CALL(value = self->object._get_configs());
            return ::java::util::t_ArrayList::wrap_Object(value);
          }

          static PyObject *t_ATNConfigSet_get__dipsIntoOuterContext(t_ATNConfigSet *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object._get_dipsIntoOuterContext());
            Py_RETURN_BOOL(value);
          }
          static int t_ATNConfigSet_set__dipsIntoOuterContext(t_ATNConfigSet *self, PyObject *arg, void *data)
          {
            jboolean value;
            if (!parseArg(arg, "Z", &value))
            {
              INT_CALL(self->object._set_dipsIntoOuterContext(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "dipsIntoOuterContext", arg);
            return -1;
          }

          static PyObject *t_ATNConfigSet_get__fullCtx(t_ATNConfigSet *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object._get_fullCtx());
            Py_RETURN_BOOL(value);
          }

          static PyObject *t_ATNConfigSet_get__hasSemanticContext(t_ATNConfigSet *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object._get_hasSemanticContext());
            Py_RETURN_BOOL(value);
          }
          static int t_ATNConfigSet_set__hasSemanticContext(t_ATNConfigSet *self, PyObject *arg, void *data)
          {
            jboolean value;
            if (!parseArg(arg, "Z", &value))
            {
              INT_CALL(self->object._set_hasSemanticContext(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "hasSemanticContext", arg);
            return -1;
          }

          static PyObject *t_ATNConfigSet_get__uniqueAlt(t_ATNConfigSet *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_uniqueAlt());
            return PyLong_FromLong((long) value);
          }
          static int t_ATNConfigSet_set__uniqueAlt(t_ATNConfigSet *self, PyObject *arg, void *data)
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object._set_uniqueAlt(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "uniqueAlt", arg);
            return -1;
          }

          static PyObject *t_ATNConfigSet_get__alts(t_ATNConfigSet *self, void *data)
          {
            ::java::util::BitSet value((jobject) NULL);
            OBJ_CALL(value = self->object.getAlts());
            return ::java::util::t_BitSet::wrap_Object(value);
          }

          static PyObject *t_ATNConfigSet_get__empty(t_ATNConfigSet *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isEmpty());
            Py_RETURN_BOOL(value);
          }

          static PyObject *t_ATNConfigSet_get__predicates(t_ATNConfigSet *self, void *data)
          {
            ::java::util::List value((jobject) NULL);
            OBJ_CALL(value = self->object.getPredicates());
            return ::java::util::t_List::wrap_Object(value);
          }

          static PyObject *t_ATNConfigSet_get__readonly(t_ATNConfigSet *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isReadonly());
            Py_RETURN_BOOL(value);
          }
          static int t_ATNConfigSet_set__readonly(t_ATNConfigSet *self, PyObject *arg, void *data)
          {
            {
              jboolean value;
              if (!parseArg(arg, "Z", &value))
              {
                INT_CALL(self->object.setReadonly(value));
                return 0;
              }
            }
            PyErr_SetArgsError((PyObject *) self, "readonly", arg);
            return -1;
          }

          static PyObject *t_ATNConfigSet_get__states(t_ATNConfigSet *self, void *data)
          {
            ::java::util::Set value((jobject) NULL);
            OBJ_CALL(value = self->object.getStates());
            return ::java::util::t_Set::wrap_Object(value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/SemanticContext$PrecedencePredicate.h"
#include "org/antlr/v4/runtime/atn/SemanticContext$PrecedencePredicate.h"
#include "java/lang/Comparable.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "org/antlr/v4/runtime/RuleContext.h"
#include "org/antlr/v4/runtime/Recognizer.h"
#include "java/lang/String.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *SemanticContext$PrecedencePredicate::class$ = NULL;
          jmethodID *SemanticContext$PrecedencePredicate::mids$ = NULL;
          jfieldID *SemanticContext$PrecedencePredicate::fids$ = NULL;
          bool SemanticContext$PrecedencePredicate::live$ = false;

          jclass SemanticContext$PrecedencePredicate::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/SemanticContext$PrecedencePredicate");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_040c4cd0390c5aff] = env->getMethodID(cls, "<init>", "(I)V");
              mids$[mid_compareTo_208d1032bbda3b94] = env->getMethodID(cls, "compareTo", "(Lorg/antlr/v4/runtime/atn/SemanticContext$PrecedencePredicate;)I");
              mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
              mids$[mid_eval_a1c281c055657321] = env->getMethodID(cls, "eval", "(Lorg/antlr/v4/runtime/Recognizer;Lorg/antlr/v4/runtime/RuleContext;)Z");
              mids$[mid_evalPrecedence_55d66a334128c50a] = env->getMethodID(cls, "evalPrecedence", "(Lorg/antlr/v4/runtime/Recognizer;Lorg/antlr/v4/runtime/RuleContext;)Lorg/antlr/v4/runtime/atn/SemanticContext;");
              mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

              fids$ = new jfieldID[max_fid];
              fids$[fid_precedence] = env->getFieldID(cls, "precedence", "I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          SemanticContext$PrecedencePredicate::SemanticContext$PrecedencePredicate(jint a0) : ::org::antlr::v4::runtime::atn::SemanticContext(env->newObject(initializeClass, &mids$, mid_init$_040c4cd0390c5aff, a0)) {}

          jint SemanticContext$PrecedencePredicate::compareTo(const SemanticContext$PrecedencePredicate & a0) const
          {
            return env->callIntMethod(this$, mids$[mid_compareTo_208d1032bbda3b94], a0.this$);
          }

          jboolean SemanticContext$PrecedencePredicate::equals(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
          }

          jboolean SemanticContext$PrecedencePredicate::eval(const ::org::antlr::v4::runtime::Recognizer & a0, const ::org::antlr::v4::runtime::RuleContext & a1) const
          {
            return env->callBooleanMethod(this$, mids$[mid_eval_a1c281c055657321], a0.this$, a1.this$);
          }

          ::org::antlr::v4::runtime::atn::SemanticContext SemanticContext$PrecedencePredicate::evalPrecedence(const ::org::antlr::v4::runtime::Recognizer & a0, const ::org::antlr::v4::runtime::RuleContext & a1) const
          {
            return ::org::antlr::v4::runtime::atn::SemanticContext(env->callObjectMethod(this$, mids$[mid_evalPrecedence_55d66a334128c50a], a0.this$, a1.this$));
          }

          jint SemanticContext$PrecedencePredicate::hashCode() const
          {
            return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
          }

          ::java::lang::String SemanticContext$PrecedencePredicate::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }

          jint SemanticContext$PrecedencePredicate::_get_precedence() const
          {
            return env->getIntField(this$, fids$[fid_precedence]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_SemanticContext$PrecedencePredicate_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_SemanticContext$PrecedencePredicate_instance_(PyTypeObject *type, PyObject *arg);
          static int t_SemanticContext$PrecedencePredicate_init_(t_SemanticContext$PrecedencePredicate *self, PyObject *args, PyObject *kwds);
          static PyObject *t_SemanticContext$PrecedencePredicate_compareTo(t_SemanticContext$PrecedencePredicate *self, PyObject *arg);
          static PyObject *t_SemanticContext$PrecedencePredicate_equals(t_SemanticContext$PrecedencePredicate *self, PyObject *args);
          static PyObject *t_SemanticContext$PrecedencePredicate_eval(t_SemanticContext$PrecedencePredicate *self, PyObject *args);
          static PyObject *t_SemanticContext$PrecedencePredicate_evalPrecedence(t_SemanticContext$PrecedencePredicate *self, PyObject *args);
          static PyObject *t_SemanticContext$PrecedencePredicate_hashCode(t_SemanticContext$PrecedencePredicate *self, PyObject *args);
          static PyObject *t_SemanticContext$PrecedencePredicate_toString(t_SemanticContext$PrecedencePredicate *self, PyObject *args);
          static PyObject *t_SemanticContext$PrecedencePredicate_get__precedence(t_SemanticContext$PrecedencePredicate *self, void *data);

          static PyGetSetDef t_SemanticContext$PrecedencePredicate__fields_[] = {
            DECLARE_GET_FIELD(t_SemanticContext$PrecedencePredicate, precedence),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_SemanticContext$PrecedencePredicate__methods_[] = {
            DECLARE_METHOD(t_SemanticContext$PrecedencePredicate, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_SemanticContext$PrecedencePredicate, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_SemanticContext$PrecedencePredicate, compareTo, METH_O),
            DECLARE_METHOD(t_SemanticContext$PrecedencePredicate, equals, METH_VARARGS),
            DECLARE_METHOD(t_SemanticContext$PrecedencePredicate, eval, METH_VARARGS),
            DECLARE_METHOD(t_SemanticContext$PrecedencePredicate, evalPrecedence, METH_VARARGS),
            DECLARE_METHOD(t_SemanticContext$PrecedencePredicate, hashCode, METH_VARARGS),
            DECLARE_METHOD(t_SemanticContext$PrecedencePredicate, toString, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(SemanticContext$PrecedencePredicate)[] = {
            { Py_tp_methods, t_SemanticContext$PrecedencePredicate__methods_ },
            { Py_tp_init, (void *) t_SemanticContext$PrecedencePredicate_init_ },
            { Py_tp_getset, t_SemanticContext$PrecedencePredicate__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(SemanticContext$PrecedencePredicate)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::SemanticContext),
            NULL
          };

          DEFINE_TYPE(SemanticContext$PrecedencePredicate, t_SemanticContext$PrecedencePredicate, SemanticContext$PrecedencePredicate);

          void t_SemanticContext$PrecedencePredicate::install(PyObject *module)
          {
            installType(&PY_TYPE(SemanticContext$PrecedencePredicate), &PY_TYPE_DEF(SemanticContext$PrecedencePredicate), module, "SemanticContext$PrecedencePredicate", 0);
          }

          void t_SemanticContext$PrecedencePredicate::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(SemanticContext$PrecedencePredicate), "class_", make_descriptor(SemanticContext$PrecedencePredicate::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(SemanticContext$PrecedencePredicate), "wrapfn_", make_descriptor(t_SemanticContext$PrecedencePredicate::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(SemanticContext$PrecedencePredicate), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_SemanticContext$PrecedencePredicate_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, SemanticContext$PrecedencePredicate::initializeClass, 1)))
              return NULL;
            return t_SemanticContext$PrecedencePredicate::wrap_Object(SemanticContext$PrecedencePredicate(((t_SemanticContext$PrecedencePredicate *) arg)->object.this$));
          }
          static PyObject *t_SemanticContext$PrecedencePredicate_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, SemanticContext$PrecedencePredicate::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_SemanticContext$PrecedencePredicate_init_(t_SemanticContext$PrecedencePredicate *self, PyObject *args, PyObject *kwds)
          {
            jint a0;
            SemanticContext$PrecedencePredicate object((jobject) NULL);

            if (!parseArgs(args, "I", &a0))
            {
              INT_CALL(object = SemanticContext$PrecedencePredicate(a0));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_SemanticContext$PrecedencePredicate_compareTo(t_SemanticContext$PrecedencePredicate *self, PyObject *arg)
          {
            SemanticContext$PrecedencePredicate a0((jobject) NULL);
            jint result;

            if (!parseArg(arg, "k", SemanticContext$PrecedencePredicate::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.compareTo(a0));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError((PyObject *) self, "compareTo", arg);
            return NULL;
          }

          static PyObject *t_SemanticContext$PrecedencePredicate_equals(t_SemanticContext$PrecedencePredicate *self, PyObject *args)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "o", &a0))
            {
              OBJ_CALL(result = self->object.equals(a0));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(SemanticContext$PrecedencePredicate), (PyObject *) self, "equals", args, 2);
          }

          static PyObject *t_SemanticContext$PrecedencePredicate_eval(t_SemanticContext$PrecedencePredicate *self, PyObject *args)
          {
            ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
            PyTypeObject **p0;
            ::org::antlr::v4::runtime::RuleContext a1((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "Kk", ::org::antlr::v4::runtime::Recognizer::initializeClass, ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a1))
            {
              OBJ_CALL(result = self->object.eval(a0, a1));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(SemanticContext$PrecedencePredicate), (PyObject *) self, "eval", args, 2);
          }

          static PyObject *t_SemanticContext$PrecedencePredicate_evalPrecedence(t_SemanticContext$PrecedencePredicate *self, PyObject *args)
          {
            ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
            PyTypeObject **p0;
            ::org::antlr::v4::runtime::RuleContext a1((jobject) NULL);
            ::org::antlr::v4::runtime::atn::SemanticContext result((jobject) NULL);

            if (!parseArgs(args, "Kk", ::org::antlr::v4::runtime::Recognizer::initializeClass, ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a1))
            {
              OBJ_CALL(result = self->object.evalPrecedence(a0, a1));
              return ::org::antlr::v4::runtime::atn::t_SemanticContext::wrap_Object(result);
            }

            return callSuper(PY_TYPE(SemanticContext$PrecedencePredicate), (PyObject *) self, "evalPrecedence", args, 2);
          }

          static PyObject *t_SemanticContext$PrecedencePredicate_hashCode(t_SemanticContext$PrecedencePredicate *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.hashCode());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(SemanticContext$PrecedencePredicate), (PyObject *) self, "hashCode", args, 2);
          }

          static PyObject *t_SemanticContext$PrecedencePredicate_toString(t_SemanticContext$PrecedencePredicate *self, PyObject *args)
          {
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.toString());
              return j2p(result);
            }

            return callSuper(PY_TYPE(SemanticContext$PrecedencePredicate), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_SemanticContext$PrecedencePredicate_get__precedence(t_SemanticContext$PrecedencePredicate *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_precedence());
            return PyLong_FromLong((long) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/io/SyncFailedException.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace io {

    ::java::lang::Class *SyncFailedException::class$ = NULL;
    jmethodID *SyncFailedException::mids$ = NULL;
    bool SyncFailedException::live$ = false;

    jclass SyncFailedException::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/io/SyncFailedException");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_9fd2eb66a64e6f0f] = env->getMethodID(cls, "<init>", "(Ljava/lang/String;)V");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    SyncFailedException::SyncFailedException(const ::java::lang::String & a0) : ::java::io::IOException(env->newObject(initializeClass, &mids$, mid_init$_9fd2eb66a64e6f0f, a0.this$)) {}
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace io {
    static PyObject *t_SyncFailedException_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_SyncFailedException_instance_(PyTypeObject *type, PyObject *arg);
    static int t_SyncFailedException_init_(t_SyncFailedException *self, PyObject *args, PyObject *kwds);

    static PyMethodDef t_SyncFailedException__methods_[] = {
      DECLARE_METHOD(t_SyncFailedException, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_SyncFailedException, instance_, METH_O | METH_CLASS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(SyncFailedException)[] = {
      { Py_tp_methods, t_SyncFailedException__methods_ },
      { Py_tp_init, (void *) t_SyncFailedException_init_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(SyncFailedException)[] = {
      &PY_TYPE_DEF(::java::io::IOException),
      NULL
    };

    DEFINE_TYPE(SyncFailedException, t_SyncFailedException, SyncFailedException);

    void t_SyncFailedException::install(PyObject *module)
    {
      installType(&PY_TYPE(SyncFailedException), &PY_TYPE_DEF(SyncFailedException), module, "SyncFailedException", 0);
    }

    void t_SyncFailedException::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(SyncFailedException), "class_", make_descriptor(SyncFailedException::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SyncFailedException), "wrapfn_", make_descriptor(t_SyncFailedException::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(SyncFailedException), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_SyncFailedException_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, SyncFailedException::initializeClass, 1)))
        return NULL;
      return t_SyncFailedException::wrap_Object(SyncFailedException(((t_SyncFailedException *) arg)->object.this$));
    }
    static PyObject *t_SyncFailedException_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, SyncFailedException::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static int t_SyncFailedException_init_(t_SyncFailedException *self, PyObject *args, PyObject *kwds)
    {
      ::java::lang::String a0((jobject) NULL);
      SyncFailedException object((jobject) NULL);

      if (!parseArgs(args, "s", &a0))
      {
        INT_CALL(object = SyncFailedException(a0));
        self->object = object;
      }
      else
      {
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ArrayPredictionContext.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/SingletonPredictionContext.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ArrayPredictionContext::class$ = NULL;
          jmethodID *ArrayPredictionContext::mids$ = NULL;
          jfieldID *ArrayPredictionContext::fids$ = NULL;
          bool ArrayPredictionContext::live$ = false;

          jclass ArrayPredictionContext::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ArrayPredictionContext");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_5f7228132fa71a31] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/atn/SingletonPredictionContext;)V");
              mids$[mid_init$_d89cc7ccad3b30d5] = env->getMethodID(cls, "<init>", "([Lorg/antlr/v4/runtime/atn/PredictionContext;[I)V");
              mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
              mids$[mid_getParent_de7c941e2462c7c5] = env->getMethodID(cls, "getParent", "(I)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_getReturnState_1e143afe1894d213] = env->getMethodID(cls, "getReturnState", "(I)I");
              mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
              mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

              fids$ = new jfieldID[max_fid];
              fids$[fid_parents] = env->getFieldID(cls, "parents", "[Lorg/antlr/v4/runtime/atn/PredictionContext;");
              fids$[fid_returnStates] = env->getFieldID(cls, "returnStates", "[I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ArrayPredictionContext::ArrayPredictionContext(const ::org::antlr::v4::runtime::atn::SingletonPredictionContext & a0) : ::org::antlr::v4::runtime::atn::PredictionContext(env->newObject(initializeClass, &mids$, mid_init$_5f7228132fa71a31, a0.this$)) {}

          ArrayPredictionContext::ArrayPredictionContext(const JArray< ::org::antlr::v4::runtime::atn::PredictionContext > & a0, const JArray< jint > & a1) : ::org::antlr::v4::runtime::atn::PredictionContext(env->newObject(initializeClass, &mids$, mid_init$_d89cc7ccad3b30d5, a0.this$, a1.this$)) {}

          jboolean ArrayPredictionContext::equals(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
          }

          ::org::antlr::v4::runtime::atn::PredictionContext ArrayPredictionContext::getParent(jint a0) const
          {
            return ::org::antlr::v4::runtime::atn::PredictionContext(env->callObjectMethod(this$, mids$[mid_getParent_de7c941e2462c7c5], a0));
          }

          jint ArrayPredictionContext::getReturnState(jint a0) const
          {
            return env->callIntMethod(this$, mids$[mid_getReturnState_1e143afe1894d213], a0);
          }

          jboolean ArrayPredictionContext::isEmpty() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
          }

          jint ArrayPredictionContext::size() const
          {
            return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
          }

          ::java::lang::String ArrayPredictionContext::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }

          JArray< ::org::antlr::v4::runtime::atn::PredictionContext > ArrayPredictionContext::_get_parents() const
          {
            return JArray< ::org::antlr::v4::runtime::atn::PredictionContext >(env->getObjectField(this$, fids$[fid_parents]));
          }

          JArray< jint > ArrayPredictionContext::_get_returnStates() const
          {
            return JArray< jint >(env->getObjectField(this$, fids$[fid_returnStates]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ArrayPredictionContext_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ArrayPredictionContext_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ArrayPredictionContext_init_(t_ArrayPredictionContext *self, PyObject *args, PyObject *kwds);
          static PyObject *t_ArrayPredictionContext_equals(t_ArrayPredictionContext *self, PyObject *args);
          static PyObject *t_ArrayPredictionContext_getParent(t_ArrayPredictionContext *self, PyObject *args);
          static PyObject *t_ArrayPredictionContext_getReturnState(t_ArrayPredictionContext *self, PyObject *args);
          static PyObject *t_ArrayPredictionContext_isEmpty(t_ArrayPredictionContext *self, PyObject *args);
          static PyObject *t_ArrayPredictionContext_size(t_ArrayPredictionContext *self, PyObject *args);
          static PyObject *t_ArrayPredictionContext_toString(t_ArrayPredictionContext *self, PyObject *args);
          static PyObject *t_ArrayPredictionContext_get__parents(t_ArrayPredictionContext *self, void *data);
          static PyObject *t_ArrayPredictionContext_get__returnStates(t_ArrayPredictionContext *self, void *data);

          static PyObject *t_ArrayPredictionContext_get__empty(t_ArrayPredictionContext *self, void *data);
          static PyGetSetDef t_ArrayPredictionContext__fields_[] = {
            DECLARE_GET_FIELD(t_ArrayPredictionContext, parents),
            DECLARE_GET_FIELD(t_ArrayPredictionContext, returnStates),
            DECLARE_GET_FIELD(t_ArrayPredictionContext, empty),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ArrayPredictionContext__methods_[] = {
            DECLARE_METHOD(t_ArrayPredictionContext, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ArrayPredictionContext, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ArrayPredictionContext, equals, METH_VARARGS),
            DECLARE_METHOD(t_ArrayPredictionContext, getParent, METH_VARARGS),
            DECLARE_METHOD(t_ArrayPredictionContext, getReturnState, METH_VARARGS),
            DECLARE_METHOD(t_ArrayPredictionContext, isEmpty, METH_VARARGS),
            DECLARE_METHOD(t_ArrayPredictionContext, size, METH_VARARGS),
            DECLARE_METHOD(t_ArrayPredictionContext, toString, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ArrayPredictionContext)[] = {
            { Py_tp_methods, t_ArrayPredictionContext__methods_ },
            { Py_tp_init, (void *) t_ArrayPredictionContext_init_ },
            { Py_tp_getset, t_ArrayPredictionContext__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ArrayPredictionContext)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::PredictionContext),
            NULL
          };

          DEFINE_TYPE(ArrayPredictionContext, t_ArrayPredictionContext, ArrayPredictionContext);

          void t_ArrayPredictionContext::install(PyObject *module)
          {
            installType(&PY_TYPE(ArrayPredictionContext), &PY_TYPE_DEF(ArrayPredictionContext), module, "ArrayPredictionContext", 0);
          }

          void t_ArrayPredictionContext::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ArrayPredictionContext), "class_", make_descriptor(ArrayPredictionContext::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ArrayPredictionContext), "wrapfn_", make_descriptor(t_ArrayPredictionContext::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ArrayPredictionContext), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_ArrayPredictionContext_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ArrayPredictionContext::initializeClass, 1)))
              return NULL;
            return t_ArrayPredictionContext::wrap_Object(ArrayPredictionContext(((t_ArrayPredictionContext *) arg)->object.this$));
          }
          static PyObject *t_ArrayPredictionContext_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ArrayPredictionContext::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ArrayPredictionContext_init_(t_ArrayPredictionContext *self, PyObject *args, PyObject *kwds)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 1:
              {
                ::org::antlr::v4::runtime::atn::SingletonPredictionContext a0((jobject) NULL);
                ArrayPredictionContext object((jobject) NULL);

                if (!parseArgs(args, "k", ::org::antlr::v4::runtime::atn::SingletonPredictionContext::initializeClass, &a0))
                {
                  INT_CALL(object = ArrayPredictionContext(a0));
                  self->object = object;
                  break;
                }
              }
              goto err;
             case 2:
              {
                JArray< ::org::antlr::v4::runtime::atn::PredictionContext > a0((jobject) NULL);
                JArray< jint > a1((jobject) NULL);
                ArrayPredictionContext object((jobject) NULL);

                if (!parseArgs(args, "[k[I", ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, &a0, &a1))
                {
                  INT_CALL(object = ArrayPredictionContext(a0, a1));
                  self->object = object;
                  break;
                }
              }
             default:
             err:
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_ArrayPredictionContext_equals(t_ArrayPredictionContext *self, PyObject *args)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "o", &a0))
            {
              OBJ_CALL(result = self->object.equals(a0));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(ArrayPredictionContext), (PyObject *) self, "equals", args, 2);
          }

          static PyObject *t_ArrayPredictionContext_getParent(t_ArrayPredictionContext *self, PyObject *args)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::PredictionContext result((jobject) NULL);

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.getParent(a0));
              return ::org::antlr::v4::runtime::atn::t_PredictionContext::wrap_Object(result);
            }

            return callSuper(PY_TYPE(ArrayPredictionContext), (PyObject *) self, "getParent", args, 2);
          }

          static PyObject *t_ArrayPredictionContext_getReturnState(t_ArrayPredictionContext *self, PyObject *args)
          {
            jint a0;
            jint result;

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.getReturnState(a0));
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(ArrayPredictionContext), (PyObject *) self, "getReturnState", args, 2);
          }

          static PyObject *t_ArrayPredictionContext_isEmpty(t_ArrayPredictionContext *self, PyObject *args)
          {
            jboolean result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.isEmpty());
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(ArrayPredictionContext), (PyObject *) self, "isEmpty", args, 2);
          }

          static PyObject *t_ArrayPredictionContext_size(t_ArrayPredictionContext *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.size());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(ArrayPredictionContext), (PyObject *) self, "size", args, 2);
          }

          static PyObject *t_ArrayPredictionContext_toString(t_ArrayPredictionContext *self, PyObject *args)
          {
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.toString());
              return j2p(result);
            }

            return callSuper(PY_TYPE(ArrayPredictionContext), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_ArrayPredictionContext_get__parents(t_ArrayPredictionContext *self, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::PredictionContext > value((jobject) NULL);
            OBJ_CALL(value = self->object._get_parents());
            return JArray<jobject>(value.this$).wrap(::org::antlr::v4::runtime::atn::t_PredictionContext::wrap_jobject);
          }

          static PyObject *t_ArrayPredictionContext_get__returnStates(t_ArrayPredictionContext *self, void *data)
          {
            JArray< jint > value((jobject) NULL);
            OBJ_CALL(value = self->object._get_returnStates());
            return value.wrap();
          }

          static PyObject *t_ArrayPredictionContext_get__empty(t_ArrayPredictionContext *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isEmpty());
            Py_RETURN_BOOL(value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/concurrent/Delayed.h"
#include "java/util/concurrent/Delayed.h"
#include "java/util/concurrent/TimeUnit.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace concurrent {

      ::java::lang::Class *Delayed::class$ = NULL;
      jmethodID *Delayed::mids$ = NULL;
      bool Delayed::live$ = false;

      jclass Delayed::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/concurrent/Delayed");

          mids$ = new jmethodID[max_mid];
          mids$[mid_getDelay_3e6b60f4affbf1c6] = env->getMethodID(cls, "getDelay", "(Ljava/util/concurrent/TimeUnit;)J");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jlong Delayed::getDelay(const ::java::util::concurrent::TimeUnit & a0) const
      {
        return env->callLongMethod(this$, mids$[mid_getDelay_3e6b60f4affbf1c6], a0.this$);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace concurrent {
      static PyObject *t_Delayed_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Delayed_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_Delayed_getDelay(t_Delayed *self, PyObject *arg);

      static PyMethodDef t_Delayed__methods_[] = {
        DECLARE_METHOD(t_Delayed, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Delayed, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_Delayed, getDelay, METH_O),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(Delayed)[] = {
        { Py_tp_methods, t_Delayed__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(Delayed)[] = {
        &PY_TYPE_DEF(::java::lang::Comparable),
        NULL
      };

      DEFINE_TYPE(Delayed, t_Delayed, Delayed);

      void t_Delayed::install(PyObject *module)
      {
        installType(&PY_TYPE(Delayed), &PY_TYPE_DEF(Delayed), module, "Delayed", 0);
      }

      void t_Delayed::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(Delayed), "class_", make_descriptor(Delayed::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Delayed), "wrapfn_", make_descriptor(t_Delayed::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(Delayed), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_Delayed_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, Delayed::initializeClass, 1)))
          return NULL;
        return t_Delayed::wrap_Object(Delayed(((t_Delayed *) arg)->object.this$));
      }
      static PyObject *t_Delayed_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, Delayed::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_Delayed_getDelay(t_Delayed *self, PyObject *arg)
      {
        ::java::util::concurrent::TimeUnit a0((jobject) NULL);
        PyTypeObject **p0;
        jlong result;

        if (!parseArg(arg, "K", ::java::util::concurrent::TimeUnit::initializeClass, &a0, &p0, ::java::util::concurrent::t_TimeUnit::parameters_))
        {
          OBJ_CALL(result = self->object.getDelay(a0));
          return PyLong_FromLongLong((PY_LONG_LONG) result);
        }

        PyErr_SetArgsError((PyObject *) self, "getDelay", arg);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/regex/MatchResult.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace java {
  namespace util {
    namespace regex {

      ::java::lang::Class *MatchResult::class$ = NULL;
      jmethodID *MatchResult::mids$ = NULL;
      bool MatchResult::live$ = false;

      jclass MatchResult::initializeClass(bool getOnly)
      {
        if (getOnly)
          return (jclass) (live$ ? class$->this$ : NULL);
        if (class$ == NULL)
        {
          jclass cls = (jclass) env->findClass("java/util/regex/MatchResult");

          mids$ = new jmethodID[max_mid];
          mids$[mid_end_9972fcc56b44e79d] = env->getMethodID(cls, "end", "()I");
          mids$[mid_end_1e143afe1894d213] = env->getMethodID(cls, "end", "(I)I");
          mids$[mid_group_db9b55ba01e03e4b] = env->getMethodID(cls, "group", "()Ljava/lang/String;");
          mids$[mid_group_d7593acad64ef635] = env->getMethodID(cls, "group", "(I)Ljava/lang/String;");
          mids$[mid_groupCount_9972fcc56b44e79d] = env->getMethodID(cls, "groupCount", "()I");
          mids$[mid_start_9972fcc56b44e79d] = env->getMethodID(cls, "start", "()I");
          mids$[mid_start_1e143afe1894d213] = env->getMethodID(cls, "start", "(I)I");

          class$ = new ::java::lang::Class(cls);
          live$ = true;
        }
        return (jclass) class$->this$;
      }

      jint MatchResult::end() const
      {
        return env->callIntMethod(this$, mids$[mid_end_9972fcc56b44e79d]);
      }

      jint MatchResult::end(jint a0) const
      {
        return env->callIntMethod(this$, mids$[mid_end_1e143afe1894d213], a0);
      }

      ::java::lang::String MatchResult::group() const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_group_db9b55ba01e03e4b]));
      }

      ::java::lang::String MatchResult::group(jint a0) const
      {
        return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_group_d7593acad64ef635], a0));
      }

      jint MatchResult::groupCount() const
      {
        return env->callIntMethod(this$, mids$[mid_groupCount_9972fcc56b44e79d]);
      }

      jint MatchResult::start() const
      {
        return env->callIntMethod(this$, mids$[mid_start_9972fcc56b44e79d]);
      }

      jint MatchResult::start(jint a0) const
      {
        return env->callIntMethod(this$, mids$[mid_start_1e143afe1894d213], a0);
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    namespace regex {
      static PyObject *t_MatchResult_cast_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_MatchResult_instance_(PyTypeObject *type, PyObject *arg);
      static PyObject *t_MatchResult_end(t_MatchResult *self, PyObject *args);
      static PyObject *t_MatchResult_group(t_MatchResult *self, PyObject *args);
      static PyObject *t_MatchResult_groupCount(t_MatchResult *self);
      static PyObject *t_MatchResult_start(t_MatchResult *self, PyObject *args);

      static PyMethodDef t_MatchResult__methods_[] = {
        DECLARE_METHOD(t_MatchResult, cast_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_MatchResult, instance_, METH_O | METH_CLASS),
        DECLARE_METHOD(t_MatchResult, end, METH_VARARGS),
        DECLARE_METHOD(t_MatchResult, group, METH_VARARGS),
        DECLARE_METHOD(t_MatchResult, groupCount, METH_NOARGS),
        DECLARE_METHOD(t_MatchResult, start, METH_VARARGS),
        { NULL, NULL, 0, NULL }
      };

      static PyType_Slot PY_TYPE_SLOTS(MatchResult)[] = {
        { Py_tp_methods, t_MatchResult__methods_ },
        { Py_tp_init, (void *) abstract_init },
        { 0, NULL }
      };

      static PyType_Def *PY_TYPE_BASES(MatchResult)[] = {
        &PY_TYPE_DEF(::java::lang::Object),
        NULL
      };

      DEFINE_TYPE(MatchResult, t_MatchResult, MatchResult);

      void t_MatchResult::install(PyObject *module)
      {
        installType(&PY_TYPE(MatchResult), &PY_TYPE_DEF(MatchResult), module, "MatchResult", 0);
      }

      void t_MatchResult::initialize(PyObject *module)
      {
        PyObject_SetAttrString((PyObject *) PY_TYPE(MatchResult), "class_", make_descriptor(MatchResult::initializeClass, 1));
        PyObject_SetAttrString((PyObject *) PY_TYPE(MatchResult), "wrapfn_", make_descriptor(t_MatchResult::wrap_jobject));
        PyObject_SetAttrString((PyObject *) PY_TYPE(MatchResult), "boxfn_", make_descriptor(boxObject));
      }

      static PyObject *t_MatchResult_cast_(PyTypeObject *type, PyObject *arg)
      {
        if (!(arg = castCheck(arg, MatchResult::initializeClass, 1)))
          return NULL;
        return t_MatchResult::wrap_Object(MatchResult(((t_MatchResult *) arg)->object.this$));
      }
      static PyObject *t_MatchResult_instance_(PyTypeObject *type, PyObject *arg)
      {
        if (!castCheck(arg, MatchResult::initializeClass, 0))
          Py_RETURN_FALSE;
        Py_RETURN_TRUE;
      }

      static PyObject *t_MatchResult_end(t_MatchResult *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            jint result;
            OBJ_CALL(result = self->object.end());
            return PyLong_FromLong((long) result);
          }
          break;
         case 1:
          {
            jint a0;
            jint result;

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.end(a0));
              return PyLong_FromLong((long) result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "end", args);
        return NULL;
      }

      static PyObject *t_MatchResult_group(t_MatchResult *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            ::java::lang::String result((jobject) NULL);
            OBJ_CALL(result = self->object.group());
            return j2p(result);
          }
          break;
         case 1:
          {
            jint a0;
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.group(a0));
              return j2p(result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "group", args);
        return NULL;
      }

      static PyObject *t_MatchResult_groupCount(t_MatchResult *self)
      {
        jint result;
        OBJ_CALL(result = self->object.groupCount());
        return PyLong_FromLong((long) result);
      }

      static PyObject *t_MatchResult_start(t_MatchResult *self, PyObject *args)
      {
        switch (PyTuple_GET_SIZE(args)) {
         case 0:
          {
            jint result;
            OBJ_CALL(result = self->object.start());
            return PyLong_FromLong((long) result);
          }
          break;
         case 1:
          {
            jint a0;
            jint result;

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.start(a0));
              return PyLong_FromLong((long) result);
            }
          }
        }

        PyErr_SetArgsError((PyObject *) self, "start", args);
        return NULL;
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/EmptyPredictionContext.h"
#include "org/antlr/v4/runtime/atn/PredictionContext.h"
#include "java/lang/Object.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *EmptyPredictionContext::class$ = NULL;
          jmethodID *EmptyPredictionContext::mids$ = NULL;
          bool EmptyPredictionContext::live$ = false;

          jclass EmptyPredictionContext::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/EmptyPredictionContext");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
              mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
              mids$[mid_getParent_de7c941e2462c7c5] = env->getMethodID(cls, "getParent", "(I)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_getReturnState_1e143afe1894d213] = env->getMethodID(cls, "getReturnState", "(I)I");
              mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
              mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          EmptyPredictionContext::EmptyPredictionContext() : ::org::antlr::v4::runtime::atn::SingletonPredictionContext(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          jboolean EmptyPredictionContext::equals(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
          }

          ::org::antlr::v4::runtime::atn::PredictionContext EmptyPredictionContext::getParent(jint a0) const
          {
            return ::org::antlr::v4::runtime::atn::PredictionContext(env->callObjectMethod(this$, mids$[mid_getParent_de7c941e2462c7c5], a0));
          }

          jint EmptyPredictionContext::getReturnState(jint a0) const
          {
            return env->callIntMethod(this$, mids$[mid_getReturnState_1e143afe1894d213], a0);
          }

          jboolean EmptyPredictionContext::isEmpty() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
          }

          jint EmptyPredictionContext::size() const
          {
            return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
          }

          ::java::lang::String EmptyPredictionContext::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_EmptyPredictionContext_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_EmptyPredictionContext_instance_(PyTypeObject *type, PyObject *arg);
          static int t_EmptyPredictionContext_init_(t_EmptyPredictionContext *self, PyObject *args, PyObject *kwds);
          static PyObject *t_EmptyPredictionContext_equals(t_EmptyPredictionContext *self, PyObject *args);
          static PyObject *t_EmptyPredictionContext_getParent(t_EmptyPredictionContext *self, PyObject *args);
          static PyObject *t_EmptyPredictionContext_getReturnState(t_EmptyPredictionContext *self, PyObject *args);
          static PyObject *t_EmptyPredictionContext_isEmpty(t_EmptyPredictionContext *self, PyObject *args);
          static PyObject *t_EmptyPredictionContext_size(t_EmptyPredictionContext *self, PyObject *args);
          static PyObject *t_EmptyPredictionContext_toString(t_EmptyPredictionContext *self, PyObject *args);
          static PyObject *t_EmptyPredictionContext_get__empty(t_EmptyPredictionContext *self, void *data);
          static PyGetSetDef t_EmptyPredictionContext__fields_[] = {
            DECLARE_GET_FIELD(t_EmptyPredictionContext, empty),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_EmptyPredictionContext__methods_[] = {
            DECLARE_METHOD(t_EmptyPredictionContext, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_EmptyPredictionContext, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_EmptyPredictionContext, equals, METH_VARARGS),
            DECLARE_METHOD(t_EmptyPredictionContext, getParent, METH_VARARGS),
            DECLARE_METHOD(t_EmptyPredictionContext, getReturnState, METH_VARARGS),
            DECLARE_METHOD(t_EmptyPredictionContext, isEmpty, METH_VARARGS),
            DECLARE_METHOD(t_EmptyPredictionContext, size, METH_VARARGS),
            DECLARE_METHOD(t_EmptyPredictionContext, toString, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(EmptyPredictionContext)[] = {
            { Py_tp_methods, t_EmptyPredictionContext__methods_ },
            { Py_tp_init, (void *) t_EmptyPredictionContext_init_ },
            { Py_tp_getset, t_EmptyPredictionContext__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(EmptyPredictionContext)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::SingletonPredictionContext),
            NULL
          };

          DEFINE_TYPE(EmptyPredictionContext, t_EmptyPredictionContext, EmptyPredictionContext);

          void t_EmptyPredictionContext::install(PyObject *module)
          {
            installType(&PY_TYPE(EmptyPredictionContext), &PY_TYPE_DEF(EmptyPredictionContext), module, "EmptyPredictionContext", 0);
          }

          void t_EmptyPredictionContext::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(EmptyPredictionContext), "class_", make_descriptor(EmptyPredictionContext::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(EmptyPredictionContext), "wrapfn_", make_descriptor(t_EmptyPredictionContext::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(EmptyPredictionContext), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_EmptyPredictionContext_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, EmptyPredictionContext::initializeClass, 1)))
              return NULL;
            return t_EmptyPredictionContext::wrap_Object(EmptyPredictionContext(((t_EmptyPredictionContext *) arg)->object.this$));
          }
          static PyObject *t_EmptyPredictionContext_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, EmptyPredictionContext::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_EmptyPredictionContext_init_(t_EmptyPredictionContext *self, PyObject *args, PyObject *kwds)
          {
            EmptyPredictionContext object((jobject) NULL);

            INT_CALL(object = EmptyPredictionContext());
            self->object = object;

            return 0;
          }

          static PyObject *t_EmptyPredictionContext_equals(t_EmptyPredictionContext *self, PyObject *args)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "o", &a0))
            {
              OBJ_CALL(result = self->object.equals(a0));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(EmptyPredictionContext), (PyObject *) self, "equals", args, 2);
          }

          static PyObject *t_EmptyPredictionContext_getParent(t_EmptyPredictionContext *self, PyObject *args)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::PredictionContext result((jobject) NULL);

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.getParent(a0));
              return ::org::antlr::v4::runtime::atn::t_PredictionContext::wrap_Object(result);
            }

            return callSuper(PY_TYPE(EmptyPredictionContext), (PyObject *) self, "getParent", args, 2);
          }

          static PyObject *t_EmptyPredictionContext_getReturnState(t_EmptyPredictionContext *self, PyObject *args)
          {
            jint a0;
            jint result;

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.getReturnState(a0));
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(EmptyPredictionContext), (PyObject *) self, "getReturnState", args, 2);
          }

          static PyObject *t_EmptyPredictionContext_isEmpty(t_EmptyPredictionContext *self, PyObject *args)
          {
            jboolean result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.isEmpty());
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(EmptyPredictionContext), (PyObject *) self, "isEmpty", args, 2);
          }

          static PyObject *t_EmptyPredictionContext_size(t_EmptyPredictionContext *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.size());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(EmptyPredictionContext), (PyObject *) self, "size", args, 2);
          }

          static PyObject *t_EmptyPredictionContext_toString(t_EmptyPredictionContext *self, PyObject *args)
          {
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.toString());
              return j2p(result);
            }

            return callSuper(PY_TYPE(EmptyPredictionContext), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_EmptyPredictionContext_get__empty(t_EmptyPredictionContext *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isEmpty());
            Py_RETURN_BOOL(value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/LexerAction.h"
#include "org/antlr/v4/runtime/atn/LexerActionType.h"
#include "org/antlr/v4/runtime/Lexer.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *LexerAction::class$ = NULL;
          jmethodID *LexerAction::mids$ = NULL;
          bool LexerAction::live$ = false;

          jclass LexerAction::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/LexerAction");

              mids$ = new jmethodID[max_mid];
              mids$[mid_execute_65b83ab4f609e8cb] = env->getMethodID(cls, "execute", "(Lorg/antlr/v4/runtime/Lexer;)V");
              mids$[mid_getActionType_ec7e0ccc070cae12] = env->getMethodID(cls, "getActionType", "()Lorg/antlr/v4/runtime/atn/LexerActionType;");
              mids$[mid_isPositionDependent_8454bd5aa23fd11e] = env->getMethodID(cls, "isPositionDependent", "()Z");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          void LexerAction::execute(const ::org::antlr::v4::runtime::Lexer & a0) const
          {
            env->callVoidMethod(this$, mids$[mid_execute_65b83ab4f609e8cb], a0.this$);
          }

          ::org::antlr::v4::runtime::atn::LexerActionType LexerAction::getActionType() const
          {
            return ::org::antlr::v4::runtime::atn::LexerActionType(env->callObjectMethod(this$, mids$[mid_getActionType_ec7e0ccc070cae12]));
          }

          jboolean LexerAction::isPositionDependent() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isPositionDependent_8454bd5aa23fd11e]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_LexerAction_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_LexerAction_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_LexerAction_execute(t_LexerAction *self, PyObject *arg);
          static PyObject *t_LexerAction_getActionType(t_LexerAction *self);
          static PyObject *t_LexerAction_isPositionDependent(t_LexerAction *self);
          static PyObject *t_LexerAction_get__actionType(t_LexerAction *self, void *data);
          static PyObject *t_LexerAction_get__positionDependent(t_LexerAction *self, void *data);
          static PyGetSetDef t_LexerAction__fields_[] = {
            DECLARE_GET_FIELD(t_LexerAction, actionType),
            DECLARE_GET_FIELD(t_LexerAction, positionDependent),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_LexerAction__methods_[] = {
            DECLARE_METHOD(t_LexerAction, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_LexerAction, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_LexerAction, execute, METH_O),
            DECLARE_METHOD(t_LexerAction, getActionType, METH_NOARGS),
            DECLARE_METHOD(t_LexerAction, isPositionDependent, METH_NOARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(LexerAction)[] = {
            { Py_tp_methods, t_LexerAction__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_LexerAction__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(LexerAction)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(LexerAction, t_LexerAction, LexerAction);

          void t_LexerAction::install(PyObject *module)
          {
            installType(&PY_TYPE(LexerAction), &PY_TYPE_DEF(LexerAction), module, "LexerAction", 0);
          }

          void t_LexerAction::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerAction), "class_", make_descriptor(LexerAction::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerAction), "wrapfn_", make_descriptor(t_LexerAction::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerAction), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_LexerAction_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, LexerAction::initializeClass, 1)))
              return NULL;
            return t_LexerAction::wrap_Object(LexerAction(((t_LexerAction *) arg)->object.this$));
          }
          static PyObject *t_LexerAction_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, LexerAction::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_LexerAction_execute(t_LexerAction *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::Lexer a0((jobject) NULL);
            PyTypeObject **p0;

            if (!parseArg(arg, "K", ::org::antlr::v4::runtime::Lexer::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Lexer::parameters_))
            {
              OBJ_CALL(self->object.execute(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "execute", arg);
            return NULL;
          }

          static PyObject *t_LexerAction_getActionType(t_LexerAction *self)
          {
            ::org::antlr::v4::runtime::atn::LexerActionType result((jobject) NULL);
            OBJ_CALL(result = self->object.getActionType());
            return ::org::antlr::v4::runtime::atn::t_LexerActionType::wrap_Object(result);
          }

          static PyObject *t_LexerAction_isPositionDependent(t_LexerAction *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.isPositionDependent());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_LexerAction_get__actionType(t_LexerAction *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::LexerActionType value((jobject) NULL);
            OBJ_CALL(value = self->object.getActionType());
            return ::org::antlr::v4::runtime::atn::t_LexerActionType::wrap_Object(value);
          }

          static PyObject *t_LexerAction_get__positionDependent(t_LexerAction *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isPositionDependent());
            Py_RETURN_BOOL(value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/DecisionInfo.h"
#include "org/antlr/v4/runtime/atn/ErrorInfo.h"
#include "org/antlr/v4/runtime/atn/PredicateEvalInfo.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/atn/LookaheadEventInfo.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/AmbiguityInfo.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/atn/ContextSensitivityInfo.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *DecisionInfo::class$ = NULL;
          jmethodID *DecisionInfo::mids$ = NULL;
          jfieldID *DecisionInfo::fids$ = NULL;
          bool DecisionInfo::live$ = false;

          jclass DecisionInfo::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/DecisionInfo");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_040c4cd0390c5aff] = env->getMethodID(cls, "<init>", "(I)V");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

              fids$ = new jfieldID[max_fid];
              fids$[fid_LL_ATNTransitions] = env->getFieldID(cls, "LL_ATNTransitions", "J");
              fids$[fid_LL_DFATransitions] = env->getFieldID(cls, "LL_DFATransitions", "J");
              fids$[fid_LL_Fallback] = env->getFieldID(cls, "LL_Fallback", "J");
              fids$[fid_LL_MaxLook] = env->getFieldID(cls, "LL_MaxLook", "J");
              fids$[fid_LL_MaxLookEvent] = env->getFieldID(cls, "LL_MaxLookEvent", "Lorg/antlr/v4/runtime/atn/LookaheadEventInfo;");
              fids$[fid_LL_MinLook] = env->getFieldID(cls, "LL_MinLook", "J");
              fids$[fid_LL_TotalLook] = env->getFieldID(cls, "LL_TotalLook", "J");
              fids$[fid_SLL_ATNTransitions] = env->getFieldID(cls, "SLL_ATNTransitions", "J");
              fids$[fid_SLL_DFATransitions] = env->getFieldID(cls, "SLL_DFATransitions", "J");
              fids$[fid_SLL_MaxLook] = env->getFieldID(cls, "SLL_MaxLook", "J");
              fids$[fid_SLL_MaxLookEvent] = env->getFieldID(cls, "SLL_MaxLookEvent", "Lorg/antlr/v4/runtime/atn/LookaheadEventInfo;");
              fids$[fid_SLL_MinLook] = env->getFieldID(cls, "SLL_MinLook", "J");
              fids$[fid_SLL_TotalLook] = env->getFieldID(cls, "SLL_TotalLook", "J");
              fids$[fid_ambiguities] = env->getFieldID(cls, "ambiguities", "Ljava/util/List;");
              fids$[fid_contextSensitivities] = env->getFieldID(cls, "contextSensitivities", "Ljava/util/List;");
              fids$[fid_decision] = env->getFieldID(cls, "decision", "I");
              fids$[fid_errors] = env->getFieldID(cls, "errors", "Ljava/util/List;");
              fids$[fid_invocations] = env->getFieldID(cls, "invocations", "J");
              fids$[fid_predicateEvals] = env->getFieldID(cls, "predicateEvals", "Ljava/util/List;");
              fids$[fid_timeInPrediction] = env->getFieldID(cls, "timeInPrediction", "J");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          DecisionInfo::DecisionInfo(jint a0) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_040c4cd0390c5aff, a0)) {}

          ::java::lang::String DecisionInfo::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }

          jlong DecisionInfo::_get_LL_ATNTransitions() const
          {
            return env->getLongField(this$, fids$[fid_LL_ATNTransitions]);
          }

          void DecisionInfo::_set_LL_ATNTransitions(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_LL_ATNTransitions], a0);
          }

          jlong DecisionInfo::_get_LL_DFATransitions() const
          {
            return env->getLongField(this$, fids$[fid_LL_DFATransitions]);
          }

          void DecisionInfo::_set_LL_DFATransitions(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_LL_DFATransitions], a0);
          }

          jlong DecisionInfo::_get_LL_Fallback() const
          {
            return env->getLongField(this$, fids$[fid_LL_Fallback]);
          }

          void DecisionInfo::_set_LL_Fallback(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_LL_Fallback], a0);
          }

          jlong DecisionInfo::_get_LL_MaxLook() const
          {
            return env->getLongField(this$, fids$[fid_LL_MaxLook]);
          }

          void DecisionInfo::_set_LL_MaxLook(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_LL_MaxLook], a0);
          }

          ::org::antlr::v4::runtime::atn::LookaheadEventInfo DecisionInfo::_get_LL_MaxLookEvent() const
          {
            return ::org::antlr::v4::runtime::atn::LookaheadEventInfo(env->getObjectField(this$, fids$[fid_LL_MaxLookEvent]));
          }

          void DecisionInfo::_set_LL_MaxLookEvent(const ::org::antlr::v4::runtime::atn::LookaheadEventInfo & a0) const
          {
            env->setObjectField(this$, fids$[fid_LL_MaxLookEvent], a0.this$);
          }

          jlong DecisionInfo::_get_LL_MinLook() const
          {
            return env->getLongField(this$, fids$[fid_LL_MinLook]);
          }

          void DecisionInfo::_set_LL_MinLook(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_LL_MinLook], a0);
          }

          jlong DecisionInfo::_get_LL_TotalLook() const
          {
            return env->getLongField(this$, fids$[fid_LL_TotalLook]);
          }

          void DecisionInfo::_set_LL_TotalLook(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_LL_TotalLook], a0);
          }

          jlong DecisionInfo::_get_SLL_ATNTransitions() const
          {
            return env->getLongField(this$, fids$[fid_SLL_ATNTransitions]);
          }

          void DecisionInfo::_set_SLL_ATNTransitions(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_SLL_ATNTransitions], a0);
          }

          jlong DecisionInfo::_get_SLL_DFATransitions() const
          {
            return env->getLongField(this$, fids$[fid_SLL_DFATransitions]);
          }

          void DecisionInfo::_set_SLL_DFATransitions(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_SLL_DFATransitions], a0);
          }

          jlong DecisionInfo::_get_SLL_MaxLook() const
          {
            return env->getLongField(this$, fids$[fid_SLL_MaxLook]);
          }

          void DecisionInfo::_set_SLL_MaxLook(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_SLL_MaxLook], a0);
          }

          ::org::antlr::v4::runtime::atn::LookaheadEventInfo DecisionInfo::_get_SLL_MaxLookEvent() const
          {
            return ::org::antlr::v4::runtime::atn::LookaheadEventInfo(env->getObjectField(this$, fids$[fid_SLL_MaxLookEvent]));
          }

          void DecisionInfo::_set_SLL_MaxLookEvent(const ::org::antlr::v4::runtime::atn::LookaheadEventInfo & a0) const
          {
            env->setObjectField(this$, fids$[fid_SLL_MaxLookEvent], a0.this$);
          }

          jlong DecisionInfo::_get_SLL_MinLook() const
          {
            return env->getLongField(this$, fids$[fid_SLL_MinLook]);
          }

          void DecisionInfo::_set_SLL_MinLook(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_SLL_MinLook], a0);
          }

          jlong DecisionInfo::_get_SLL_TotalLook() const
          {
            return env->getLongField(this$, fids$[fid_SLL_TotalLook]);
          }

          void DecisionInfo::_set_SLL_TotalLook(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_SLL_TotalLook], a0);
          }

          ::java::util::List DecisionInfo::_get_ambiguities() const
          {
            return ::java::util::List(env->getObjectField(this$, fids$[fid_ambiguities]));
          }

          ::java::util::List DecisionInfo::_get_contextSensitivities() const
          {
            return ::java::util::List(env->getObjectField(this$, fids$[fid_contextSensitivities]));
          }

          jint DecisionInfo::_get_decision() const
          {
            return env->getIntField(this$, fids$[fid_decision]);
          }

          ::java::util::List DecisionInfo::_get_errors() const
          {
            return ::java::util::List(env->getObjectField(this$, fids$[fid_errors]));
          }

          jlong DecisionInfo::_get_invocations() const
          {
            return env->getLongField(this$, fids$[fid_invocations]);
          }

          void DecisionInfo::_set_invocations(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_invocations], a0);
          }

          ::java::util::List DecisionInfo::_get_predicateEvals() const
          {
            return ::java::util::List(env->getObjectField(this$, fids$[fid_predicateEvals]));
          }

          jlong DecisionInfo::_get_timeInPrediction() const
          {
            return env->getLongField(this$, fids$[fid_timeInPrediction]);
          }

          void DecisionInfo::_set_timeInPrediction(jlong a0) const
          {
            env->setLongField(this$, fids$[fid_timeInPrediction], a0);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_DecisionInfo_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_DecisionInfo_instance_(PyTypeObject *type, PyObject *arg);
          static int t_DecisionInfo_init_(t_DecisionInfo *self, PyObject *args, PyObject *kwds);
          static PyObject *t_DecisionInfo_toString(t_DecisionInfo *self, PyObject *args);
          static PyObject *t_DecisionInfo_get__LL_ATNTransitions(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__LL_ATNTransitions(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__LL_DFATransitions(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__LL_DFATransitions(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__LL_Fallback(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__LL_Fallback(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__LL_MaxLook(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__LL_MaxLook(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__LL_MaxLookEvent(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__LL_MaxLookEvent(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__LL_MinLook(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__LL_MinLook(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__LL_TotalLook(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__LL_TotalLook(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__SLL_ATNTransitions(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__SLL_ATNTransitions(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__SLL_DFATransitions(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__SLL_DFATransitions(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__SLL_MaxLook(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__SLL_MaxLook(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__SLL_MaxLookEvent(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__SLL_MaxLookEvent(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__SLL_MinLook(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__SLL_MinLook(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__SLL_TotalLook(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__SLL_TotalLook(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__ambiguities(t_DecisionInfo *self, void *data);
          static PyObject *t_DecisionInfo_get__contextSensitivities(t_DecisionInfo *self, void *data);
          static PyObject *t_DecisionInfo_get__decision(t_DecisionInfo *self, void *data);
          static PyObject *t_DecisionInfo_get__errors(t_DecisionInfo *self, void *data);
          static PyObject *t_DecisionInfo_get__invocations(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__invocations(t_DecisionInfo *self, PyObject *arg, void *data);
          static PyObject *t_DecisionInfo_get__predicateEvals(t_DecisionInfo *self, void *data);
          static PyObject *t_DecisionInfo_get__timeInPrediction(t_DecisionInfo *self, void *data);
          static int t_DecisionInfo_set__timeInPrediction(t_DecisionInfo *self, PyObject *arg, void *data);

          static PyGetSetDef t_DecisionInfo__fields_[] = {
            DECLARE_GETSET_FIELD(t_DecisionInfo, LL_ATNTransitions),
            DECLARE_GETSET_FIELD(t_DecisionInfo, LL_DFATransitions),
            DECLARE_GETSET_FIELD(t_DecisionInfo, LL_Fallback),
            DECLARE_GETSET_FIELD(t_DecisionInfo, LL_MaxLook),
            DECLARE_GETSET_FIELD(t_DecisionInfo, LL_MaxLookEvent),
            DECLARE_GETSET_FIELD(t_DecisionInfo, LL_MinLook),
            DECLARE_GETSET_FIELD(t_DecisionInfo, LL_TotalLook),
            DECLARE_GETSET_FIELD(t_DecisionInfo, SLL_ATNTransitions),
            DECLARE_GETSET_FIELD(t_DecisionInfo, SLL_DFATransitions),
            DECLARE_GETSET_FIELD(t_DecisionInfo, SLL_MaxLook),
            DECLARE_GETSET_FIELD(t_DecisionInfo, SLL_MaxLookEvent),
            DECLARE_GETSET_FIELD(t_DecisionInfo, SLL_MinLook),
            DECLARE_GETSET_FIELD(t_DecisionInfo, SLL_TotalLook),
            DECLARE_GET_FIELD(t_DecisionInfo, ambiguities),
            DECLARE_GET_FIELD(t_DecisionInfo, contextSensitivities),
            DECLARE_GET_FIELD(t_DecisionInfo, decision),
            DECLARE_GET_FIELD(t_DecisionInfo, errors),
            DECLARE_GETSET_FIELD(t_DecisionInfo, invocations),
            DECLARE_GET_FIELD(t_DecisionInfo, predicateEvals),
            DECLARE_GETSET_FIELD(t_DecisionInfo, timeInPrediction),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_DecisionInfo__methods_[] = {
            DECLARE_METHOD(t_DecisionInfo, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_DecisionInfo, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_DecisionInfo, toString, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(DecisionInfo)[] = {
            { Py_tp_methods, t_DecisionInfo__methods_ },
            { Py_tp_init, (void *) t_DecisionInfo_init_ },
            { Py_tp_getset, t_DecisionInfo__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(DecisionInfo)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(DecisionInfo, t_DecisionInfo, DecisionInfo);

          void t_DecisionInfo::install(PyObject *module)
          {
            installType(&PY_TYPE(DecisionInfo), &PY_TYPE_DEF(DecisionInfo), module, "DecisionInfo", 0);
          }

          void t_DecisionInfo::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(DecisionInfo), "class_", make_descriptor(DecisionInfo::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(DecisionInfo), "wrapfn_", make_descriptor(t_DecisionInfo::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(DecisionInfo), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_DecisionInfo_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, DecisionInfo::initializeClass, 1)))
              return NULL;
            return t_DecisionInfo::wrap_Object(DecisionInfo(((t_DecisionInfo *) arg)->object.this$));
          }
          static PyObject *t_DecisionInfo_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, DecisionInfo::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_DecisionInfo_init_(t_DecisionInfo *self, PyObject *args, PyObject *kwds)
          {
            jint a0;
            DecisionInfo object((jobject) NULL);

            if (!parseArgs(args, "I", &a0))
            {
              INT_CALL(object = DecisionInfo(a0));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_DecisionInfo_toString(t_DecisionInfo *self, PyObject *args)
          {
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.toString());
              return j2p(result);
            }

            return callSuper(PY_TYPE(DecisionInfo), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_DecisionInfo_get__LL_ATNTransitions(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_LL_ATNTransitions());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__LL_ATNTransitions(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_LL_ATNTransitions(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "LL_ATNTransitions", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__LL_DFATransitions(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_LL_DFATransitions());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__LL_DFATransitions(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_LL_DFATransitions(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "LL_DFATransitions", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__LL_Fallback(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_LL_Fallback());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__LL_Fallback(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_LL_Fallback(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "LL_Fallback", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__LL_MaxLook(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_LL_MaxLook());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__LL_MaxLook(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_LL_MaxLook(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "LL_MaxLook", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__LL_MaxLookEvent(t_DecisionInfo *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::LookaheadEventInfo value((jobject) NULL);
            OBJ_CALL(value = self->object._get_LL_MaxLookEvent());
            return ::org::antlr::v4::runtime::atn::t_LookaheadEventInfo::wrap_Object(value);
          }
          static int t_DecisionInfo_set__LL_MaxLookEvent(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            ::org::antlr::v4::runtime::atn::LookaheadEventInfo value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::LookaheadEventInfo::initializeClass, &value))
            {
              INT_CALL(self->object._set_LL_MaxLookEvent(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "LL_MaxLookEvent", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__LL_MinLook(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_LL_MinLook());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__LL_MinLook(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_LL_MinLook(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "LL_MinLook", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__LL_TotalLook(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_LL_TotalLook());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__LL_TotalLook(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_LL_TotalLook(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "LL_TotalLook", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__SLL_ATNTransitions(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_SLL_ATNTransitions());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__SLL_ATNTransitions(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_SLL_ATNTransitions(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "SLL_ATNTransitions", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__SLL_DFATransitions(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_SLL_DFATransitions());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__SLL_DFATransitions(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_SLL_DFATransitions(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "SLL_DFATransitions", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__SLL_MaxLook(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_SLL_MaxLook());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__SLL_MaxLook(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_SLL_MaxLook(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "SLL_MaxLook", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__SLL_MaxLookEvent(t_DecisionInfo *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::LookaheadEventInfo value((jobject) NULL);
            OBJ_CALL(value = self->object._get_SLL_MaxLookEvent());
            return ::org::antlr::v4::runtime::atn::t_LookaheadEventInfo::wrap_Object(value);
          }
          static int t_DecisionInfo_set__SLL_MaxLookEvent(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            ::org::antlr::v4::runtime::atn::LookaheadEventInfo value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::LookaheadEventInfo::initializeClass, &value))
            {
              INT_CALL(self->object._set_SLL_MaxLookEvent(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "SLL_MaxLookEvent", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__SLL_MinLook(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_SLL_MinLook());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__SLL_MinLook(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_SLL_MinLook(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "SLL_MinLook", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__SLL_TotalLook(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_SLL_TotalLook());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__SLL_TotalLook(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_SLL_TotalLook(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "SLL_TotalLook", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__ambiguities(t_DecisionInfo *self, void *data)
          {
            ::java::util::List value((jobject) NULL);
            OBJ_CALL(value = self->object._get_ambiguities());
            return ::java::util::t_List::wrap_Object(value);
          }

          static PyObject *t_DecisionInfo_get__contextSensitivities(t_DecisionInfo *self, void *data)
          {
            ::java::util::List value((jobject) NULL);
            OBJ_CALL(value = self->object._get_contextSensitivities());
            return ::java::util::t_List::wrap_Object(value);
          }

          static PyObject *t_DecisionInfo_get__decision(t_DecisionInfo *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_decision());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_DecisionInfo_get__errors(t_DecisionInfo *self, void *data)
          {
            ::java::util::List value((jobject) NULL);
            OBJ_CALL(value = self->object._get_errors());
            return ::java::util::t_List::wrap_Object(value);
          }

          static PyObject *t_DecisionInfo_get__invocations(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_invocations());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__invocations(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_invocations(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "invocations", arg);
            return -1;
          }

          static PyObject *t_DecisionInfo_get__predicateEvals(t_DecisionInfo *self, void *data)
          {
            ::java::util::List value((jobject) NULL);
            OBJ_CALL(value = self->object._get_predicateEvals());
            return ::java::util::t_List::wrap_Object(value);
          }

          static PyObject *t_DecisionInfo_get__timeInPrediction(t_DecisionInfo *self, void *data)
          {
            jlong value;
            OBJ_CALL(value = self->object._get_timeInPrediction());
            return PyLong_FromLongLong((PY_LONG_LONG) value);
          }
          static int t_DecisionInfo_set__timeInPrediction(t_DecisionInfo *self, PyObject *arg, void *data)
          {
            jlong value;
            if (!parseArg(arg, "J", &value))
            {
              INT_CALL(self->object._set_timeInPrediction(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "timeInPrediction", arg);
            return -1;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/TokensStartState.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *TokensStartState::class$ = NULL;
          jmethodID *TokensStartState::mids$ = NULL;
          bool TokensStartState::live$ = false;

          jclass TokensStartState::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/TokensStartState");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
              mids$[mid_getStateType_9972fcc56b44e79d] = env->getMethodID(cls, "getStateType", "()I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          TokensStartState::TokensStartState() : ::org::antlr::v4::runtime::atn::DecisionState(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          jint TokensStartState::getStateType() const
          {
            return env->callIntMethod(this$, mids$[mid_getStateType_9972fcc56b44e79d]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_TokensStartState_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_TokensStartState_instance_(PyTypeObject *type, PyObject *arg);
          static int t_TokensStartState_init_(t_TokensStartState *self, PyObject *args, PyObject *kwds);
          static PyObject *t_TokensStartState_getStateType(t_TokensStartState *self, PyObject *args);
          static PyObject *t_TokensStartState_get__stateType(t_TokensStartState *self, void *data);
          static PyGetSetDef t_TokensStartState__fields_[] = {
            DECLARE_GET_FIELD(t_TokensStartState, stateType),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_TokensStartState__methods_[] = {
            DECLARE_METHOD(t_TokensStartState, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_TokensStartState, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_TokensStartState, getStateType, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(TokensStartState)[] = {
            { Py_tp_methods, t_TokensStartState__methods_ },
            { Py_tp_init, (void *) t_TokensStartState_init_ },
            { Py_tp_getset, t_TokensStartState__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(TokensStartState)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::DecisionState),
            NULL
          };

          DEFINE_TYPE(TokensStartState, t_TokensStartState, TokensStartState);

          void t_TokensStartState::install(PyObject *module)
          {
            installType(&PY_TYPE(TokensStartState), &PY_TYPE_DEF(TokensStartState), module, "TokensStartState", 0);
          }

          void t_TokensStartState::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(TokensStartState), "class_", make_descriptor(TokensStartState::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(TokensStartState), "wrapfn_", make_descriptor(t_TokensStartState::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(TokensStartState), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_TokensStartState_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, TokensStartState::initializeClass, 1)))
              return NULL;
            return t_TokensStartState::wrap_Object(TokensStartState(((t_TokensStartState *) arg)->object.this$));
          }
          static PyObject *t_TokensStartState_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, TokensStartState::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_TokensStartState_init_(t_TokensStartState *self, PyObject *args, PyObject *kwds)
          {
            TokensStartState object((jobject) NULL);

            INT_CALL(object = TokensStartState());
            self->object = object;

            return 0;
          }

          static PyObject *t_TokensStartState_getStateType(t_TokensStartState *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.getStateType());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(TokensStartState), (PyObject *) self, "getStateType", args, 2);
          }

          static PyObject *t_TokensStartState_get__stateType(t_TokensStartState *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getStateType());
            return PyLong_FromLong((long) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/DecisionState.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *DecisionState::class$ = NULL;
          jmethodID *DecisionState::mids$ = NULL;
          jfieldID *DecisionState::fids$ = NULL;
          bool DecisionState::live$ = false;

          jclass DecisionState::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/DecisionState");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");

              fids$ = new jfieldID[max_fid];
              fids$[fid_decision] = env->getFieldID(cls, "decision", "I");
              fids$[fid_nonGreedy] = env->getFieldID(cls, "nonGreedy", "Z");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          DecisionState::DecisionState() : ::org::antlr::v4::runtime::atn::ATNState(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          jint DecisionState::_get_decision() const
          {
            return env->getIntField(this$, fids$[fid_decision]);
          }

          void DecisionState::_set_decision(jint a0) const
          {
            env->setIntField(this$, fids$[fid_decision], a0);
          }

          jboolean DecisionState::_get_nonGreedy() const
          {
            return env->getBooleanField(this$, fids$[fid_nonGreedy]);
          }

          void DecisionState::_set_nonGreedy(jboolean a0) const
          {
            env->setBooleanField(this$, fids$[fid_nonGreedy], a0);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_DecisionState_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_DecisionState_instance_(PyTypeObject *type, PyObject *arg);
          static int t_DecisionState_init_(t_DecisionState *self, PyObject *args, PyObject *kwds);
          static PyObject *t_DecisionState_get__decision(t_DecisionState *self, void *data);
          static int t_DecisionState_set__decision(t_DecisionState *self, PyObject *arg, void *data);
          static PyObject *t_DecisionState_get__nonGreedy(t_DecisionState *self, void *data);
          static int t_DecisionState_set__nonGreedy(t_DecisionState *self, PyObject *arg, void *data);

          static PyGetSetDef t_DecisionState__fields_[] = {
            DECLARE_GETSET_FIELD(t_DecisionState, decision),
            DECLARE_GETSET_FIELD(t_DecisionState, nonGreedy),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_DecisionState__methods_[] = {
            DECLARE_METHOD(t_DecisionState, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_DecisionState, instance_, METH_O | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(DecisionState)[] = {
            { Py_tp_methods, t_DecisionState__methods_ },
            { Py_tp_init, (void *) t_DecisionState_init_ },
            { Py_tp_getset, t_DecisionState__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(DecisionState)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::ATNState),
            NULL
          };

          DEFINE_TYPE(DecisionState, t_DecisionState, DecisionState);

          void t_DecisionState::install(PyObject *module)
          {
            installType(&PY_TYPE(DecisionState), &PY_TYPE_DEF(DecisionState), module, "DecisionState", 0);
          }

          void t_DecisionState::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(DecisionState), "class_", make_descriptor(DecisionState::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(DecisionState), "wrapfn_", make_descriptor(t_DecisionState::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(DecisionState), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_DecisionState_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, DecisionState::initializeClass, 1)))
              return NULL;
            return t_DecisionState::wrap_Object(DecisionState(((t_DecisionState *) arg)->object.this$));
          }
          static PyObject *t_DecisionState_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, DecisionState::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_DecisionState_init_(t_DecisionState *self, PyObject *args, PyObject *kwds)
          {
            DecisionState object((jobject) NULL);

            INT_CALL(object = DecisionState());
            self->object = object;

            return 0;
          }

          static PyObject *t_DecisionState_get__decision(t_DecisionState *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_decision());
            return PyLong_FromLong((long) value);
          }
          static int t_DecisionState_set__decision(t_DecisionState *self, PyObject *arg, void *data)
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object._set_decision(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "decision", arg);
            return -1;
          }

          static PyObject *t_DecisionState_get__nonGreedy(t_DecisionState *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object._get_nonGreedy());
            Py_RETURN_BOOL(value);
          }
          static int t_DecisionState_set__nonGreedy(t_DecisionState *self, PyObject *arg, void *data)
          {
            jboolean value;
            if (!parseArg(arg, "Z", &value))
            {
              INT_CALL(self->object._set_nonGreedy(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "nonGreedy", arg);
            return -1;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/SemanticContext.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/RuleContext.h"
#include "org/antlr/v4/runtime/atn/SemanticContext.h"
#include "org/antlr/v4/runtime/Recognizer.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *SemanticContext::class$ = NULL;
          jmethodID *SemanticContext::mids$ = NULL;
          bool SemanticContext::live$ = false;
          SemanticContext *SemanticContext::NONE = NULL;

          jclass SemanticContext::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/SemanticContext");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
              mids$[mid_and_36e29c160357f0ff] = env->getStaticMethodID(cls, "and", "(Lorg/antlr/v4/runtime/atn/SemanticContext;Lorg/antlr/v4/runtime/atn/SemanticContext;)Lorg/antlr/v4/runtime/atn/SemanticContext;");
              mids$[mid_eval_a1c281c055657321] = env->getMethodID(cls, "eval", "(Lorg/antlr/v4/runtime/Recognizer;Lorg/antlr/v4/runtime/RuleContext;)Z");
              mids$[mid_evalPrecedence_55d66a334128c50a] = env->getMethodID(cls, "evalPrecedence", "(Lorg/antlr/v4/runtime/Recognizer;Lorg/antlr/v4/runtime/RuleContext;)Lorg/antlr/v4/runtime/atn/SemanticContext;");
              mids$[mid_or_36e29c160357f0ff] = env->getStaticMethodID(cls, "or", "(Lorg/antlr/v4/runtime/atn/SemanticContext;Lorg/antlr/v4/runtime/atn/SemanticContext;)Lorg/antlr/v4/runtime/atn/SemanticContext;");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              NONE = new SemanticContext(env->getStaticObjectField(cls, "NONE", "Lorg/antlr/v4/runtime/atn/SemanticContext;"));
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          SemanticContext::SemanticContext() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          SemanticContext SemanticContext::and$(const SemanticContext & a0, const SemanticContext & a1)
          {
            jclass cls = env->getClass(initializeClass);
            return SemanticContext(env->callStaticObjectMethod(cls, mids$[mid_and_36e29c160357f0ff], a0.this$, a1.this$));
          }

          jboolean SemanticContext::eval(const ::org::antlr::v4::runtime::Recognizer & a0, const ::org::antlr::v4::runtime::RuleContext & a1) const
          {
            return env->callBooleanMethod(this$, mids$[mid_eval_a1c281c055657321], a0.this$, a1.this$);
          }

          SemanticContext SemanticContext::evalPrecedence(const ::org::antlr::v4::runtime::Recognizer & a0, const ::org::antlr::v4::runtime::RuleContext & a1) const
          {
            return SemanticContext(env->callObjectMethod(this$, mids$[mid_evalPrecedence_55d66a334128c50a], a0.this$, a1.this$));
          }

          SemanticContext SemanticContext::or$(const SemanticContext & a0, const SemanticContext & a1)
          {
            jclass cls = env->getClass(initializeClass);
            return SemanticContext(env->callStaticObjectMethod(cls, mids$[mid_or_36e29c160357f0ff], a0.this$, a1.this$));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"
#include "org/antlr/v4/runtime/atn/SemanticContext$PrecedencePredicate.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_SemanticContext_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_SemanticContext_instance_(PyTypeObject *type, PyObject *arg);
          static int t_SemanticContext_init_(t_SemanticContext *self, PyObject *args, PyObject *kwds);
          static PyObject *t_SemanticContext_and(PyTypeObject *type, PyObject *args);
          static PyObject *t_SemanticContext_eval(t_SemanticContext *self, PyObject *args);
          static PyObject *t_SemanticContext_evalPrecedence(t_SemanticContext *self, PyObject *args);
          static PyObject *t_SemanticContext_or(PyTypeObject *type, PyObject *args);

          static PyMethodDef t_SemanticContext__methods_[] = {
            DECLARE_METHOD(t_SemanticContext, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_SemanticContext, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_SemanticContext, and, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_SemanticContext, eval, METH_VARARGS),
            DECLARE_METHOD(t_SemanticContext, evalPrecedence, METH_VARARGS),
            DECLARE_METHOD(t_SemanticContext, or, METH_VARARGS | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(SemanticContext)[] = {
            { Py_tp_methods, t_SemanticContext__methods_ },
            { Py_tp_init, (void *) t_SemanticContext_init_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(SemanticContext)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(SemanticContext, t_SemanticContext, SemanticContext);

          void t_SemanticContext::install(PyObject *module)
          {
            installType(&PY_TYPE(SemanticContext), &PY_TYPE_DEF(SemanticContext), module, "SemanticContext", 0);
            PyObject_SetAttrString((PyObject *) PY_TYPE(SemanticContext), "PrecedencePredicate", make_descriptor(&PY_TYPE_DEF(SemanticContext$PrecedencePredicate)));
          }

          void t_SemanticContext::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(SemanticContext), "class_", make_descriptor(SemanticContext::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(SemanticContext), "wrapfn_", make_descriptor(t_SemanticContext::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(SemanticContext), "boxfn_", make_descriptor(boxObject));
            env->getClass(SemanticContext::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(SemanticContext), "NONE", make_descriptor(t_SemanticContext::wrap_Object(*SemanticContext::NONE)));
          }

          static PyObject *t_SemanticContext_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, SemanticContext::initializeClass, 1)))
              return NULL;
            return t_SemanticContext::wrap_Object(SemanticContext(((t_SemanticContext *) arg)->object.this$));
          }
          static PyObject *t_SemanticContext_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, SemanticContext::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_SemanticContext_init_(t_SemanticContext *self, PyObject *args, PyObject *kwds)
          {
            SemanticContext object((jobject) NULL);

            INT_CALL(object = SemanticContext());
            self->object = object;

            return 0;
          }

          static PyObject *t_SemanticContext_and(PyTypeObject *type, PyObject *args)
          {
            SemanticContext a0((jobject) NULL);
            SemanticContext a1((jobject) NULL);
            SemanticContext result((jobject) NULL);

            if (!parseArgs(args, "kk", SemanticContext::initializeClass, SemanticContext::initializeClass, &a0, &a1))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::SemanticContext::and$(a0, a1));
              return t_SemanticContext::wrap_Object(result);
            }

            PyErr_SetArgsError(type, "and", args);
            return NULL;
          }

          static PyObject *t_SemanticContext_eval(t_SemanticContext *self, PyObject *args)
          {
            ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
            PyTypeObject **p0;
            ::org::antlr::v4::runtime::RuleContext a1((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "Kk", ::org::antlr::v4::runtime::Recognizer::initializeClass, ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a1))
            {
              OBJ_CALL(result = self->object.eval(a0, a1));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "eval", args);
            return NULL;
          }

          static PyObject *t_SemanticContext_evalPrecedence(t_SemanticContext *self, PyObject *args)
          {
            ::org::antlr::v4::runtime::Recognizer a0((jobject) NULL);
            PyTypeObject **p0;
            ::org::antlr::v4::runtime::RuleContext a1((jobject) NULL);
            SemanticContext result((jobject) NULL);

            if (!parseArgs(args, "Kk", ::org::antlr::v4::runtime::Recognizer::initializeClass, ::org::antlr::v4::runtime::RuleContext::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Recognizer::parameters_, &a1))
            {
              OBJ_CALL(result = self->object.evalPrecedence(a0, a1));
              return t_SemanticContext::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "evalPrecedence", args);
            return NULL;
          }

          static PyObject *t_SemanticContext_or(PyTypeObject *type, PyObject *args)
          {
            SemanticContext a0((jobject) NULL);
            SemanticContext a1((jobject) NULL);
            SemanticContext result((jobject) NULL);

            if (!parseArgs(args, "kk", SemanticContext::initializeClass, SemanticContext::initializeClass, &a0, &a1))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::SemanticContext::or$(a0, a1));
              return t_SemanticContext::wrap_Object(result);
            }

            PyErr_SetArgsError(type, "or", args);
            return NULL;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "java/util/IdentityHashMap.h"
#include "java/util/Map.h"
#include "java/util/Collection.h"
#include "java/util/Map$Entry.h"
#include "java/lang/Cloneable.h"
#include "java/util/function/BiConsumer.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/util/function/BiFunction.h"
#include "java/util/Set.h"
#include "java/io/Serializable.h"
#include "JArray.h"

namespace java {
  namespace util {

    ::java::lang::Class *IdentityHashMap::class$ = NULL;
    jmethodID *IdentityHashMap::mids$ = NULL;
    bool IdentityHashMap::live$ = false;

    jclass IdentityHashMap::initializeClass(bool getOnly)
    {
      if (getOnly)
        return (jclass) (live$ ? class$->this$ : NULL);
      if (class$ == NULL)
      {
        jclass cls = (jclass) env->findClass("java/util/IdentityHashMap");

        mids$ = new jmethodID[max_mid];
        mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
        mids$[mid_init$_040c4cd0390c5aff] = env->getMethodID(cls, "<init>", "(I)V");
        mids$[mid_init$_408bd889ee3beae5] = env->getMethodID(cls, "<init>", "(Ljava/util/Map;)V");
        mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
        mids$[mid_clone_d6bcd06f3102c4d9] = env->getMethodID(cls, "clone", "()Ljava/lang/Object;");
        mids$[mid_containsKey_8b72f2dcdde6fd1d] = env->getMethodID(cls, "containsKey", "(Ljava/lang/Object;)Z");
        mids$[mid_containsValue_8b72f2dcdde6fd1d] = env->getMethodID(cls, "containsValue", "(Ljava/lang/Object;)Z");
        mids$[mid_entrySet_7dcf4034c6d1a92a] = env->getMethodID(cls, "entrySet", "()Ljava/util/Set;");
        mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
        mids$[mid_forEach_94704ed6ccc48468] = env->getMethodID(cls, "forEach", "(Ljava/util/function/BiConsumer;)V");
        mids$[mid_get_e5ae0f8c04795fa9] = env->getMethodID(cls, "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
        mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
        mids$[mid_keySet_7dcf4034c6d1a92a] = env->getMethodID(cls, "keySet", "()Ljava/util/Set;");
        mids$[mid_put_128a89bbc17a8b69] = env->getMethodID(cls, "put", "(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_putAll_408bd889ee3beae5] = env->getMethodID(cls, "putAll", "(Ljava/util/Map;)V");
        mids$[mid_remove_e5ae0f8c04795fa9] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Ljava/lang/Object;");
        mids$[mid_replaceAll_22221e328874bd4f] = env->getMethodID(cls, "replaceAll", "(Ljava/util/function/BiFunction;)V");
        mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
        mids$[mid_values_d4dfbf7a26ff41df] = env->getMethodID(cls, "values", "()Ljava/util/Collection;");

        class$ = new ::java::lang::Class(cls);
        live$ = true;
      }
      return (jclass) class$->this$;
    }

    IdentityHashMap::IdentityHashMap() : ::java::util::AbstractMap(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

    IdentityHashMap::IdentityHashMap(jint a0) : ::java::util::AbstractMap(env->newObject(initializeClass, &mids$, mid_init$_040c4cd0390c5aff, a0)) {}

    IdentityHashMap::IdentityHashMap(const ::java::util::Map & a0) : ::java::util::AbstractMap(env->newObject(initializeClass, &mids$, mid_init$_408bd889ee3beae5, a0.this$)) {}

    void IdentityHashMap::clear() const
    {
      env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
    }

    ::java::lang::Object IdentityHashMap::clone() const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_clone_d6bcd06f3102c4d9]));
    }

    jboolean IdentityHashMap::containsKey(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_containsKey_8b72f2dcdde6fd1d], a0.this$);
    }

    jboolean IdentityHashMap::containsValue(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_containsValue_8b72f2dcdde6fd1d], a0.this$);
    }

    ::java::util::Set IdentityHashMap::entrySet() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_entrySet_7dcf4034c6d1a92a]));
    }

    jboolean IdentityHashMap::equals(const ::java::lang::Object & a0) const
    {
      return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
    }

    void IdentityHashMap::forEach(const ::java::util::function::BiConsumer & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_forEach_94704ed6ccc48468], a0.this$);
    }

    ::java::lang::Object IdentityHashMap::get(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_e5ae0f8c04795fa9], a0.this$));
    }

    jint IdentityHashMap::hashCode() const
    {
      return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
    }

    jboolean IdentityHashMap::isEmpty() const
    {
      return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
    }

    ::java::util::Set IdentityHashMap::keySet() const
    {
      return ::java::util::Set(env->callObjectMethod(this$, mids$[mid_keySet_7dcf4034c6d1a92a]));
    }

    ::java::lang::Object IdentityHashMap::put(const ::java::lang::Object & a0, const ::java::lang::Object & a1) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_put_128a89bbc17a8b69], a0.this$, a1.this$));
    }

    void IdentityHashMap::putAll(const ::java::util::Map & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_putAll_408bd889ee3beae5], a0.this$);
    }

    ::java::lang::Object IdentityHashMap::remove(const ::java::lang::Object & a0) const
    {
      return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_remove_e5ae0f8c04795fa9], a0.this$));
    }

    void IdentityHashMap::replaceAll(const ::java::util::function::BiFunction & a0) const
    {
      env->callVoidMethod(this$, mids$[mid_replaceAll_22221e328874bd4f], a0.this$);
    }

    jint IdentityHashMap::size() const
    {
      return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
    }

    ::java::util::Collection IdentityHashMap::values() const
    {
      return ::java::util::Collection(env->callObjectMethod(this$, mids$[mid_values_d4dfbf7a26ff41df]));
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace java {
  namespace util {
    static PyObject *t_IdentityHashMap_cast_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_IdentityHashMap_instance_(PyTypeObject *type, PyObject *arg);
    static PyObject *t_IdentityHashMap_of_(t_IdentityHashMap *self, PyObject *args);
    static int t_IdentityHashMap_init_(t_IdentityHashMap *self, PyObject *args, PyObject *kwds);
    static PyObject *t_IdentityHashMap_clear(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_clone(t_IdentityHashMap *self);
    static PyObject *t_IdentityHashMap_containsKey(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_containsValue(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_entrySet(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_equals(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_forEach(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_get(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_hashCode(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_isEmpty(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_keySet(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_put(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_putAll(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_remove(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_replaceAll(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_size(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_values(t_IdentityHashMap *self, PyObject *args);
    static PyObject *t_IdentityHashMap_get__empty(t_IdentityHashMap *self, void *data);
    static PyObject *t_IdentityHashMap_get__parameters_(t_IdentityHashMap *self, void *data);
    static PyGetSetDef t_IdentityHashMap__fields_[] = {
      DECLARE_GET_FIELD(t_IdentityHashMap, empty),
      DECLARE_GET_FIELD(t_IdentityHashMap, parameters_),
      { NULL, NULL, NULL, NULL, NULL }
    };

    static PyMethodDef t_IdentityHashMap__methods_[] = {
      DECLARE_METHOD(t_IdentityHashMap, cast_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_IdentityHashMap, instance_, METH_O | METH_CLASS),
      DECLARE_METHOD(t_IdentityHashMap, of_, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, clear, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, clone, METH_NOARGS),
      DECLARE_METHOD(t_IdentityHashMap, containsKey, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, containsValue, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, entrySet, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, equals, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, forEach, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, get, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, hashCode, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, isEmpty, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, keySet, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, put, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, putAll, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, remove, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, replaceAll, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, size, METH_VARARGS),
      DECLARE_METHOD(t_IdentityHashMap, values, METH_VARARGS),
      { NULL, NULL, 0, NULL }
    };

    static PyType_Slot PY_TYPE_SLOTS(IdentityHashMap)[] = {
      { Py_tp_methods, t_IdentityHashMap__methods_ },
      { Py_tp_init, (void *) t_IdentityHashMap_init_ },
      { Py_tp_getset, t_IdentityHashMap__fields_ },
      { 0, NULL }
    };

    static PyType_Def *PY_TYPE_BASES(IdentityHashMap)[] = {
      &PY_TYPE_DEF(::java::util::AbstractMap),
      NULL
    };

    DEFINE_TYPE(IdentityHashMap, t_IdentityHashMap, IdentityHashMap);
    PyObject *t_IdentityHashMap::wrap_Object(const IdentityHashMap& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_IdentityHashMap::wrap_Object(object);
      if (obj != NULL && obj != Py_None)
      {
        t_IdentityHashMap *self = (t_IdentityHashMap *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    PyObject *t_IdentityHashMap::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
    {
      PyObject *obj = t_IdentityHashMap::wrap_jobject(object);
      if (obj != NULL && obj != Py_None)
      {
        t_IdentityHashMap *self = (t_IdentityHashMap *) obj;
        self->parameters[0] = p0;
        self->parameters[1] = p1;
      }
      return obj;
    }

    void t_IdentityHashMap::install(PyObject *module)
    {
      installType(&PY_TYPE(IdentityHashMap), &PY_TYPE_DEF(IdentityHashMap), module, "IdentityHashMap", 0);
    }

    void t_IdentityHashMap::initialize(PyObject *module)
    {
      PyObject_SetAttrString((PyObject *) PY_TYPE(IdentityHashMap), "class_", make_descriptor(IdentityHashMap::initializeClass, 1));
      PyObject_SetAttrString((PyObject *) PY_TYPE(IdentityHashMap), "wrapfn_", make_descriptor(t_IdentityHashMap::wrap_jobject));
      PyObject_SetAttrString((PyObject *) PY_TYPE(IdentityHashMap), "boxfn_", make_descriptor(boxObject));
    }

    static PyObject *t_IdentityHashMap_cast_(PyTypeObject *type, PyObject *arg)
    {
      if (!(arg = castCheck(arg, IdentityHashMap::initializeClass, 1)))
        return NULL;
      return t_IdentityHashMap::wrap_Object(IdentityHashMap(((t_IdentityHashMap *) arg)->object.this$));
    }
    static PyObject *t_IdentityHashMap_instance_(PyTypeObject *type, PyObject *arg)
    {
      if (!castCheck(arg, IdentityHashMap::initializeClass, 0))
        Py_RETURN_FALSE;
      Py_RETURN_TRUE;
    }

    static PyObject *t_IdentityHashMap_of_(t_IdentityHashMap *self, PyObject *args)
    {
      if (!parseArg(args, "T", 2, &(self->parameters)))
        Py_RETURN_SELF;
      return PyErr_SetArgsError((PyObject *) self, "of_", args);
    }

    static int t_IdentityHashMap_init_(t_IdentityHashMap *self, PyObject *args, PyObject *kwds)
    {
      switch (PyTuple_GET_SIZE(args)) {
       case 0:
        {
          IdentityHashMap object((jobject) NULL);

          INT_CALL(object = IdentityHashMap());
          self->object = object;
          break;
        }
       case 1:
        {
          jint a0;
          IdentityHashMap object((jobject) NULL);

          if (!parseArgs(args, "I", &a0))
          {
            INT_CALL(object = IdentityHashMap(a0));
            self->object = object;
            break;
          }
        }
        {
          ::java::util::Map a0((jobject) NULL);
          PyTypeObject **p0;
          IdentityHashMap object((jobject) NULL);

          if (!parseArgs(args, "K", ::java::util::Map::initializeClass, &a0, &p0, ::java::util::t_Map::parameters_))
          {
            INT_CALL(object = IdentityHashMap(a0));
            self->object = object;
            break;
          }
        }
       default:
        PyErr_SetArgsError((PyObject *) self, "__init__", args);
        return -1;
      }

      return 0;
    }

    static PyObject *t_IdentityHashMap_clear(t_IdentityHashMap *self, PyObject *args)
    {

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(self->object.clear());
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "clear", args, 2);
    }

    static PyObject *t_IdentityHashMap_clone(t_IdentityHashMap *self)
    {
      ::java::lang::Object result((jobject) NULL);
      OBJ_CALL(result = self->object.clone());
      return ::java::lang::t_Object::wrap_Object(result);
    }

    static PyObject *t_IdentityHashMap_containsKey(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.containsKey(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "containsKey", args, 2);
    }

    static PyObject *t_IdentityHashMap_containsValue(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.containsValue(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "containsValue", args, 2);
    }

    static PyObject *t_IdentityHashMap_entrySet(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::util::Set result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.entrySet());
        return ::java::util::t_Set::wrap_Object(result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "entrySet", args, 2);
    }

    static PyObject *t_IdentityHashMap_equals(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      jboolean result;

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.equals(a0));
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "equals", args, 2);
    }

    static PyObject *t_IdentityHashMap_forEach(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::util::function::BiConsumer a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArgs(args, "K", ::java::util::function::BiConsumer::initializeClass, &a0, &p0, ::java::util::function::t_BiConsumer::parameters_))
      {
        OBJ_CALL(self->object.forEach(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "forEach", args, 2);
    }

    static PyObject *t_IdentityHashMap_get(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.get(a0));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "get", args, 2);
    }

    static PyObject *t_IdentityHashMap_hashCode(t_IdentityHashMap *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.hashCode());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "hashCode", args, 2);
    }

    static PyObject *t_IdentityHashMap_isEmpty(t_IdentityHashMap *self, PyObject *args)
    {
      jboolean result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.isEmpty());
        Py_RETURN_BOOL(result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "isEmpty", args, 2);
    }

    static PyObject *t_IdentityHashMap_keySet(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::util::Set result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.keySet());
        return ::java::util::t_Set::wrap_Object(result, self->parameters[0]);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "keySet", args, 2);
    }

    static PyObject *t_IdentityHashMap_put(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object a1((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "OO", self->parameters[0], self->parameters[1], &a0, &a1))
      {
        OBJ_CALL(result = self->object.put(a0, a1));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "put", args, 2);
    }

    static PyObject *t_IdentityHashMap_putAll(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::util::Map a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArgs(args, "K", ::java::util::Map::initializeClass, &a0, &p0, ::java::util::t_Map::parameters_))
      {
        OBJ_CALL(self->object.putAll(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "putAll", args, 2);
    }

    static PyObject *t_IdentityHashMap_remove(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::lang::Object a0((jobject) NULL);
      ::java::lang::Object result((jobject) NULL);

      if (!parseArgs(args, "o", &a0))
      {
        OBJ_CALL(result = self->object.remove(a0));
        return self->parameters[1] != NULL ? wrapType(self->parameters[1], result.this$) : ::java::lang::t_Object::wrap_Object(result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "remove", args, 2);
    }

    static PyObject *t_IdentityHashMap_replaceAll(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::util::function::BiFunction a0((jobject) NULL);
      PyTypeObject **p0;

      if (!parseArgs(args, "K", ::java::util::function::BiFunction::initializeClass, &a0, &p0, ::java::util::function::t_BiFunction::parameters_))
      {
        OBJ_CALL(self->object.replaceAll(a0));
        Py_RETURN_NONE;
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "replaceAll", args, 2);
    }

    static PyObject *t_IdentityHashMap_size(t_IdentityHashMap *self, PyObject *args)
    {
      jint result;

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.size());
        return PyLong_FromLong((long) result);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "size", args, 2);
    }

    static PyObject *t_IdentityHashMap_values(t_IdentityHashMap *self, PyObject *args)
    {
      ::java::util::Collection result((jobject) NULL);

      if (!parseArgs(args, ""))
      {
        OBJ_CALL(result = self->object.values());
        return ::java::util::t_Collection::wrap_Object(result, self->parameters[1]);
      }

      return callSuper(PY_TYPE(IdentityHashMap), (PyObject *) self, "values", args, 2);
    }
    static PyObject *t_IdentityHashMap_get__parameters_(t_IdentityHashMap *self, void *data)
    {
      return typeParameters(self->parameters, sizeof(self->parameters));
    }

    static PyObject *t_IdentityHashMap_get__empty(t_IdentityHashMap *self, void *data)
    {
      jboolean value;
      OBJ_CALL(value = self->object.isEmpty());
      Py_RETURN_BOOL(value);
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ATNType.h"
#include "org/antlr/v4/runtime/atn/ATNType.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ATNType::class$ = NULL;
          jmethodID *ATNType::mids$ = NULL;
          bool ATNType::live$ = false;
          ATNType *ATNType::LEXER = NULL;
          ATNType *ATNType::PARSER = NULL;

          jclass ATNType::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ATNType");

              mids$ = new jmethodID[max_mid];
              mids$[mid_valueOf_42f33926539db7ec] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lorg/antlr/v4/runtime/atn/ATNType;");
              mids$[mid_values_d620a1810d3ec011] = env->getStaticMethodID(cls, "values", "()[Lorg/antlr/v4/runtime/atn/ATNType;");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              LEXER = new ATNType(env->getStaticObjectField(cls, "LEXER", "Lorg/antlr/v4/runtime/atn/ATNType;"));
              PARSER = new ATNType(env->getStaticObjectField(cls, "PARSER", "Lorg/antlr/v4/runtime/atn/ATNType;"));
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ATNType ATNType::valueOf(const ::java::lang::String & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return ATNType(env->callStaticObjectMethod(cls, mids$[mid_valueOf_42f33926539db7ec], a0.this$));
          }

          JArray< ATNType > ATNType::values()
          {
            jclass cls = env->getClass(initializeClass);
            return JArray< ATNType >(env->callStaticObjectMethod(cls, mids$[mid_values_d620a1810d3ec011]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ATNType_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNType_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNType_of_(t_ATNType *self, PyObject *args);
          static PyObject *t_ATNType_valueOf(PyTypeObject *type, PyObject *args);
          static PyObject *t_ATNType_values(PyTypeObject *type);
          static PyObject *t_ATNType_get__parameters_(t_ATNType *self, void *data);
          static PyGetSetDef t_ATNType__fields_[] = {
            DECLARE_GET_FIELD(t_ATNType, parameters_),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ATNType__methods_[] = {
            DECLARE_METHOD(t_ATNType, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNType, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNType, of_, METH_VARARGS),
            DECLARE_METHOD(t_ATNType, valueOf, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_ATNType, values, METH_NOARGS | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ATNType)[] = {
            { Py_tp_methods, t_ATNType__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_ATNType__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ATNType)[] = {
            &PY_TYPE_DEF(::java::lang::Enum),
            NULL
          };

          DEFINE_TYPE(ATNType, t_ATNType, ATNType);
          PyObject *t_ATNType::wrap_Object(const ATNType& object, PyTypeObject *p0)
          {
            PyObject *obj = t_ATNType::wrap_Object(object);
            if (obj != NULL && obj != Py_None)
            {
              t_ATNType *self = (t_ATNType *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          PyObject *t_ATNType::wrap_jobject(const jobject& object, PyTypeObject *p0)
          {
            PyObject *obj = t_ATNType::wrap_jobject(object);
            if (obj != NULL && obj != Py_None)
            {
              t_ATNType *self = (t_ATNType *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          void t_ATNType::install(PyObject *module)
          {
            installType(&PY_TYPE(ATNType), &PY_TYPE_DEF(ATNType), module, "ATNType", 0);
          }

          void t_ATNType::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNType), "class_", make_descriptor(ATNType::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNType), "wrapfn_", make_descriptor(t_ATNType::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNType), "boxfn_", make_descriptor(boxObject));
            env->getClass(ATNType::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNType), "LEXER", make_descriptor(t_ATNType::wrap_Object(*ATNType::LEXER)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNType), "PARSER", make_descriptor(t_ATNType::wrap_Object(*ATNType::PARSER)));
          }

          static PyObject *t_ATNType_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ATNType::initializeClass, 1)))
              return NULL;
            return t_ATNType::wrap_Object(ATNType(((t_ATNType *) arg)->object.this$));
          }
          static PyObject *t_ATNType_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ATNType::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_ATNType_of_(t_ATNType *self, PyObject *args)
          {
            if (!parseArg(args, "T", 1, &(self->parameters)))
              Py_RETURN_SELF;
            return PyErr_SetArgsError((PyObject *) self, "of_", args);
          }

          static PyObject *t_ATNType_valueOf(PyTypeObject *type, PyObject *args)
          {
            ::java::lang::String a0((jobject) NULL);
            ATNType result((jobject) NULL);

            if (!parseArgs(args, "s", &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::ATNType::valueOf(a0));
              return t_ATNType::wrap_Object(result);
            }

            return callSuper(type, "valueOf", args, 2);
          }

          static PyObject *t_ATNType_values(PyTypeObject *type)
          {
            JArray< ATNType > result((jobject) NULL);
            OBJ_CALL(result = ::org::antlr::v4::runtime::atn::ATNType::values());
            return JArray<jobject>(result.this$).wrap(t_ATNType::wrap_jobject);
          }
          static PyObject *t_ATNType_get__parameters_(t_ATNType *self, void *data)
          {
            return typeParameters(self->parameters, sizeof(self->parameters));
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/RuleStartState.h"
#include "org/antlr/v4/runtime/atn/RuleStopState.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *RuleStartState::class$ = NULL;
          jmethodID *RuleStartState::mids$ = NULL;
          jfieldID *RuleStartState::fids$ = NULL;
          bool RuleStartState::live$ = false;

          jclass RuleStartState::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/RuleStartState");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
              mids$[mid_getStateType_9972fcc56b44e79d] = env->getMethodID(cls, "getStateType", "()I");

              fids$ = new jfieldID[max_fid];
              fids$[fid_isLeftRecursiveRule] = env->getFieldID(cls, "isLeftRecursiveRule", "Z");
              fids$[fid_stopState] = env->getFieldID(cls, "stopState", "Lorg/antlr/v4/runtime/atn/RuleStopState;");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          RuleStartState::RuleStartState() : ::org::antlr::v4::runtime::atn::ATNState(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          jint RuleStartState::getStateType() const
          {
            return env->callIntMethod(this$, mids$[mid_getStateType_9972fcc56b44e79d]);
          }

          jboolean RuleStartState::_get_isLeftRecursiveRule() const
          {
            return env->getBooleanField(this$, fids$[fid_isLeftRecursiveRule]);
          }

          void RuleStartState::_set_isLeftRecursiveRule(jboolean a0) const
          {
            env->setBooleanField(this$, fids$[fid_isLeftRecursiveRule], a0);
          }

          ::org::antlr::v4::runtime::atn::RuleStopState RuleStartState::_get_stopState() const
          {
            return ::org::antlr::v4::runtime::atn::RuleStopState(env->getObjectField(this$, fids$[fid_stopState]));
          }

          void RuleStartState::_set_stopState(const ::org::antlr::v4::runtime::atn::RuleStopState & a0) const
          {
            env->setObjectField(this$, fids$[fid_stopState], a0.this$);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_RuleStartState_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_RuleStartState_instance_(PyTypeObject *type, PyObject *arg);
          static int t_RuleStartState_init_(t_RuleStartState *self, PyObject *args, PyObject *kwds);
          static PyObject *t_RuleStartState_getStateType(t_RuleStartState *self, PyObject *args);
          static PyObject *t_RuleStartState_get__isLeftRecursiveRule(t_RuleStartState *self, void *data);
          static int t_RuleStartState_set__isLeftRecursiveRule(t_RuleStartState *self, PyObject *arg, void *data);
          static PyObject *t_RuleStartState_get__stopState(t_RuleStartState *self, void *data);
          static int t_RuleStartState_set__stopState(t_RuleStartState *self, PyObject *arg, void *data);

          static PyObject *t_RuleStartState_get__stateType(t_RuleStartState *self, void *data);
          static PyGetSetDef t_RuleStartState__fields_[] = {
            DECLARE_GETSET_FIELD(t_RuleStartState, isLeftRecursiveRule),
            DECLARE_GETSET_FIELD(t_RuleStartState, stopState),
            DECLARE_GET_FIELD(t_RuleStartState, stateType),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_RuleStartState__methods_[] = {
            DECLARE_METHOD(t_RuleStartState, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_RuleStartState, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_RuleStartState, getStateType, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(RuleStartState)[] = {
            { Py_tp_methods, t_RuleStartState__methods_ },
            { Py_tp_init, (void *) t_RuleStartState_init_ },
            { Py_tp_getset, t_RuleStartState__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(RuleStartState)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::ATNState),
            NULL
          };

          DEFINE_TYPE(RuleStartState, t_RuleStartState, RuleStartState);

          void t_RuleStartState::install(PyObject *module)
          {
            installType(&PY_TYPE(RuleStartState), &PY_TYPE_DEF(RuleStartState), module, "RuleStartState", 0);
          }

          void t_RuleStartState::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(RuleStartState), "class_", make_descriptor(RuleStartState::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(RuleStartState), "wrapfn_", make_descriptor(t_RuleStartState::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(RuleStartState), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_RuleStartState_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, RuleStartState::initializeClass, 1)))
              return NULL;
            return t_RuleStartState::wrap_Object(RuleStartState(((t_RuleStartState *) arg)->object.this$));
          }
          static PyObject *t_RuleStartState_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, RuleStartState::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_RuleStartState_init_(t_RuleStartState *self, PyObject *args, PyObject *kwds)
          {
            RuleStartState object((jobject) NULL);

            INT_CALL(object = RuleStartState());
            self->object = object;

            return 0;
          }

          static PyObject *t_RuleStartState_getStateType(t_RuleStartState *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.getStateType());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(RuleStartState), (PyObject *) self, "getStateType", args, 2);
          }

          static PyObject *t_RuleStartState_get__isLeftRecursiveRule(t_RuleStartState *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object._get_isLeftRecursiveRule());
            Py_RETURN_BOOL(value);
          }
          static int t_RuleStartState_set__isLeftRecursiveRule(t_RuleStartState *self, PyObject *arg, void *data)
          {
            jboolean value;
            if (!parseArg(arg, "Z", &value))
            {
              INT_CALL(self->object._set_isLeftRecursiveRule(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "isLeftRecursiveRule", arg);
            return -1;
          }

          static PyObject *t_RuleStartState_get__stopState(t_RuleStartState *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::RuleStopState value((jobject) NULL);
            OBJ_CALL(value = self->object._get_stopState());
            return ::org::antlr::v4::runtime::atn::t_RuleStopState::wrap_Object(value);
          }
          static int t_RuleStartState_set__stopState(t_RuleStartState *self, PyObject *arg, void *data)
          {
            ::org::antlr::v4::runtime::atn::RuleStopState value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::atn::RuleStopState::initializeClass, &value))
            {
              INT_CALL(self->object._set_stopState(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "stopState", arg);
            return -1;
          }

          static PyObject *t_RuleStartState_get__stateType(t_RuleStartState *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getStateType());
            return PyLong_FromLong((long) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ProfilingATNSimulator.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/ParserRuleContext.h"
#include "org/antlr/v4/runtime/atn/DecisionInfo.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "org/antlr/v4/runtime/Parser.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ProfilingATNSimulator::class$ = NULL;
          jmethodID *ProfilingATNSimulator::mids$ = NULL;
          bool ProfilingATNSimulator::live$ = false;

          jclass ProfilingATNSimulator::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ProfilingATNSimulator");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_32103c89317c9cb1] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/Parser;)V");
              mids$[mid_adaptivePredict_72c80921051c0d0f] = env->getMethodID(cls, "adaptivePredict", "(Lorg/antlr/v4/runtime/TokenStream;ILorg/antlr/v4/runtime/ParserRuleContext;)I");
              mids$[mid_getDecisionInfo_7d2aa8394c2bb88e] = env->getMethodID(cls, "getDecisionInfo", "()[Lorg/antlr/v4/runtime/atn/DecisionInfo;");
              mids$[mid_reportAttemptingFullContext_ed6a15b8ee7d4bab] = env->getMethodID(cls, "reportAttemptingFullContext", "(Lorg/antlr/v4/runtime/dfa/DFA;Ljava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;II)V");
              mids$[mid_reportContextSensitivity_e936c26f7898466f] = env->getMethodID(cls, "reportContextSensitivity", "(Lorg/antlr/v4/runtime/dfa/DFA;ILorg/antlr/v4/runtime/atn/ATNConfigSet;II)V");
              mids$[mid_getExistingTargetState_61638a030e2cccdc] = env->getMethodID(cls, "getExistingTargetState", "(Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_computeTargetState_11874a3ad517578a] = env->getMethodID(cls, "computeTargetState", "(Lorg/antlr/v4/runtime/dfa/DFA;Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_computeReachSet_8357bfef0945b314] = env->getMethodID(cls, "computeReachSet", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;IZ)Lorg/antlr/v4/runtime/atn/ATNConfigSet;");
              mids$[mid_evalSemanticContext_f2ecdd5ff8d6fb82] = env->getMethodID(cls, "evalSemanticContext", "(Lorg/antlr/v4/runtime/atn/SemanticContext;Lorg/antlr/v4/runtime/ParserRuleContext;IZ)Z");
              mids$[mid_reportAmbiguity_8df929a94940cc45] = env->getMethodID(cls, "reportAmbiguity", "(Lorg/antlr/v4/runtime/dfa/DFA;Lorg/antlr/v4/runtime/dfa/DFAState;IIZLjava/util/BitSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;)V");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ProfilingATNSimulator::ProfilingATNSimulator(const ::org::antlr::v4::runtime::Parser & a0) : ::org::antlr::v4::runtime::atn::ParserATNSimulator(env->newObject(initializeClass, &mids$, mid_init$_32103c89317c9cb1, a0.this$)) {}

          jint ProfilingATNSimulator::adaptivePredict(const ::org::antlr::v4::runtime::TokenStream & a0, jint a1, const ::org::antlr::v4::runtime::ParserRuleContext & a2) const
          {
            return env->callIntMethod(this$, mids$[mid_adaptivePredict_72c80921051c0d0f], a0.this$, a1, a2.this$);
          }

          JArray< ::org::antlr::v4::runtime::atn::DecisionInfo > ProfilingATNSimulator::getDecisionInfo() const
          {
            return JArray< ::org::antlr::v4::runtime::atn::DecisionInfo >(env->callObjectMethod(this$, mids$[mid_getDecisionInfo_7d2aa8394c2bb88e]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ProfilingATNSimulator_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ProfilingATNSimulator_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ProfilingATNSimulator_init_(t_ProfilingATNSimulator *self, PyObject *args, PyObject *kwds);
          static PyObject *t_ProfilingATNSimulator_adaptivePredict(t_ProfilingATNSimulator *self, PyObject *args);
          static PyObject *t_ProfilingATNSimulator_getDecisionInfo(t_ProfilingATNSimulator *self);
          static PyObject *t_ProfilingATNSimulator_get__decisionInfo(t_ProfilingATNSimulator *self, void *data);
          static PyGetSetDef t_ProfilingATNSimulator__fields_[] = {
            DECLARE_GET_FIELD(t_ProfilingATNSimulator, decisionInfo),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ProfilingATNSimulator__methods_[] = {
            DECLARE_METHOD(t_ProfilingATNSimulator, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ProfilingATNSimulator, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ProfilingATNSimulator, adaptivePredict, METH_VARARGS),
            DECLARE_METHOD(t_ProfilingATNSimulator, getDecisionInfo, METH_NOARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ProfilingATNSimulator)[] = {
            { Py_tp_methods, t_ProfilingATNSimulator__methods_ },
            { Py_tp_init, (void *) t_ProfilingATNSimulator_init_ },
            { Py_tp_getset, t_ProfilingATNSimulator__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ProfilingATNSimulator)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::ParserATNSimulator),
            NULL
          };

          DEFINE_TYPE(ProfilingATNSimulator, t_ProfilingATNSimulator, ProfilingATNSimulator);

          void t_ProfilingATNSimulator::install(PyObject *module)
          {
            installType(&PY_TYPE(ProfilingATNSimulator), &PY_TYPE_DEF(ProfilingATNSimulator), module, "ProfilingATNSimulator", 0);
          }

          void t_ProfilingATNSimulator::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ProfilingATNSimulator), "class_", make_descriptor(ProfilingATNSimulator::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ProfilingATNSimulator), "wrapfn_", make_descriptor(t_ProfilingATNSimulator::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ProfilingATNSimulator), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_ProfilingATNSimulator_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ProfilingATNSimulator::initializeClass, 1)))
              return NULL;
            return t_ProfilingATNSimulator::wrap_Object(ProfilingATNSimulator(((t_ProfilingATNSimulator *) arg)->object.this$));
          }
          static PyObject *t_ProfilingATNSimulator_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ProfilingATNSimulator::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ProfilingATNSimulator_init_(t_ProfilingATNSimulator *self, PyObject *args, PyObject *kwds)
          {
            ::org::antlr::v4::runtime::Parser a0((jobject) NULL);
            PyTypeObject **p0;
            ProfilingATNSimulator object((jobject) NULL);

            if (!parseArgs(args, "K", ::org::antlr::v4::runtime::Parser::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Parser::parameters_))
            {
              INT_CALL(object = ProfilingATNSimulator(a0));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_ProfilingATNSimulator_adaptivePredict(t_ProfilingATNSimulator *self, PyObject *args)
          {
            ::org::antlr::v4::runtime::TokenStream a0((jobject) NULL);
            jint a1;
            ::org::antlr::v4::runtime::ParserRuleContext a2((jobject) NULL);
            jint result;

            if (!parseArgs(args, "kIk", ::org::antlr::v4::runtime::TokenStream::initializeClass, ::org::antlr::v4::runtime::ParserRuleContext::initializeClass, &a0, &a1, &a2))
            {
              OBJ_CALL(result = self->object.adaptivePredict(a0, a1, a2));
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(ProfilingATNSimulator), (PyObject *) self, "adaptivePredict", args, 2);
          }

          static PyObject *t_ProfilingATNSimulator_getDecisionInfo(t_ProfilingATNSimulator *self)
          {
            JArray< ::org::antlr::v4::runtime::atn::DecisionInfo > result((jobject) NULL);
            OBJ_CALL(result = self->object.getDecisionInfo());
            return JArray<jobject>(result.this$).wrap(::org::antlr::v4::runtime::atn::t_DecisionInfo::wrap_jobject);
          }

          static PyObject *t_ProfilingATNSimulator_get__decisionInfo(t_ProfilingATNSimulator *self, void *data)
          {
            JArray< ::org::antlr::v4::runtime::atn::DecisionInfo > value((jobject) NULL);
            OBJ_CALL(value = self->object.getDecisionInfo());
            return JArray<jobject>(value.this$).wrap(::org::antlr::v4::runtime::atn::t_DecisionInfo::wrap_jobject);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/SingletonPredictionContext.h"
#include "java/lang/Class.h"
#include "java/lang/Object.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/SingletonPredictionContext.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *SingletonPredictionContext::class$ = NULL;
          jmethodID *SingletonPredictionContext::mids$ = NULL;
          jfieldID *SingletonPredictionContext::fids$ = NULL;
          bool SingletonPredictionContext::live$ = false;

          jclass SingletonPredictionContext::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/SingletonPredictionContext");

              mids$ = new jmethodID[max_mid];
              mids$[mid_create_43fc0b0b66366a2f] = env->getStaticMethodID(cls, "create", "(Lorg/antlr/v4/runtime/atn/PredictionContext;I)Lorg/antlr/v4/runtime/atn/SingletonPredictionContext;");
              mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
              mids$[mid_getParent_de7c941e2462c7c5] = env->getMethodID(cls, "getParent", "(I)Lorg/antlr/v4/runtime/atn/PredictionContext;");
              mids$[mid_getReturnState_1e143afe1894d213] = env->getMethodID(cls, "getReturnState", "(I)I");
              mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

              fids$ = new jfieldID[max_fid];
              fids$[fid_parent] = env->getFieldID(cls, "parent", "Lorg/antlr/v4/runtime/atn/PredictionContext;");
              fids$[fid_returnState] = env->getFieldID(cls, "returnState", "I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          SingletonPredictionContext SingletonPredictionContext::create(const ::org::antlr::v4::runtime::atn::PredictionContext & a0, jint a1)
          {
            jclass cls = env->getClass(initializeClass);
            return SingletonPredictionContext(env->callStaticObjectMethod(cls, mids$[mid_create_43fc0b0b66366a2f], a0.this$, a1));
          }

          jboolean SingletonPredictionContext::equals(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
          }

          ::org::antlr::v4::runtime::atn::PredictionContext SingletonPredictionContext::getParent(jint a0) const
          {
            return ::org::antlr::v4::runtime::atn::PredictionContext(env->callObjectMethod(this$, mids$[mid_getParent_de7c941e2462c7c5], a0));
          }

          jint SingletonPredictionContext::getReturnState(jint a0) const
          {
            return env->callIntMethod(this$, mids$[mid_getReturnState_1e143afe1894d213], a0);
          }

          jint SingletonPredictionContext::size() const
          {
            return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
          }

          ::java::lang::String SingletonPredictionContext::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }

          ::org::antlr::v4::runtime::atn::PredictionContext SingletonPredictionContext::_get_parent() const
          {
            return ::org::antlr::v4::runtime::atn::PredictionContext(env->getObjectField(this$, fids$[fid_parent]));
          }

          jint SingletonPredictionContext::_get_returnState() const
          {
            return env->getIntField(this$, fids$[fid_returnState]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_SingletonPredictionContext_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_SingletonPredictionContext_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_SingletonPredictionContext_create(PyTypeObject *type, PyObject *args);
          static PyObject *t_SingletonPredictionContext_equals(t_SingletonPredictionContext *self, PyObject *args);
          static PyObject *t_SingletonPredictionContext_getParent(t_SingletonPredictionContext *self, PyObject *args);
          static PyObject *t_SingletonPredictionContext_getReturnState(t_SingletonPredictionContext *self, PyObject *args);
          static PyObject *t_SingletonPredictionContext_size(t_SingletonPredictionContext *self, PyObject *args);
          static PyObject *t_SingletonPredictionContext_toString(t_SingletonPredictionContext *self, PyObject *args);
          static PyObject *t_SingletonPredictionContext_get__parent(t_SingletonPredictionContext *self, void *data);
          static PyObject *t_SingletonPredictionContext_get__returnState(t_SingletonPredictionContext *self, void *data);

          static PyGetSetDef t_SingletonPredictionContext__fields_[] = {
            DECLARE_GET_FIELD(t_SingletonPredictionContext, parent),
            DECLARE_GET_FIELD(t_SingletonPredictionContext, returnState),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_SingletonPredictionContext__methods_[] = {
            DECLARE_METHOD(t_SingletonPredictionContext, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_SingletonPredictionContext, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_SingletonPredictionContext, create, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_SingletonPredictionContext, equals, METH_VARARGS),
            DECLARE_METHOD(t_SingletonPredictionContext, getParent, METH_VARARGS),
            DECLARE_METHOD(t_SingletonPredictionContext, getReturnState, METH_VARARGS),
            DECLARE_METHOD(t_SingletonPredictionContext, size, METH_VARARGS),
            DECLARE_METHOD(t_SingletonPredictionContext, toString, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(SingletonPredictionContext)[] = {
            { Py_tp_methods, t_SingletonPredictionContext__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_SingletonPredictionContext__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(SingletonPredictionContext)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::PredictionContext),
            NULL
          };

          DEFINE_TYPE(SingletonPredictionContext, t_SingletonPredictionContext, SingletonPredictionContext);

          void t_SingletonPredictionContext::install(PyObject *module)
          {
            installType(&PY_TYPE(SingletonPredictionContext), &PY_TYPE_DEF(SingletonPredictionContext), module, "SingletonPredictionContext", 0);
          }

          void t_SingletonPredictionContext::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(SingletonPredictionContext), "class_", make_descriptor(SingletonPredictionContext::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(SingletonPredictionContext), "wrapfn_", make_descriptor(t_SingletonPredictionContext::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(SingletonPredictionContext), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_SingletonPredictionContext_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, SingletonPredictionContext::initializeClass, 1)))
              return NULL;
            return t_SingletonPredictionContext::wrap_Object(SingletonPredictionContext(((t_SingletonPredictionContext *) arg)->object.this$));
          }
          static PyObject *t_SingletonPredictionContext_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, SingletonPredictionContext::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_SingletonPredictionContext_create(PyTypeObject *type, PyObject *args)
          {
            ::org::antlr::v4::runtime::atn::PredictionContext a0((jobject) NULL);
            jint a1;
            SingletonPredictionContext result((jobject) NULL);

            if (!parseArgs(args, "kI", ::org::antlr::v4::runtime::atn::PredictionContext::initializeClass, &a0, &a1))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::SingletonPredictionContext::create(a0, a1));
              return t_SingletonPredictionContext::wrap_Object(result);
            }

            PyErr_SetArgsError(type, "create", args);
            return NULL;
          }

          static PyObject *t_SingletonPredictionContext_equals(t_SingletonPredictionContext *self, PyObject *args)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "o", &a0))
            {
              OBJ_CALL(result = self->object.equals(a0));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(SingletonPredictionContext), (PyObject *) self, "equals", args, 2);
          }

          static PyObject *t_SingletonPredictionContext_getParent(t_SingletonPredictionContext *self, PyObject *args)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::PredictionContext result((jobject) NULL);

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.getParent(a0));
              return ::org::antlr::v4::runtime::atn::t_PredictionContext::wrap_Object(result);
            }

            return callSuper(PY_TYPE(SingletonPredictionContext), (PyObject *) self, "getParent", args, 2);
          }

          static PyObject *t_SingletonPredictionContext_getReturnState(t_SingletonPredictionContext *self, PyObject *args)
          {
            jint a0;
            jint result;

            if (!parseArgs(args, "I", &a0))
            {
              OBJ_CALL(result = self->object.getReturnState(a0));
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(SingletonPredictionContext), (PyObject *) self, "getReturnState", args, 2);
          }

          static PyObject *t_SingletonPredictionContext_size(t_SingletonPredictionContext *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.size());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(SingletonPredictionContext), (PyObject *) self, "size", args, 2);
          }

          static PyObject *t_SingletonPredictionContext_toString(t_SingletonPredictionContext *self, PyObject *args)
          {
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.toString());
              return j2p(result);
            }

            return callSuper(PY_TYPE(SingletonPredictionContext), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_SingletonPredictionContext_get__parent(t_SingletonPredictionContext *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::PredictionContext value((jobject) NULL);
            OBJ_CALL(value = self->object._get_parent());
            return ::org::antlr::v4::runtime::atn::t_PredictionContext::wrap_Object(value);
          }

          static PyObject *t_SingletonPredictionContext_get__returnState(t_SingletonPredictionContext *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_returnState());
            return PyLong_FromLong((long) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/RuleStopState.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *RuleStopState::class$ = NULL;
          jmethodID *RuleStopState::mids$ = NULL;
          bool RuleStopState::live$ = false;

          jclass RuleStopState::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/RuleStopState");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
              mids$[mid_getStateType_9972fcc56b44e79d] = env->getMethodID(cls, "getStateType", "()I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          RuleStopState::RuleStopState() : ::org::antlr::v4::runtime::atn::ATNState(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          jint RuleStopState::getStateType() const
          {
            return env->callIntMethod(this$, mids$[mid_getStateType_9972fcc56b44e79d]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_RuleStopState_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_RuleStopState_instance_(PyTypeObject *type, PyObject *arg);
          static int t_RuleStopState_init_(t_RuleStopState *self, PyObject *args, PyObject *kwds);
          static PyObject *t_RuleStopState_getStateType(t_RuleStopState *self, PyObject *args);
          static PyObject *t_RuleStopState_get__stateType(t_RuleStopState *self, void *data);
          static PyGetSetDef t_RuleStopState__fields_[] = {
            DECLARE_GET_FIELD(t_RuleStopState, stateType),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_RuleStopState__methods_[] = {
            DECLARE_METHOD(t_RuleStopState, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_RuleStopState, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_RuleStopState, getStateType, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(RuleStopState)[] = {
            { Py_tp_methods, t_RuleStopState__methods_ },
            { Py_tp_init, (void *) t_RuleStopState_init_ },
            { Py_tp_getset, t_RuleStopState__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(RuleStopState)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::ATNState),
            NULL
          };

          DEFINE_TYPE(RuleStopState, t_RuleStopState, RuleStopState);

          void t_RuleStopState::install(PyObject *module)
          {
            installType(&PY_TYPE(RuleStopState), &PY_TYPE_DEF(RuleStopState), module, "RuleStopState", 0);
          }

          void t_RuleStopState::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(RuleStopState), "class_", make_descriptor(RuleStopState::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(RuleStopState), "wrapfn_", make_descriptor(t_RuleStopState::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(RuleStopState), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_RuleStopState_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, RuleStopState::initializeClass, 1)))
              return NULL;
            return t_RuleStopState::wrap_Object(RuleStopState(((t_RuleStopState *) arg)->object.this$));
          }
          static PyObject *t_RuleStopState_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, RuleStopState::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_RuleStopState_init_(t_RuleStopState *self, PyObject *args, PyObject *kwds)
          {
            RuleStopState object((jobject) NULL);

            INT_CALL(object = RuleStopState());
            self->object = object;

            return 0;
          }

          static PyObject *t_RuleStopState_getStateType(t_RuleStopState *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.getStateType());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(RuleStopState), (PyObject *) self, "getStateType", args, 2);
          }

          static PyObject *t_RuleStopState_get__stateType(t_RuleStopState *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getStateType());
            return PyLong_FromLong((long) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ErrorInfo.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ErrorInfo::class$ = NULL;
          jmethodID *ErrorInfo::mids$ = NULL;
          bool ErrorInfo::live$ = false;

          jclass ErrorInfo::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ErrorInfo");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_4923a124fb8045e3] = env->getMethodID(cls, "<init>", "(ILorg/antlr/v4/runtime/atn/ATNConfigSet;Lorg/antlr/v4/runtime/TokenStream;IIZ)V");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ErrorInfo::ErrorInfo(jint a0, const ::org::antlr::v4::runtime::atn::ATNConfigSet & a1, const ::org::antlr::v4::runtime::TokenStream & a2, jint a3, jint a4, jboolean a5) : ::org::antlr::v4::runtime::atn::DecisionEventInfo(env->newObject(initializeClass, &mids$, mid_init$_4923a124fb8045e3, a0, a1.this$, a2.this$, a3, a4, a5)) {}
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ErrorInfo_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ErrorInfo_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ErrorInfo_init_(t_ErrorInfo *self, PyObject *args, PyObject *kwds);

          static PyMethodDef t_ErrorInfo__methods_[] = {
            DECLARE_METHOD(t_ErrorInfo, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ErrorInfo, instance_, METH_O | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ErrorInfo)[] = {
            { Py_tp_methods, t_ErrorInfo__methods_ },
            { Py_tp_init, (void *) t_ErrorInfo_init_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ErrorInfo)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::DecisionEventInfo),
            NULL
          };

          DEFINE_TYPE(ErrorInfo, t_ErrorInfo, ErrorInfo);

          void t_ErrorInfo::install(PyObject *module)
          {
            installType(&PY_TYPE(ErrorInfo), &PY_TYPE_DEF(ErrorInfo), module, "ErrorInfo", 0);
          }

          void t_ErrorInfo::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ErrorInfo), "class_", make_descriptor(ErrorInfo::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ErrorInfo), "wrapfn_", make_descriptor(t_ErrorInfo::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ErrorInfo), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_ErrorInfo_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ErrorInfo::initializeClass, 1)))
              return NULL;
            return t_ErrorInfo::wrap_Object(ErrorInfo(((t_ErrorInfo *) arg)->object.this$));
          }
          static PyObject *t_ErrorInfo_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ErrorInfo::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ErrorInfo_init_(t_ErrorInfo *self, PyObject *args, PyObject *kwds)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::ATNConfigSet a1((jobject) NULL);
            ::org::antlr::v4::runtime::TokenStream a2((jobject) NULL);
            jint a3;
            jint a4;
            jboolean a5;
            ErrorInfo object((jobject) NULL);

            if (!parseArgs(args, "IkkIIZ", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, ::org::antlr::v4::runtime::TokenStream::initializeClass, &a0, &a1, &a2, &a3, &a4, &a5))
            {
              INT_CALL(object = ErrorInfo(a0, a1, a2, a3, a4, a5));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/PredicateEvalInfo.h"
#include "org/antlr/v4/runtime/atn/SemanticContext.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *PredicateEvalInfo::class$ = NULL;
          jmethodID *PredicateEvalInfo::mids$ = NULL;
          jfieldID *PredicateEvalInfo::fids$ = NULL;
          bool PredicateEvalInfo::live$ = false;

          jclass PredicateEvalInfo::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/PredicateEvalInfo");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_6769cac35bd030ad] = env->getMethodID(cls, "<init>", "(ILorg/antlr/v4/runtime/TokenStream;IILorg/antlr/v4/runtime/atn/SemanticContext;ZIZ)V");

              fids$ = new jfieldID[max_fid];
              fids$[fid_evalResult] = env->getFieldID(cls, "evalResult", "Z");
              fids$[fid_predictedAlt] = env->getFieldID(cls, "predictedAlt", "I");
              fids$[fid_semctx] = env->getFieldID(cls, "semctx", "Lorg/antlr/v4/runtime/atn/SemanticContext;");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          PredicateEvalInfo::PredicateEvalInfo(jint a0, const ::org::antlr::v4::runtime::TokenStream & a1, jint a2, jint a3, const ::org::antlr::v4::runtime::atn::SemanticContext & a4, jboolean a5, jint a6, jboolean a7) : ::org::antlr::v4::runtime::atn::DecisionEventInfo(env->newObject(initializeClass, &mids$, mid_init$_6769cac35bd030ad, a0, a1.this$, a2, a3, a4.this$, a5, a6, a7)) {}

          jboolean PredicateEvalInfo::_get_evalResult() const
          {
            return env->getBooleanField(this$, fids$[fid_evalResult]);
          }

          jint PredicateEvalInfo::_get_predictedAlt() const
          {
            return env->getIntField(this$, fids$[fid_predictedAlt]);
          }

          ::org::antlr::v4::runtime::atn::SemanticContext PredicateEvalInfo::_get_semctx() const
          {
            return ::org::antlr::v4::runtime::atn::SemanticContext(env->getObjectField(this$, fids$[fid_semctx]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_PredicateEvalInfo_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_PredicateEvalInfo_instance_(PyTypeObject *type, PyObject *arg);
          static int t_PredicateEvalInfo_init_(t_PredicateEvalInfo *self, PyObject *args, PyObject *kwds);
          static PyObject *t_PredicateEvalInfo_get__evalResult(t_PredicateEvalInfo *self, void *data);
          static PyObject *t_PredicateEvalInfo_get__predictedAlt(t_PredicateEvalInfo *self, void *data);
          static PyObject *t_PredicateEvalInfo_get__semctx(t_PredicateEvalInfo *self, void *data);

          static PyGetSetDef t_PredicateEvalInfo__fields_[] = {
            DECLARE_GET_FIELD(t_PredicateEvalInfo, evalResult),
            DECLARE_GET_FIELD(t_PredicateEvalInfo, predictedAlt),
            DECLARE_GET_FIELD(t_PredicateEvalInfo, semctx),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_PredicateEvalInfo__methods_[] = {
            DECLARE_METHOD(t_PredicateEvalInfo, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_PredicateEvalInfo, instance_, METH_O | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(PredicateEvalInfo)[] = {
            { Py_tp_methods, t_PredicateEvalInfo__methods_ },
            { Py_tp_init, (void *) t_PredicateEvalInfo_init_ },
            { Py_tp_getset, t_PredicateEvalInfo__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(PredicateEvalInfo)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::DecisionEventInfo),
            NULL
          };

          DEFINE_TYPE(PredicateEvalInfo, t_PredicateEvalInfo, PredicateEvalInfo);

          void t_PredicateEvalInfo::install(PyObject *module)
          {
            installType(&PY_TYPE(PredicateEvalInfo), &PY_TYPE_DEF(PredicateEvalInfo), module, "PredicateEvalInfo", 0);
          }

          void t_PredicateEvalInfo::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredicateEvalInfo), "class_", make_descriptor(PredicateEvalInfo::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredicateEvalInfo), "wrapfn_", make_descriptor(t_PredicateEvalInfo::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(PredicateEvalInfo), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_PredicateEvalInfo_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, PredicateEvalInfo::initializeClass, 1)))
              return NULL;
            return t_PredicateEvalInfo::wrap_Object(PredicateEvalInfo(((t_PredicateEvalInfo *) arg)->object.this$));
          }
          static PyObject *t_PredicateEvalInfo_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, PredicateEvalInfo::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_PredicateEvalInfo_init_(t_PredicateEvalInfo *self, PyObject *args, PyObject *kwds)
          {
            jint a0;
            ::org::antlr::v4::runtime::TokenStream a1((jobject) NULL);
            jint a2;
            jint a3;
            ::org::antlr::v4::runtime::atn::SemanticContext a4((jobject) NULL);
            jboolean a5;
            jint a6;
            jboolean a7;
            PredicateEvalInfo object((jobject) NULL);

            if (!parseArgs(args, "IkIIkZIZ", ::org::antlr::v4::runtime::TokenStream::initializeClass, ::org::antlr::v4::runtime::atn::SemanticContext::initializeClass, &a0, &a1, &a2, &a3, &a4, &a5, &a6, &a7))
            {
              INT_CALL(object = PredicateEvalInfo(a0, a1, a2, a3, a4, a5, a6, a7));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_PredicateEvalInfo_get__evalResult(t_PredicateEvalInfo *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object._get_evalResult());
            Py_RETURN_BOOL(value);
          }

          static PyObject *t_PredicateEvalInfo_get__predictedAlt(t_PredicateEvalInfo *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_predictedAlt());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_PredicateEvalInfo_get__semctx(t_PredicateEvalInfo *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::SemanticContext value((jobject) NULL);
            OBJ_CALL(value = self->object._get_semctx());
            return ::org::antlr::v4::runtime::atn::t_SemanticContext::wrap_Object(value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet$AbstractConfigHashSet.h"
#include "org/antlr/v4/runtime/atn/ATNConfig.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ATNConfigSet$AbstractConfigHashSet::class$ = NULL;
          jmethodID *ATNConfigSet$AbstractConfigHashSet::mids$ = NULL;
          bool ATNConfigSet$AbstractConfigHashSet::live$ = false;

          jclass ATNConfigSet$AbstractConfigHashSet::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ATNConfigSet$AbstractConfigHashSet");

              mids$ = new jmethodID[max_mid];
              mids$[mid_asElementType_4bdbef118d757cb2] = env->getMethodID(cls, "asElementType", "(Ljava/lang/Object;)Lorg/antlr/v4/runtime/atn/ATNConfig;");
              mids$[mid_createBucket_f15c60f066bd2efc] = env->getMethodID(cls, "createBucket", "(I)[Lorg/antlr/v4/runtime/atn/ATNConfig;");
              mids$[mid_createBuckets_c44ec40cdfdc0a78] = env->getMethodID(cls, "createBuckets", "(I)[[Lorg/antlr/v4/runtime/atn/ATNConfig;");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ATNConfigSet$AbstractConfigHashSet_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNConfigSet$AbstractConfigHashSet_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ATNConfigSet$AbstractConfigHashSet_of_(t_ATNConfigSet$AbstractConfigHashSet *self, PyObject *args);
          static PyObject *t_ATNConfigSet$AbstractConfigHashSet_get__parameters_(t_ATNConfigSet$AbstractConfigHashSet *self, void *data);
          static PyGetSetDef t_ATNConfigSet$AbstractConfigHashSet__fields_[] = {
            DECLARE_GET_FIELD(t_ATNConfigSet$AbstractConfigHashSet, parameters_),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_ATNConfigSet$AbstractConfigHashSet__methods_[] = {
            DECLARE_METHOD(t_ATNConfigSet$AbstractConfigHashSet, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNConfigSet$AbstractConfigHashSet, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ATNConfigSet$AbstractConfigHashSet, of_, METH_VARARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ATNConfigSet$AbstractConfigHashSet)[] = {
            { Py_tp_methods, t_ATNConfigSet$AbstractConfigHashSet__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_ATNConfigSet$AbstractConfigHashSet__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ATNConfigSet$AbstractConfigHashSet)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::misc::Array2DHashSet),
            NULL
          };

          DEFINE_TYPE(ATNConfigSet$AbstractConfigHashSet, t_ATNConfigSet$AbstractConfigHashSet, ATNConfigSet$AbstractConfigHashSet);
          PyObject *t_ATNConfigSet$AbstractConfigHashSet::wrap_Object(const ATNConfigSet$AbstractConfigHashSet& object, PyTypeObject *p0)
          {
            PyObject *obj = t_ATNConfigSet$AbstractConfigHashSet::wrap_Object(object);
            if (obj != NULL && obj != Py_None)
            {
              t_ATNConfigSet$AbstractConfigHashSet *self = (t_ATNConfigSet$AbstractConfigHashSet *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          PyObject *t_ATNConfigSet$AbstractConfigHashSet::wrap_jobject(const jobject& object, PyTypeObject *p0)
          {
            PyObject *obj = t_ATNConfigSet$AbstractConfigHashSet::wrap_jobject(object);
            if (obj != NULL && obj != Py_None)
            {
              t_ATNConfigSet$AbstractConfigHashSet *self = (t_ATNConfigSet$AbstractConfigHashSet *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          void t_ATNConfigSet$AbstractConfigHashSet::install(PyObject *module)
          {
            installType(&PY_TYPE(ATNConfigSet$AbstractConfigHashSet), &PY_TYPE_DEF(ATNConfigSet$AbstractConfigHashSet), module, "ATNConfigSet$AbstractConfigHashSet", 0);
          }

          void t_ATNConfigSet$AbstractConfigHashSet::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfigSet$AbstractConfigHashSet), "class_", make_descriptor(ATNConfigSet$AbstractConfigHashSet::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfigSet$AbstractConfigHashSet), "wrapfn_", make_descriptor(t_ATNConfigSet$AbstractConfigHashSet::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ATNConfigSet$AbstractConfigHashSet), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_ATNConfigSet$AbstractConfigHashSet_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ATNConfigSet$AbstractConfigHashSet::initializeClass, 1)))
              return NULL;
            return t_ATNConfigSet$AbstractConfigHashSet::wrap_Object(ATNConfigSet$AbstractConfigHashSet(((t_ATNConfigSet$AbstractConfigHashSet *) arg)->object.this$));
          }
          static PyObject *t_ATNConfigSet$AbstractConfigHashSet_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ATNConfigSet$AbstractConfigHashSet::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_ATNConfigSet$AbstractConfigHashSet_of_(t_ATNConfigSet$AbstractConfigHashSet *self, PyObject *args)
          {
            if (!parseArg(args, "T", 1, &(self->parameters)))
              Py_RETURN_SELF;
            return PyErr_SetArgsError((PyObject *) self, "of_", args);
          }
          static PyObject *t_ATNConfigSet$AbstractConfigHashSet_get__parameters_(t_ATNConfigSet$AbstractConfigHashSet *self, void *data)
          {
            return typeParameters(self->parameters, sizeof(self->parameters));
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/LexerActionType.h"
#include "org/antlr/v4/runtime/atn/LexerActionType.h"
#include "java/lang/String.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *LexerActionType::class$ = NULL;
          jmethodID *LexerActionType::mids$ = NULL;
          bool LexerActionType::live$ = false;
          LexerActionType *LexerActionType::CHANNEL = NULL;
          LexerActionType *LexerActionType::CUSTOM = NULL;
          LexerActionType *LexerActionType::MODE = NULL;
          LexerActionType *LexerActionType::MORE = NULL;
          LexerActionType *LexerActionType::POP_MODE = NULL;
          LexerActionType *LexerActionType::PUSH_MODE = NULL;
          LexerActionType *LexerActionType::SKIP = NULL;
          LexerActionType *LexerActionType::TYPE = NULL;

          jclass LexerActionType::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/LexerActionType");

              mids$ = new jmethodID[max_mid];
              mids$[mid_valueOf_ecc89bcae4a5a765] = env->getStaticMethodID(cls, "valueOf", "(Ljava/lang/String;)Lorg/antlr/v4/runtime/atn/LexerActionType;");
              mids$[mid_values_fa7009317d22ca34] = env->getStaticMethodID(cls, "values", "()[Lorg/antlr/v4/runtime/atn/LexerActionType;");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              CHANNEL = new LexerActionType(env->getStaticObjectField(cls, "CHANNEL", "Lorg/antlr/v4/runtime/atn/LexerActionType;"));
              CUSTOM = new LexerActionType(env->getStaticObjectField(cls, "CUSTOM", "Lorg/antlr/v4/runtime/atn/LexerActionType;"));
              MODE = new LexerActionType(env->getStaticObjectField(cls, "MODE", "Lorg/antlr/v4/runtime/atn/LexerActionType;"));
              MORE = new LexerActionType(env->getStaticObjectField(cls, "MORE", "Lorg/antlr/v4/runtime/atn/LexerActionType;"));
              POP_MODE = new LexerActionType(env->getStaticObjectField(cls, "POP_MODE", "Lorg/antlr/v4/runtime/atn/LexerActionType;"));
              PUSH_MODE = new LexerActionType(env->getStaticObjectField(cls, "PUSH_MODE", "Lorg/antlr/v4/runtime/atn/LexerActionType;"));
              SKIP = new LexerActionType(env->getStaticObjectField(cls, "SKIP", "Lorg/antlr/v4/runtime/atn/LexerActionType;"));
              TYPE = new LexerActionType(env->getStaticObjectField(cls, "TYPE", "Lorg/antlr/v4/runtime/atn/LexerActionType;"));
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          LexerActionType LexerActionType::valueOf(const ::java::lang::String & a0)
          {
            jclass cls = env->getClass(initializeClass);
            return LexerActionType(env->callStaticObjectMethod(cls, mids$[mid_valueOf_ecc89bcae4a5a765], a0.this$));
          }

          JArray< LexerActionType > LexerActionType::values()
          {
            jclass cls = env->getClass(initializeClass);
            return JArray< LexerActionType >(env->callStaticObjectMethod(cls, mids$[mid_values_fa7009317d22ca34]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_LexerActionType_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_LexerActionType_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_LexerActionType_of_(t_LexerActionType *self, PyObject *args);
          static PyObject *t_LexerActionType_valueOf(PyTypeObject *type, PyObject *args);
          static PyObject *t_LexerActionType_values(PyTypeObject *type);
          static PyObject *t_LexerActionType_get__parameters_(t_LexerActionType *self, void *data);
          static PyGetSetDef t_LexerActionType__fields_[] = {
            DECLARE_GET_FIELD(t_LexerActionType, parameters_),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_LexerActionType__methods_[] = {
            DECLARE_METHOD(t_LexerActionType, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_LexerActionType, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_LexerActionType, of_, METH_VARARGS),
            DECLARE_METHOD(t_LexerActionType, valueOf, METH_VARARGS | METH_CLASS),
            DECLARE_METHOD(t_LexerActionType, values, METH_NOARGS | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(LexerActionType)[] = {
            { Py_tp_methods, t_LexerActionType__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_LexerActionType__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(LexerActionType)[] = {
            &PY_TYPE_DEF(::java::lang::Enum),
            NULL
          };

          DEFINE_TYPE(LexerActionType, t_LexerActionType, LexerActionType);
          PyObject *t_LexerActionType::wrap_Object(const LexerActionType& object, PyTypeObject *p0)
          {
            PyObject *obj = t_LexerActionType::wrap_Object(object);
            if (obj != NULL && obj != Py_None)
            {
              t_LexerActionType *self = (t_LexerActionType *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          PyObject *t_LexerActionType::wrap_jobject(const jobject& object, PyTypeObject *p0)
          {
            PyObject *obj = t_LexerActionType::wrap_jobject(object);
            if (obj != NULL && obj != Py_None)
            {
              t_LexerActionType *self = (t_LexerActionType *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          void t_LexerActionType::install(PyObject *module)
          {
            installType(&PY_TYPE(LexerActionType), &PY_TYPE_DEF(LexerActionType), module, "LexerActionType", 0);
          }

          void t_LexerActionType::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "class_", make_descriptor(LexerActionType::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "wrapfn_", make_descriptor(t_LexerActionType::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "boxfn_", make_descriptor(boxObject));
            env->getClass(LexerActionType::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "CHANNEL", make_descriptor(t_LexerActionType::wrap_Object(*LexerActionType::CHANNEL)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "CUSTOM", make_descriptor(t_LexerActionType::wrap_Object(*LexerActionType::CUSTOM)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "MODE", make_descriptor(t_LexerActionType::wrap_Object(*LexerActionType::MODE)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "MORE", make_descriptor(t_LexerActionType::wrap_Object(*LexerActionType::MORE)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "POP_MODE", make_descriptor(t_LexerActionType::wrap_Object(*LexerActionType::POP_MODE)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "PUSH_MODE", make_descriptor(t_LexerActionType::wrap_Object(*LexerActionType::PUSH_MODE)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "SKIP", make_descriptor(t_LexerActionType::wrap_Object(*LexerActionType::SKIP)));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerActionType), "TYPE", make_descriptor(t_LexerActionType::wrap_Object(*LexerActionType::TYPE)));
          }

          static PyObject *t_LexerActionType_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, LexerActionType::initializeClass, 1)))
              return NULL;
            return t_LexerActionType::wrap_Object(LexerActionType(((t_LexerActionType *) arg)->object.this$));
          }
          static PyObject *t_LexerActionType_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, LexerActionType::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_LexerActionType_of_(t_LexerActionType *self, PyObject *args)
          {
            if (!parseArg(args, "T", 1, &(self->parameters)))
              Py_RETURN_SELF;
            return PyErr_SetArgsError((PyObject *) self, "of_", args);
          }

          static PyObject *t_LexerActionType_valueOf(PyTypeObject *type, PyObject *args)
          {
            ::java::lang::String a0((jobject) NULL);
            LexerActionType result((jobject) NULL);

            if (!parseArgs(args, "s", &a0))
            {
              OBJ_CALL(result = ::org::antlr::v4::runtime::atn::LexerActionType::valueOf(a0));
              return t_LexerActionType::wrap_Object(result);
            }

            return callSuper(type, "valueOf", args, 2);
          }

          static PyObject *t_LexerActionType_values(PyTypeObject *type)
          {
            JArray< LexerActionType > result((jobject) NULL);
            OBJ_CALL(result = ::org::antlr::v4::runtime::atn::LexerActionType::values());
            return JArray<jobject>(result.this$).wrap(t_LexerActionType::wrap_jobject);
          }
          static PyObject *t_LexerActionType_get__parameters_(t_LexerActionType *self, void *data)
          {
            return typeParameters(self->parameters, sizeof(self->parameters));
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/Lexer.h"
#include "org/antlr/v4/runtime/TokenSource.h"
#include "org/antlr/v4/runtime/IntStream.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/RecognitionException.h"
#include "java/lang/Object.h"
#include "org/antlr/v4/runtime/TokenFactory.h"
#include "org/antlr/v4/runtime/LexerNoViableAltException.h"
#include "java/lang/Integer.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/LexerATNSimulator.h"
#include "java/util/List.h"
#include "org/antlr/v4/runtime/Token.h"
#include "org/antlr/v4/runtime/CharStream.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *Lexer::class$ = NULL;
        jmethodID *Lexer::mids$ = NULL;
        jfieldID *Lexer::fids$ = NULL;
        bool Lexer::live$ = false;
        jint Lexer::DEFAULT_MODE = (jint) 0;
        jint Lexer::DEFAULT_TOKEN_CHANNEL = (jint) 0;
        jint Lexer::HIDDEN = (jint) 0;
        jint Lexer::MAX_CHAR_VALUE = (jint) 0;
        jint Lexer::MIN_CHAR_VALUE = (jint) 0;
        jint Lexer::MORE = (jint) 0;
        jint Lexer::SKIP = (jint) 0;

        jclass Lexer::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/Lexer");

            mids$ = new jmethodID[max_mid];
            mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
            mids$[mid_init$_2707b4f45eb93125] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/CharStream;)V");
            mids$[mid_emit_ed548981de5895c4] = env->getMethodID(cls, "emit", "()Lorg/antlr/v4/runtime/Token;");
            mids$[mid_emit_9d1d45425dbf6563] = env->getMethodID(cls, "emit", "(Lorg/antlr/v4/runtime/Token;)V");
            mids$[mid_emitEOF_ed548981de5895c4] = env->getMethodID(cls, "emitEOF", "()Lorg/antlr/v4/runtime/Token;");
            mids$[mid_getAllTokens_49ec78390f08338a] = env->getMethodID(cls, "getAllTokens", "()Ljava/util/List;");
            mids$[mid_getChannel_9972fcc56b44e79d] = env->getMethodID(cls, "getChannel", "()I");
            mids$[mid_getCharErrorDisplay_d7593acad64ef635] = env->getMethodID(cls, "getCharErrorDisplay", "(I)Ljava/lang/String;");
            mids$[mid_getCharIndex_9972fcc56b44e79d] = env->getMethodID(cls, "getCharIndex", "()I");
            mids$[mid_getCharPositionInLine_9972fcc56b44e79d] = env->getMethodID(cls, "getCharPositionInLine", "()I");
            mids$[mid_getErrorDisplay_9bfa75c9f141b67f] = env->getMethodID(cls, "getErrorDisplay", "(Ljava/lang/String;)Ljava/lang/String;");
            mids$[mid_getErrorDisplay_d7593acad64ef635] = env->getMethodID(cls, "getErrorDisplay", "(I)Ljava/lang/String;");
            mids$[mid_getInputStream_f3effd93aa48b2fd] = env->getMethodID(cls, "getInputStream", "()Lorg/antlr/v4/runtime/CharStream;");
            mids$[mid_getLine_9972fcc56b44e79d] = env->getMethodID(cls, "getLine", "()I");
            mids$[mid_getModeNames_9865da0b5ee490bc] = env->getMethodID(cls, "getModeNames", "()[Ljava/lang/String;");
            mids$[mid_getSourceName_db9b55ba01e03e4b] = env->getMethodID(cls, "getSourceName", "()Ljava/lang/String;");
            mids$[mid_getText_db9b55ba01e03e4b] = env->getMethodID(cls, "getText", "()Ljava/lang/String;");
            mids$[mid_getToken_ed548981de5895c4] = env->getMethodID(cls, "getToken", "()Lorg/antlr/v4/runtime/Token;");
            mids$[mid_getTokenFactory_9bf94c5de004cd3c] = env->getMethodID(cls, "getTokenFactory", "()Lorg/antlr/v4/runtime/TokenFactory;");
            mids$[mid_getTokenNames_9865da0b5ee490bc] = env->getMethodID(cls, "getTokenNames", "()[Ljava/lang/String;");
            mids$[mid_getType_9972fcc56b44e79d] = env->getMethodID(cls, "getType", "()I");
            mids$[mid_mode_040c4cd0390c5aff] = env->getMethodID(cls, "mode", "(I)V");
            mids$[mid_more_f2cc1bce94666404] = env->getMethodID(cls, "more", "()V");
            mids$[mid_nextToken_ed548981de5895c4] = env->getMethodID(cls, "nextToken", "()Lorg/antlr/v4/runtime/Token;");
            mids$[mid_notifyListeners_a901e1d87728c926] = env->getMethodID(cls, "notifyListeners", "(Lorg/antlr/v4/runtime/LexerNoViableAltException;)V");
            mids$[mid_popMode_9972fcc56b44e79d] = env->getMethodID(cls, "popMode", "()I");
            mids$[mid_pushMode_040c4cd0390c5aff] = env->getMethodID(cls, "pushMode", "(I)V");
            mids$[mid_recover_a901e1d87728c926] = env->getMethodID(cls, "recover", "(Lorg/antlr/v4/runtime/LexerNoViableAltException;)V");
            mids$[mid_recover_f905eba101774394] = env->getMethodID(cls, "recover", "(Lorg/antlr/v4/runtime/RecognitionException;)V");
            mids$[mid_reset_f2cc1bce94666404] = env->getMethodID(cls, "reset", "()V");
            mids$[mid_setChannel_040c4cd0390c5aff] = env->getMethodID(cls, "setChannel", "(I)V");
            mids$[mid_setCharPositionInLine_040c4cd0390c5aff] = env->getMethodID(cls, "setCharPositionInLine", "(I)V");
            mids$[mid_setInputStream_316a0f0e15ab92d4] = env->getMethodID(cls, "setInputStream", "(Lorg/antlr/v4/runtime/IntStream;)V");
            mids$[mid_setLine_040c4cd0390c5aff] = env->getMethodID(cls, "setLine", "(I)V");
            mids$[mid_setText_9fd2eb66a64e6f0f] = env->getMethodID(cls, "setText", "(Ljava/lang/String;)V");
            mids$[mid_setToken_9d1d45425dbf6563] = env->getMethodID(cls, "setToken", "(Lorg/antlr/v4/runtime/Token;)V");
            mids$[mid_setTokenFactory_a25e147938e67e01] = env->getMethodID(cls, "setTokenFactory", "(Lorg/antlr/v4/runtime/TokenFactory;)V");
            mids$[mid_setType_040c4cd0390c5aff] = env->getMethodID(cls, "setType", "(I)V");
            mids$[mid_skip_f2cc1bce94666404] = env->getMethodID(cls, "skip", "()V");

            fids$ = new jfieldID[max_fid];
            fids$[fid__channel] = env->getFieldID(cls, "_channel", "I");
            fids$[fid__hitEOF] = env->getFieldID(cls, "_hitEOF", "Z");
            fids$[fid__input] = env->getFieldID(cls, "_input", "Lorg/antlr/v4/runtime/CharStream;");
            fids$[fid__mode] = env->getFieldID(cls, "_mode", "I");
            fids$[fid__text] = env->getFieldID(cls, "_text", "Ljava/lang/String;");
            fids$[fid__token] = env->getFieldID(cls, "_token", "Lorg/antlr/v4/runtime/Token;");
            fids$[fid__tokenStartCharIndex] = env->getFieldID(cls, "_tokenStartCharIndex", "I");
            fids$[fid__tokenStartCharPositionInLine] = env->getFieldID(cls, "_tokenStartCharPositionInLine", "I");
            fids$[fid__tokenStartLine] = env->getFieldID(cls, "_tokenStartLine", "I");
            fids$[fid__type] = env->getFieldID(cls, "_type", "I");

            class$ = new ::java::lang::Class(cls);
            cls = (jclass) class$->this$;

            DEFAULT_MODE = env->getStaticIntField(cls, "DEFAULT_MODE");
            DEFAULT_TOKEN_CHANNEL = env->getStaticIntField(cls, "DEFAULT_TOKEN_CHANNEL");
            HIDDEN = env->getStaticIntField(cls, "HIDDEN");
            MAX_CHAR_VALUE = env->getStaticIntField(cls, "MAX_CHAR_VALUE");
            MIN_CHAR_VALUE = env->getStaticIntField(cls, "MIN_CHAR_VALUE");
            MORE = env->getStaticIntField(cls, "MORE");
            SKIP = env->getStaticIntField(cls, "SKIP");
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        Lexer::Lexer() : ::org::antlr::v4::runtime::Recognizer(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

        Lexer::Lexer(const ::org::antlr::v4::runtime::CharStream & a0) : ::org::antlr::v4::runtime::Recognizer(env->newObject(initializeClass, &mids$, mid_init$_2707b4f45eb93125, a0.this$)) {}

        ::org::antlr::v4::runtime::Token Lexer::emit() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_emit_ed548981de5895c4]));
        }

        void Lexer::emit(const ::org::antlr::v4::runtime::Token & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_emit_9d1d45425dbf6563], a0.this$);
        }

        ::org::antlr::v4::runtime::Token Lexer::emitEOF() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_emitEOF_ed548981de5895c4]));
        }

        ::java::util::List Lexer::getAllTokens() const
        {
          return ::java::util::List(env->callObjectMethod(this$, mids$[mid_getAllTokens_49ec78390f08338a]));
        }

        jint Lexer::getChannel() const
        {
          return env->callIntMethod(this$, mids$[mid_getChannel_9972fcc56b44e79d]);
        }

        ::java::lang::String Lexer::getCharErrorDisplay(jint a0) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getCharErrorDisplay_d7593acad64ef635], a0));
        }

        jint Lexer::getCharIndex() const
        {
          return env->callIntMethod(this$, mids$[mid_getCharIndex_9972fcc56b44e79d]);
        }

        jint Lexer::getCharPositionInLine() const
        {
          return env->callIntMethod(this$, mids$[mid_getCharPositionInLine_9972fcc56b44e79d]);
        }

        ::java::lang::String Lexer::getErrorDisplay(const ::java::lang::String & a0) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getErrorDisplay_9bfa75c9f141b67f], a0.this$));
        }

        ::java::lang::String Lexer::getErrorDisplay(jint a0) const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getErrorDisplay_d7593acad64ef635], a0));
        }

        ::org::antlr::v4::runtime::CharStream Lexer::getInputStream() const
        {
          return ::org::antlr::v4::runtime::CharStream(env->callObjectMethod(this$, mids$[mid_getInputStream_f3effd93aa48b2fd]));
        }

        jint Lexer::getLine() const
        {
          return env->callIntMethod(this$, mids$[mid_getLine_9972fcc56b44e79d]);
        }

        JArray< ::java::lang::String > Lexer::getModeNames() const
        {
          return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_getModeNames_9865da0b5ee490bc]));
        }

        ::java::lang::String Lexer::getSourceName() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getSourceName_db9b55ba01e03e4b]));
        }

        ::java::lang::String Lexer::getText() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getText_db9b55ba01e03e4b]));
        }

        ::org::antlr::v4::runtime::Token Lexer::getToken() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_getToken_ed548981de5895c4]));
        }

        ::org::antlr::v4::runtime::TokenFactory Lexer::getTokenFactory() const
        {
          return ::org::antlr::v4::runtime::TokenFactory(env->callObjectMethod(this$, mids$[mid_getTokenFactory_9bf94c5de004cd3c]));
        }

        JArray< ::java::lang::String > Lexer::getTokenNames() const
        {
          return JArray< ::java::lang::String >(env->callObjectMethod(this$, mids$[mid_getTokenNames_9865da0b5ee490bc]));
        }

        jint Lexer::getType() const
        {
          return env->callIntMethod(this$, mids$[mid_getType_9972fcc56b44e79d]);
        }

        void Lexer::mode(jint a0) const
        {
          env->callVoidMethod(this$, mids$[mid_mode_040c4cd0390c5aff], a0);
        }

        void Lexer::more() const
        {
          env->callVoidMethod(this$, mids$[mid_more_f2cc1bce94666404]);
        }

        ::org::antlr::v4::runtime::Token Lexer::nextToken() const
        {
          return ::org::antlr::v4::runtime::Token(env->callObjectMethod(this$, mids$[mid_nextToken_ed548981de5895c4]));
        }

        void Lexer::notifyListeners(const ::org::antlr::v4::runtime::LexerNoViableAltException & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_notifyListeners_a901e1d87728c926], a0.this$);
        }

        jint Lexer::popMode() const
        {
          return env->callIntMethod(this$, mids$[mid_popMode_9972fcc56b44e79d]);
        }

        void Lexer::pushMode(jint a0) const
        {
          env->callVoidMethod(this$, mids$[mid_pushMode_040c4cd0390c5aff], a0);
        }

        void Lexer::recover(const ::org::antlr::v4::runtime::LexerNoViableAltException & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_recover_a901e1d87728c926], a0.this$);
        }

        void Lexer::recover(const ::org::antlr::v4::runtime::RecognitionException & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_recover_f905eba101774394], a0.this$);
        }

        void Lexer::reset() const
        {
          env->callVoidMethod(this$, mids$[mid_reset_f2cc1bce94666404]);
        }

        void Lexer::setChannel(jint a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setChannel_040c4cd0390c5aff], a0);
        }

        void Lexer::setCharPositionInLine(jint a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setCharPositionInLine_040c4cd0390c5aff], a0);
        }

        void Lexer::setInputStream(const ::org::antlr::v4::runtime::IntStream & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setInputStream_316a0f0e15ab92d4], a0.this$);
        }

        void Lexer::setLine(jint a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setLine_040c4cd0390c5aff], a0);
        }

        void Lexer::setText(const ::java::lang::String & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setText_9fd2eb66a64e6f0f], a0.this$);
        }

        void Lexer::setToken(const ::org::antlr::v4::runtime::Token & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setToken_9d1d45425dbf6563], a0.this$);
        }

        void Lexer::setTokenFactory(const ::org::antlr::v4::runtime::TokenFactory & a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setTokenFactory_a25e147938e67e01], a0.this$);
        }

        void Lexer::setType(jint a0) const
        {
          env->callVoidMethod(this$, mids$[mid_setType_040c4cd0390c5aff], a0);
        }

        void Lexer::skip() const
        {
          env->callVoidMethod(this$, mids$[mid_skip_f2cc1bce94666404]);
        }

        jint Lexer::_get__channel() const
        {
          return env->getIntField(this$, fids$[fid__channel]);
        }

        void Lexer::_set__channel(jint a0) const
        {
          env->setIntField(this$, fids$[fid__channel], a0);
        }

        jboolean Lexer::_get__hitEOF() const
        {
          return env->getBooleanField(this$, fids$[fid__hitEOF]);
        }

        void Lexer::_set__hitEOF(jboolean a0) const
        {
          env->setBooleanField(this$, fids$[fid__hitEOF], a0);
        }

        ::org::antlr::v4::runtime::CharStream Lexer::_get__input() const
        {
          return ::org::antlr::v4::runtime::CharStream(env->getObjectField(this$, fids$[fid__input]));
        }

        void Lexer::_set__input(const ::org::antlr::v4::runtime::CharStream & a0) const
        {
          env->setObjectField(this$, fids$[fid__input], a0.this$);
        }

        jint Lexer::_get__mode() const
        {
          return env->getIntField(this$, fids$[fid__mode]);
        }

        void Lexer::_set__mode(jint a0) const
        {
          env->setIntField(this$, fids$[fid__mode], a0);
        }

        ::java::lang::String Lexer::_get__text() const
        {
          return ::java::lang::String(env->getObjectField(this$, fids$[fid__text]));
        }

        void Lexer::_set__text(const ::java::lang::String & a0) const
        {
          env->setObjectField(this$, fids$[fid__text], a0.this$);
        }

        ::org::antlr::v4::runtime::Token Lexer::_get__token() const
        {
          return ::org::antlr::v4::runtime::Token(env->getObjectField(this$, fids$[fid__token]));
        }

        void Lexer::_set__token(const ::org::antlr::v4::runtime::Token & a0) const
        {
          env->setObjectField(this$, fids$[fid__token], a0.this$);
        }

        jint Lexer::_get__tokenStartCharIndex() const
        {
          return env->getIntField(this$, fids$[fid__tokenStartCharIndex]);
        }

        void Lexer::_set__tokenStartCharIndex(jint a0) const
        {
          env->setIntField(this$, fids$[fid__tokenStartCharIndex], a0);
        }

        jint Lexer::_get__tokenStartCharPositionInLine() const
        {
          return env->getIntField(this$, fids$[fid__tokenStartCharPositionInLine]);
        }

        void Lexer::_set__tokenStartCharPositionInLine(jint a0) const
        {
          env->setIntField(this$, fids$[fid__tokenStartCharPositionInLine], a0);
        }

        jint Lexer::_get__tokenStartLine() const
        {
          return env->getIntField(this$, fids$[fid__tokenStartLine]);
        }

        void Lexer::_set__tokenStartLine(jint a0) const
        {
          env->setIntField(this$, fids$[fid__tokenStartLine], a0);
        }

        jint Lexer::_get__type() const
        {
          return env->getIntField(this$, fids$[fid__type]);
        }

        void Lexer::_set__type(jint a0) const
        {
          env->setIntField(this$, fids$[fid__type], a0);
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_Lexer_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Lexer_instance_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_Lexer_of_(t_Lexer *self, PyObject *args);
        static int t_Lexer_init_(t_Lexer *self, PyObject *args, PyObject *kwds);
        static PyObject *t_Lexer_emit(t_Lexer *self, PyObject *args);
        static PyObject *t_Lexer_emitEOF(t_Lexer *self);
        static PyObject *t_Lexer_getAllTokens(t_Lexer *self);
        static PyObject *t_Lexer_getChannel(t_Lexer *self);
        static PyObject *t_Lexer_getCharErrorDisplay(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_getCharIndex(t_Lexer *self);
        static PyObject *t_Lexer_getCharPositionInLine(t_Lexer *self);
        static PyObject *t_Lexer_getErrorDisplay(t_Lexer *self, PyObject *args);
        static PyObject *t_Lexer_getInputStream(t_Lexer *self, PyObject *args);
        static PyObject *t_Lexer_getLine(t_Lexer *self);
        static PyObject *t_Lexer_getModeNames(t_Lexer *self);
        static PyObject *t_Lexer_getSourceName(t_Lexer *self);
        static PyObject *t_Lexer_getText(t_Lexer *self);
        static PyObject *t_Lexer_getToken(t_Lexer *self);
        static PyObject *t_Lexer_getTokenFactory(t_Lexer *self, PyObject *args);
        static PyObject *t_Lexer_getTokenNames(t_Lexer *self, PyObject *args);
        static PyObject *t_Lexer_getType(t_Lexer *self);
        static PyObject *t_Lexer_mode(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_more(t_Lexer *self);
        static PyObject *t_Lexer_nextToken(t_Lexer *self);
        static PyObject *t_Lexer_notifyListeners(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_popMode(t_Lexer *self);
        static PyObject *t_Lexer_pushMode(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_recover(t_Lexer *self, PyObject *args);
        static PyObject *t_Lexer_reset(t_Lexer *self);
        static PyObject *t_Lexer_setChannel(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_setCharPositionInLine(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_setInputStream(t_Lexer *self, PyObject *args);
        static PyObject *t_Lexer_setLine(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_setText(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_setToken(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_setTokenFactory(t_Lexer *self, PyObject *args);
        static PyObject *t_Lexer_setType(t_Lexer *self, PyObject *arg);
        static PyObject *t_Lexer_skip(t_Lexer *self);
        static PyObject *t_Lexer_get___channel(t_Lexer *self, void *data);
        static int t_Lexer_set___channel(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get___hitEOF(t_Lexer *self, void *data);
        static int t_Lexer_set___hitEOF(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get___input(t_Lexer *self, void *data);
        static int t_Lexer_set___input(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get___mode(t_Lexer *self, void *data);
        static int t_Lexer_set___mode(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get___text(t_Lexer *self, void *data);
        static int t_Lexer_set___text(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get___token(t_Lexer *self, void *data);
        static int t_Lexer_set___token(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get___tokenStartCharIndex(t_Lexer *self, void *data);
        static int t_Lexer_set___tokenStartCharIndex(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get___tokenStartCharPositionInLine(t_Lexer *self, void *data);
        static int t_Lexer_set___tokenStartCharPositionInLine(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get___tokenStartLine(t_Lexer *self, void *data);
        static int t_Lexer_set___tokenStartLine(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get___type(t_Lexer *self, void *data);
        static int t_Lexer_set___type(t_Lexer *self, PyObject *arg, void *data);

        static PyObject *t_Lexer_get__allTokens(t_Lexer *self, void *data);
        static PyObject *t_Lexer_get__channel(t_Lexer *self, void *data);
        static int t_Lexer_set__channel(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get__charIndex(t_Lexer *self, void *data);
        static PyObject *t_Lexer_get__charPositionInLine(t_Lexer *self, void *data);
        static int t_Lexer_set__charPositionInLine(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get__inputStream(t_Lexer *self, void *data);
        static int t_Lexer_set__inputStream(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get__line(t_Lexer *self, void *data);
        static int t_Lexer_set__line(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get__modeNames(t_Lexer *self, void *data);
        static PyObject *t_Lexer_get__sourceName(t_Lexer *self, void *data);
        static PyObject *t_Lexer_get__text(t_Lexer *self, void *data);
        static int t_Lexer_set__text(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get__token(t_Lexer *self, void *data);
        static int t_Lexer_set__token(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get__tokenFactory(t_Lexer *self, void *data);
        static int t_Lexer_set__tokenFactory(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get__tokenNames(t_Lexer *self, void *data);
        static PyObject *t_Lexer_get__type(t_Lexer *self, void *data);
        static int t_Lexer_set__type(t_Lexer *self, PyObject *arg, void *data);
        static PyObject *t_Lexer_get__parameters_(t_Lexer *self, void *data);
        static PyGetSetDef t_Lexer__fields_[] = {
          DECLARE_GETSET_FIELD(t_Lexer, _channel),
          DECLARE_GETSET_FIELD(t_Lexer, _hitEOF),
          DECLARE_GETSET_FIELD(t_Lexer, _input),
          DECLARE_GETSET_FIELD(t_Lexer, _mode),
          DECLARE_GETSET_FIELD(t_Lexer, _text),
          DECLARE_GETSET_FIELD(t_Lexer, _token),
          DECLARE_GETSET_FIELD(t_Lexer, _tokenStartCharIndex),
          DECLARE_GETSET_FIELD(t_Lexer, _tokenStartCharPositionInLine),
          DECLARE_GETSET_FIELD(t_Lexer, _tokenStartLine),
          DECLARE_GETSET_FIELD(t_Lexer, _type),
          DECLARE_GET_FIELD(t_Lexer, allTokens),
          DECLARE_GETSET_FIELD(t_Lexer, channel),
          DECLARE_GET_FIELD(t_Lexer, charIndex),
          DECLARE_GETSET_FIELD(t_Lexer, charPositionInLine),
          DECLARE_GETSET_FIELD(t_Lexer, inputStream),
          DECLARE_GETSET_FIELD(t_Lexer, line),
          DECLARE_GET_FIELD(t_Lexer, modeNames),
          DECLARE_GET_FIELD(t_Lexer, sourceName),
          DECLARE_GETSET_FIELD(t_Lexer, text),
          DECLARE_GETSET_FIELD(t_Lexer, token),
          DECLARE_GETSET_FIELD(t_Lexer, tokenFactory),
          DECLARE_GET_FIELD(t_Lexer, tokenNames),
          DECLARE_GETSET_FIELD(t_Lexer, type),
          DECLARE_GET_FIELD(t_Lexer, parameters_),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_Lexer__methods_[] = {
          DECLARE_METHOD(t_Lexer, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Lexer, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_Lexer, of_, METH_VARARGS),
          DECLARE_METHOD(t_Lexer, emit, METH_VARARGS),
          DECLARE_METHOD(t_Lexer, emitEOF, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getAllTokens, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getChannel, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getCharErrorDisplay, METH_O),
          DECLARE_METHOD(t_Lexer, getCharIndex, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getCharPositionInLine, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getErrorDisplay, METH_VARARGS),
          DECLARE_METHOD(t_Lexer, getInputStream, METH_VARARGS),
          DECLARE_METHOD(t_Lexer, getLine, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getModeNames, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getSourceName, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getText, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getToken, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, getTokenFactory, METH_VARARGS),
          DECLARE_METHOD(t_Lexer, getTokenNames, METH_VARARGS),
          DECLARE_METHOD(t_Lexer, getType, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, mode, METH_O),
          DECLARE_METHOD(t_Lexer, more, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, nextToken, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, notifyListeners, METH_O),
          DECLARE_METHOD(t_Lexer, popMode, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, pushMode, METH_O),
          DECLARE_METHOD(t_Lexer, recover, METH_VARARGS),
          DECLARE_METHOD(t_Lexer, reset, METH_NOARGS),
          DECLARE_METHOD(t_Lexer, setChannel, METH_O),
          DECLARE_METHOD(t_Lexer, setCharPositionInLine, METH_O),
          DECLARE_METHOD(t_Lexer, setInputStream, METH_VARARGS),
          DECLARE_METHOD(t_Lexer, setLine, METH_O),
          DECLARE_METHOD(t_Lexer, setText, METH_O),
          DECLARE_METHOD(t_Lexer, setToken, METH_O),
          DECLARE_METHOD(t_Lexer, setTokenFactory, METH_VARARGS),
          DECLARE_METHOD(t_Lexer, setType, METH_O),
          DECLARE_METHOD(t_Lexer, skip, METH_NOARGS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(Lexer)[] = {
          { Py_tp_methods, t_Lexer__methods_ },
          { Py_tp_init, (void *) t_Lexer_init_ },
          { Py_tp_getset, t_Lexer__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(Lexer)[] = {
          &PY_TYPE_DEF(::org::antlr::v4::runtime::Recognizer),
          NULL
        };

        DEFINE_TYPE(Lexer, t_Lexer, Lexer);
        PyObject *t_Lexer::wrap_Object(const Lexer& object, PyTypeObject *p0, PyTypeObject *p1)
        {
          PyObject *obj = t_Lexer::wrap_Object(object);
          if (obj != NULL && obj != Py_None)
          {
            t_Lexer *self = (t_Lexer *) obj;
            self->parameters[0] = p0;
            self->parameters[1] = p1;
          }
          return obj;
        }

        PyObject *t_Lexer::wrap_jobject(const jobject& object, PyTypeObject *p0, PyTypeObject *p1)
        {
          PyObject *obj = t_Lexer::wrap_jobject(object);
          if (obj != NULL && obj != Py_None)
          {
            t_Lexer *self = (t_Lexer *) obj;
            self->parameters[0] = p0;
            self->parameters[1] = p1;
          }
          return obj;
        }

        void t_Lexer::install(PyObject *module)
        {
          installType(&PY_TYPE(Lexer), &PY_TYPE_DEF(Lexer), module, "Lexer", 0);
        }

        void t_Lexer::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "class_", make_descriptor(Lexer::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "wrapfn_", make_descriptor(t_Lexer::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "boxfn_", make_descriptor(boxObject));
          env->getClass(Lexer::initializeClass);
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "DEFAULT_MODE", make_descriptor(Lexer::DEFAULT_MODE));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "DEFAULT_TOKEN_CHANNEL", make_descriptor(Lexer::DEFAULT_TOKEN_CHANNEL));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "HIDDEN", make_descriptor(Lexer::HIDDEN));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "MAX_CHAR_VALUE", make_descriptor(Lexer::MAX_CHAR_VALUE));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "MIN_CHAR_VALUE", make_descriptor(Lexer::MIN_CHAR_VALUE));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "MORE", make_descriptor(Lexer::MORE));
          PyObject_SetAttrString((PyObject *) PY_TYPE(Lexer), "SKIP", make_descriptor(Lexer::SKIP));
        }

        static PyObject *t_Lexer_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, Lexer::initializeClass, 1)))
            return NULL;
          return t_Lexer::wrap_Object(Lexer(((t_Lexer *) arg)->object.this$));
        }
        static PyObject *t_Lexer_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, Lexer::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static PyObject *t_Lexer_of_(t_Lexer *self, PyObject *args)
        {
          if (!parseArg(args, "T", 2, &(self->parameters)))
            Py_RETURN_SELF;
          return PyErr_SetArgsError((PyObject *) self, "of_", args);
        }

        static int t_Lexer_init_(t_Lexer *self, PyObject *args, PyObject *kwds)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 0:
            {
              Lexer object((jobject) NULL);

              INT_CALL(object = Lexer());
              self->object = object;
              self->parameters[0] = ::java::lang::PY_TYPE(Integer);
              self->parameters[1] = ::org::antlr::v4::runtime::atn::PY_TYPE(LexerATNSimulator);
              break;
            }
           case 1:
            {
              ::org::antlr::v4::runtime::CharStream a0((jobject) NULL);
              Lexer object((jobject) NULL);

              if (!parseArgs(args, "k", ::org::antlr::v4::runtime::CharStream::initializeClass, &a0))
              {
                INT_CALL(object = Lexer(a0));
                self->object = object;
                self->parameters[0] = ::java::lang::PY_TYPE(Integer);
                self->parameters[1] = ::org::antlr::v4::runtime::atn::PY_TYPE(LexerATNSimulator);
                break;
              }
            }
           default:
            PyErr_SetArgsError((PyObject *) self, "__init__", args);
            return -1;
          }

          return 0;
        }

        static PyObject *t_Lexer_emit(t_Lexer *self, PyObject *args)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 0:
            {
              ::org::antlr::v4::runtime::Token result((jobject) NULL);
              OBJ_CALL(result = self->object.emit());
              return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
            }
            break;
           case 1:
            {
              ::org::antlr::v4::runtime::Token a0((jobject) NULL);

              if (!parseArgs(args, "k", ::org::antlr::v4::runtime::Token::initializeClass, &a0))
              {
                OBJ_CALL(self->object.emit(a0));
                Py_RETURN_NONE;
              }
            }
          }

          PyErr_SetArgsError((PyObject *) self, "emit", args);
          return NULL;
        }

        static PyObject *t_Lexer_emitEOF(t_Lexer *self)
        {
          ::org::antlr::v4::runtime::Token result((jobject) NULL);
          OBJ_CALL(result = self->object.emitEOF());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
        }

        static PyObject *t_Lexer_getAllTokens(t_Lexer *self)
        {
          ::java::util::List result((jobject) NULL);
          OBJ_CALL(result = self->object.getAllTokens());
          return ::java::util::t_List::wrap_Object(result);
        }

        static PyObject *t_Lexer_getChannel(t_Lexer *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getChannel());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Lexer_getCharErrorDisplay(t_Lexer *self, PyObject *arg)
        {
          jint a0;
          ::java::lang::String result((jobject) NULL);

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(result = self->object.getCharErrorDisplay(a0));
            return j2p(result);
          }

          PyErr_SetArgsError((PyObject *) self, "getCharErrorDisplay", arg);
          return NULL;
        }

        static PyObject *t_Lexer_getCharIndex(t_Lexer *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getCharIndex());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Lexer_getCharPositionInLine(t_Lexer *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getCharPositionInLine());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Lexer_getErrorDisplay(t_Lexer *self, PyObject *args)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 1:
            {
              ::java::lang::String a0((jobject) NULL);
              ::java::lang::String result((jobject) NULL);

              if (!parseArgs(args, "s", &a0))
              {
                OBJ_CALL(result = self->object.getErrorDisplay(a0));
                return j2p(result);
              }
            }
            {
              jint a0;
              ::java::lang::String result((jobject) NULL);

              if (!parseArgs(args, "I", &a0))
              {
                OBJ_CALL(result = self->object.getErrorDisplay(a0));
                return j2p(result);
              }
            }
          }

          PyErr_SetArgsError((PyObject *) self, "getErrorDisplay", args);
          return NULL;
        }

        static PyObject *t_Lexer_getInputStream(t_Lexer *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::CharStream result((jobject) NULL);

          if (!parseArgs(args, ""))
          {
            OBJ_CALL(result = self->object.getInputStream());
            return ::org::antlr::v4::runtime::t_CharStream::wrap_Object(result);
          }

          return callSuper(PY_TYPE(Lexer), (PyObject *) self, "getInputStream", args, 2);
        }

        static PyObject *t_Lexer_getLine(t_Lexer *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getLine());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Lexer_getModeNames(t_Lexer *self)
        {
          JArray< ::java::lang::String > result((jobject) NULL);
          OBJ_CALL(result = self->object.getModeNames());
          return JArray<jstring>(result.this$).wrap();
        }

        static PyObject *t_Lexer_getSourceName(t_Lexer *self)
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getSourceName());
          return j2p(result);
        }

        static PyObject *t_Lexer_getText(t_Lexer *self)
        {
          ::java::lang::String result((jobject) NULL);
          OBJ_CALL(result = self->object.getText());
          return j2p(result);
        }

        static PyObject *t_Lexer_getToken(t_Lexer *self)
        {
          ::org::antlr::v4::runtime::Token result((jobject) NULL);
          OBJ_CALL(result = self->object.getToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
        }

        static PyObject *t_Lexer_getTokenFactory(t_Lexer *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::TokenFactory result((jobject) NULL);

          if (!parseArgs(args, ""))
          {
            OBJ_CALL(result = self->object.getTokenFactory());
            return ::org::antlr::v4::runtime::t_TokenFactory::wrap_Object(result);
          }

          return callSuper(PY_TYPE(Lexer), (PyObject *) self, "getTokenFactory", args, 2);
        }

        static PyObject *t_Lexer_getTokenNames(t_Lexer *self, PyObject *args)
        {
          JArray< ::java::lang::String > result((jobject) NULL);

          if (!parseArgs(args, ""))
          {
            OBJ_CALL(result = self->object.getTokenNames());
            return JArray<jstring>(result.this$).wrap();
          }

          return callSuper(PY_TYPE(Lexer), (PyObject *) self, "getTokenNames", args, 2);
        }

        static PyObject *t_Lexer_getType(t_Lexer *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getType());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Lexer_mode(t_Lexer *self, PyObject *arg)
        {
          jint a0;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(self->object.mode(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "mode", arg);
          return NULL;
        }

        static PyObject *t_Lexer_more(t_Lexer *self)
        {
          OBJ_CALL(self->object.more());
          Py_RETURN_NONE;
        }

        static PyObject *t_Lexer_nextToken(t_Lexer *self)
        {
          ::org::antlr::v4::runtime::Token result((jobject) NULL);
          OBJ_CALL(result = self->object.nextToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(result);
        }

        static PyObject *t_Lexer_notifyListeners(t_Lexer *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::LexerNoViableAltException a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::LexerNoViableAltException::initializeClass, &a0))
          {
            OBJ_CALL(self->object.notifyListeners(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "notifyListeners", arg);
          return NULL;
        }

        static PyObject *t_Lexer_popMode(t_Lexer *self)
        {
          jint result;
          OBJ_CALL(result = self->object.popMode());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_Lexer_pushMode(t_Lexer *self, PyObject *arg)
        {
          jint a0;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(self->object.pushMode(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "pushMode", arg);
          return NULL;
        }

        static PyObject *t_Lexer_recover(t_Lexer *self, PyObject *args)
        {
          switch (PyTuple_GET_SIZE(args)) {
           case 1:
            {
              ::org::antlr::v4::runtime::LexerNoViableAltException a0((jobject) NULL);

              if (!parseArgs(args, "k", ::org::antlr::v4::runtime::LexerNoViableAltException::initializeClass, &a0))
              {
                OBJ_CALL(self->object.recover(a0));
                Py_RETURN_NONE;
              }
            }
            {
              ::org::antlr::v4::runtime::RecognitionException a0((jobject) NULL);

              if (!parseArgs(args, "k", ::org::antlr::v4::runtime::RecognitionException::initializeClass, &a0))
              {
                OBJ_CALL(self->object.recover(a0));
                Py_RETURN_NONE;
              }
            }
          }

          PyErr_SetArgsError((PyObject *) self, "recover", args);
          return NULL;
        }

        static PyObject *t_Lexer_reset(t_Lexer *self)
        {
          OBJ_CALL(self->object.reset());
          Py_RETURN_NONE;
        }

        static PyObject *t_Lexer_setChannel(t_Lexer *self, PyObject *arg)
        {
          jint a0;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(self->object.setChannel(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setChannel", arg);
          return NULL;
        }

        static PyObject *t_Lexer_setCharPositionInLine(t_Lexer *self, PyObject *arg)
        {
          jint a0;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(self->object.setCharPositionInLine(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setCharPositionInLine", arg);
          return NULL;
        }

        static PyObject *t_Lexer_setInputStream(t_Lexer *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::IntStream a0((jobject) NULL);

          if (!parseArgs(args, "k", ::org::antlr::v4::runtime::IntStream::initializeClass, &a0))
          {
            OBJ_CALL(self->object.setInputStream(a0));
            Py_RETURN_NONE;
          }

          return callSuper(PY_TYPE(Lexer), (PyObject *) self, "setInputStream", args, 2);
        }

        static PyObject *t_Lexer_setLine(t_Lexer *self, PyObject *arg)
        {
          jint a0;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(self->object.setLine(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setLine", arg);
          return NULL;
        }

        static PyObject *t_Lexer_setText(t_Lexer *self, PyObject *arg)
        {
          ::java::lang::String a0((jobject) NULL);

          if (!parseArg(arg, "s", &a0))
          {
            OBJ_CALL(self->object.setText(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setText", arg);
          return NULL;
        }

        static PyObject *t_Lexer_setToken(t_Lexer *self, PyObject *arg)
        {
          ::org::antlr::v4::runtime::Token a0((jobject) NULL);

          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::Token::initializeClass, &a0))
          {
            OBJ_CALL(self->object.setToken(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setToken", arg);
          return NULL;
        }

        static PyObject *t_Lexer_setTokenFactory(t_Lexer *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::TokenFactory a0((jobject) NULL);
          PyTypeObject **p0;

          if (!parseArgs(args, "K", ::org::antlr::v4::runtime::TokenFactory::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_TokenFactory::parameters_))
          {
            OBJ_CALL(self->object.setTokenFactory(a0));
            Py_RETURN_NONE;
          }

          return callSuper(PY_TYPE(Lexer), (PyObject *) self, "setTokenFactory", args, 2);
        }

        static PyObject *t_Lexer_setType(t_Lexer *self, PyObject *arg)
        {
          jint a0;

          if (!parseArg(arg, "I", &a0))
          {
            OBJ_CALL(self->object.setType(a0));
            Py_RETURN_NONE;
          }

          PyErr_SetArgsError((PyObject *) self, "setType", arg);
          return NULL;
        }

        static PyObject *t_Lexer_skip(t_Lexer *self)
        {
          OBJ_CALL(self->object.skip());
          Py_RETURN_NONE;
        }
        static PyObject *t_Lexer_get__parameters_(t_Lexer *self, void *data)
        {
          return typeParameters(self->parameters, sizeof(self->parameters));
        }

        static PyObject *t_Lexer_get___channel(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object._get__channel());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set___channel(t_Lexer *self, PyObject *arg, void *data)
        {
          jint value;
          if (!parseArg(arg, "I", &value))
          {
            INT_CALL(self->object._set__channel(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_channel", arg);
          return -1;
        }

        static PyObject *t_Lexer_get___hitEOF(t_Lexer *self, void *data)
        {
          jboolean value;
          OBJ_CALL(value = self->object._get__hitEOF());
          Py_RETURN_BOOL(value);
        }
        static int t_Lexer_set___hitEOF(t_Lexer *self, PyObject *arg, void *data)
        {
          jboolean value;
          if (!parseArg(arg, "Z", &value))
          {
            INT_CALL(self->object._set__hitEOF(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_hitEOF", arg);
          return -1;
        }

        static PyObject *t_Lexer_get___input(t_Lexer *self, void *data)
        {
          ::org::antlr::v4::runtime::CharStream value((jobject) NULL);
          OBJ_CALL(value = self->object._get__input());
          return ::org::antlr::v4::runtime::t_CharStream::wrap_Object(value);
        }
        static int t_Lexer_set___input(t_Lexer *self, PyObject *arg, void *data)
        {
          ::org::antlr::v4::runtime::CharStream value((jobject) NULL);
          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::CharStream::initializeClass, &value))
          {
            INT_CALL(self->object._set__input(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_input", arg);
          return -1;
        }

        static PyObject *t_Lexer_get___mode(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object._get__mode());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set___mode(t_Lexer *self, PyObject *arg, void *data)
        {
          jint value;
          if (!parseArg(arg, "I", &value))
          {
            INT_CALL(self->object._set__mode(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_mode", arg);
          return -1;
        }

        static PyObject *t_Lexer_get___text(t_Lexer *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object._get__text());
          return j2p(value);
        }
        static int t_Lexer_set___text(t_Lexer *self, PyObject *arg, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          if (!parseArg(arg, "s", &value))
          {
            INT_CALL(self->object._set__text(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_text", arg);
          return -1;
        }

        static PyObject *t_Lexer_get___token(t_Lexer *self, void *data)
        {
          ::org::antlr::v4::runtime::Token value((jobject) NULL);
          OBJ_CALL(value = self->object._get__token());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(value);
        }
        static int t_Lexer_set___token(t_Lexer *self, PyObject *arg, void *data)
        {
          ::org::antlr::v4::runtime::Token value((jobject) NULL);
          if (!parseArg(arg, "k", ::org::antlr::v4::runtime::Token::initializeClass, &value))
          {
            INT_CALL(self->object._set__token(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_token", arg);
          return -1;
        }

        static PyObject *t_Lexer_get___tokenStartCharIndex(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object._get__tokenStartCharIndex());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set___tokenStartCharIndex(t_Lexer *self, PyObject *arg, void *data)
        {
          jint value;
          if (!parseArg(arg, "I", &value))
          {
            INT_CALL(self->object._set__tokenStartCharIndex(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_tokenStartCharIndex", arg);
          return -1;
        }

        static PyObject *t_Lexer_get___tokenStartCharPositionInLine(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object._get__tokenStartCharPositionInLine());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set___tokenStartCharPositionInLine(t_Lexer *self, PyObject *arg, void *data)
        {
          jint value;
          if (!parseArg(arg, "I", &value))
          {
            INT_CALL(self->object._set__tokenStartCharPositionInLine(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_tokenStartCharPositionInLine", arg);
          return -1;
        }

        static PyObject *t_Lexer_get___tokenStartLine(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object._get__tokenStartLine());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set___tokenStartLine(t_Lexer *self, PyObject *arg, void *data)
        {
          jint value;
          if (!parseArg(arg, "I", &value))
          {
            INT_CALL(self->object._set__tokenStartLine(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_tokenStartLine", arg);
          return -1;
        }

        static PyObject *t_Lexer_get___type(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object._get__type());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set___type(t_Lexer *self, PyObject *arg, void *data)
        {
          jint value;
          if (!parseArg(arg, "I", &value))
          {
            INT_CALL(self->object._set__type(value));
            return 0;
          }
          PyErr_SetArgsError((PyObject *) self, "_type", arg);
          return -1;
        }

        static PyObject *t_Lexer_get__allTokens(t_Lexer *self, void *data)
        {
          ::java::util::List value((jobject) NULL);
          OBJ_CALL(value = self->object.getAllTokens());
          return ::java::util::t_List::wrap_Object(value);
        }

        static PyObject *t_Lexer_get__channel(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getChannel());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set__channel(t_Lexer *self, PyObject *arg, void *data)
        {
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object.setChannel(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "channel", arg);
          return -1;
        }

        static PyObject *t_Lexer_get__charIndex(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getCharIndex());
          return PyLong_FromLong((long) value);
        }

        static PyObject *t_Lexer_get__charPositionInLine(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getCharPositionInLine());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set__charPositionInLine(t_Lexer *self, PyObject *arg, void *data)
        {
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object.setCharPositionInLine(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "charPositionInLine", arg);
          return -1;
        }

        static PyObject *t_Lexer_get__inputStream(t_Lexer *self, void *data)
        {
          ::org::antlr::v4::runtime::CharStream value((jobject) NULL);
          OBJ_CALL(value = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_CharStream::wrap_Object(value);
        }
        static int t_Lexer_set__inputStream(t_Lexer *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::IntStream value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::IntStream::initializeClass, &value))
            {
              INT_CALL(self->object.setInputStream(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "inputStream", arg);
          return -1;
        }

        static PyObject *t_Lexer_get__line(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getLine());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set__line(t_Lexer *self, PyObject *arg, void *data)
        {
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object.setLine(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "line", arg);
          return -1;
        }

        static PyObject *t_Lexer_get__modeNames(t_Lexer *self, void *data)
        {
          JArray< ::java::lang::String > value((jobject) NULL);
          OBJ_CALL(value = self->object.getModeNames());
          return JArray<jstring>(value.this$).wrap();
        }

        static PyObject *t_Lexer_get__sourceName(t_Lexer *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object.getSourceName());
          return j2p(value);
        }

        static PyObject *t_Lexer_get__text(t_Lexer *self, void *data)
        {
          ::java::lang::String value((jobject) NULL);
          OBJ_CALL(value = self->object.getText());
          return j2p(value);
        }
        static int t_Lexer_set__text(t_Lexer *self, PyObject *arg, void *data)
        {
          {
            ::java::lang::String value((jobject) NULL);
            if (!parseArg(arg, "s", &value))
            {
              INT_CALL(self->object.setText(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "text", arg);
          return -1;
        }

        static PyObject *t_Lexer_get__token(t_Lexer *self, void *data)
        {
          ::org::antlr::v4::runtime::Token value((jobject) NULL);
          OBJ_CALL(value = self->object.getToken());
          return ::org::antlr::v4::runtime::t_Token::wrap_Object(value);
        }
        static int t_Lexer_set__token(t_Lexer *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::Token value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::Token::initializeClass, &value))
            {
              INT_CALL(self->object.setToken(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "token", arg);
          return -1;
        }

        static PyObject *t_Lexer_get__tokenFactory(t_Lexer *self, void *data)
        {
          ::org::antlr::v4::runtime::TokenFactory value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenFactory());
          return ::org::antlr::v4::runtime::t_TokenFactory::wrap_Object(value);
        }
        static int t_Lexer_set__tokenFactory(t_Lexer *self, PyObject *arg, void *data)
        {
          {
            ::org::antlr::v4::runtime::TokenFactory value((jobject) NULL);
            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::TokenFactory::initializeClass, &value))
            {
              INT_CALL(self->object.setTokenFactory(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "tokenFactory", arg);
          return -1;
        }

        static PyObject *t_Lexer_get__tokenNames(t_Lexer *self, void *data)
        {
          JArray< ::java::lang::String > value((jobject) NULL);
          OBJ_CALL(value = self->object.getTokenNames());
          return JArray<jstring>(value.this$).wrap();
        }

        static PyObject *t_Lexer_get__type(t_Lexer *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getType());
          return PyLong_FromLong((long) value);
        }
        static int t_Lexer_set__type(t_Lexer *self, PyObject *arg, void *data)
        {
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object.setType(value));
              return 0;
            }
          }
          PyErr_SetArgsError((PyObject *) self, "type", arg);
          return -1;
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/LookaheadEventInfo.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *LookaheadEventInfo::class$ = NULL;
          jmethodID *LookaheadEventInfo::mids$ = NULL;
          jfieldID *LookaheadEventInfo::fids$ = NULL;
          bool LookaheadEventInfo::live$ = false;

          jclass LookaheadEventInfo::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/LookaheadEventInfo");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_2cb5b6c5ebfb1d4d] = env->getMethodID(cls, "<init>", "(ILorg/antlr/v4/runtime/atn/ATNConfigSet;ILorg/antlr/v4/runtime/TokenStream;IIZ)V");

              fids$ = new jfieldID[max_fid];
              fids$[fid_predictedAlt] = env->getFieldID(cls, "predictedAlt", "I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          LookaheadEventInfo::LookaheadEventInfo(jint a0, const ::org::antlr::v4::runtime::atn::ATNConfigSet & a1, jint a2, const ::org::antlr::v4::runtime::TokenStream & a3, jint a4, jint a5, jboolean a6) : ::org::antlr::v4::runtime::atn::DecisionEventInfo(env->newObject(initializeClass, &mids$, mid_init$_2cb5b6c5ebfb1d4d, a0, a1.this$, a2, a3.this$, a4, a5, a6)) {}

          jint LookaheadEventInfo::_get_predictedAlt() const
          {
            return env->getIntField(this$, fids$[fid_predictedAlt]);
          }

          void LookaheadEventInfo::_set_predictedAlt(jint a0) const
          {
            env->setIntField(this$, fids$[fid_predictedAlt], a0);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_LookaheadEventInfo_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_LookaheadEventInfo_instance_(PyTypeObject *type, PyObject *arg);
          static int t_LookaheadEventInfo_init_(t_LookaheadEventInfo *self, PyObject *args, PyObject *kwds);
          static PyObject *t_LookaheadEventInfo_get__predictedAlt(t_LookaheadEventInfo *self, void *data);
          static int t_LookaheadEventInfo_set__predictedAlt(t_LookaheadEventInfo *self, PyObject *arg, void *data);

          static PyGetSetDef t_LookaheadEventInfo__fields_[] = {
            DECLARE_GETSET_FIELD(t_LookaheadEventInfo, predictedAlt),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_LookaheadEventInfo__methods_[] = {
            DECLARE_METHOD(t_LookaheadEventInfo, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_LookaheadEventInfo, instance_, METH_O | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(LookaheadEventInfo)[] = {
            { Py_tp_methods, t_LookaheadEventInfo__methods_ },
            { Py_tp_init, (void *) t_LookaheadEventInfo_init_ },
            { Py_tp_getset, t_LookaheadEventInfo__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(LookaheadEventInfo)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::DecisionEventInfo),
            NULL
          };

          DEFINE_TYPE(LookaheadEventInfo, t_LookaheadEventInfo, LookaheadEventInfo);

          void t_LookaheadEventInfo::install(PyObject *module)
          {
            installType(&PY_TYPE(LookaheadEventInfo), &PY_TYPE_DEF(LookaheadEventInfo), module, "LookaheadEventInfo", 0);
          }

          void t_LookaheadEventInfo::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(LookaheadEventInfo), "class_", make_descriptor(LookaheadEventInfo::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LookaheadEventInfo), "wrapfn_", make_descriptor(t_LookaheadEventInfo::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LookaheadEventInfo), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_LookaheadEventInfo_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, LookaheadEventInfo::initializeClass, 1)))
              return NULL;
            return t_LookaheadEventInfo::wrap_Object(LookaheadEventInfo(((t_LookaheadEventInfo *) arg)->object.this$));
          }
          static PyObject *t_LookaheadEventInfo_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, LookaheadEventInfo::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_LookaheadEventInfo_init_(t_LookaheadEventInfo *self, PyObject *args, PyObject *kwds)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::ATNConfigSet a1((jobject) NULL);
            jint a2;
            ::org::antlr::v4::runtime::TokenStream a3((jobject) NULL);
            jint a4;
            jint a5;
            jboolean a6;
            LookaheadEventInfo object((jobject) NULL);

            if (!parseArgs(args, "IkIkIIZ", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, ::org::antlr::v4::runtime::TokenStream::initializeClass, &a0, &a1, &a2, &a3, &a4, &a5, &a6))
            {
              INT_CALL(object = LookaheadEventInfo(a0, a1, a2, a3, a4, a5, a6));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_LookaheadEventInfo_get__predictedAlt(t_LookaheadEventInfo *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_predictedAlt());
            return PyLong_FromLong((long) value);
          }
          static int t_LookaheadEventInfo_set__predictedAlt(t_LookaheadEventInfo *self, PyObject *arg, void *data)
          {
            jint value;
            if (!parseArg(arg, "I", &value))
            {
              INT_CALL(self->object._set_predictedAlt(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "predictedAlt", arg);
            return -1;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/misc/Array2DHashSet.h"
#include "java/util/Collection.h"
#include "java/lang/Class.h"
#include "java/lang/String.h"
#include "java/util/Iterator.h"
#include "java/util/Set.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace misc {

          ::java::lang::Class *Array2DHashSet::class$ = NULL;
          jmethodID *Array2DHashSet::mids$ = NULL;
          bool Array2DHashSet::live$ = false;
          jint Array2DHashSet::INITAL_BUCKET_CAPACITY = (jint) 0;
          jint Array2DHashSet::INITAL_CAPACITY = (jint) 0;
          jdouble Array2DHashSet::LOAD_FACTOR = (jdouble) 0;

          jclass Array2DHashSet::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/misc/Array2DHashSet");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_f2cc1bce94666404] = env->getMethodID(cls, "<init>", "()V");
              mids$[mid_add_8b72f2dcdde6fd1d] = env->getMethodID(cls, "add", "(Ljava/lang/Object;)Z");
              mids$[mid_addAll_15d9cc2398c22637] = env->getMethodID(cls, "addAll", "(Ljava/util/Collection;)Z");
              mids$[mid_clear_f2cc1bce94666404] = env->getMethodID(cls, "clear", "()V");
              mids$[mid_contains_8b72f2dcdde6fd1d] = env->getMethodID(cls, "contains", "(Ljava/lang/Object;)Z");
              mids$[mid_containsAll_15d9cc2398c22637] = env->getMethodID(cls, "containsAll", "(Ljava/util/Collection;)Z");
              mids$[mid_containsFast_8b72f2dcdde6fd1d] = env->getMethodID(cls, "containsFast", "(Ljava/lang/Object;)Z");
              mids$[mid_equals_8b72f2dcdde6fd1d] = env->getMethodID(cls, "equals", "(Ljava/lang/Object;)Z");
              mids$[mid_get_e5ae0f8c04795fa9] = env->getMethodID(cls, "get", "(Ljava/lang/Object;)Ljava/lang/Object;");
              mids$[mid_getOrAdd_e5ae0f8c04795fa9] = env->getMethodID(cls, "getOrAdd", "(Ljava/lang/Object;)Ljava/lang/Object;");
              mids$[mid_hashCode_9972fcc56b44e79d] = env->getMethodID(cls, "hashCode", "()I");
              mids$[mid_isEmpty_8454bd5aa23fd11e] = env->getMethodID(cls, "isEmpty", "()Z");
              mids$[mid_iterator_233a192dadb0917d] = env->getMethodID(cls, "iterator", "()Ljava/util/Iterator;");
              mids$[mid_remove_8b72f2dcdde6fd1d] = env->getMethodID(cls, "remove", "(Ljava/lang/Object;)Z");
              mids$[mid_removeAll_15d9cc2398c22637] = env->getMethodID(cls, "removeAll", "(Ljava/util/Collection;)Z");
              mids$[mid_removeFast_8b72f2dcdde6fd1d] = env->getMethodID(cls, "removeFast", "(Ljava/lang/Object;)Z");
              mids$[mid_retainAll_15d9cc2398c22637] = env->getMethodID(cls, "retainAll", "(Ljava/util/Collection;)Z");
              mids$[mid_size_9972fcc56b44e79d] = env->getMethodID(cls, "size", "()I");
              mids$[mid_toArray_6becf78ffd87a9bc] = env->getMethodID(cls, "toArray", "()[Ljava/lang/Object;");
              mids$[mid_toArray_609b05756010dc5d] = env->getMethodID(cls, "toArray", "([Ljava/lang/Object;)[Ljava/lang/Object;");
              mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");
              mids$[mid_toTableString_db9b55ba01e03e4b] = env->getMethodID(cls, "toTableString", "()Ljava/lang/String;");
              mids$[mid_asElementType_e5ae0f8c04795fa9] = env->getMethodID(cls, "asElementType", "(Ljava/lang/Object;)Ljava/lang/Object;");
              mids$[mid_createBucket_a2672f0f17055095] = env->getMethodID(cls, "createBucket", "(I)[Ljava/lang/Object;");
              mids$[mid_createBuckets_c9c58dbf27467cd5] = env->getMethodID(cls, "createBuckets", "(I)[[Ljava/lang/Object;");
              mids$[mid_getOrAddImpl_e5ae0f8c04795fa9] = env->getMethodID(cls, "getOrAddImpl", "(Ljava/lang/Object;)Ljava/lang/Object;");
              mids$[mid_getBucket_5a4805a36cf611e7] = env->getMethodID(cls, "getBucket", "(Ljava/lang/Object;)I");
              mids$[mid_expand_f2cc1bce94666404] = env->getMethodID(cls, "expand", "()V");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              INITAL_BUCKET_CAPACITY = env->getStaticIntField(cls, "INITAL_BUCKET_CAPACITY");
              INITAL_CAPACITY = env->getStaticIntField(cls, "INITAL_CAPACITY");
              LOAD_FACTOR = env->getStaticDoubleField(cls, "LOAD_FACTOR");
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          Array2DHashSet::Array2DHashSet() : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_f2cc1bce94666404)) {}

          jboolean Array2DHashSet::add(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_add_8b72f2dcdde6fd1d], a0.this$);
          }

          jboolean Array2DHashSet::addAll(const ::java::util::Collection & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_addAll_15d9cc2398c22637], a0.this$);
          }

          void Array2DHashSet::clear() const
          {
            env->callVoidMethod(this$, mids$[mid_clear_f2cc1bce94666404]);
          }

          jboolean Array2DHashSet::contains(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_contains_8b72f2dcdde6fd1d], a0.this$);
          }

          jboolean Array2DHashSet::containsAll(const ::java::util::Collection & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_containsAll_15d9cc2398c22637], a0.this$);
          }

          jboolean Array2DHashSet::containsFast(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_containsFast_8b72f2dcdde6fd1d], a0.this$);
          }

          jboolean Array2DHashSet::equals(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_equals_8b72f2dcdde6fd1d], a0.this$);
          }

          ::java::lang::Object Array2DHashSet::get(const ::java::lang::Object & a0) const
          {
            return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_get_e5ae0f8c04795fa9], a0.this$));
          }

          ::java::lang::Object Array2DHashSet::getOrAdd(const ::java::lang::Object & a0) const
          {
            return ::java::lang::Object(env->callObjectMethod(this$, mids$[mid_getOrAdd_e5ae0f8c04795fa9], a0.this$));
          }

          jint Array2DHashSet::hashCode() const
          {
            return env->callIntMethod(this$, mids$[mid_hashCode_9972fcc56b44e79d]);
          }

          jboolean Array2DHashSet::isEmpty() const
          {
            return env->callBooleanMethod(this$, mids$[mid_isEmpty_8454bd5aa23fd11e]);
          }

          ::java::util::Iterator Array2DHashSet::iterator() const
          {
            return ::java::util::Iterator(env->callObjectMethod(this$, mids$[mid_iterator_233a192dadb0917d]));
          }

          jboolean Array2DHashSet::remove(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_remove_8b72f2dcdde6fd1d], a0.this$);
          }

          jboolean Array2DHashSet::removeAll(const ::java::util::Collection & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_removeAll_15d9cc2398c22637], a0.this$);
          }

          jboolean Array2DHashSet::removeFast(const ::java::lang::Object & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_removeFast_8b72f2dcdde6fd1d], a0.this$);
          }

          jboolean Array2DHashSet::retainAll(const ::java::util::Collection & a0) const
          {
            return env->callBooleanMethod(this$, mids$[mid_retainAll_15d9cc2398c22637], a0.this$);
          }

          jint Array2DHashSet::size() const
          {
            return env->callIntMethod(this$, mids$[mid_size_9972fcc56b44e79d]);
          }

          JArray< ::java::lang::Object > Array2DHashSet::toArray() const
          {
            return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_6becf78ffd87a9bc]));
          }

          JArray< ::java::lang::Object > Array2DHashSet::toArray(const JArray< ::java::lang::Object > & a0) const
          {
            return JArray< ::java::lang::Object >(env->callObjectMethod(this$, mids$[mid_toArray_609b05756010dc5d], a0.this$));
          }

          ::java::lang::String Array2DHashSet::toString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
          }

          ::java::lang::String Array2DHashSet::toTableString() const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toTableString_db9b55ba01e03e4b]));
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace misc {
          static PyObject *t_Array2DHashSet_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_Array2DHashSet_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_Array2DHashSet_of_(t_Array2DHashSet *self, PyObject *args);
          static int t_Array2DHashSet_init_(t_Array2DHashSet *self, PyObject *args, PyObject *kwds);
          static PyObject *t_Array2DHashSet_add(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_addAll(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_clear(t_Array2DHashSet *self);
          static PyObject *t_Array2DHashSet_contains(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_containsAll(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_containsFast(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_equals(t_Array2DHashSet *self, PyObject *args);
          static PyObject *t_Array2DHashSet_get(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_getOrAdd(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_hashCode(t_Array2DHashSet *self, PyObject *args);
          static PyObject *t_Array2DHashSet_isEmpty(t_Array2DHashSet *self);
          static PyObject *t_Array2DHashSet_iterator(t_Array2DHashSet *self);
          static PyObject *t_Array2DHashSet_remove(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_removeAll(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_removeFast(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_retainAll(t_Array2DHashSet *self, PyObject *arg);
          static PyObject *t_Array2DHashSet_size(t_Array2DHashSet *self);
          static PyObject *t_Array2DHashSet_toArray(t_Array2DHashSet *self, PyObject *args);
          static PyObject *t_Array2DHashSet_toString(t_Array2DHashSet *self, PyObject *args);
          static PyObject *t_Array2DHashSet_toTableString(t_Array2DHashSet *self);
          static PyObject *t_Array2DHashSet_get__empty(t_Array2DHashSet *self, void *data);
          static PyObject *t_Array2DHashSet_get__parameters_(t_Array2DHashSet *self, void *data);
          static PyGetSetDef t_Array2DHashSet__fields_[] = {
            DECLARE_GET_FIELD(t_Array2DHashSet, empty),
            DECLARE_GET_FIELD(t_Array2DHashSet, parameters_),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_Array2DHashSet__methods_[] = {
            DECLARE_METHOD(t_Array2DHashSet, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_Array2DHashSet, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_Array2DHashSet, of_, METH_VARARGS),
            DECLARE_METHOD(t_Array2DHashSet, add, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, addAll, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, clear, METH_NOARGS),
            DECLARE_METHOD(t_Array2DHashSet, contains, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, containsAll, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, containsFast, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, equals, METH_VARARGS),
            DECLARE_METHOD(t_Array2DHashSet, get, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, getOrAdd, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, hashCode, METH_VARARGS),
            DECLARE_METHOD(t_Array2DHashSet, isEmpty, METH_NOARGS),
            DECLARE_METHOD(t_Array2DHashSet, iterator, METH_NOARGS),
            DECLARE_METHOD(t_Array2DHashSet, remove, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, removeAll, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, removeFast, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, retainAll, METH_O),
            DECLARE_METHOD(t_Array2DHashSet, size, METH_NOARGS),
            DECLARE_METHOD(t_Array2DHashSet, toArray, METH_VARARGS),
            DECLARE_METHOD(t_Array2DHashSet, toString, METH_VARARGS),
            DECLARE_METHOD(t_Array2DHashSet, toTableString, METH_NOARGS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(Array2DHashSet)[] = {
            { Py_tp_methods, t_Array2DHashSet__methods_ },
            { Py_tp_init, (void *) t_Array2DHashSet_init_ },
            { Py_tp_getset, t_Array2DHashSet__fields_ },
            { Py_tp_iter, (void *) ((PyObject *(*)(t_Array2DHashSet *)) get_generic_iterator< t_Array2DHashSet >) },
            { Py_tp_iternext, (void *) 0 },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(Array2DHashSet)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(Array2DHashSet, t_Array2DHashSet, Array2DHashSet);
          PyObject *t_Array2DHashSet::wrap_Object(const Array2DHashSet& object, PyTypeObject *p0)
          {
            PyObject *obj = t_Array2DHashSet::wrap_Object(object);
            if (obj != NULL && obj != Py_None)
            {
              t_Array2DHashSet *self = (t_Array2DHashSet *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          PyObject *t_Array2DHashSet::wrap_jobject(const jobject& object, PyTypeObject *p0)
          {
            PyObject *obj = t_Array2DHashSet::wrap_jobject(object);
            if (obj != NULL && obj != Py_None)
            {
              t_Array2DHashSet *self = (t_Array2DHashSet *) obj;
              self->parameters[0] = p0;
            }
            return obj;
          }

          void t_Array2DHashSet::install(PyObject *module)
          {
            installType(&PY_TYPE(Array2DHashSet), &PY_TYPE_DEF(Array2DHashSet), module, "Array2DHashSet", 0);
          }

          void t_Array2DHashSet::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(Array2DHashSet), "class_", make_descriptor(Array2DHashSet::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Array2DHashSet), "wrapfn_", make_descriptor(t_Array2DHashSet::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Array2DHashSet), "boxfn_", make_descriptor(boxObject));
            env->getClass(Array2DHashSet::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(Array2DHashSet), "INITAL_BUCKET_CAPACITY", make_descriptor(Array2DHashSet::INITAL_BUCKET_CAPACITY));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Array2DHashSet), "INITAL_CAPACITY", make_descriptor(Array2DHashSet::INITAL_CAPACITY));
            PyObject_SetAttrString((PyObject *) PY_TYPE(Array2DHashSet), "LOAD_FACTOR", make_descriptor(Array2DHashSet::LOAD_FACTOR));
          }

          static PyObject *t_Array2DHashSet_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, Array2DHashSet::initializeClass, 1)))
              return NULL;
            return t_Array2DHashSet::wrap_Object(Array2DHashSet(((t_Array2DHashSet *) arg)->object.this$));
          }
          static PyObject *t_Array2DHashSet_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, Array2DHashSet::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_Array2DHashSet_of_(t_Array2DHashSet *self, PyObject *args)
          {
            if (!parseArg(args, "T", 1, &(self->parameters)))
              Py_RETURN_SELF;
            return PyErr_SetArgsError((PyObject *) self, "of_", args);
          }

          static int t_Array2DHashSet_init_(t_Array2DHashSet *self, PyObject *args, PyObject *kwds)
          {
            Array2DHashSet object((jobject) NULL);

            INT_CALL(object = Array2DHashSet());
            self->object = object;

            return 0;
          }

          static PyObject *t_Array2DHashSet_add(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "O", self->parameters[0], &a0))
            {
              OBJ_CALL(result = self->object.add(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "add", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_addAll(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.addAll(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "addAll", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_clear(t_Array2DHashSet *self)
          {
            OBJ_CALL(self->object.clear());
            Py_RETURN_NONE;
          }

          static PyObject *t_Array2DHashSet_contains(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "o", &a0))
            {
              OBJ_CALL(result = self->object.contains(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "contains", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_containsAll(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.containsAll(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "containsAll", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_containsFast(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "O", self->parameters[0], &a0))
            {
              OBJ_CALL(result = self->object.containsFast(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "containsFast", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_equals(t_Array2DHashSet *self, PyObject *args)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArgs(args, "o", &a0))
            {
              OBJ_CALL(result = self->object.equals(a0));
              Py_RETURN_BOOL(result);
            }

            return callSuper(PY_TYPE(Array2DHashSet), (PyObject *) self, "equals", args, 2);
          }

          static PyObject *t_Array2DHashSet_get(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::lang::Object a0((jobject) NULL);
            ::java::lang::Object result((jobject) NULL);

            if (!parseArg(arg, "O", self->parameters[0], &a0))
            {
              OBJ_CALL(result = self->object.get(a0));
              return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "get", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_getOrAdd(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::lang::Object a0((jobject) NULL);
            ::java::lang::Object result((jobject) NULL);

            if (!parseArg(arg, "O", self->parameters[0], &a0))
            {
              OBJ_CALL(result = self->object.getOrAdd(a0));
              return self->parameters[0] != NULL ? wrapType(self->parameters[0], result.this$) : ::java::lang::t_Object::wrap_Object(result);
            }

            PyErr_SetArgsError((PyObject *) self, "getOrAdd", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_hashCode(t_Array2DHashSet *self, PyObject *args)
          {
            jint result;

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.hashCode());
              return PyLong_FromLong((long) result);
            }

            return callSuper(PY_TYPE(Array2DHashSet), (PyObject *) self, "hashCode", args, 2);
          }

          static PyObject *t_Array2DHashSet_isEmpty(t_Array2DHashSet *self)
          {
            jboolean result;
            OBJ_CALL(result = self->object.isEmpty());
            Py_RETURN_BOOL(result);
          }

          static PyObject *t_Array2DHashSet_iterator(t_Array2DHashSet *self)
          {
            ::java::util::Iterator result((jobject) NULL);
            OBJ_CALL(result = self->object.iterator());
            return ::java::util::t_Iterator::wrap_Object(result, self->parameters[0]);
          }

          static PyObject *t_Array2DHashSet_remove(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "o", &a0))
            {
              OBJ_CALL(result = self->object.remove(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "remove", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_removeAll(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.removeAll(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "removeAll", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_removeFast(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::lang::Object a0((jobject) NULL);
            jboolean result;

            if (!parseArg(arg, "O", self->parameters[0], &a0))
            {
              OBJ_CALL(result = self->object.removeFast(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "removeFast", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_retainAll(t_Array2DHashSet *self, PyObject *arg)
          {
            ::java::util::Collection a0((jobject) NULL);
            PyTypeObject **p0;
            jboolean result;

            if (!parseArg(arg, "K", ::java::util::Collection::initializeClass, &a0, &p0, ::java::util::t_Collection::parameters_))
            {
              OBJ_CALL(result = self->object.retainAll(a0));
              Py_RETURN_BOOL(result);
            }

            PyErr_SetArgsError((PyObject *) self, "retainAll", arg);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_size(t_Array2DHashSet *self)
          {
            jint result;
            OBJ_CALL(result = self->object.size());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_Array2DHashSet_toArray(t_Array2DHashSet *self, PyObject *args)
          {
            switch (PyTuple_GET_SIZE(args)) {
             case 0:
              {
                JArray< ::java::lang::Object > result((jobject) NULL);
                OBJ_CALL(result = self->object.toArray());
                return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
              }
              break;
             case 1:
              {
                JArray< ::java::lang::Object > a0((jobject) NULL);
                JArray< ::java::lang::Object > result((jobject) NULL);

                if (!parseArgs(args, "[o", &a0))
                {
                  OBJ_CALL(result = self->object.toArray(a0));
                  return JArray<jobject>(result.this$).wrap(::java::lang::t_Object::wrap_jobject);
                }
              }
            }

            PyErr_SetArgsError((PyObject *) self, "toArray", args);
            return NULL;
          }

          static PyObject *t_Array2DHashSet_toString(t_Array2DHashSet *self, PyObject *args)
          {
            ::java::lang::String result((jobject) NULL);

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(result = self->object.toString());
              return j2p(result);
            }

            return callSuper(PY_TYPE(Array2DHashSet), (PyObject *) self, "toString", args, 2);
          }

          static PyObject *t_Array2DHashSet_toTableString(t_Array2DHashSet *self)
          {
            ::java::lang::String result((jobject) NULL);
            OBJ_CALL(result = self->object.toTableString());
            return j2p(result);
          }
          static PyObject *t_Array2DHashSet_get__parameters_(t_Array2DHashSet *self, void *data)
          {
            return typeParameters(self->parameters, sizeof(self->parameters));
          }

          static PyObject *t_Array2DHashSet_get__empty(t_Array2DHashSet *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object.isEmpty());
            Py_RETURN_BOOL(value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/DecisionEventInfo.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *DecisionEventInfo::class$ = NULL;
          jmethodID *DecisionEventInfo::mids$ = NULL;
          jfieldID *DecisionEventInfo::fids$ = NULL;
          bool DecisionEventInfo::live$ = false;

          jclass DecisionEventInfo::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/DecisionEventInfo");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_4923a124fb8045e3] = env->getMethodID(cls, "<init>", "(ILorg/antlr/v4/runtime/atn/ATNConfigSet;Lorg/antlr/v4/runtime/TokenStream;IIZ)V");

              fids$ = new jfieldID[max_fid];
              fids$[fid_configs] = env->getFieldID(cls, "configs", "Lorg/antlr/v4/runtime/atn/ATNConfigSet;");
              fids$[fid_decision] = env->getFieldID(cls, "decision", "I");
              fids$[fid_fullCtx] = env->getFieldID(cls, "fullCtx", "Z");
              fids$[fid_input] = env->getFieldID(cls, "input", "Lorg/antlr/v4/runtime/TokenStream;");
              fids$[fid_startIndex] = env->getFieldID(cls, "startIndex", "I");
              fids$[fid_stopIndex] = env->getFieldID(cls, "stopIndex", "I");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          DecisionEventInfo::DecisionEventInfo(jint a0, const ::org::antlr::v4::runtime::atn::ATNConfigSet & a1, const ::org::antlr::v4::runtime::TokenStream & a2, jint a3, jint a4, jboolean a5) : ::java::lang::Object(env->newObject(initializeClass, &mids$, mid_init$_4923a124fb8045e3, a0, a1.this$, a2.this$, a3, a4, a5)) {}

          ::org::antlr::v4::runtime::atn::ATNConfigSet DecisionEventInfo::_get_configs() const
          {
            return ::org::antlr::v4::runtime::atn::ATNConfigSet(env->getObjectField(this$, fids$[fid_configs]));
          }

          jint DecisionEventInfo::_get_decision() const
          {
            return env->getIntField(this$, fids$[fid_decision]);
          }

          jboolean DecisionEventInfo::_get_fullCtx() const
          {
            return env->getBooleanField(this$, fids$[fid_fullCtx]);
          }

          ::org::antlr::v4::runtime::TokenStream DecisionEventInfo::_get_input() const
          {
            return ::org::antlr::v4::runtime::TokenStream(env->getObjectField(this$, fids$[fid_input]));
          }

          jint DecisionEventInfo::_get_startIndex() const
          {
            return env->getIntField(this$, fids$[fid_startIndex]);
          }

          jint DecisionEventInfo::_get_stopIndex() const
          {
            return env->getIntField(this$, fids$[fid_stopIndex]);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_DecisionEventInfo_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_DecisionEventInfo_instance_(PyTypeObject *type, PyObject *arg);
          static int t_DecisionEventInfo_init_(t_DecisionEventInfo *self, PyObject *args, PyObject *kwds);
          static PyObject *t_DecisionEventInfo_get__configs(t_DecisionEventInfo *self, void *data);
          static PyObject *t_DecisionEventInfo_get__decision(t_DecisionEventInfo *self, void *data);
          static PyObject *t_DecisionEventInfo_get__fullCtx(t_DecisionEventInfo *self, void *data);
          static PyObject *t_DecisionEventInfo_get__input(t_DecisionEventInfo *self, void *data);
          static PyObject *t_DecisionEventInfo_get__startIndex(t_DecisionEventInfo *self, void *data);
          static PyObject *t_DecisionEventInfo_get__stopIndex(t_DecisionEventInfo *self, void *data);

          static PyGetSetDef t_DecisionEventInfo__fields_[] = {
            DECLARE_GET_FIELD(t_DecisionEventInfo, configs),
            DECLARE_GET_FIELD(t_DecisionEventInfo, decision),
            DECLARE_GET_FIELD(t_DecisionEventInfo, fullCtx),
            DECLARE_GET_FIELD(t_DecisionEventInfo, input),
            DECLARE_GET_FIELD(t_DecisionEventInfo, startIndex),
            DECLARE_GET_FIELD(t_DecisionEventInfo, stopIndex),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_DecisionEventInfo__methods_[] = {
            DECLARE_METHOD(t_DecisionEventInfo, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_DecisionEventInfo, instance_, METH_O | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(DecisionEventInfo)[] = {
            { Py_tp_methods, t_DecisionEventInfo__methods_ },
            { Py_tp_init, (void *) t_DecisionEventInfo_init_ },
            { Py_tp_getset, t_DecisionEventInfo__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(DecisionEventInfo)[] = {
            &PY_TYPE_DEF(::java::lang::Object),
            NULL
          };

          DEFINE_TYPE(DecisionEventInfo, t_DecisionEventInfo, DecisionEventInfo);

          void t_DecisionEventInfo::install(PyObject *module)
          {
            installType(&PY_TYPE(DecisionEventInfo), &PY_TYPE_DEF(DecisionEventInfo), module, "DecisionEventInfo", 0);
          }

          void t_DecisionEventInfo::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(DecisionEventInfo), "class_", make_descriptor(DecisionEventInfo::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(DecisionEventInfo), "wrapfn_", make_descriptor(t_DecisionEventInfo::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(DecisionEventInfo), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_DecisionEventInfo_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, DecisionEventInfo::initializeClass, 1)))
              return NULL;
            return t_DecisionEventInfo::wrap_Object(DecisionEventInfo(((t_DecisionEventInfo *) arg)->object.this$));
          }
          static PyObject *t_DecisionEventInfo_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, DecisionEventInfo::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_DecisionEventInfo_init_(t_DecisionEventInfo *self, PyObject *args, PyObject *kwds)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::ATNConfigSet a1((jobject) NULL);
            ::org::antlr::v4::runtime::TokenStream a2((jobject) NULL);
            jint a3;
            jint a4;
            jboolean a5;
            DecisionEventInfo object((jobject) NULL);

            if (!parseArgs(args, "IkkIIZ", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, ::org::antlr::v4::runtime::TokenStream::initializeClass, &a0, &a1, &a2, &a3, &a4, &a5))
            {
              INT_CALL(object = DecisionEventInfo(a0, a1, a2, a3, a4, a5));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_DecisionEventInfo_get__configs(t_DecisionEventInfo *self, void *data)
          {
            ::org::antlr::v4::runtime::atn::ATNConfigSet value((jobject) NULL);
            OBJ_CALL(value = self->object._get_configs());
            return ::org::antlr::v4::runtime::atn::t_ATNConfigSet::wrap_Object(value);
          }

          static PyObject *t_DecisionEventInfo_get__decision(t_DecisionEventInfo *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_decision());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_DecisionEventInfo_get__fullCtx(t_DecisionEventInfo *self, void *data)
          {
            jboolean value;
            OBJ_CALL(value = self->object._get_fullCtx());
            Py_RETURN_BOOL(value);
          }

          static PyObject *t_DecisionEventInfo_get__input(t_DecisionEventInfo *self, void *data)
          {
            ::org::antlr::v4::runtime::TokenStream value((jobject) NULL);
            OBJ_CALL(value = self->object._get_input());
            return ::org::antlr::v4::runtime::t_TokenStream::wrap_Object(value);
          }

          static PyObject *t_DecisionEventInfo_get__startIndex(t_DecisionEventInfo *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_startIndex());
            return PyLong_FromLong((long) value);
          }

          static PyObject *t_DecisionEventInfo_get__stopIndex(t_DecisionEventInfo *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object._get_stopIndex());
            return PyLong_FromLong((long) value);
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/AmbiguityInfo.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet.h"
#include "java/util/BitSet.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *AmbiguityInfo::class$ = NULL;
          jmethodID *AmbiguityInfo::mids$ = NULL;
          jfieldID *AmbiguityInfo::fids$ = NULL;
          bool AmbiguityInfo::live$ = false;

          jclass AmbiguityInfo::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/AmbiguityInfo");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_359917a5a1990093] = env->getMethodID(cls, "<init>", "(ILorg/antlr/v4/runtime/atn/ATNConfigSet;Ljava/util/BitSet;Lorg/antlr/v4/runtime/TokenStream;IIZ)V");

              fids$ = new jfieldID[max_fid];
              fids$[fid_ambigAlts] = env->getFieldID(cls, "ambigAlts", "Ljava/util/BitSet;");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          AmbiguityInfo::AmbiguityInfo(jint a0, const ::org::antlr::v4::runtime::atn::ATNConfigSet & a1, const ::java::util::BitSet & a2, const ::org::antlr::v4::runtime::TokenStream & a3, jint a4, jint a5, jboolean a6) : ::org::antlr::v4::runtime::atn::DecisionEventInfo(env->newObject(initializeClass, &mids$, mid_init$_359917a5a1990093, a0, a1.this$, a2.this$, a3.this$, a4, a5, a6)) {}

          ::java::util::BitSet AmbiguityInfo::_get_ambigAlts() const
          {
            return ::java::util::BitSet(env->getObjectField(this$, fids$[fid_ambigAlts]));
          }

          void AmbiguityInfo::_set_ambigAlts(const ::java::util::BitSet & a0) const
          {
            env->setObjectField(this$, fids$[fid_ambigAlts], a0.this$);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_AmbiguityInfo_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_AmbiguityInfo_instance_(PyTypeObject *type, PyObject *arg);
          static int t_AmbiguityInfo_init_(t_AmbiguityInfo *self, PyObject *args, PyObject *kwds);
          static PyObject *t_AmbiguityInfo_get__ambigAlts(t_AmbiguityInfo *self, void *data);
          static int t_AmbiguityInfo_set__ambigAlts(t_AmbiguityInfo *self, PyObject *arg, void *data);

          static PyGetSetDef t_AmbiguityInfo__fields_[] = {
            DECLARE_GETSET_FIELD(t_AmbiguityInfo, ambigAlts),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_AmbiguityInfo__methods_[] = {
            DECLARE_METHOD(t_AmbiguityInfo, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_AmbiguityInfo, instance_, METH_O | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(AmbiguityInfo)[] = {
            { Py_tp_methods, t_AmbiguityInfo__methods_ },
            { Py_tp_init, (void *) t_AmbiguityInfo_init_ },
            { Py_tp_getset, t_AmbiguityInfo__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(AmbiguityInfo)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::DecisionEventInfo),
            NULL
          };

          DEFINE_TYPE(AmbiguityInfo, t_AmbiguityInfo, AmbiguityInfo);

          void t_AmbiguityInfo::install(PyObject *module)
          {
            installType(&PY_TYPE(AmbiguityInfo), &PY_TYPE_DEF(AmbiguityInfo), module, "AmbiguityInfo", 0);
          }

          void t_AmbiguityInfo::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(AmbiguityInfo), "class_", make_descriptor(AmbiguityInfo::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(AmbiguityInfo), "wrapfn_", make_descriptor(t_AmbiguityInfo::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(AmbiguityInfo), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_AmbiguityInfo_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, AmbiguityInfo::initializeClass, 1)))
              return NULL;
            return t_AmbiguityInfo::wrap_Object(AmbiguityInfo(((t_AmbiguityInfo *) arg)->object.this$));
          }
          static PyObject *t_AmbiguityInfo_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, AmbiguityInfo::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_AmbiguityInfo_init_(t_AmbiguityInfo *self, PyObject *args, PyObject *kwds)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::ATNConfigSet a1((jobject) NULL);
            ::java::util::BitSet a2((jobject) NULL);
            ::org::antlr::v4::runtime::TokenStream a3((jobject) NULL);
            jint a4;
            jint a5;
            jboolean a6;
            AmbiguityInfo object((jobject) NULL);

            if (!parseArgs(args, "IkkkIIZ", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, ::java::util::BitSet::initializeClass, ::org::antlr::v4::runtime::TokenStream::initializeClass, &a0, &a1, &a2, &a3, &a4, &a5, &a6))
            {
              INT_CALL(object = AmbiguityInfo(a0, a1, a2, a3, a4, a5, a6));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }

          static PyObject *t_AmbiguityInfo_get__ambigAlts(t_AmbiguityInfo *self, void *data)
          {
            ::java::util::BitSet value((jobject) NULL);
            OBJ_CALL(value = self->object._get_ambigAlts());
            return ::java::util::t_BitSet::wrap_Object(value);
          }
          static int t_AmbiguityInfo_set__ambigAlts(t_AmbiguityInfo *self, PyObject *arg, void *data)
          {
            ::java::util::BitSet value((jobject) NULL);
            if (!parseArg(arg, "k", ::java::util::BitSet::initializeClass, &value))
            {
              INT_CALL(self->object._set_ambigAlts(value));
              return 0;
            }
            PyErr_SetArgsError((PyObject *) self, "ambigAlts", arg);
            return -1;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/ContextSensitivityInfo.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet.h"
#include "org/antlr/v4/runtime/TokenStream.h"
#include "java/lang/Class.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *ContextSensitivityInfo::class$ = NULL;
          jmethodID *ContextSensitivityInfo::mids$ = NULL;
          bool ContextSensitivityInfo::live$ = false;

          jclass ContextSensitivityInfo::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/ContextSensitivityInfo");

              mids$ = new jmethodID[max_mid];
              mids$[mid_init$_c7e20e4a88977c69] = env->getMethodID(cls, "<init>", "(ILorg/antlr/v4/runtime/atn/ATNConfigSet;Lorg/antlr/v4/runtime/TokenStream;II)V");

              class$ = new ::java::lang::Class(cls);
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          ContextSensitivityInfo::ContextSensitivityInfo(jint a0, const ::org::antlr::v4::runtime::atn::ATNConfigSet & a1, const ::org::antlr::v4::runtime::TokenStream & a2, jint a3, jint a4) : ::org::antlr::v4::runtime::atn::DecisionEventInfo(env->newObject(initializeClass, &mids$, mid_init$_c7e20e4a88977c69, a0, a1.this$, a2.this$, a3, a4)) {}
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_ContextSensitivityInfo_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_ContextSensitivityInfo_instance_(PyTypeObject *type, PyObject *arg);
          static int t_ContextSensitivityInfo_init_(t_ContextSensitivityInfo *self, PyObject *args, PyObject *kwds);

          static PyMethodDef t_ContextSensitivityInfo__methods_[] = {
            DECLARE_METHOD(t_ContextSensitivityInfo, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_ContextSensitivityInfo, instance_, METH_O | METH_CLASS),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(ContextSensitivityInfo)[] = {
            { Py_tp_methods, t_ContextSensitivityInfo__methods_ },
            { Py_tp_init, (void *) t_ContextSensitivityInfo_init_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(ContextSensitivityInfo)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::DecisionEventInfo),
            NULL
          };

          DEFINE_TYPE(ContextSensitivityInfo, t_ContextSensitivityInfo, ContextSensitivityInfo);

          void t_ContextSensitivityInfo::install(PyObject *module)
          {
            installType(&PY_TYPE(ContextSensitivityInfo), &PY_TYPE_DEF(ContextSensitivityInfo), module, "ContextSensitivityInfo", 0);
          }

          void t_ContextSensitivityInfo::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(ContextSensitivityInfo), "class_", make_descriptor(ContextSensitivityInfo::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ContextSensitivityInfo), "wrapfn_", make_descriptor(t_ContextSensitivityInfo::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(ContextSensitivityInfo), "boxfn_", make_descriptor(boxObject));
          }

          static PyObject *t_ContextSensitivityInfo_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, ContextSensitivityInfo::initializeClass, 1)))
              return NULL;
            return t_ContextSensitivityInfo::wrap_Object(ContextSensitivityInfo(((t_ContextSensitivityInfo *) arg)->object.this$));
          }
          static PyObject *t_ContextSensitivityInfo_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, ContextSensitivityInfo::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static int t_ContextSensitivityInfo_init_(t_ContextSensitivityInfo *self, PyObject *args, PyObject *kwds)
          {
            jint a0;
            ::org::antlr::v4::runtime::atn::ATNConfigSet a1((jobject) NULL);
            ::org::antlr::v4::runtime::TokenStream a2((jobject) NULL);
            jint a3;
            jint a4;
            ContextSensitivityInfo object((jobject) NULL);

            if (!parseArgs(args, "IkkII", ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, ::org::antlr::v4::runtime::TokenStream::initializeClass, &a0, &a1, &a2, &a3, &a4))
            {
              INT_CALL(object = ContextSensitivityInfo(a0, a1, a2, a3, a4));
              self->object = object;
            }
            else
            {
              PyErr_SetArgsError((PyObject *) self, "__init__", args);
              return -1;
            }

            return 0;
          }
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/LexerNoViableAltException.h"
#include "org/antlr/v4/runtime/atn/ATNConfigSet.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/Lexer.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/CharStream.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {

        ::java::lang::Class *LexerNoViableAltException::class$ = NULL;
        jmethodID *LexerNoViableAltException::mids$ = NULL;
        bool LexerNoViableAltException::live$ = false;

        jclass LexerNoViableAltException::initializeClass(bool getOnly)
        {
          if (getOnly)
            return (jclass) (live$ ? class$->this$ : NULL);
          if (class$ == NULL)
          {
            jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/LexerNoViableAltException");

            mids$ = new jmethodID[max_mid];
            mids$[mid_init$_3b6a8534ba222b3e] = env->getMethodID(cls, "<init>", "(Lorg/antlr/v4/runtime/Lexer;Lorg/antlr/v4/runtime/CharStream;ILorg/antlr/v4/runtime/atn/ATNConfigSet;)V");
            mids$[mid_getDeadEndConfigs_63f4947260fb4a02] = env->getMethodID(cls, "getDeadEndConfigs", "()Lorg/antlr/v4/runtime/atn/ATNConfigSet;");
            mids$[mid_getInputStream_f3effd93aa48b2fd] = env->getMethodID(cls, "getInputStream", "()Lorg/antlr/v4/runtime/CharStream;");
            mids$[mid_getStartIndex_9972fcc56b44e79d] = env->getMethodID(cls, "getStartIndex", "()I");
            mids$[mid_toString_db9b55ba01e03e4b] = env->getMethodID(cls, "toString", "()Ljava/lang/String;");

            class$ = new ::java::lang::Class(cls);
            live$ = true;
          }
          return (jclass) class$->this$;
        }

        LexerNoViableAltException::LexerNoViableAltException(const ::org::antlr::v4::runtime::Lexer & a0, const ::org::antlr::v4::runtime::CharStream & a1, jint a2, const ::org::antlr::v4::runtime::atn::ATNConfigSet & a3) : ::org::antlr::v4::runtime::RecognitionException(env->newObject(initializeClass, &mids$, mid_init$_3b6a8534ba222b3e, a0.this$, a1.this$, a2, a3.this$)) {}

        ::org::antlr::v4::runtime::atn::ATNConfigSet LexerNoViableAltException::getDeadEndConfigs() const
        {
          return ::org::antlr::v4::runtime::atn::ATNConfigSet(env->callObjectMethod(this$, mids$[mid_getDeadEndConfigs_63f4947260fb4a02]));
        }

        ::org::antlr::v4::runtime::CharStream LexerNoViableAltException::getInputStream() const
        {
          return ::org::antlr::v4::runtime::CharStream(env->callObjectMethod(this$, mids$[mid_getInputStream_f3effd93aa48b2fd]));
        }

        jint LexerNoViableAltException::getStartIndex() const
        {
          return env->callIntMethod(this$, mids$[mid_getStartIndex_9972fcc56b44e79d]);
        }

        ::java::lang::String LexerNoViableAltException::toString() const
        {
          return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_toString_db9b55ba01e03e4b]));
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        static PyObject *t_LexerNoViableAltException_cast_(PyTypeObject *type, PyObject *arg);
        static PyObject *t_LexerNoViableAltException_instance_(PyTypeObject *type, PyObject *arg);
        static int t_LexerNoViableAltException_init_(t_LexerNoViableAltException *self, PyObject *args, PyObject *kwds);
        static PyObject *t_LexerNoViableAltException_getDeadEndConfigs(t_LexerNoViableAltException *self);
        static PyObject *t_LexerNoViableAltException_getInputStream(t_LexerNoViableAltException *self, PyObject *args);
        static PyObject *t_LexerNoViableAltException_getStartIndex(t_LexerNoViableAltException *self);
        static PyObject *t_LexerNoViableAltException_toString(t_LexerNoViableAltException *self, PyObject *args);
        static PyObject *t_LexerNoViableAltException_get__deadEndConfigs(t_LexerNoViableAltException *self, void *data);
        static PyObject *t_LexerNoViableAltException_get__inputStream(t_LexerNoViableAltException *self, void *data);
        static PyObject *t_LexerNoViableAltException_get__startIndex(t_LexerNoViableAltException *self, void *data);
        static PyGetSetDef t_LexerNoViableAltException__fields_[] = {
          DECLARE_GET_FIELD(t_LexerNoViableAltException, deadEndConfigs),
          DECLARE_GET_FIELD(t_LexerNoViableAltException, inputStream),
          DECLARE_GET_FIELD(t_LexerNoViableAltException, startIndex),
          { NULL, NULL, NULL, NULL, NULL }
        };

        static PyMethodDef t_LexerNoViableAltException__methods_[] = {
          DECLARE_METHOD(t_LexerNoViableAltException, cast_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_LexerNoViableAltException, instance_, METH_O | METH_CLASS),
          DECLARE_METHOD(t_LexerNoViableAltException, getDeadEndConfigs, METH_NOARGS),
          DECLARE_METHOD(t_LexerNoViableAltException, getInputStream, METH_VARARGS),
          DECLARE_METHOD(t_LexerNoViableAltException, getStartIndex, METH_NOARGS),
          DECLARE_METHOD(t_LexerNoViableAltException, toString, METH_VARARGS),
          { NULL, NULL, 0, NULL }
        };

        static PyType_Slot PY_TYPE_SLOTS(LexerNoViableAltException)[] = {
          { Py_tp_methods, t_LexerNoViableAltException__methods_ },
          { Py_tp_init, (void *) t_LexerNoViableAltException_init_ },
          { Py_tp_getset, t_LexerNoViableAltException__fields_ },
          { 0, NULL }
        };

        static PyType_Def *PY_TYPE_BASES(LexerNoViableAltException)[] = {
          &PY_TYPE_DEF(::org::antlr::v4::runtime::RecognitionException),
          NULL
        };

        DEFINE_TYPE(LexerNoViableAltException, t_LexerNoViableAltException, LexerNoViableAltException);

        void t_LexerNoViableAltException::install(PyObject *module)
        {
          installType(&PY_TYPE(LexerNoViableAltException), &PY_TYPE_DEF(LexerNoViableAltException), module, "LexerNoViableAltException", 0);
        }

        void t_LexerNoViableAltException::initialize(PyObject *module)
        {
          PyObject_SetAttrString((PyObject *) PY_TYPE(LexerNoViableAltException), "class_", make_descriptor(LexerNoViableAltException::initializeClass, 1));
          PyObject_SetAttrString((PyObject *) PY_TYPE(LexerNoViableAltException), "wrapfn_", make_descriptor(t_LexerNoViableAltException::wrap_jobject));
          PyObject_SetAttrString((PyObject *) PY_TYPE(LexerNoViableAltException), "boxfn_", make_descriptor(boxObject));
        }

        static PyObject *t_LexerNoViableAltException_cast_(PyTypeObject *type, PyObject *arg)
        {
          if (!(arg = castCheck(arg, LexerNoViableAltException::initializeClass, 1)))
            return NULL;
          return t_LexerNoViableAltException::wrap_Object(LexerNoViableAltException(((t_LexerNoViableAltException *) arg)->object.this$));
        }
        static PyObject *t_LexerNoViableAltException_instance_(PyTypeObject *type, PyObject *arg)
        {
          if (!castCheck(arg, LexerNoViableAltException::initializeClass, 0))
            Py_RETURN_FALSE;
          Py_RETURN_TRUE;
        }

        static int t_LexerNoViableAltException_init_(t_LexerNoViableAltException *self, PyObject *args, PyObject *kwds)
        {
          ::org::antlr::v4::runtime::Lexer a0((jobject) NULL);
          PyTypeObject **p0;
          ::org::antlr::v4::runtime::CharStream a1((jobject) NULL);
          jint a2;
          ::org::antlr::v4::runtime::atn::ATNConfigSet a3((jobject) NULL);
          LexerNoViableAltException object((jobject) NULL);

          if (!parseArgs(args, "KkIk", ::org::antlr::v4::runtime::Lexer::initializeClass, ::org::antlr::v4::runtime::CharStream::initializeClass, ::org::antlr::v4::runtime::atn::ATNConfigSet::initializeClass, &a0, &p0, ::org::antlr::v4::runtime::t_Lexer::parameters_, &a1, &a2, &a3))
          {
            INT_CALL(object = LexerNoViableAltException(a0, a1, a2, a3));
            self->object = object;
          }
          else
          {
            PyErr_SetArgsError((PyObject *) self, "__init__", args);
            return -1;
          }

          return 0;
        }

        static PyObject *t_LexerNoViableAltException_getDeadEndConfigs(t_LexerNoViableAltException *self)
        {
          ::org::antlr::v4::runtime::atn::ATNConfigSet result((jobject) NULL);
          OBJ_CALL(result = self->object.getDeadEndConfigs());
          return ::org::antlr::v4::runtime::atn::t_ATNConfigSet::wrap_Object(result);
        }

        static PyObject *t_LexerNoViableAltException_getInputStream(t_LexerNoViableAltException *self, PyObject *args)
        {
          ::org::antlr::v4::runtime::CharStream result((jobject) NULL);

          if (!parseArgs(args, ""))
          {
            OBJ_CALL(result = self->object.getInputStream());
            return ::org::antlr::v4::runtime::t_CharStream::wrap_Object(result);
          }

          return callSuper(PY_TYPE(LexerNoViableAltException), (PyObject *) self, "getInputStream", args, 2);
        }

        static PyObject *t_LexerNoViableAltException_getStartIndex(t_LexerNoViableAltException *self)
        {
          jint result;
          OBJ_CALL(result = self->object.getStartIndex());
          return PyLong_FromLong((long) result);
        }

        static PyObject *t_LexerNoViableAltException_toString(t_LexerNoViableAltException *self, PyObject *args)
        {
          ::java::lang::String result((jobject) NULL);

          if (!parseArgs(args, ""))
          {
            OBJ_CALL(result = self->object.toString());
            return j2p(result);
          }

          return callSuper(PY_TYPE(LexerNoViableAltException), (PyObject *) self, "toString", args, 2);
        }

        static PyObject *t_LexerNoViableAltException_get__deadEndConfigs(t_LexerNoViableAltException *self, void *data)
        {
          ::org::antlr::v4::runtime::atn::ATNConfigSet value((jobject) NULL);
          OBJ_CALL(value = self->object.getDeadEndConfigs());
          return ::org::antlr::v4::runtime::atn::t_ATNConfigSet::wrap_Object(value);
        }

        static PyObject *t_LexerNoViableAltException_get__inputStream(t_LexerNoViableAltException *self, void *data)
        {
          ::org::antlr::v4::runtime::CharStream value((jobject) NULL);
          OBJ_CALL(value = self->object.getInputStream());
          return ::org::antlr::v4::runtime::t_CharStream::wrap_Object(value);
        }

        static PyObject *t_LexerNoViableAltException_get__startIndex(t_LexerNoViableAltException *self, void *data)
        {
          jint value;
          OBJ_CALL(value = self->object.getStartIndex());
          return PyLong_FromLong((long) value);
        }
      }
    }
  }
}
#include <jni.h>
#include "JCCEnv.h"
#include "org/antlr/v4/runtime/atn/LexerATNSimulator.h"
#include "org/antlr/v4/runtime/atn/ATN.h"
#include "java/lang/Class.h"
#include "org/antlr/v4/runtime/Lexer.h"
#include "java/lang/String.h"
#include "org/antlr/v4/runtime/atn/LexerATNSimulator.h"
#include "org/antlr/v4/runtime/CharStream.h"
#include "JArray.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {

          ::java::lang::Class *LexerATNSimulator::class$ = NULL;
          jmethodID *LexerATNSimulator::mids$ = NULL;
          bool LexerATNSimulator::live$ = false;
          jint LexerATNSimulator::MAX_DFA_EDGE = (jint) 0;
          jint LexerATNSimulator::MIN_DFA_EDGE = (jint) 0;
          jboolean LexerATNSimulator::debug = (jboolean) 0;
          jboolean LexerATNSimulator::dfa_debug = (jboolean) 0;
          jint LexerATNSimulator::match_calls = (jint) 0;

          jclass LexerATNSimulator::initializeClass(bool getOnly)
          {
            if (getOnly)
              return (jclass) (live$ ? class$->this$ : NULL);
            if (class$ == NULL)
            {
              jclass cls = (jclass) env->findClass("org/antlr/v4/runtime/atn/LexerATNSimulator");

              mids$ = new jmethodID[max_mid];
              mids$[mid_clearDFA_f2cc1bce94666404] = env->getMethodID(cls, "clearDFA", "()V");
              mids$[mid_consume_2707b4f45eb93125] = env->getMethodID(cls, "consume", "(Lorg/antlr/v4/runtime/CharStream;)V");
              mids$[mid_copyState_dabe8737d4978eb7] = env->getMethodID(cls, "copyState", "(Lorg/antlr/v4/runtime/atn/LexerATNSimulator;)V");
              mids$[mid_getCharPositionInLine_9972fcc56b44e79d] = env->getMethodID(cls, "getCharPositionInLine", "()I");
              mids$[mid_getLine_9972fcc56b44e79d] = env->getMethodID(cls, "getLine", "()I");
              mids$[mid_getText_a6673f9c65468e49] = env->getMethodID(cls, "getText", "(Lorg/antlr/v4/runtime/CharStream;)Ljava/lang/String;");
              mids$[mid_getTokenName_d7593acad64ef635] = env->getMethodID(cls, "getTokenName", "(I)Ljava/lang/String;");
              mids$[mid_match_606bfe0c091c8dca] = env->getMethodID(cls, "match", "(Lorg/antlr/v4/runtime/CharStream;I)I");
              mids$[mid_reset_f2cc1bce94666404] = env->getMethodID(cls, "reset", "()V");
              mids$[mid_setCharPositionInLine_040c4cd0390c5aff] = env->getMethodID(cls, "setCharPositionInLine", "(I)V");
              mids$[mid_setLine_040c4cd0390c5aff] = env->getMethodID(cls, "setLine", "(I)V");
              mids$[mid_execATN_086111a0517e6705] = env->getMethodID(cls, "execATN", "(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/dfa/DFAState;)I");
              mids$[mid_computeStartState_fb79feee007f2d4b] = env->getMethodID(cls, "computeStartState", "(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/ATNState;)Lorg/antlr/v4/runtime/atn/ATNConfigSet;");
              mids$[mid_getReachableTarget_88792c9aa2dfa8d2] = env->getMethodID(cls, "getReachableTarget", "(Lorg/antlr/v4/runtime/atn/Transition;I)Lorg/antlr/v4/runtime/atn/ATNState;");
              mids$[mid_getEpsilonTarget_9a8f25c6b37b3b66] = env->getMethodID(cls, "getEpsilonTarget", "(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/LexerATNConfig;Lorg/antlr/v4/runtime/atn/Transition;Lorg/antlr/v4/runtime/atn/ATNConfigSet;ZZ)Lorg/antlr/v4/runtime/atn/LexerATNConfig;");
              mids$[mid_addDFAEdge_b6f9f8ac7e0d0d95] = env->getMethodID(cls, "addDFAEdge", "(Lorg/antlr/v4/runtime/dfa/DFAState;ILorg/antlr/v4/runtime/dfa/DFAState;)V");
              mids$[mid_addDFAEdge_19b2da3acdaf08d7] = env->getMethodID(cls, "addDFAEdge", "(Lorg/antlr/v4/runtime/dfa/DFAState;ILorg/antlr/v4/runtime/atn/ATNConfigSet;)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_addDFAState_d54434b122b921bd] = env->getMethodID(cls, "addDFAState", "(Lorg/antlr/v4/runtime/atn/ATNConfigSet;)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_getExistingTargetState_61638a030e2cccdc] = env->getMethodID(cls, "getExistingTargetState", "(Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_computeTargetState_018bc3c2b2e26e07] = env->getMethodID(cls, "computeTargetState", "(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/dfa/DFAState;I)Lorg/antlr/v4/runtime/dfa/DFAState;");
              mids$[mid_getReachableConfigSet_bfa67a3a840daca4] = env->getMethodID(cls, "getReachableConfigSet", "(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/ATNConfigSet;Lorg/antlr/v4/runtime/atn/ATNConfigSet;I)V");
              mids$[mid_evaluatePredicate_8d7a06d66e151b44] = env->getMethodID(cls, "evaluatePredicate", "(Lorg/antlr/v4/runtime/CharStream;IIZ)Z");
              mids$[mid_captureSimState_5b4214430d0eb94a] = env->getMethodID(cls, "captureSimState", "(Lorg/antlr/v4/runtime/atn/LexerATNSimulator$SimState;Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/dfa/DFAState;)V");
              mids$[mid_matchATN_6d7ecf36311e21ee] = env->getMethodID(cls, "matchATN", "(Lorg/antlr/v4/runtime/CharStream;)I");
              mids$[mid_failOrAccept_0892ae32cfb7f7e5] = env->getMethodID(cls, "failOrAccept", "(Lorg/antlr/v4/runtime/atn/LexerATNSimulator$SimState;Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/ATNConfigSet;I)I");
              mids$[mid_closure_9d5e7a72e181a17a] = env->getMethodID(cls, "closure", "(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/LexerATNConfig;Lorg/antlr/v4/runtime/atn/ATNConfigSet;ZZZ)Z");
              mids$[mid_accept_7fe8fb8810e3ab5c] = env->getMethodID(cls, "accept", "(Lorg/antlr/v4/runtime/CharStream;Lorg/antlr/v4/runtime/atn/LexerActionExecutor;IIII)V");

              class$ = new ::java::lang::Class(cls);
              cls = (jclass) class$->this$;

              MAX_DFA_EDGE = env->getStaticIntField(cls, "MAX_DFA_EDGE");
              MIN_DFA_EDGE = env->getStaticIntField(cls, "MIN_DFA_EDGE");
              debug = env->getStaticBooleanField(cls, "debug");
              dfa_debug = env->getStaticBooleanField(cls, "dfa_debug");
              match_calls = env->getStaticIntField(cls, "match_calls");
              live$ = true;
            }
            return (jclass) class$->this$;
          }

          void LexerATNSimulator::clearDFA() const
          {
            env->callVoidMethod(this$, mids$[mid_clearDFA_f2cc1bce94666404]);
          }

          void LexerATNSimulator::consume(const ::org::antlr::v4::runtime::CharStream & a0) const
          {
            env->callVoidMethod(this$, mids$[mid_consume_2707b4f45eb93125], a0.this$);
          }

          void LexerATNSimulator::copyState(const LexerATNSimulator & a0) const
          {
            env->callVoidMethod(this$, mids$[mid_copyState_dabe8737d4978eb7], a0.this$);
          }

          jint LexerATNSimulator::getCharPositionInLine() const
          {
            return env->callIntMethod(this$, mids$[mid_getCharPositionInLine_9972fcc56b44e79d]);
          }

          jint LexerATNSimulator::getLine() const
          {
            return env->callIntMethod(this$, mids$[mid_getLine_9972fcc56b44e79d]);
          }

          ::java::lang::String LexerATNSimulator::getText(const ::org::antlr::v4::runtime::CharStream & a0) const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getText_a6673f9c65468e49], a0.this$));
          }

          ::java::lang::String LexerATNSimulator::getTokenName(jint a0) const
          {
            return ::java::lang::String(env->callObjectMethod(this$, mids$[mid_getTokenName_d7593acad64ef635], a0));
          }

          jint LexerATNSimulator::match(const ::org::antlr::v4::runtime::CharStream & a0, jint a1) const
          {
            return env->callIntMethod(this$, mids$[mid_match_606bfe0c091c8dca], a0.this$, a1);
          }

          void LexerATNSimulator::reset() const
          {
            env->callVoidMethod(this$, mids$[mid_reset_f2cc1bce94666404]);
          }

          void LexerATNSimulator::setCharPositionInLine(jint a0) const
          {
            env->callVoidMethod(this$, mids$[mid_setCharPositionInLine_040c4cd0390c5aff], a0);
          }

          void LexerATNSimulator::setLine(jint a0) const
          {
            env->callVoidMethod(this$, mids$[mid_setLine_040c4cd0390c5aff], a0);
          }
        }
      }
    }
  }
}

#include "structmember.h"
#include "functions.h"
#include "macros.h"

namespace org {
  namespace antlr {
    namespace v4 {
      namespace runtime {
        namespace atn {
          static PyObject *t_LexerATNSimulator_cast_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_LexerATNSimulator_instance_(PyTypeObject *type, PyObject *arg);
          static PyObject *t_LexerATNSimulator_clearDFA(t_LexerATNSimulator *self, PyObject *args);
          static PyObject *t_LexerATNSimulator_consume(t_LexerATNSimulator *self, PyObject *arg);
          static PyObject *t_LexerATNSimulator_copyState(t_LexerATNSimulator *self, PyObject *arg);
          static PyObject *t_LexerATNSimulator_getCharPositionInLine(t_LexerATNSimulator *self);
          static PyObject *t_LexerATNSimulator_getLine(t_LexerATNSimulator *self);
          static PyObject *t_LexerATNSimulator_getText(t_LexerATNSimulator *self, PyObject *arg);
          static PyObject *t_LexerATNSimulator_getTokenName(t_LexerATNSimulator *self, PyObject *arg);
          static PyObject *t_LexerATNSimulator_match(t_LexerATNSimulator *self, PyObject *args);
          static PyObject *t_LexerATNSimulator_reset(t_LexerATNSimulator *self, PyObject *args);
          static PyObject *t_LexerATNSimulator_setCharPositionInLine(t_LexerATNSimulator *self, PyObject *arg);
          static PyObject *t_LexerATNSimulator_setLine(t_LexerATNSimulator *self, PyObject *arg);
          static PyObject *t_LexerATNSimulator_get__charPositionInLine(t_LexerATNSimulator *self, void *data);
          static int t_LexerATNSimulator_set__charPositionInLine(t_LexerATNSimulator *self, PyObject *arg, void *data);
          static PyObject *t_LexerATNSimulator_get__line(t_LexerATNSimulator *self, void *data);
          static int t_LexerATNSimulator_set__line(t_LexerATNSimulator *self, PyObject *arg, void *data);
          static PyGetSetDef t_LexerATNSimulator__fields_[] = {
            DECLARE_GETSET_FIELD(t_LexerATNSimulator, charPositionInLine),
            DECLARE_GETSET_FIELD(t_LexerATNSimulator, line),
            { NULL, NULL, NULL, NULL, NULL }
          };

          static PyMethodDef t_LexerATNSimulator__methods_[] = {
            DECLARE_METHOD(t_LexerATNSimulator, cast_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_LexerATNSimulator, instance_, METH_O | METH_CLASS),
            DECLARE_METHOD(t_LexerATNSimulator, clearDFA, METH_VARARGS),
            DECLARE_METHOD(t_LexerATNSimulator, consume, METH_O),
            DECLARE_METHOD(t_LexerATNSimulator, copyState, METH_O),
            DECLARE_METHOD(t_LexerATNSimulator, getCharPositionInLine, METH_NOARGS),
            DECLARE_METHOD(t_LexerATNSimulator, getLine, METH_NOARGS),
            DECLARE_METHOD(t_LexerATNSimulator, getText, METH_O),
            DECLARE_METHOD(t_LexerATNSimulator, getTokenName, METH_O),
            DECLARE_METHOD(t_LexerATNSimulator, match, METH_VARARGS),
            DECLARE_METHOD(t_LexerATNSimulator, reset, METH_VARARGS),
            DECLARE_METHOD(t_LexerATNSimulator, setCharPositionInLine, METH_O),
            DECLARE_METHOD(t_LexerATNSimulator, setLine, METH_O),
            { NULL, NULL, 0, NULL }
          };

          static PyType_Slot PY_TYPE_SLOTS(LexerATNSimulator)[] = {
            { Py_tp_methods, t_LexerATNSimulator__methods_ },
            { Py_tp_init, (void *) abstract_init },
            { Py_tp_getset, t_LexerATNSimulator__fields_ },
            { 0, NULL }
          };

          static PyType_Def *PY_TYPE_BASES(LexerATNSimulator)[] = {
            &PY_TYPE_DEF(::org::antlr::v4::runtime::atn::ATNSimulator),
            NULL
          };

          DEFINE_TYPE(LexerATNSimulator, t_LexerATNSimulator, LexerATNSimulator);

          void t_LexerATNSimulator::install(PyObject *module)
          {
            installType(&PY_TYPE(LexerATNSimulator), &PY_TYPE_DEF(LexerATNSimulator), module, "LexerATNSimulator", 0);
          }

          void t_LexerATNSimulator::initialize(PyObject *module)
          {
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerATNSimulator), "class_", make_descriptor(LexerATNSimulator::initializeClass, 1));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerATNSimulator), "wrapfn_", make_descriptor(t_LexerATNSimulator::wrap_jobject));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerATNSimulator), "boxfn_", make_descriptor(boxObject));
            env->getClass(LexerATNSimulator::initializeClass);
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerATNSimulator), "MAX_DFA_EDGE", make_descriptor(LexerATNSimulator::MAX_DFA_EDGE));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerATNSimulator), "MIN_DFA_EDGE", make_descriptor(LexerATNSimulator::MIN_DFA_EDGE));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerATNSimulator), "debug", make_descriptor(LexerATNSimulator::debug));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerATNSimulator), "dfa_debug", make_descriptor(LexerATNSimulator::dfa_debug));
            PyObject_SetAttrString((PyObject *) PY_TYPE(LexerATNSimulator), "match_calls", make_descriptor(LexerATNSimulator::match_calls));
          }

          static PyObject *t_LexerATNSimulator_cast_(PyTypeObject *type, PyObject *arg)
          {
            if (!(arg = castCheck(arg, LexerATNSimulator::initializeClass, 1)))
              return NULL;
            return t_LexerATNSimulator::wrap_Object(LexerATNSimulator(((t_LexerATNSimulator *) arg)->object.this$));
          }
          static PyObject *t_LexerATNSimulator_instance_(PyTypeObject *type, PyObject *arg)
          {
            if (!castCheck(arg, LexerATNSimulator::initializeClass, 0))
              Py_RETURN_FALSE;
            Py_RETURN_TRUE;
          }

          static PyObject *t_LexerATNSimulator_clearDFA(t_LexerATNSimulator *self, PyObject *args)
          {

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(self->object.clearDFA());
              Py_RETURN_NONE;
            }

            return callSuper(PY_TYPE(LexerATNSimulator), (PyObject *) self, "clearDFA", args, 2);
          }

          static PyObject *t_LexerATNSimulator_consume(t_LexerATNSimulator *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::CharStream a0((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::CharStream::initializeClass, &a0))
            {
              OBJ_CALL(self->object.consume(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "consume", arg);
            return NULL;
          }

          static PyObject *t_LexerATNSimulator_copyState(t_LexerATNSimulator *self, PyObject *arg)
          {
            LexerATNSimulator a0((jobject) NULL);

            if (!parseArg(arg, "k", LexerATNSimulator::initializeClass, &a0))
            {
              OBJ_CALL(self->object.copyState(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "copyState", arg);
            return NULL;
          }

          static PyObject *t_LexerATNSimulator_getCharPositionInLine(t_LexerATNSimulator *self)
          {
            jint result;
            OBJ_CALL(result = self->object.getCharPositionInLine());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_LexerATNSimulator_getLine(t_LexerATNSimulator *self)
          {
            jint result;
            OBJ_CALL(result = self->object.getLine());
            return PyLong_FromLong((long) result);
          }

          static PyObject *t_LexerATNSimulator_getText(t_LexerATNSimulator *self, PyObject *arg)
          {
            ::org::antlr::v4::runtime::CharStream a0((jobject) NULL);
            ::java::lang::String result((jobject) NULL);

            if (!parseArg(arg, "k", ::org::antlr::v4::runtime::CharStream::initializeClass, &a0))
            {
              OBJ_CALL(result = self->object.getText(a0));
              return j2p(result);
            }

            PyErr_SetArgsError((PyObject *) self, "getText", arg);
            return NULL;
          }

          static PyObject *t_LexerATNSimulator_getTokenName(t_LexerATNSimulator *self, PyObject *arg)
          {
            jint a0;
            ::java::lang::String result((jobject) NULL);

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(result = self->object.getTokenName(a0));
              return j2p(result);
            }

            PyErr_SetArgsError((PyObject *) self, "getTokenName", arg);
            return NULL;
          }

          static PyObject *t_LexerATNSimulator_match(t_LexerATNSimulator *self, PyObject *args)
          {
            ::org::antlr::v4::runtime::CharStream a0((jobject) NULL);
            jint a1;
            jint result;

            if (!parseArgs(args, "kI", ::org::antlr::v4::runtime::CharStream::initializeClass, &a0, &a1))
            {
              OBJ_CALL(result = self->object.match(a0, a1));
              return PyLong_FromLong((long) result);
            }

            PyErr_SetArgsError((PyObject *) self, "match", args);
            return NULL;
          }

          static PyObject *t_LexerATNSimulator_reset(t_LexerATNSimulator *self, PyObject *args)
          {

            if (!parseArgs(args, ""))
            {
              OBJ_CALL(self->object.reset());
              Py_RETURN_NONE;
            }

            return callSuper(PY_TYPE(LexerATNSimulator), (PyObject *) self, "reset", args, 2);
          }

          static PyObject *t_LexerATNSimulator_setCharPositionInLine(t_LexerATNSimulator *self, PyObject *arg)
          {
            jint a0;

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(self->object.setCharPositionInLine(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "setCharPositionInLine", arg);
            return NULL;
          }

          static PyObject *t_LexerATNSimulator_setLine(t_LexerATNSimulator *self, PyObject *arg)
          {
            jint a0;

            if (!parseArg(arg, "I", &a0))
            {
              OBJ_CALL(self->object.setLine(a0));
              Py_RETURN_NONE;
            }

            PyErr_SetArgsError((PyObject *) self, "setLine", arg);
            return NULL;
          }

          static PyObject *t_LexerATNSimulator_get__charPositionInLine(t_LexerATNSimulator *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getCharPositionInLine());
            return PyLong_FromLong((long) value);
          }
          static int t_LexerATNSimulator_set__charPositionInLine(t_LexerATNSimulator *self, PyObject *arg, void *data)
          {
            {
              jint value;
              if (!parseArg(arg, "I", &value))
              {
                INT_CALL(self->object.setCharPositionInLine(value));
                return 0;
              }
            }
            PyErr_SetArgsError((PyObject *) self, "charPositionInLine", arg);
            return -1;
          }

          static PyObject *t_LexerATNSimulator_get__line(t_LexerATNSimulator *self, void *data)
          {
            jint value;
            OBJ_CALL(value = self->object.getLine());
            return PyLong_FromLong((long) value);
          }
          static int t_LexerATNSimulator_set__line(t_LexerATNSimulator *self, PyObject *arg, void *data)
          {
            {
              jint value;
              if (!parseArg(arg, "I", &value))
              {
                INT_CALL(self->object.setLine(value));
                return 0;
              }
            }
            PyErr_SetArgsError((PyObject *) self, "line", arg);
            return -1;
          }
        }
      }
    }
  }
}
